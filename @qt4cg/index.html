<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2025/">2025</a>, <a href="2024/">2024</a>, <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="minutes—02-11"><h2>QT4 CG meeting 109 draft minutes<span class="toot-id"> #minutes—02-11</span></h2><div class="pubdate">11 Feb at 17:10:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2025/02-11">https://qt4cg.org/meeting/minutes/2025/02-11</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-1779"><h2>Issue #1779 closed<span class="toot-id"> #closed-1779</span></h2><div class="pubdate">11 Feb at 17:04:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1779">https://github.com/qt4cg/qtspecs/issues/1779</a></div><p>XPath 4.0 EBNF grammar</p></div>
<div class="toot" id="closed-1783"><h2>Issue #1783 closed<span class="toot-id"> #closed-1783</span></h2><div class="pubdate">11 Feb at 17:04:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1783">https://github.com/qt4cg/qtspecs/pull/1783</a></div><p>1779 Make CharRef XQuery-only</p></div>
<div class="toot" id="closed-1752"><h2>Issue #1752 closed<span class="toot-id"> #closed-1752</span></h2><div class="pubdate">11 Feb at 17:02:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1752">https://github.com/qt4cg/qtspecs/issues/1752</a></div><p>Return type of fn:partition()</p></div>
<div class="toot" id="closed-1761"><h2>Issue #1761 closed<span class="toot-id"> #closed-1761</span></h2><div class="pubdate">11 Feb at 17:02:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1761">https://github.com/qt4cg/qtspecs/pull/1761</a></div><p>1752 Correct return type of fn:partition()</p></div>
<div class="toot" id="closed-1751"><h2>Issue #1751 closed<span class="toot-id"> #closed-1751</span></h2><div class="pubdate">11 Feb at 17:00:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1751">https://github.com/qt4cg/qtspecs/issues/1751</a></div><p>bin:encode-string - should the result have a BOM?</p></div>
<div class="toot" id="closed-1765"><h2>Issue #1765 closed<span class="toot-id"> #closed-1765</span></h2><div class="pubdate">11 Feb at 17:00:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1765">https://github.com/qt4cg/qtspecs/pull/1765</a></div><p>1751 Clarify BOM handling</p></div>
<div class="toot" id="closed-1770"><h2>Issue #1770 closed<span class="toot-id"> #closed-1770</span></h2><div class="pubdate">11 Feb at 16:58:28 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1770">https://github.com/qt4cg/qtspecs/issues/1770</a></div><p>Union patterns in XSLT</p></div>
<div class="toot" id="closed-1772"><h2>Issue #1772 closed<span class="toot-id"> #closed-1772</span></h2><div class="pubdate">11 Feb at 16:58:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1772">https://github.com/qt4cg/qtspecs/pull/1772</a></div><p>1770 Default priority of rules with a union pattern</p></div>
<div class="toot" id="closed-402"><h2>Issue #402 closed<span class="toot-id"> #closed-402</span></h2><div class="pubdate">11 Feb at 16:56:09 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/402">https://github.com/qt4cg/qtspecs/issues/402</a></div><p>XSLT patterns: intersect and except</p></div>
<div class="toot" id="closed-1773"><h2>Issue #1773 closed<span class="toot-id"> #closed-1773</span></h2><div class="pubdate">11 Feb at 16:56:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1773">https://github.com/qt4cg/qtspecs/pull/1773</a></div><p>402 Change the semantics of intersect and except in patterns</p></div>
<div class="toot" id="closed-1784"><h2>Issue #1784 closed<span class="toot-id"> #closed-1784</span></h2><div class="pubdate">11 Feb at 16:53:58 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1784">https://github.com/qt4cg/qtspecs/pull/1784</a></div><p>1781 Drop obsolete material from XSLT spec</p></div>
<div class="toot" id="closed-755"><h2>Issue #755 closed<span class="toot-id"> #closed-755</span></h2><div class="pubdate">11 Feb at 16:51:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/755">https://github.com/qt4cg/qtspecs/issues/755</a></div><p>with expression; chaining and concatenation</p></div>
<div class="toot" id="closed-877"><h2>Issue #877 closed<span class="toot-id"> #closed-877</span></h2><div class="pubdate">11 Feb at 16:51:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/877">https://github.com/qt4cg/qtspecs/issues/877</a></div><p>Inconsistency in XQFO comparator functions/operators with recursive rules</p></div>
<div class="toot" id="closed-1729"><h2>Issue #1729 closed<span class="toot-id"> #closed-1729</span></h2><div class="pubdate">11 Feb at 16:50:42 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1729">https://github.com/qt4cg/qtspecs/issues/1729</a></div><p>Grammar problems introduced by #1721</p></div>
<div class="toot" id="closed-1767"><h2>Issue #1767 closed<span class="toot-id"> #closed-1767</span></h2><div class="pubdate">11 Feb at 16:50:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1767">https://github.com/qt4cg/qtspecs/pull/1767</a></div><p>1729/1737 Fix grammar for "declare record"</p></div>
<div class="toot" id="created-1791"><h2>Pull request #1791 created<span class="toot-id"> #created-1791</span></h2><div class="pubdate">11 Feb at 11:12:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1791">https://github.com/qt4cg/qtspecs/pull/1791</a></div><details><summary>1789 Fix singleton terminology</summary><div class="markup"><p>Replaces "singleton map" with "single-entry map" and "singleton array" with "single-member array"; the term "singleton" now always means count()=1, not size()=1.</p>
<p>Fix #1789</p>
</div></details></div>
<div class="toot" id="created-1790"><h2>Pull request #1790 created<span class="toot-id"> #created-1790</span></h2><div class="pubdate">11 Feb at 10:04:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1790">https://github.com/qt4cg/qtspecs/pull/1790</a></div><details><summary>1788 Replace statement that maps are unordered</summary><div class="markup"><p>Fix #1788</p>
</div></details></div>
<div class="toot" id="created-1789"><h2>Issue #1789 created<span class="toot-id"> #created-1789</span></h2><div class="pubdate">11 Feb at 09:00:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1789">https://github.com/qt4cg/qtspecs/issues/1789</a></div><details><summary>Terminology: "singleton map"</summary><div class="markup"><p>We often use the term "singleton map" to mean a map containing a single entry (key-value pair).</p>
<p>But in XQ 4.14.3.1 we use the same term to mean "a sequence containing a single map".</p>
</div></details></div>
<div class="toot" id="created-1788"><h2>Issue #1788 created<span class="toot-id"> #created-1788</span></h2><div class="pubdate">10 Feb at 14:50:28 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1788">https://github.com/qt4cg/qtspecs/issues/1788</a></div><details><summary>Drop reference to maps being unordered</summary><div class="markup"><p>In F&amp;O 17.5.1.5 elements-to-maps record layout, mapping rules, delete</p>
<blockquote>
<p>Because the child elements are converted to a map, their order is not retained.</p>
</blockquote>
<p>Substitute a rule that the entries in the map will correspond with "order of first appearance".</p>
</div></details></div>
<div class="toot" id="agenda-02-11"><h2>QT4 CG meeting 109 draft agenda<span class="toot-id"> #agenda-02-11</span></h2><div class="pubdate">10 Feb at 14:00:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2025/02-11">https://qt4cg.org/meeting/agenda/2025/02-11</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-1787"><h2>Issue #1787 created<span class="toot-id"> #created-1787</span></h2><div class="pubdate">10 Feb at 10:47:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1787">https://github.com/qt4cg/qtspecs/issues/1787</a></div><details><summary>Sorted maps revisited</summary><div class="markup"><p>Now that we have ordered maps established, I'd like to make another attempt to introduce sorted maps - that is, maps whose ordering is by key value. The entries in such a map would be sorted by key, but there's no attempt to maintain sort order in subsequent put() operations.</p>
<p>We introduce map:sort($m) essentially as a convenient shorthand for <code>map:of-pairs(sort(map:pairs($m), fn{?key}))</code>.</p>
<p>And then we introduce something like <code>map:get-range($from, $to)</code> which returns the keys (or pairs, or entries) whose keys are in a given range -- which the implementation can optimize if it knows the map has been sorted.</p>
</div></details></div>
<div class="toot" id="created-1786"><h2>Issue #1786 created<span class="toot-id"> #created-1786</span></h2><div class="pubdate">09 Feb at 09:38:14 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1786">https://github.com/qt4cg/qtspecs/issues/1786</a></div><details><summary>A case study for XSLT transformation of JSON: the transpiler</summary><div class="markup"><p>One of the design aims of XSLT 4.0 is that it should be easier to transform JSON. Back in 2016 I published a paper at XML Prague (https://www.saxonica.com/papers/xmlprague-2016mhk.pdf) with the rather disappointing result that for a couple of non-trivial JSON transformation tasks, the easiest solution was to convert the JSON to XML, transform the XML, and then convert it back. In many ways it was that discovery that motivated the whole XSLT 4.0 project. So I want to review to what extent we have solved that problem, and what remains to be done. In particular, I have recently raised a number of open issues related to how we transform JSON-derived trees of maps and arrays using template rules, and I'm not sure we can resolve those issues without testing the proposals against real use cases.</p>
<p>I'm proposing to take as a case study the Java-to-C# transpiler which we described in a 2021 paper at https://www.saxonica.com/papers/markupuk-2021mhk.pdf. This is a real XSLT application in daily use. It invokes the (open source) JavaParser to emit an XML representation of Java source code, it performs various transformations of that XML, and then finally spits out equivalent C# source code. My basic question is: suppose the JavaParser had chosen to emit JSON instead of XML (as it might perfectly reasonably have chosen to do). Would we be able to write the transpiler in XSLT 4.0 to work entirely within the JSON space, avoiding all use of XML?</p>
<p>I chose this case study for several reasons:</p>
<ul>
<li>It's entirely plausible that the input might have been JSON rather than XML</li>
<li>The application relies very heavily (and successfully) on rule-based processing: if we didn't have template rules, then it would be dominated by large xsl:choose statements with hundreds of branches.</li>
<li>At around 5000 lines of XSLT, it's large enough to be non-trivial, yet small enough to be tractable as a case study.</li>
</ul>
<p>I looked at a couple of other candidates, and found they were things that could be readily done in XSLT 3.0 without any enhancements. For example we have production XSLT 3.0 code that takes a JSON data feed from our online shop at saxonica.com and uses it to update our sales database and to generate license keys. The JSON is voluminous but the structure is simple, and the constructs in XSLT 3.0 for handling maps and arrays are entirely up to the job. The transpiler differs in that the JSON has a much more interesting recursive structure, making rule-based transformation a natural fit to the task.</p>
<p>I'm not proposing to actually produce a complete replacement of the current transpiler, only to explore the task of doing so in enough detail to get some useful insights. I propose to use this issue tracker to capture my working notes as the study proceeds, but if there are recommendations affecting the 4.0 specs (as seems likely), then I will extract those into separate issues. Perhaps at the end of the process I will write up the case study as a conference paper.</p>
<p>My rough plan is as follows:</p>
<ol>
<li>Explore conversion of the current XML output by JavaParser to JSON using the new elements-to-maps() function. We have a number of open issues on the usability of this function and it will be interesting to see whether we encounter similar difficulties to those that have already been raised, and whether the suggested solutions are appropriate.</li>
<li>Convert the xml-to-java stylesheet to work on this JSON input. This stylesheet is not actually a working part of the transpiler, rather it's something we built as a stepping stone; before attempting to convert the XML syntax tree to C#, we felt it would be instructive to write code that converted it back to Java. This is an 820-line stylesheet and it should be feasible to convert it completely.</li>
<li>The transpiler currently produces, as an intermediate output, a "digest" file containing summary information about all the classes and methods found in the Java code, and their subtyping/override relationships. We then have a process that augments this digest with attributes that are needed by the C# generation, for example which methods to label with "virtual" or "override" modifiers. I propose to experiment with producing (and transforming) this digest in JSON rather than XML format.</li>
<li>Examine the XSLT code that generates C# output to look for features that appear to be tricky to convert, for example anything that uses the parent or ancestor axis, and study to what extent we now have the capability in XSLT 4.0 to handle those situations.</li>
</ol>
<p>Using this format (a GitHub issue) to record progress carries a risk that there will be comments that take things off at a tangent. Please help by resisting that temptation: if there are interesting issues raised in your mind, please take those up as separate issues.</p>
</div></details></div>
<div class="toot" id="created-1785"><h2>Issue #1785 created<span class="toot-id"> #created-1785</span></h2><div class="pubdate">08 Feb at 08:57:57 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1785">https://github.com/qt4cg/qtspecs/issues/1785</a></div><details><summary>XQuery 4.0 grammar: `ArrowExpr` target, `ReverseAxis`</summary><div class="markup"><p>While testing the parser generated from the specification grammar, I encountered two issues.</p>
<h3>1. <code>ArrowExpr</code> target must be optional</h3>
<p>The current definition in the specification is as follows:</p>
<pre><code>ArrowExpr ::= UnaryExpr (SequenceArrowTarget | MappingArrowTarget | LookupArrowTarget)
</code></pre>
<p>However, the target part must at least be optional, or better zero-or-more:</p>
<pre><code>ArrowExpr ::= UnaryExpr (SequenceArrowTarget | MappingArrowTarget | LookupArrowTarget)*
</code></pre>
<p>Otherwise arrow targets are expected almost everywhere. Making it zero-or-more allows parsing of</p>
<pre><code>a =&gt; b() =&gt; c()
</code></pre>
<p>which would not be possible without extra parentheses if it was optional.</p>
<h3>2. Missing <code>preceding-sibling</code> in <code>ReverseAxis</code></h3>
<p>The <code>ReverseAxis</code> production currently appears as:</p>
<pre><code>ReverseAxis ::= ( "ancestor"
                | "ancestor-or-self"
                | "parent"
                | "preceding"
                | "preceding-or-self"
                | "preceding-sibling-or-self" ) "::"
</code></pre>
<p>It is missing the <code>prededing-sibling</code> axis.</p>
</div></details></div>
<div class="toot" id="created-1784"><h2>Pull request #1784 created<span class="toot-id"> #created-1784</span></h2><div class="pubdate">07 Feb at 21:45:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1784">https://github.com/qt4cg/qtspecs/pull/1784</a></div><details><summary>1781 Drop obsolete material from XSLT spec</summary><div class="markup"><p>Drops material mainly deriving from when XSLT 3.0 had to work with both XPath 3.0 and 3.1. Includes non-normative exposition and some obsolete conformance statements.</p>
</div></details></div>
<div class="toot" id="created-1783"><h2>Pull request #1783 created<span class="toot-id"> #created-1783</span></h2><div class="pubdate">07 Feb at 21:03:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1783">https://github.com/qt4cg/qtspecs/pull/1783</a></div><details><summary>1779 Make CharRef XQuery-only</summary><div class="markup"><p>Fix #1779</p>
<p>Makes the CharRef token XQuery-only.</p>
</div></details></div>
<div class="toot" id="created-1782"><h2>Pull request #1782 created<span class="toot-id"> #created-1782</span></h2><div class="pubdate">07 Feb at 12:46:20 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1782">https://github.com/qt4cg/qtspecs/pull/1782</a></div><details><summary>1776 Add lookup patterns using ? and ??</summary><div class="markup"><p>Fix #1776</p>
</div></details></div>
<div class="toot" id="closed-1026"><h2>Issue #1026 closed<span class="toot-id"> #closed-1026</span></h2><div class="pubdate">07 Feb at 12:44:03 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1026">https://github.com/qt4cg/qtspecs/issues/1026</a></div><p>XSLT match patterns on pinned maps and arrays</p></div>
<div class="toot" id="created-1781"><h2>Issue #1781 created<span class="toot-id"> #created-1781</span></h2><div class="pubdate">07 Feb at 12:15:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1781">https://github.com/qt4cg/qtspecs/issues/1781</a></div><details><summary>XSLT: drop section 23 (Processing JSON Data) and Appendix B</summary><div class="markup"><p>Section 23 Processing JSON data at one time contained the specification of maps, before this moved into XPath 3.1. This has now gone, and what's left is pretty much content-free.</p>
<p>Appendix B contains a stylesheet for converting XML to JSON. It has some educational value, but not much, and I think it can go.</p>
</div></details></div>
<div class="toot" id="created-1780"><h2>Issue #1780 created<span class="toot-id"> #created-1780</span></h2><div class="pubdate">07 Feb at 11:49:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1780">https://github.com/qt4cg/qtspecs/issues/1780</a></div><details><summary>xsl:for-each optional variable introduction</summary><div class="markup"><p>I spend quite a lot of time writing</p>
<pre><code>&lt;xsl:for-each select="foo"&gt;
   &lt;xsl:variable name="foo" select="." as="element(foo)"/&gt;
   &lt;xsl:for-each select="$foo/bar"&gt;
      &lt;xsl:variable name="bar" select="." as="element(bar)"/&gt;
      .... do some stuff with $foo and $bar
   &lt;/xsl:for-each&gt;
&lt;/xsl:for-each&gt;
</code></pre>
<p>I'd prefer to go (much like xquery)</p>
<pre><code>&lt;xsl:for-each name="foo" as="element(foo)" select="foo"&gt;
   &lt;xsl:for-each name="bar" as="element(bar)" select="$foo/bar"&gt;
      .... do some stuff with $foo and $bar
   &lt;/xsl:for-each&gt;
&lt;/xsl:for-each&gt;
</code></pre>
</div></details></div></div><p>See 3606
            more statuses in yearly archives.</p></article></main></body></html>