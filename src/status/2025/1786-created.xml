<item>
   <title>Issue #1786 created</title>
   <pubDate>2025-02-09T09:38:14Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1786</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-1786</guid>
   <description>&lt;div&gt;&lt;p&gt;A case study for XSLT transformation of JSON: the transpiler&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;One of the design aims of XSLT 4.0 is that it should be easier to transform JSON. Back in 2016 I published a paper at XML Prague (https://www.saxonica.com/papers/xmlprague-2016mhk.pdf) with the rather disappointing result that for a couple of non-trivial JSON transformation tasks, the easiest solution was to convert the JSON to XML, transform the XML, and then convert it back. In many ways it was that discovery that motivated the whole XSLT 4.0 project. So I want to review to what extent we have solved that problem, and what remains to be done. In particular, I have recently raised a number of open issues related to how we transform JSON-derived trees of maps and arrays using template rules, and I'm not sure we can resolve those issues without testing the proposals against real use cases.&lt;/p&gt;
&lt;p&gt;I'm proposing to take as a case study the Java-to-C# transpiler which we described in a 2021 paper at https://www.saxonica.com/papers/markupuk-2021mhk.pdf. This is a real XSLT application in daily use. It invokes the (open source) JavaParser to emit an XML representation of Java source code, it performs various transformations of that XML, and then finally spits out equivalent C# source code. My basic question is: suppose the JavaParser had chosen to emit JSON instead of XML (as it might perfectly reasonably have chosen to do). Would we be able to write the transpiler in XSLT 4.0 to work entirely within the JSON space, avoiding all use of XML?&lt;/p&gt;
&lt;p&gt;I chose this case study for several reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It's entirely plausible that the input might have been JSON rather than XML&lt;/li&gt;
&lt;li&gt;The application relies very heavily (and successfully) on rule-based processing: if we didn't have template rules, then it would be dominated by large xsl:choose statements with hundreds of branches.&lt;/li&gt;
&lt;li&gt;At around 5000 lines of XSLT, it's large enough to be non-trivial, yet small enough to be tractable as a case study.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I looked at a couple of other candidates, and found they were things that could be readily done in XSLT 3.0 without any enhancements. For example we have production XSLT 3.0 code that takes a JSON data feed from our online shop at saxonica.com and uses it to update our sales database and to generate license keys. The JSON is voluminous but the structure is simple, and the constructs in XSLT 3.0 for handling maps and arrays are entirely up to the job. The transpiler differs in that the JSON has a much more interesting recursive structure, making rule-based transformation a natural fit to the task.&lt;/p&gt;
&lt;p&gt;I'm not proposing to actually produce a complete replacement of the current transpiler, only to explore the task of doing so in enough detail to get some useful insights. I propose to use this issue tracker to capture my working notes as the study proceeds, but if there are recommendations affecting the 4.0 specs (as seems likely), then I will extract those into separate issues. Perhaps at the end of the process I will write up the case study as a conference paper.&lt;/p&gt;
&lt;p&gt;My rough plan is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Explore conversion of the current XML output by JavaParser to JSON using the new elements-to-maps() function. We have a number of open issues on the usability of this function and it will be interesting to see whether we encounter similar difficulties to those that have already been raised, and whether the suggested solutions are appropriate.&lt;/li&gt;
&lt;li&gt;Convert the xml-to-java stylesheet to work on this JSON input. This stylesheet is not actually a working part of the transpiler, rather it's something we built as a stepping stone; before attempting to convert the XML syntax tree to C#, we felt it would be instructive to write code that converted it back to Java. This is an 820-line stylesheet and it should be feasible to convert it completely.&lt;/li&gt;
&lt;li&gt;The transpiler currently produces, as an intermediate output, a "digest" file containing summary information about all the classes and methods found in the Java code, and their subtyping/override relationships. We then have a process that augments this digest with attributes that are needed by the C# generation, for example which methods to label with "virtual" or "override" modifiers. I propose to experiment with producing (and transforming) this digest in JSON rather than XML format.&lt;/li&gt;
&lt;li&gt;Examine the XSLT code that generates C# output to look for features that appear to be tricky to convert, for example anything that uses the parent or ancestor axis, and study to what extent we now have the capability in XSLT 4.0 to handle those situations.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Using this format (a GitHub issue) to record progress carries a risk that there will be comments that take things off at a tangent. Please help by resisting that temptation: if there are interesting issues raised in your mind, please take those up as separate issues.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
