<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><!--Generated by the DeltaXML.com xhtml-outfilter.xsl--><!--Using XSL Processor: Saxonica--><title>-[[Page not found · GitHub Pages]]- +[[XQuery 4.0 and XPath 4.0 WG Review Draft]]+</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/shared-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p></div><div class="head"><p><a href="https://www.w3.org/"><span class="deltaxml-new-img"><img style="border: 2px solid green" src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></span></a></p><h1><a id="title"></a><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 WG Review Draft</span></h1><h2><a id="w3c-doctype"></a><span class="deltaxml-new" style="background:#90EE90">W3C Editor's Draft 19&nbsp;February&nbsp;2025</span></h2><dl><dt><span class="deltaxml-new" style="background:#90EE90">This version:</span></dt><dd><a href="http://www.w3.org/TR/2000/WD-shared-40-20000101/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/2000/WD-shared-40-20000101/</span></a></dd><dt><span class="deltaxml-new" style="background:#90EE90">Most recent version of XQuery and XPath:</span></dt><dd><a href="http://www.w3.org/TR/shared/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/shared/</span></a></dd><dt><span class="deltaxml-new" style="background:#90EE90">Most recent Recommendation of XQuery and XPath:</span></dt><dd><span class="xpath"><a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/"><span class="deltaxml-new" style="background:#90EE90">https://www.w3.org/TR/2017/REC-xpath-31-20170321/</span></a></span><span class="xquery"><a href="https://www.w3.org/TR/2017/REC-xquery-31-20170321/"><span class="deltaxml-new" style="background:#90EE90">https://www.w3.org/TR/2017/REC-xquery-31-20170321/</span></a></span></dd><dt><span class="deltaxml-new" style="background:#90EE90">Editor:</span></dt><dd><span class="deltaxml-new" style="background:#90EE90">Michael Kay, Saxonica </span><a href="mailto:mike@saxonica.com"><span class="deltaxml-new" style="background:#90EE90">&lt;mike@saxonica.com&gt;</span></a></dd></dl><p><span class="deltaxml-new" style="background:#90EE90">Please check the </span><a href="https://www.w3.org/XML/2017/qt-errata/xquery-31-errata.html"><strong><span class="deltaxml-new" style="background:#90EE90">errata</span></strong></a><span class="deltaxml-new" style="background:#90EE90"> for any errors or issues reported since publication.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See also </span><a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery-31"><strong><span class="deltaxml-new" style="background:#90EE90">translations</span></strong></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright"><span class="deltaxml-new" style="background:#90EE90">Copyright</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;©&nbsp;2000&nbsp;</span><a href="https://www.w3.org/"><abbr title="World Wide Web Consortium"><span class="deltaxml-new" style="background:#90EE90">W3C</span></abbr></a><sup><span class="deltaxml-new" style="background:#90EE90">®</span></sup><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology"><span class="deltaxml-new" style="background:#90EE90">MIT</span></abbr></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics"><span class="deltaxml-new" style="background:#90EE90">ERCIM</span></abbr></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="https://www.keio.ac.jp/"><span class="deltaxml-new" style="background:#90EE90">Keio</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="http://ev.buaa.edu.cn/"><span class="deltaxml-new" style="background:#90EE90">Beihang</span></a><span class="deltaxml-new" style="background:#90EE90">). W3C </span><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer"><span class="deltaxml-new" style="background:#90EE90">liability</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks"><span class="deltaxml-new" style="background:#90EE90">trademark</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="https://www.w3.org/Consortium/Legal/copyright-documents"><span class="deltaxml-new" style="background:#90EE90">document use</span></a><span class="deltaxml-new" style="background:#90EE90"> rules apply.</span></p><hr></div><div><h2><a id="abstract"></a><span class="deltaxml-new" style="background:#90EE90">Abstract</span></h2><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90"> XQuery 4.0 and XPath 4.0 is an expression language that allows the processing of values conforming to the data model defined in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. The name of the language derives from its most distinctive feature, the path expression, which provides a means of hierarchic addressing of the nodes in an XML tree. As well as modeling the tree structure of XML, the data model also includes atomic items, function items, maps, arrays, and sequences. This version of XPath supports JSON as well as XML, and adds many new functions in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 is a superset of XPath 3.1. A detailed list of changes made since XPath 3.1 can be found in </span><a href="#id-revision-log"><b><span class="deltaxml-new" style="background:#90EE90">L Change Log</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">XML is a versatile markup language, capable of labeling the information content of diverse data sources, including structured and semi-structured documents, relational databases, and object repositories. A query language that uses the structure of XML intelligently can express queries across all these kinds of data, whether physically stored in XML or viewed as XML via middleware. This specification describes a query language called XQuery, which is designed to be broadly applicable across many types of XML data sources.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">A list of changes made since XQuery 3.1 can be found in </span><a href="#id-revision-log"><b><span class="deltaxml-new" style="background:#90EE90">L Change Log</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div></div><div><h2><a id="status"></a><span class="deltaxml-new" style="background:#90EE90">Status of this Document</span></h2><p><span class="deltaxml-new" style="background:#90EE90">This is a draft prepared by the QT4CG (officially registered in W3C as the XSLT Extensions Community Group). Comments are invited.</span></p></div><nav id="toc"><h2><a id="contents"></a><span class="deltaxml-new" style="background:#90EE90">Table of Contents</span></h2><ol class="toc"><li><a href="#id-introduction"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Introduction</span></span></a><ol class="toc"></ol></li><li><a href="#id-basics"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Basics</span></span></a><ol class="toc"><li><a href="#id-terminology"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Terminology</span></span></a><ol class="toc"><li><a href="#id-values"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.1.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Values</span></span></a></li><li><a href="#id-namespaces-and-qnames"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.1.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Namespaces and QNames</span></span></a></li></ol></li><li><a href="#context"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90"> Module Context and Expression Context</span></span></a><ol class="toc"><li><a href="#static_context"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.2.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Static Context</span></span></a><a href="#id-function-definitions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.2.1.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Function Definitions</span></span></a><a href="#id-decimal-formats"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.2.1.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Decimal Formats</span></span></a></li><li><a href="#eval_context"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.2.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Dynamic Context</span></span></a></li></ol></li><li><a href="#id-processing-model"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Processing Model</span></span></a><ol class="toc"><li><a href="#id-data-model-generation"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Data Model Generation</span></span></a></li><li><a href="#id-schema-import-processing"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Schema Import Processing</span></span></a></li><li><a href="#id-expression-processing"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Expression Processing</span></span></a><a href="#id-static-analysis"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.3.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Static Analysis Phase</span></span></a><a href="#id-dynamic-evaluation"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.3.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Dynamic Evaluation Phase</span></span></a></li><li><a href="#id-input-sources"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Input Sources</span></span></a></li><li><a href="#id-serialization"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.5 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Serialization</span></span></a></li><li><a href="#id-consistency-constraints"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.3.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Consistency Constraints</span></span></a></li></ol></li><li><a href="#errors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Error Handling</span></span></a><ol class="toc"><li><a href="#id-kinds-of-errors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.4.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Kinds of Errors</span></span></a></li><li><a href="#id-identifying-errors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.4.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Identifying and Reporting Errors</span></span></a></li><li><a href="#id-handling-dynamic"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.4.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Handling Dynamic Errors</span></span></a></li><li><a href="#id-errors-and-opt"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.4.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Errors and Optimization</span></span></a></li><li><a href="#id-guarded-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.4.5 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Guarded Expressions</span></span></a></li><li><a href="#id-implausible-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.4.6 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Implausible Expressions</span></span></a></li></ol></li><li><a href="#id-important-concepts"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Concepts</span></span></a><ol class="toc"><li><a href="#id-document-order"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.5.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Document Order</span></span></a></li><li><a href="#id-typed-value"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.5.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Typed Value and String Value</span></span></a></li><li><a href="#id-atomization"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.5.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></span></a></li><li><a href="#id-ebv"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.5.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Effective Boolean Value</span></span></a></li><li><a href="#id-uri-literals"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.5.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">URI Literals</span></span></a></li><li><a href="#id-resolve-relative-uri"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">2.5.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Resolving a Relative URI Reference</span></span></a></li></ol></li></ol></li><li><a href="#id-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Types</span></span></a><ol class="toc"><li><a href="#id-sequencetype-syntax"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Sequence Types</span></span></a><ol class="toc"><li><a href="#id-sequence-type-examples"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.1.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Examples of Sequence Types</span></span></a></li><li><a href="#id-sequencetype-matching"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.1.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Sequence Type Matching</span></span></a></li></ol></li><li><a href="#id-matching-item"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Item Types</span></span></a><ol class="toc"><li><a href="#general-item-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">General item types</span></span></a></li><li><a href="#id-atomic-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Atomic Types</span></span></a></li><li><a href="#id-union-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Union Types</span></span></a></li><li><a href="#id-namespace-sensitive"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Namespace-sensitive Types</span></span></a></li><li><a href="#id-choice-item-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.5 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Choice Item Types</span></span></a></li><li><a href="#id-enumeration-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.6 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Enumeration Types</span></span></a></li><li><a href="#node-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.7 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Node Types</span></span></a><a href="#id-simple-node-tests"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.7.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Simple Node Tests</span></span></a><a href="#id-element-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.7.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Element Test</span></span></a><a href="#id-schema-element-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.7.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Schema Element Test</span></span></a><a href="#id-attribute-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.7.4 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Attribute Test</span></span></a><a href="#id-schema-attribute-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.7.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Schema Attribute Test</span></span></a></li><li><a href="#id-function-map-array-tests"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.8 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Function, Map, and Array Tests</span></span></a><a href="#id-function-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.8.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Function Test</span></span></a><a href="#id-map-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.8.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Map Test</span></span></a><a href="#id-record-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.8.3 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Record Test</span></span></a><a href="#id-recursive-record-tests"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.8.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Recursive Record Tests</span></span></a><a href="#id-array-test"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.8.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Array Test</span></span></a></li><li><a href="#id-xs-error"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.2.9 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">xs:error</span></span></a></li></ol></li><li><a href="#id-sequencetype-subtype"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Subtype Relationships</span></span></a><ol class="toc"><li><a href="#id-seqtype-subtype"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Subtypes of Sequence Types</span></span></a></li><li><a href="#id-itemtype-subtype"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Subtypes of Item Types</span></span></a><a href="#id-item-subtype-general"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">General Rules</span></span></a><a href="#id-item-subtype-choice"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Choice Item Types</span></span></a><a href="#id-item-subtype-atomic"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Atomic and Union Types</span></span></a><a href="#id-item-subtype-nodes"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Node Types: General Rules</span></span></a><a href="#id-item-subtype-elements"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Node Types: Element Tests</span></span></a><a href="#id-item-subtype-attributes"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Node Types: Attribute Tests</span></span></a><a href="#id-item-subtype-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.7 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Functions</span></span></a><a href="#id-item-subtype-maps"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.8 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Maps</span></span></a><a href="#id-item-subtype-arrays"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.9 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Arrays</span></span></a><a href="#id-item-subtype-records"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.10 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Record Tests</span></span></a><a href="#id-itemtype-subtype-aliases"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.2.11 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Named Item Types</span></span></a></li><li><a href="#id-assertions-subtype"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.3.3 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">The judgement subtype-assertions(AnnotationsA, AnnotationsB) </span></span></a></li></ol></li><li><a href="#id-coercion-rules"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.4 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Coercion Rules</span></span></a><ol class="toc"><li><a href="#id-xpath-10-compatibility"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.4.1 </span></span><span class="content xpath"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 Compatibility Rules</span></span></a></li><li><a href="#id-item-coercion-rules"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.4.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Item Coercion Rules</span></span></a></li><li><a href="#id-implausible-coercions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.4.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Implausible Coercions</span></span></a></li><li><a href="#id-function-coercion"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.4.4 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Function Coercion</span></span></a></li><li><a href="#id-coercion-examples"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.4.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Examples of Coercions</span></span></a></li></ol></li><li><a href="#id-predefined-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">3.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Schema Types</span></span></a></li></ol></li><li><a href="#id-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Expressions</span></span></a><ol class="toc"><li><a href="#comments"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Comments</span></span></a></li><li><a href="#id-primary-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Primary Expressions</span></span></a><ol class="toc"><li><a href="#id-literals"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Literals</span></span></a><a href="#id-numeric-literals"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.1.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Numeric Literals</span></span></a><a href="#id-string-literal"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.1.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">String Literals</span></span></a><a href="#id-constants-other-types"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.1.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Constants of Other Types</span></span></a></li><li><a href="#id-variables"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Variable References</span></span></a></li><li><a href="#id-context-value-references"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Context Value References</span></span></a></li><li><a href="#id-paren-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Parenthesized Expressions</span></span></a></li><li><a href="#id-enclosed-expr"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.2.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Enclosed Expressions</span></span></a></li></ol></li><li><a href="#id-postfix-expression"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Postfix Expressions</span></span></a></li><li><a href="#id-filter-expression"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.4 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Filter Expressions</span></span></a></li><li><a href="#id-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Functions</span></span></a><ol class="toc"><li><a href="#id-static-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Static Function Calls</span></span></a><a href="#id-function-calls"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.1.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Static Function Call Syntax</span></span></a><a href="#id-eval-static-function-call"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.1.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Evaluating Static Function Calls</span></span></a></li><li><a href="#id-dynamic-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Function Items</span></span></a><a href="#id-dynamic-function-invocation"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Dynamic Function Calls</span></span></a><a href="#id-eval-dynamic-function-call"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Evaluating Dynamic Function Calls</span></span></a><a href="#id-partial-function-application"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Partial Function Application</span></span></a><a href="#id-named-function-ref"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Named Function References</span></span></a><a href="#id-inline-func"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2.5 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Inline Function Expressions</span></span></a><a href="#id-focus-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Focus Functions</span></span></a><a href="#id-function-identity"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.2.7 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Function Identity</span></span></a></li><li><a href="#id-variadic-functions-overview"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.5.3 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Variadic Functions</span></span></a></li></ol></li><li><a href="#id-path-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Path Expressions</span></span></a><ol class="toc"><li><a href="#id-absolute-path-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Absolute Path Expressions</span></span></a></li><li><a href="#id-relative-path-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Relative Path Expressions</span></span></a></li><li><a href="#id-path-operator"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Path operator (/)</span></span></a></li><li><a href="#id-steps"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Steps</span></span></a><a href="#axes"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.4.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Axes</span></span></a><a href="#node-tests"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.4.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Node Tests</span></span></a><a href="#implausible-axis-steps"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.4.3 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Implausible Axis Steps</span></span></a></li><li><a href="#id-predicate"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Predicates within Steps</span></span></a></li><li><a href="#unabbrev"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Unabbreviated Syntax</span></span></a></li><li><a href="#abbrev"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.6.7 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Abbreviated Syntax</span></span></a></li></ol></li><li><a href="#id-sequence-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.7 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Sequence Expressions</span></span></a><ol class="toc"><li><a href="#construct_seq"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.7.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Sequence Concatenation</span></span></a></li><li><a href="#id-range-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.7.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Range Expressions</span></span></a></li><li><a href="#combining_seq"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.7.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Combining Node Sequences</span></span></a></li></ol></li><li><a href="#id-arithmetic"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.8 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Arithmetic Expressions</span></span></a></li><li><a href="#id-string-expr"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.9 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">String Expressions</span></span></a><ol class="toc"><li><a href="#id-string-concat-expr"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.9.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">String Concatenation Expressions</span></span></a></li><li><a href="#id-string-templates"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.9.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">String Templates</span></span></a></li><li><a href="#id-string-constructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.9.3 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">String Constructors</span></span></a></li></ol></li><li><a href="#id-comparisons"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.10 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Comparison Expressions</span></span></a><ol class="toc"><li><a href="#id-value-comparisons"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.10.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Value Comparisons</span></span></a></li><li><a href="#id-general-comparisons"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.10.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">General Comparisons</span></span></a></li><li><a href="#id-node-comparisons"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.10.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Node Comparisons</span></span></a></li></ol></li><li><a href="#id-logical-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.11 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Logical Expressions</span></span></a></li><li><a href="#id-constructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Node Constructors</span></span></a><ol class="toc"><li><a href="#id-element-constructor"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Direct Element Constructors</span></span></a><a href="#id-attributes"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.1.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Attributes</span></span></a><a href="#id-namespaces"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.1.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Namespace Declaration Attributes</span></span></a><a href="#id-content"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.1.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Content</span></span></a><a href="#id-whitespace"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.1.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Boundary Whitespace</span></span></a></li><li><a href="#id-otherConstructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Other Direct Constructors</span></span></a></li><li><a href="#id-computedConstructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Computed Constructors</span></span></a><a href="#id-computedElements"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Computed Element Constructors</span></span></a><a href="#id-computedAttributes"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Computed Attribute Constructors</span></span></a><a href="#id-documentConstructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Document Node Constructors</span></span></a><a href="#id-textConstructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Text Node Constructors</span></span></a><a href="#id-computed-pis"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Computed Processing Instruction Constructors</span></span></a><a href="#id-computed-comments"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Computed Comment Constructors</span></span></a><a href="#id-computed-namespaces"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.3.7 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Computed Namespace Constructors</span></span></a></li><li><a href="#id-ns-nodes-on-elements"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.12.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">In-scope Namespaces of a Constructed Element</span></span></a></li></ol></li><li><a href="#id-flwor-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90"> FLWOR Expressions For and Let Expressions </span></span></a><ol class="toc"><li><a href="#id-binding-rules"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.1 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Variable Bindings</span></span></a></li><li><a href="#id-xquery-for-clause"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.2 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">For Clause</span></span></a></li><li><a href="#id-xquery-let-clause"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.3 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Let Clause</span></span></a></li><li><a href="#id-windows"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.4 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Window Clause</span></span></a><a href="#id-tumbling-windows"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.4.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Tumbling Windows</span></span></a><a href="#id-sliding-windows"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.4.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Sliding Windows</span></span></a><a href="#id-effects-of-window-clauses"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.4.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Effects of Window Clauses on the Tuple Stream</span></span></a></li><li><a href="#id-where"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.5 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Where Clause</span></span></a></li><li><a href="#id-while"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.6 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">While Clause</span></span></a></li><li><a href="#id-count"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.7 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Count Clause</span></span></a></li><li><a href="#id-group-by"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.8 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Group By Clause</span></span></a></li><li><a href="#id-order-by-clause"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.9 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Order By Clause</span></span></a></li><li><a href="#id-return-clause"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.10 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Return Clause</span></span></a></li><li><a href="#id-for-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.11 </span></span><span class="content xpath"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">For Expressions</span></span></a></li><li><a href="#id-let-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.13.12 </span></span><span class="content xpath"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Let Expressions</span></span></a></li></ol></li><li><a href="#id-maps-and-arrays"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Maps and Arrays</span></span></a><ol class="toc"><li><a href="#id-maps"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Maps</span></span></a><a href="#id-map-constructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.1.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Map Constructors</span></span></a><a href="#id-map-lookup"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.1.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Map Lookup using Function Call Syntax</span></span></a></li><li><a href="#id-arrays"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Arrays</span></span></a><a href="#id-array-constructors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.2.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Array Constructors</span></span></a><a href="#id-array-lookup"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Array Lookup using Function Call Syntax</span></span></a></li><li><a href="#id-lookup"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.3 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Lookup Expressions for Maps and Arrays</span></span></a><a href="#id-postfix-lookup"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.3.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Postfix Lookup Expressions</span></span></a><a href="#id-unary-lookup"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.3.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Unary Lookup</span></span></a><a href="#id-deep-lookup"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.3.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Deep Lookup</span></span></a><a href="#id-implausible-lookup-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.3.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Implausible Lookup Expressions</span></span></a></li><li><a href="#id-filter-maps-and-arrays"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.4 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Filter Expressions for Maps and Arrays</span></span></a></li><li><a href="#id-pinned-maps-and-arrays"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.14.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Pinned Maps and Arrays</span></span></a></li></ol></li><li><a href="#id-unordered-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.15 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Ordered and Unordered Expressions</span></span></a></li><li><a href="#id-conditionals"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.16 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Conditional Expressions</span></span></a></li><li><a href="#id-otherwise"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.17 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Otherwise Expressions</span></span></a></li><li><a href="#id-switch"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.18 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Switch Expressions</span></span></a></li><li><a href="#id-quantified-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.19 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Quantified Expressions</span></span></a></li><li><a href="#id-try-catch"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.20 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Try/Catch Expressions</span></span></a></li><li><a href="#id-expressions-on-datatypes"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.21 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Expressions on SequenceTypes</span></span></a><ol class="toc"><li><a href="#id-instance-of"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.21.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Instance Of</span></span></a></li><li><a href="#id-typeswitch"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.21.2 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Typeswitch</span></span></a></li><li><a href="#id-cast"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.21.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Cast</span></span></a></li><li><a href="#id-castable"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.21.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Castable</span></span></a></li><li><a href="#id-constructor-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.21.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Constructor Functions</span></span></a></li><li><a href="#id-treat"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.21.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Treat</span></span></a></li></ol></li><li><a href="#id-map-operator"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.22 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Simple map operator (!)</span></span></a></li><li><a href="#id-arrow-operator"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.23 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Arrow Expressions</span></span></a><ol class="toc"><li><a href="#id-sequence-arrow-expression"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.23.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Sequence Arrow Expressions</span></span></a></li><li><a href="#id-mapping-arrow-expression"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.23.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Mapping Arrow Expressions</span></span></a></li><li><a href="#lookup-arrow-expression"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.23.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Lookup Arrow Expressions</span></span></a></li></ol></li><li><a href="#id-validate"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.24 </span></span><span class="content xquery"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Validate Expressions</span></span></a></li><li><a href="#id-extension-expressions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">4.25 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Extension Expressions</span></span></a></li></ol></li><li><a href="#id-query-prolog"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Modules and Prologs</span></span></a><ol class="toc"><li><a href="#id-version-declaration"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Version Declaration</span></span></a></li><li><a href="#id-module-declaration"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Module Declaration</span></span></a></li><li><a href="#id-boundary-space-decls"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Boundary-space Declaration</span></span></a></li><li><a href="#id-default-collation-declaration"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Default Collation Declaration</span></span></a></li><li><a href="#id-base-uri-decl"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Base URI Declaration</span></span></a></li><li><a href="#id-construction-declaration"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Construction Declaration</span></span></a></li><li><a href="#id-default-ordering-decl"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.7 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Ordering Mode Declaration</span></span></a></li><li><a href="#id-empty-order-decl"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.8 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Empty Order Declaration</span></span></a></li><li><a href="#id-copy-namespaces-decl"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.9 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Copy-Namespaces Declaration</span></span></a></li><li><a href="#id-decimal-format-decl"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.10 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Decimal Format Declaration</span></span></a></li><li><a href="#id-schema-import"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.11 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Schema Import</span></span></a></li><li><a href="#id-module-import"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.12 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Module Import</span></span></a><ol class="toc"><li><a href="#id-module-handling-module-uris"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.12.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">The Target Namespace of a Module</span></span></a></li><li><a href="#id-module-handling-multiple-same"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.12.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Multiple Modules with the same Namespace</span></span></a></li><li><a href="#id-module-handling-location-uris"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.12.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Location URIs</span></span></a></li><li><a href="#id-module-handling-cycles"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.12.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Cycles</span></span></a></li></ol></li><li><a href="#id-namespace-declaration"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.13 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Namespace Declaration</span></span></a></li><li><a href="#id-default-namespace"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.14 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Default Namespace Declaration</span></span></a></li><li><a href="#id-annotations"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.15 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Annotations</span></span></a></li><li><a href="#id-variable-declarations"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.16 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Variable Declaration</span></span></a></li><li><a href="#id-context-value-declarations"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.17 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Context Value Declaration</span></span></a></li><li><a href="#FunctionDeclns"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.18 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Function Declarations</span></span></a><ol class="toc"><li><a href="#id-user-defined-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.18.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">User-Defined Functions</span></span></a></li><li><a href="#id-function-names"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.18.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Function Names</span></span></a></li><li><a href="#id-function-parameters"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.18.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Function Parameters</span></span></a></li><li><a href="#id-function-annotations"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.18.4 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Function Annotations</span></span></a></li><li><a href="#id-external-functions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.18.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">External Functions</span></span></a></li><li><a href="#id-recursion"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.18.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Recursion</span></span></a></li></ol></li><li><a href="#id-item-type-declaration"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.19 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Item Type Declarations</span></span></a></li><li><a href="#id-option-declaration"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">5.20 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Option Declaration</span></span></a></li></ol></li><li><a href="#id-conformance"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Conformance</span></span></a><ol class="toc"><li><a href="#id-minimal-conformance"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.1 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Minimal Conformance</span></span></a></li><li><a href="#id-conform-optional-features"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.2 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Optional Features</span></span></a><ol class="toc"><li><a href="#id-schema-aware-feature"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.2.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></span></a></li><li><a href="#id-typed-data-feature"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Typed Data Feature</span></span></a></li><li><a href="#id-module-feature"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.2.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Module Feature</span></span></a></li><li><a href="#id-serialization-feature"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.2.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Serialization Feature</span></span></a></li></ol></li><li><a href="#id-data-model-conformance"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.3 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Data Model Conformance</span></span></a></li><li><a href="#id-syntax-extensions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">6.4 </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Syntax Extensions</span></span></a></li></ol></li><li><a href="#nt-bnf"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 Grammar</span></span></a><ol class="toc"><li><a href="#id-grammar"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">EBNF</span></span></a><ol class="toc"><li><a href="#EBNFNotation"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.1.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Notation</span></span></a></li><li><a href="#extra-grammatical-constraints"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.1.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Extra-grammatical Constraints</span></span></a></li><li><a href="#notes-on-parsing"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.1.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Grammar Notes</span></span></a></li></ol></li><li><a href="#productions-derived-from-XML"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Productions Derived from XML</span></span></a></li><li><a href="#lexical-structure"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Lexical structure</span></span></a><ol class="toc"><li><a href="#terminal-symbols"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Terminal Symbols</span></span></a></li><li><a href="#id-terminal-delimitation"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Terminal Delimitation</span></span></a></li><li><a href="#id-lt-and-gt-characters"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Less-Than and Greater-Than Characters</span></span></a></li><li><a href="#id-eol-handling"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">End-of-Line Handling</span></span></a><a href="#id-xml10-eol-handling"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.4.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">XML 1.0 End-of-Line Handling</span></span></a><a href="#id-xml11-eol-handling"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.4.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">XML 1.1 End-of-Line Handling</span></span></a></li><li><a href="#whitespace-rules"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Whitespace Rules</span></span></a><a href="#DefaultWhitespaceHandling"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.5.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Default Whitespace Handling</span></span></a><a href="#ExplicitWhitespaceHandling"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.3.5.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Explicit Whitespace Handling</span></span></a></li></ol></li><li><a href="#id-reserved-fn-names"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.4 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Reserved Function Names</span></span></a></li><li><a href="#id-precedence-order"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">A.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Precedence Order (Non-Normative)</span></span></a></li></ol></li><li><a href="#id-type-promotion-and-operator-mapping"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">B </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Type Promotion and Operator Mapping</span></span></a><ol class="toc"><li><a href="#promotion"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">B.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Type Promotion</span></span></a></li><li><a href="#mapping"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">B.2 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Operator Mapping</span></span></a></li></ol></li><li><a href="#id-xq-context-components"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">C </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">Context Components</span></span></a><ol class="toc"><li><a href="#id-xq-static-context-components"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">C.1 </span></span><span class="content"><span class="tocDelta"><span class="deltaxml-new" style="background:#90EE90"> Δ </span></span><span class="deltaxml-new" style="background:#90EE90">Static Context Components</span></span></a></li><li><a href="#id-xq-evaluation-context-components"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">C.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Dynamic Context Components</span></span></a></li></ol></li><li><a href="#id-xp-context-components"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">D </span></span><span class="content xpath"><span class="deltaxml-new" style="background:#90EE90">Context Components</span></span></a><ol class="toc"><li><a href="#id-xp-static-context-components"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">D.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Static Context Components</span></span></a></li><li><a href="#id-xp-evaluation-context-components"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">D.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Dynamic Context Components</span></span></a></li></ol></li><li><a href="#id-impl-defined-items"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">E </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Implementation-Defined Items</span></span></a><ol class="toc"></ol></li><li><a href="#id-references"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">F </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">References</span></span></a><ol class="toc"><li><a href="#id-normative-references"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">F.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Normative References</span></span></a></li><li><a href="#id-non-normative-references"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">F.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Non-normative References</span></span></a></li><li><a href="#id-background-material"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">F.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Background Material</span></span></a></li></ol></li><li><a href="#id-errors"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">G </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Error Conditions</span></span></a><ol class="toc"></ol></li><li><a href="#id-mime-type"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H </span></span><span class="content xquery"><span class="deltaxml-new" style="background:#90EE90">The application/xquery Media Type</span></span></a><ol class="toc"><li><a href="#id-mime-type-intro"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Introduction</span></span></a></li><li><a href="#id-registration-of-mime-type"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Registration of MIME Media Type application/xquery </span></span></a><ol class="toc"><li><a href="#id-interoperability-considerations"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.2.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Interoperability Considerations</span></span></a></li><li><a href="#id-applications-of-media-type"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.2.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Applications Using this Media Type</span></span></a></li><li><a href="#id-file-extensions"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.2.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">File Extensions</span></span></a></li><li><a href="#id-intended-usage"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.2.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Intended Usage</span></span></a></li><li><a href="#id-author-change-controller"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.2.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Author/Change Controller</span></span></a></li></ol></li><li><a href="#xquery-mime-encoding"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Encoding Considerations</span></span></a></li><li><a href="#xquery-mime-recognizing"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.4 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Recognizing XQuery Files</span></span></a></li><li><a href="#id-charset-default-rules"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.5 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Charset Default Rules</span></span></a></li><li><a href="#id-security-considerations"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">H.6 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Security Considerations</span></span></a></li></ol></li><li><a href="#id-glossary"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">I </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Glossary</span></span></a><span class="deltaxml-new" style="background:#90EE90"> (Non-Normative) </span><ol class="toc"></ol></li><li><a href="#id-atomic-comparisons"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">J </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Atomic Comparisons: An Overview</span></span></a><span class="deltaxml-new" style="background:#90EE90"> (Non-Normative) </span><ol class="toc"><li><a href="#id-equality-comparison"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">J.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Equality Comparisons</span></span></a></li><li><a href="#id-ordering-comparison"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">J.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Ordering Comparisons</span></span></a></li></ol></li><li><a href="#id-incompatibilities"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Backwards Compatibility</span></span></a><span class="deltaxml-new" style="background:#90EE90"> (Non-Normative) </span><ol class="toc"><li><a href="#id-incompatibilities-31"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Incompatibilities relative to XQuery and XPath 3.1</span></span></a></li><li><a href="#id-incompatibilities-30"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Incompatibilities relative to XQuery and XPath 3.0</span></span></a></li><li><a href="#id-incompatibilities-10"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Incompatibilities relative to XQuery and XPath 2.0 1.0 </span></span></a></li><li><a href="#id-backwards-compatibility"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K.4 </span></span><span class="content xpath"><span class="deltaxml-new" style="background:#90EE90">Incompatibilities relative to XPath 1.0</span></span></a><ol class="toc"><li><a href="#id-incompat-in-true-mode"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K.4.1 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Incompatibilities when Compatibility Mode is true</span></span></a></li><li><a href="#id-incompat-in-false-mode"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K.4.2 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Incompatibilities when Compatibility Mode is false </span></span></a></li><li><a href="#id-incompat-when-using-schema"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">K.4.3 </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Incompatibilities when using a Schema</span></span></a></li></ol></li></ol></li><li><a href="#id-revision-log"><span class="secno"><span class="deltaxml-new" style="background:#90EE90">L </span></span><span class="content"><span class="deltaxml-new" style="background:#90EE90">Change Log</span></span></a><span class="deltaxml-new" style="background:#90EE90"> (Non-Normative) </span><ol class="toc"></ol></li></ol></nav><hr><div class="body"><div class="div1"><h2><a id="id-introduction"></a><span class="deltaxml-new" style="background:#90EE90">1 Introduction</span></h2><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-terminology"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">Use the arrows to browse significant changes since the 3.1 version of this specification.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Sections with significant changes are marked Δ in the table of contents.</span></p></li></ol></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">As increasing amounts of information are stored, exchanged, and presented using XML, the ability to intelligently query XML data sources becomes increasingly important. One of the great strengths of XML is its flexibility in representing many different kinds of information from diverse sources. To exploit this flexibility, an XML query language must provide features for retrieving and interpreting information from these diverse sources.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">As increasing amounts of JSON are used for lightweight data-exchange, an XML query language for Web data needs to handle JSON as well as XML and HTML.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery is designed to be a language in which queries are concise and easily understood. It is also flexible enough to query a broad spectrum of information sources, both XML and non-XML, including both databases and documents. XQuery was originally derived from an XML query language called Quilt </span><a href="#Quilt"><span class="deltaxml-new" style="background:#90EE90">[Quilt]</span></a><span class="deltaxml-new" style="background:#90EE90">, which in turn borrowed features from several other languages, including XPath 1.0 </span><a href="#xpath"><span class="deltaxml-new" style="background:#90EE90">[XML Path Language (XPath) Version 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, XQL </span><a href="#XQL"><span class="deltaxml-new" style="background:#90EE90">[XQL]</span></a><span class="deltaxml-new" style="background:#90EE90">, XML-QL </span><a href="#XML-QL"><span class="deltaxml-new" style="background:#90EE90">[XML-QL]</span></a><span class="deltaxml-new" style="background:#90EE90">, SQL </span><a href="#SQL"><span class="deltaxml-new" style="background:#90EE90">[SQL]</span></a><span class="deltaxml-new" style="background:#90EE90">, and OQL </span><a href="#ODMG"><span class="deltaxml-new" style="background:#90EE90">[ODMG]</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath was originally designed as an expression language to address the nodes of XML trees; it has since been extended to address a variety of non-XML data sources. XPath gets its name from its use of a path notation for navigating through the hierarchical structure of an XML document; similar capabilities for navigating JSON structures were added in versions 3.0 and 3.1. XPath uses a compact, non-XML syntax, allowing XPath expressions to be embedded within URIs and to be used as XML attribute values. XPath is designed to be embedded in (or invoked from) other host languages, including both languages specialized towards XML processing (such as </span><a href="#xslt-40"><span class="deltaxml-new" style="background:#90EE90">[XSL Transformations (XSLT) Version 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and XSD), and general purpose programming languages such as Java, C#, Python, and Javascript. The interface between XPath and its host language is formalized with an abstract definition of a static and dynamic context, made available by the host language to the XPath processor.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-host-language" title="host language"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">host language</span></b><span class="deltaxml-new" style="background:#90EE90"> for XPath is any environment that provides capabilities for XPath expressions to be defined and evaluated, and that supplies a static and dynamic context for their evaluation. ] </span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-datamodel" title="data model"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: XQuery 4.0 and XPath 4.0 operates on the abstract, logical structure of an XML document or JSON object rather than its surface syntax. This logical structure, known as the </span><b><span class="deltaxml-new" style="background:#90EE90">data model</span></b><span class="deltaxml-new" style="background:#90EE90">, is defined in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 is an extension of XPath 4.0.</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath 4.0 is a subset of XQuery 4.0.</span></span></span><span class="deltaxml-new" style="background:#90EE90"> In general, any expression that is syntactically valid and executes successfully in both XPath 4.0 and XQuery 4.0 will return the same result in both languages. There are a few exceptions to this rule: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Because XQuery expands </span><span class="xquery"><span class="xquery"><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference"><span class="deltaxml-new" style="background:#90EE90">predefined entity references</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character references</span></a></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90"> predefined entity references and character references </span></span></span><span class="deltaxml-new" style="background:#90EE90"> and XPath does not, expressions containing these produce different results in the two languages. For instance, the value of the string literal </span><code><span class="deltaxml-new" style="background:#90EE90">"&amp;amp;"</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;</span></code><span class="deltaxml-new" style="background:#90EE90"> in XQuery, and </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;amp;</span></code><span class="deltaxml-new" style="background:#90EE90"> in XPath. (A host language may expand predefined entity references or character references before the XPath expression is evaluated.)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If XPath 1.0 compatibility mode is enabled, XPath behaves differently from XQuery in a number of ways, </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">which are noted throughout this document, and listed in </span><a href="#id-incompat-in-false-mode"><b><span class="deltaxml-new" style="background:#90EE90">K.4.2 Incompatibilities when Compatibility Mode is false </span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">which are discussed in </span><a href="#xpath-40"><span class="deltaxml-new" style="background:#90EE90">[XPath 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Because these languages are so closely related, their grammars and language descriptions are generated from a common source to ensure consistency.</span></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 also depends on and is closely related to the following specifications:</span></p><ul><li><p><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> defines the data model that underlies all XQuery 4.0 and XPath 4.0 expressions.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The type system of XQuery 4.0 and XPath 4.0 is based on XML Schema. It is implementation-defined whether the type system is based on </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The system function library and the operators supported by XQuery 4.0 and XPath 4.0 are defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">XQuery also has an XML-based syntax, which is described in [XQueryX 3.1]. </span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The XML-based syntax for XQuery known as XQueryX is no longer maintained.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-xquery-40-processor" title="XQuery 4.0 Processor"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 4.0 specification. ] [</span><a id="dt-xquery-31-processor" title="XQuery 3.1 Processor"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 3.1 specification. ] [</span><a id="dt-xquery-30-processor" title="XQuery 3.0 Processor"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 3.0 specification. ] [</span><a id="dt-xquery-10-processor" title="XQuery 1.0 Processor"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 1.0 specification. ] </span></p></div><p><span class="deltaxml-new" style="background:#90EE90">This document specifies a grammar for XQuery 4.0 and XPath 4.0, using the same basic EBNF notation used in </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. Unless otherwise noted (see </span><a href="#lexical-structure"><b><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></b></a><span class="deltaxml-new" style="background:#90EE90">), whitespace is not significant in </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">queries</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expressions</span></span></span><span class="deltaxml-new" style="background:#90EE90">. Grammar productions are introduced together with the features that they describe, and a complete grammar is also presented in the appendix [</span><a href="#nt-bnf"><b><span class="deltaxml-new" style="background:#90EE90">A XQuery 4.0 and XPath 4.0 Grammar</span></b></a><span class="deltaxml-new" style="background:#90EE90">]. The appendix is the normative version.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the grammar productions in this document, named symbols are underlined and literal text is enclosed in double quotes. For example, the following productions describe the syntax of a static function call:</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e232.doc-xpath40-FunctionCall" id="noid_d4e232.doc-xpath40-FunctionCall"></a><span class="deltaxml-new" style="background:#90EE90">[179]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionCall"><span class="deltaxml-new" style="background:#90EE90">FunctionCall</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#doc-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-reserved-function-names"><span class="deltaxml-new" style="background:#90EE90">xgc: reserved-function-names</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-parens"><span class="deltaxml-new" style="background:#90EE90">gn: parens</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e233.doc-xpath40-ArgumentList" id="noid_d4e233.doc-xpath40-ArgumentList"></a><span class="deltaxml-new" style="background:#90EE90">[155]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" ((</span><a href="#doc-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)?) | </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The productions should be read as follows: A function call consists of an </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by an </span><a href="#doc-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a><span class="deltaxml-new" style="background:#90EE90">. The argument list consists of an opening parenthesis, an optional list of one or more arguments (separated by commas), and a closing parenthesis.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This document normatively defines the static and dynamic semantics of XQuery 4.0 and XPath 4.0. In this document, examples and material labeled as “Note” are provided for explanatory purposes and are not normative.</span></p></div><div class="div1"><h2><a id="id-basics"></a><span class="deltaxml-new" style="background:#90EE90">2 Basics</span></h2><div class="div2"><h3><a id="id-terminology"></a><span class="deltaxml-new" style="background:#90EE90">2.1 Terminology</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-values"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-introduction"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The term </span><b><span class="deltaxml-new" style="background:#90EE90">atomic value</span></b><span class="deltaxml-new" style="background:#90EE90"> has been replaced by </span><b><span class="deltaxml-new" style="background:#90EE90">atomic item</span></b><span class="deltaxml-new" style="background:#90EE90">. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1337"><span class="deltaxml-new" style="background:#90EE90">1337</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1361"><span class="deltaxml-new" style="background:#90EE90">1361</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;2 August 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">The basic building block of XQuery 4.0 and XPath 4.0 is the </span><b><span class="deltaxml-new" style="background:#90EE90">expression</span></b><span class="deltaxml-new" style="background:#90EE90">, which is a string of </span><a href="#Unicode"><span class="deltaxml-new" style="background:#90EE90">[Unicode]</span></a><span class="deltaxml-new" style="background:#90EE90"> characters; the version of Unicode to be used is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. The language provides several kinds of expressions which may be constructed from keywords, symbols, and operands. In general, the operands of an expression are other expressions. XQuery 4.0 and XPath 4.0 allows expressions to be nested with full generality. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">(However, unlike a pure functional language, it does not allow variable substitution if the variable declaration contains construction of new nodes.)</span></span></span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This specification contains no assumptions or requirements regarding the character set encoding of strings of </span><a href="#Unicode"><span class="deltaxml-new" style="background:#90EE90">[Unicode]</span></a><span class="deltaxml-new" style="background:#90EE90"> characters.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Like XML, XQuery 4.0 and XPath 4.0 is a case-sensitive language. Keywords in XQuery 4.0 and XPath 4.0 use lower-case characters and are not reserved—that is, names in XQuery 4.0 and XPath 4.0 expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in </span><a href="#id-reserved-fn-names"><b><span class="deltaxml-new" style="background:#90EE90">A.4 Reserved Function Names</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In this specification the phrases </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must not</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should not</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">required</span></span><span class="deltaxml-new" style="background:#90EE90">, and </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">recommended</span></span><span class="deltaxml-new" style="background:#90EE90">, when used in normative text and rendered in small capitals, are to be interpreted as described in </span><a href="#RFC2119"><span class="deltaxml-new" style="background:#90EE90">[RFC2119]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Certain aspects of language processing are described in this specification as </span><b><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></b><span class="deltaxml-new" style="background:#90EE90"> or </span><b><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-implementation-defined" title="implementation defined"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Implementation-defined</span></b><span class="deltaxml-new" style="background:#90EE90"> indicates an aspect that may differ between implementations, but must be specified by the implementor for each particular implementation.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-implementation-dependent" title="implementation   dependent"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Implementation-dependent</span></b><span class="deltaxml-new" style="background:#90EE90"> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementor for any particular implementation.] </span></p></li></ul><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">A language aspect described in this specification as </span><b><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></b><span class="deltaxml-new" style="background:#90EE90"> or </span><b><span class="deltaxml-new" style="background:#90EE90">implementation dependent</span></b><span class="deltaxml-new" style="background:#90EE90"> may be further constrained by the specifications of a host language in which XPath is embedded.</span></p></div><div class="div3"><h4><a id="id-values"></a><span class="deltaxml-new" style="background:#90EE90">2.1.1 Values</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#static_context"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-terminology"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The term </span><b><span class="deltaxml-new" style="background:#90EE90">atomic value</span></b><span class="deltaxml-new" style="background:#90EE90"> has been replaced by </span><a title="atomic item" class="termref" href="#dt-atomic-item"><span class="deltaxml-new" style="background:#90EE90">atomic item</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1337"><span class="deltaxml-new" style="background:#90EE90">1337</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1361"><span class="deltaxml-new" style="background:#90EE90">1361</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;2 August 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-value" title="value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><b><span class="deltaxml-new" style="background:#90EE90">value</span></b><span class="deltaxml-new" style="background:#90EE90"> is always a </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-new" style="background:#90EE90">sequence</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-sequence" title="sequence"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">sequence</span></b><span class="deltaxml-new" style="background:#90EE90"> is an ordered collection of zero or more </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-item" title="item"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">item</span></b><span class="deltaxml-new" style="background:#90EE90"> is either an </span><a title="atomic item" class="termref" href="#dt-atomic-item"><span class="deltaxml-new" style="background:#90EE90">atomic item</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="node" class="termref" href="#dt-node"><span class="deltaxml-new" style="background:#90EE90">node</span></a><span class="deltaxml-new" style="background:#90EE90">, or a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-atomic-item" title="atomic item"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">atomic item</span></b><span class="deltaxml-new" style="background:#90EE90"> is a value in the value space of an </span><b><span class="deltaxml-new" style="background:#90EE90">atomic type</span></b><span class="deltaxml-new" style="background:#90EE90">, as defined in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-node" title="node"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">node</span></b><span class="deltaxml-new" style="background:#90EE90"> is an instance of one of the </span><b><span class="deltaxml-new" style="background:#90EE90">node kinds</span></b><span class="deltaxml-new" style="background:#90EE90"> defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#Node"><span class="deltaxml-new" style="background:#90EE90">Section 5 Nodes</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.] Each node has a unique </span><b><span class="deltaxml-new" style="background:#90EE90">node identity</span></b><span class="deltaxml-new" style="background:#90EE90">, a </span><b><span class="deltaxml-new" style="background:#90EE90">typed value</span></b><span class="deltaxml-new" style="background:#90EE90">, and a </span><b><span class="deltaxml-new" style="background:#90EE90">string value</span></b><span class="deltaxml-new" style="background:#90EE90">. In addition, some nodes have a </span><b><span class="deltaxml-new" style="background:#90EE90">name</span></b><span class="deltaxml-new" style="background:#90EE90">. The </span><b><span class="deltaxml-new" style="background:#90EE90">typed value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a node is a sequence of zero or more atomic items. The </span><b><span class="deltaxml-new" style="background:#90EE90">string value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a node is a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">. The </span><b><span class="deltaxml-new" style="background:#90EE90">name</span></b><span class="deltaxml-new" style="background:#90EE90"> of a node is a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-function-item" title="function item"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">function item</span></b><span class="deltaxml-new" style="background:#90EE90"> is an item that can be called using a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-call"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Maps (see </span><a href="#id-maps"><b><span class="deltaxml-new" style="background:#90EE90">4.14.1 Maps</span></b></a><span class="deltaxml-new" style="background:#90EE90">) and arrays (see </span><a href="#id-arrays"><b><span class="deltaxml-new" style="background:#90EE90">4.14.2 Arrays</span></b></a><span class="deltaxml-new" style="background:#90EE90">) are specific kinds of </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">s.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-singleton" title="singleton"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A sequence containing exactly one item is called a </span><b><span class="deltaxml-new" style="background:#90EE90">singleton</span></b><span class="deltaxml-new" style="background:#90EE90">.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [</span><a id="dt-empty-sequence" title="empty sequence"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A sequence containing zero items is called an </span><b><span class="deltaxml-new" style="background:#90EE90">empty sequence</span></b><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-data-model-instance" title="XDM instance"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The term </span><b><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></b><span class="deltaxml-new" style="background:#90EE90"> is used, synonymously with the term </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-new" style="background:#90EE90">value</span></a><span class="deltaxml-new" style="background:#90EE90">, to denote an unconstrained </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-new" style="background:#90EE90">sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Element nodes have a property called </span><b><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></b><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-in-scope-namespaces" title="in-scope namespaces"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></b><span class="deltaxml-new" style="background:#90EE90"> property of an element node is a set of namespace bindings, each of which associates a namespace prefix with a URI.] For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">In </span><a href="#xpath"><span class="deltaxml-new" style="background:#90EE90">[XML Path Language (XPath) Version 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, the in-scope namespaces of an element node are represented by a collection of </span><b><span class="deltaxml-new" style="background:#90EE90">namespace nodes</span></b><span class="deltaxml-new" style="background:#90EE90"> arranged on a </span><b><span class="deltaxml-new" style="background:#90EE90">namespace axis</span></b><span class="deltaxml-new" style="background:#90EE90">. As of XPath 2.0, the namespace axis is deprecated and need not be supported by a host language. A host language that does not support the namespace axis need not represent namespace bindings in the form of nodes.</span></p></div><div class="xquery note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In </span><a href="#xpath"><span class="deltaxml-new" style="background:#90EE90">[XML Path Language (XPath) Version 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, the in-scope namespaces of an element node are represented by a collection of </span><b><span class="deltaxml-new" style="background:#90EE90">namespace nodes</span></b><span class="deltaxml-new" style="background:#90EE90"> arranged on a </span><b><span class="deltaxml-new" style="background:#90EE90">namespace axis</span></b><span class="deltaxml-new" style="background:#90EE90">, which is optional and deprecated in </span><a href="#xpath-40"><span class="deltaxml-new" style="background:#90EE90">[XPath 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. XQuery does not support the namespace axis and does not represent namespace bindings in the form of nodes.</span></p><p><span class="deltaxml-new" style="background:#90EE90">However, where other specifications such as </span><a href="#xslt-xquery-serialization-40"><span class="deltaxml-new" style="background:#90EE90">[XSLT and XQuery Serialization 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> refer to namespace nodes, these nodes may be synthesized from the in-scope namespaces of an element node by interpreting each namespace binding as a namespace node. An application that needs to create a set of namespace nodes to represent these bindings for an element bound to </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> can do so using the following code. </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">in-scope-prefixes($e) ! namespace {.}{ namespace-uri-for-prefix(., $e)}</span></pre></div></div></div></div><div class="div3"><h4><a id="id-namespaces-and-qnames"></a><span class="deltaxml-new" style="background:#90EE90">2.1.2 Namespaces and QNames</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-expanded-qname" title="expanded QName"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></b><span class="deltaxml-new" style="background:#90EE90"> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.] When comparing two expanded QNames, the prefixes are ignored: the local name parts must be equal under the Unicode codepoint collation (</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#collations"><span class="deltaxml-new" style="background:#90EE90">Section 5.3.1 Collations</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">), and the namespace URI parts must either both be absent, or must be equal under the Unicode codepoint collation.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the XQuery 4.0 and XPath 4.0 grammar, QNames representing the names of elements, attributes, functions, variables, types, or other such constructs are written as instances of the grammatical production </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EQName" id="doc-xpath40-EQName"></a><span class="deltaxml-new" style="background:#90EE90">[266]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-QName" id="doc-xpath40-QName"></a><span class="deltaxml-new" style="background:#90EE90">[286]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-QName"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">Names</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-URILiteral" id="doc-xpath40-URILiteral"></a><span class="deltaxml-new" style="background:#90EE90">[265]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-URIQualifiedName" id="doc-xpath40-URIQualifiedName"></a><span class="deltaxml-new" style="background:#90EE90">[275]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BracedURILiteral" id="doc-xpath40-BracedURILiteral"></a><span class="deltaxml-new" style="background:#90EE90">[276]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"Q" "{" (</span><a href="#doc-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | [^&amp;{}])* "}"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e524.doc-xpath40-NCName" id="noid_d4e524.doc-xpath40-NCName"></a><span class="deltaxml-new" style="background:#90EE90">[287]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">Names</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> production allows a QName to be written in one of three ways: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">local-name only (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">invoice</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">A name written in this form has no prefix, and the rules for determining the namespace depend on the context in which the name appears. This form is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">prefix plus local-name (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">my:invoice</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">In this case the prefix and local name of the QName are as written, and the namespace URI is inferred from the prefix by examining the in-scope namespaces in the static context where the QName appears; the context must include a binding for the prefix. This form is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">URI plus local-name (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">Q{http://example.com/ns}invoice</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">In this case the local name and namespace URI are as written, and the prefix is absent. This way of writing a QName is context-free, which makes it particularly suitable for use in </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">queries</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expressions</span></span></span><span class="deltaxml-new" style="background:#90EE90"> that are generated by software. This form is a </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a><span class="deltaxml-new" style="background:#90EE90">. If the </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90"> BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> has no content (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">Q{}invoice</span></code><span class="deltaxml-new" style="background:#90EE90">) then the namespace URI of the QName is absent.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-qname" title="lexical QName"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></b><span class="deltaxml-new" style="background:#90EE90"> is a name that conforms to the syntax of the </span><a href="#doc-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> production]. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The namespace URI value in a </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a><span class="deltaxml-new" style="background:#90EE90"> is whitespace normalized according to the rules for the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> type in </span><a href="https://www.w3.org/TR/xmlschema-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.2.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.3.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">] if the namespace URI for an EQName is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90">s:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">pi</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> without a namespace prefix.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">math:pi</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> with a namespace prefix.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">Q{http://www.w3.org/2005/xpath-functions/math}pi</span></code><span class="deltaxml-new" style="background:#90EE90"> specifies the namespace URI using a </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">; it is not a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">This document uses the following namespace prefixes to represent the namespace URIs with which they are listed. Although these prefixes are used within this specification to refer to the corresponding namespaces, not all of these bindings will necessarily be present in the static context of every expression, and authors are free to use different prefixes for these namespaces, or to bind these prefixes to different namespaces.</span></p><ul><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema</span></code></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">xsi</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema-instance</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/array</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/map</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">math</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/math</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">err</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xqt-errors</span></code><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-identifying-errors"><b><span class="deltaxml-new" style="background:#90EE90">2.4.2 Identifying and Reporting Errors</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">local</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xquery-local-functions</span></code><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#FunctionDeclns"><b><span class="deltaxml-new" style="background:#90EE90">5.18 Function Declarations</span></b></a><span class="deltaxml-new" style="background:#90EE90">.) </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">output</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/xslt-xquery-serialization</span></code></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">xq</span></code><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2012/xquery</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-URI" title="URI"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Within this specification, the term </span><b><span class="deltaxml-new" style="background:#90EE90">URI</span></b><span class="deltaxml-new" style="background:#90EE90"> refers to a Universal Resource Identifier as defined in </span><a href="#RFC3986"><span class="deltaxml-new" style="background:#90EE90">[RFC3986]</span></a><span class="deltaxml-new" style="background:#90EE90"> and extended in </span><a href="#RFC3987"><span class="deltaxml-new" style="background:#90EE90">[RFC3987]</span></a><span class="deltaxml-new" style="background:#90EE90"> with the new name </span><b><span class="deltaxml-new" style="background:#90EE90">IRI</span></b><span class="deltaxml-new" style="background:#90EE90">.] The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as “Base URI” that are defined or referenced across the whole family of XML specifications.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In most contexts, processors are not required to raise errors if a URI is not lexically valid according to </span><a href="#RFC3986"><span class="deltaxml-new" style="background:#90EE90">[RFC3986]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#RFC3987"><span class="deltaxml-new" style="background:#90EE90">[RFC3987]</span></a><span class="deltaxml-new" style="background:#90EE90">. See </span><a href="#id-uri-literals"><b><span class="deltaxml-new" style="background:#90EE90">2.5.5 URI Literals</span></b></a><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">and </span><a href="#id-namespaces"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.2 Namespace Declaration Attributes</span></b></a></span></span><span class="deltaxml-new" style="background:#90EE90"> for details.</span></p></div></div></div><div class="div2"><h3><a id="context"></a><span class="deltaxml-new" style="background:#90EE90">2.2 </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Module Context and </span></span></span><span class="deltaxml-new" style="background:#90EE90">Expression Context</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-expression-context" title="expression context"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">expression context</span></b><span class="deltaxml-new" style="background:#90EE90"> for a given expression consists of all the information that can affect the result of the expression.] </span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-module-context" title="module context"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">module context</span></b><span class="deltaxml-new" style="background:#90EE90"> for a given module consists of all the information that is accessible to top-level expressions in the module.] The context of a top-level expression is defined based on the context of the module in which it is defined: the context of the </span><a href="#doc-xpath40-QueryBody"><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></a><span class="deltaxml-new" style="background:#90EE90"> is the context of the main module, and the context for evaluating a function body or for a variable’s initializing expression is defined based on the context of the module in which the function or variable is defined.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">This information is organized into two categories called the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> and the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div3"><h4><a id="static_context"></a><span class="deltaxml-new" style="background:#90EE90">2.2.1 Static Context</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-values"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> can be set to the value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/296"><span class="deltaxml-new" style="background:#90EE90">296</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1181"><span class="deltaxml-new" style="background:#90EE90">1181</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;30 April 2024]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1343"><span class="deltaxml-new" style="background:#90EE90">1343</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-context" title="static context"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">static context</span></b><span class="deltaxml-new" style="background:#90EE90"> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.] This information can be used to decide whether the expression contains a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The individual components of the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> are described below. </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">A default initial value for each component must be specified by the host language. The scope of each component is specified in </span><a href="#id-xp-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">D.1 Static Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Rules governing the initialization and alteration of these components can be found in </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-xpath-compat-mode" title="XPath 1.0 compatibility     mode"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode.</span></b><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">This component must be set by all host languages that include XPath 3.1 as a subset, indicating whether rules for compatibility with XPath 1.0 are in effect. XQuery sets the value of this component to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">This value is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="deltaxml-new" style="background:#90EE90"> ] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-namespaces" title="statically known namespaces"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Statically known namespaces.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from prefix to namespace URI that defines all the namespaces that are known during static processing of a given expression.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The URI value is whitespace normalized according to the rules for the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> type in </span><a href="https://www.w3.org/TR/xmlschema-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.2.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.3.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The statically known namespaces may include a binding for the zero-length prefix; however, this is used only in limited circumstances because the rules for resolving unprefixed QNames depend on how such a name is used.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Note the difference between </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, which is a dynamic property of an element node, and </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, which is a static property of an expression.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Some namespaces are predefined; additional namespaces can be added to the statically known namespaces by </span><a title="namespace declaration" class="termref" href="#dt-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">namespace declarations</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="schema import" class="termref" href="#dt-schema-import"><span class="deltaxml-new" style="background:#90EE90">schema imports</span></a><span class="deltaxml-new" style="background:#90EE90">, or </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module imports</span></a><span class="deltaxml-new" style="background:#90EE90"> in a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90">, by a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90">, and by </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attributes</span></a><span class="deltaxml-new" style="background:#90EE90"> in </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructors</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-namespace-elements-and-types" title="default namespace for elements and types"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default namespace for elements and types.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is either a namespace URI, or the special value </span><code><span class="deltaxml-new" style="background:#90EE90">"##any"</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. This indicates how unprefixed QNames are interpreted when they appear in a position where an element name or type name is expected.] </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is set to a namespace URI, this namespace is used for any such unprefixed QName. The URI value is whitespace-normalized according to the rules for the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> type in </span><a href="https://www.w3.org/TR/xmlschema-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.2.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.3.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The special value </span><code><span class="deltaxml-new" style="background:#90EE90">"##any"</span></code><span class="deltaxml-new" style="background:#90EE90"> indicates that:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">When an unprefixed QName is used as a </span><a title="name test" class="termref" href="#dt-name-test"><span class="deltaxml-new" style="background:#90EE90">name test</span></a><span class="deltaxml-new" style="background:#90EE90"> for selecting named elements in an </span><a title="axis step" class="termref" href="#dt-axis-step"><span class="deltaxml-new" style="background:#90EE90">axis step</span></a><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="name test" class="termref" href="#dt-name-test"><span class="deltaxml-new" style="background:#90EE90">name test</span></a><span class="deltaxml-new" style="background:#90EE90"> will match an element having the specified local name, in any namespace or none.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When an unprefixed QName is used in a context where a type name is expected (but not as a function name), the default namespace is the </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace, </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In any other context, an unprefixed QName represents a name in no namespace.</span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, an unprefixed QName representing an element or type name is interpreted as being in no namespace.</span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-function-namespace" title="default function namespace"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default function namespace.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is either a namespace URI, or </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.] The URI value is whitespace-normalized according to the rules for the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> type in </span><a href="https://www.w3.org/TR/xmlschema-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.2.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#anyURI"><span class="deltaxml-new" style="background:#90EE90">Section 3.3.17 anyURI </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-2</span></small></sup></p><p><span class="deltaxml-new" style="background:#90EE90"> In its simplest form its value is simply a whitespace-normalized </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> value (most commonly, the URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions</span></code><span class="deltaxml-new" style="background:#90EE90">) to be used as the default namespace for unprefixed function names. However, the use of a more complex algorithm is not precluded, for example an algorithm which searches multiple namespaces for a matching name. </span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> In XQuery, a default function namespace can be declared in the prolog in a </span><b><span class="deltaxml-new" style="background:#90EE90">default function namespace declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-default-namespace"><b><span class="deltaxml-new" style="background:#90EE90">5.14 Default Namespace Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90">); in the absence of such a declaration, the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions</span></code><span class="deltaxml-new" style="background:#90EE90"> is used.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-issd" title="in-scope schema definitions"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">In-scope schema definitions</span></b><span class="deltaxml-new" style="background:#90EE90"> is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.] It includes the following three parts:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-is-types" title="in-scope schema type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">In-scope schema types.</span></b><span class="deltaxml-new" style="background:#90EE90"> Each schema type definition is identified either by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (for a </span><b><span class="deltaxml-new" style="background:#90EE90">named type</span></b><span class="deltaxml-new" style="background:#90EE90">) or by an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> type identifier (for an </span><b><span class="deltaxml-new" style="background:#90EE90">anonymous type</span></b><span class="deltaxml-new" style="background:#90EE90">). The in-scope schema types include the predefined schema types described in </span><a href="#id-predefined-types"><b><span class="deltaxml-new" style="background:#90EE90">3.5 Schema Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="schema aware feature" class="termref" href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, in-scope schema types also include all type definitions found in imported schemas.</span></span></span><span class="deltaxml-new" style="background:#90EE90"> ] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-is-elems" title="in-scope element declarations"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">In-scope element declarations.</span></b><span class="deltaxml-new" style="background:#90EE90"> Each element declaration is identified either by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (for a top-level element declaration) or by an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> element identifier (for a local element declaration). </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> If the </span><a title="schema aware feature" class="termref" href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, in-scope element declarations include all element declarations found in imported schemas. </span></span></span><span class="deltaxml-new" style="background:#90EE90"> ] An element declaration includes information about the element’s </span><a title="substitution group" class="termref" href="#dt-substitution-group"><span class="deltaxml-new" style="background:#90EE90">substitution group</span></a><span class="deltaxml-new" style="background:#90EE90"> affiliation.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-substitution-group" title="substitution group"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Substitution groups</span></b><span class="deltaxml-new" style="background:#90EE90"> are defined in </span><a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class"><span class="deltaxml-new" style="background:#90EE90">Section 2.2.2.2 Element Substitution Group </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-1</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class"><span class="deltaxml-new" style="background:#90EE90">Section 2.2.2.2 Element Substitution Group </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-1</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. Informally, the substitution group headed by a given element (called the </span><b><span class="deltaxml-new" style="background:#90EE90">head element</span></b><span class="deltaxml-new" style="background:#90EE90">) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-is-attrs" title="in-scope attribute declarations"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">In-scope attribute declarations.</span></b><span class="deltaxml-new" style="background:#90EE90"> Each attribute declaration is identified either by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (for a top-level attribute declaration) or by an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> attribute identifier (for a local attribute declaration). </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="schema aware feature" class="termref" href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, in-scope attribute declarations include all attribute declarations found in imported schemas.</span></span></span><span class="deltaxml-new" style="background:#90EE90"> ] </span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-in-scope-variables" title="in-scope variables"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">In-scope variables.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> to type. It defines the set of variables that are available for reference within an expression. The </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is the name of the variable, and the type is the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the variable.] </span></p><p><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Variable declarations in a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> are added to </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="deltaxml-new" style="background:#90EE90"> An expression that binds a variable extends the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90">, within the scope of the variable, with the variable and its type. Within the body of an </span><a title="inline function expression" class="termref" href="#dt-inline-func"><span class="deltaxml-new" style="background:#90EE90">inline function expression</span></a><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="user-defined function" class="termref" href="#dt-udf"><span class="deltaxml-new" style="background:#90EE90">user-defined function</span></a></span></span><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> are extended by the names and types of the </span><b><span class="deltaxml-new" style="background:#90EE90">function parameters</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The static type of a variable may either be declared in a query or inferred by static type inference as discussed in </span><a href="#id-static-analysis"><b><span class="deltaxml-new" style="background:#90EE90">2.3.3.1 Static Analysis Phase</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-context-value-static-type" title="context value static type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Context value static type.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">; it defines the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90"> within the scope of a given expression.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-in-scope-named-item-types" title="in-scope named item types"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">In-scope named item types.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> to </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item types</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-named-item-type" title="named item type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">named item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">ItemType</span></code><span class="deltaxml-new" style="background:#90EE90"> identified by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Named item types serve two purposes:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">They allow frequently used item types, especially complex item types such as record types, to be given simple names, to avoid repeating the definition every time it is used.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">They allow the definition of recursive types, which are useful for describing recursive data structures such as lists and trees. For details see </span><a href="#id-recursive-record-tests"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.4 Recursive Record Tests</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">In XQuery, named item types can be declared in the Query Prolog.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">Named item types can be defined in a </span><a title="host language" class="termref" href="#dt-host-language"><span class="deltaxml-new" style="background:#90EE90">host language</span></a><span class="deltaxml-new" style="background:#90EE90"> such as XQuery 4.0 and in XSLT 4.0, but not in XPath 4.0 itself. They are available in XPath only if the host language provides the ability to define them.</span></p></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-statically-known-function-definitions" title="statically known function definitions"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Statically known function definitions.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a set of </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Function definitions are described in </span><a href="#id-function-definitions"><b><span class="deltaxml-new" style="background:#90EE90">2.2.1.1 Function Definitions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-collations" title="statically known collations"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Statically known collations.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> mapping from URI to collation. It defines the names of the collations that are available for use in processing </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">queries and</span></span></span><span class="deltaxml-new" style="background:#90EE90"> expressions.] [</span><a id="dt-collation" title="collation"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">collation</span></b><span class="deltaxml-new" style="background:#90EE90"> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#string-compare"><span class="deltaxml-new" style="background:#90EE90">Section 5.3 Comparison of strings</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-construction-mode" title="construction mode"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Construction mode.</span></b><span class="deltaxml-new" style="background:#90EE90"> The construction mode governs the behavior of element and document node constructors. If construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, the type of a constructed element node is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">, and all attribute and element nodes copied during node construction retain their original types. If construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, the type of a constructed element node is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">; all element nodes copied during node construction receive the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">, and all attribute nodes copied during node construction receive the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-empty-order" title="default order for empty sequences"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default order for empty sequences.</span></b><span class="deltaxml-new" style="background:#90EE90"> This component controls the processing of empty sequences and </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> values as ordering keys in an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in a FLWOR expression, as described in </span><a href="#id-order-by-clause"><b><span class="deltaxml-new" style="background:#90EE90">4.13.9 Order By Clause</span></b></a><span class="deltaxml-new" style="background:#90EE90">.] Its value may be </span><code><span class="deltaxml-new" style="background:#90EE90">greatest</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">least</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-boundary-space-policy" title="boundary-space policy"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Boundary-space policy.</span></b><span class="deltaxml-new" style="background:#90EE90"> This component controls the processing of </span><a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace"><span class="deltaxml-new" style="background:#90EE90">boundary whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> by </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructors</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#id-whitespace"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.4 Boundary Whitespace</span></b></a><span class="deltaxml-new" style="background:#90EE90">.] Its value may be </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-copy-namespaces-mode" title="copy-namespaces mode"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Copy-namespaces mode.</span></b><span class="deltaxml-new" style="background:#90EE90"> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in </span><a href="#id-element-constructor"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">. Its value consists of two parts: </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">inherit</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">no-inherit</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-base-uri" title="Static Base URI"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Static Base URI.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is an absolute URI, used to resolve relative URIs during static analysis. ] For example, it is used to resolve module location URIs in XQuery, and the URIs in </span><code><span class="deltaxml-new" style="background:#90EE90">xsl:import</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xsl:include</span></code><span class="deltaxml-new" style="background:#90EE90"> in XSLT. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> All expressions within a module have the same static base URI. The Static Base URI can be set using a </span><a title="base URI declaration" class="termref" href="#dt-base-uri-decl"><span class="deltaxml-new" style="background:#90EE90">base URI declaration</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90"> If </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is a subexpression of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> then the Static Base URI of </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is the same as the Static Base URI of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">. There are no constructs in XPath that require resolution of relative URI references during static analysis. </span></span></span></p><p><span class="deltaxml-new" style="background:#90EE90"> Relative URI references are resolved as described in </span><a href="#id-resolve-relative-uri"><b><span class="deltaxml-new" style="background:#90EE90">2.5.6 Resolving a Relative URI Reference</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">At execution time, relative URIs supplied to functions such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90"> are resolved against the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">, which may or may not be the same as the Static Base URI.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-decimal-formats" title="statically known decimal formats"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Statically known decimal formats.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from QNames to decimal formats, with one default format that has no visible name, referred to as the unnamed decimal format. Each format is available for use when formatting numbers using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-number</span></code><span class="deltaxml-new" style="background:#90EE90"> function.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Decimal formats are described in </span><a href="#id-decimal-formats"><b><span class="deltaxml-new" style="background:#90EE90">2.2.1.2 Decimal Formats</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="div4"><h5><a id="id-function-definitions"></a><span class="deltaxml-new" style="background:#90EE90">2.2.1.1 Function Definitions</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-function-definition" title="function definition"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">function definition</span></b><span class="deltaxml-new" style="background:#90EE90"> contains information used to evaluate a static function call, including the name, parameters, and return type of the function.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The properties of a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> include:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The function name, which is an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Parameter definitions, specifically:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A (possibly empty) list of required parameters, each having:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">a parameter name (an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">a required type (a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">A (possibly empty) list of optional parameters, each having:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">a parameter name (an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">a required type (a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">a default value expression (an </span><b><span class="deltaxml-new" style="background:#90EE90">expression</span></b><span class="deltaxml-new" style="background:#90EE90">: see </span><a href="#id-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4 Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">)</span></p></li></ul></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The names of the parameters must be distinct.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-arity-range" title="arity range"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> has an </span><b><span class="deltaxml-new" style="background:#90EE90">arity range</span></b><span class="deltaxml-new" style="background:#90EE90">, which is a range of consecutive non-negative integers. If the function definition has </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> required parameters and </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> optional parameters, then its arity range is from </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> to </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">+</span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> inclusive.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-variadic" title="variadic"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> may be declared to be </span><b><span class="deltaxml-new" style="background:#90EE90">variadic</span></b><span class="deltaxml-new" style="background:#90EE90">. In a static call of a variadic function, multiple arguments may be mapped to a single parameter in the function definition. In a variadic function with </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> declared parameters, the arity range is from </span><var><span class="deltaxml-new" style="background:#90EE90">M-1</span></var><span class="deltaxml-new" style="background:#90EE90"> to positive infinity.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">For an overview of variadic functions, see </span><a href="#id-variadic-functions-overview"><b><span class="deltaxml-new" style="background:#90EE90">4.5.3 Variadic Functions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Examples of system functions defined to be variadic are </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:codepoints-to-string</span></code><span class="deltaxml-new" style="background:#90EE90">. User-written functions in XQuery may be declared as variadic by using the </span><code><span class="deltaxml-new" style="background:#90EE90">%variadic</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation; the equivalent in XSLT is to use the attribute </span><code><span class="deltaxml-new" style="background:#90EE90">xsl:function/@variadic = "yes"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The static context may contain several </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> with the same name, but the </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity ranges</span></a><span class="deltaxml-new" style="background:#90EE90"> of two such function definitions must not overlap. For example, if two function definitions </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> have the same function name, then:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">It is acceptable for </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> to have two required parameters and no optional parameters, while </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> has three required parameters and one optional parameter.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is not acceptable for </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> to have one required parameter while </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> has three optional parameters.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is not possible for both </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> to be </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Implementations must ensure that no two </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> have the same </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> and overlapping arity ranges (even if the signatures are consistent).</span></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery and XSLT enforce this rule by defining a static error if the rule is violated; but further constraints may be needed if an API allows external functions to be added to the static context.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A return type (a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The function category, which is one of application, system, or external:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-application-function" title="application function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Application functions</span></b><span class="deltaxml-new" style="background:#90EE90"> are function definitions written in a host language such as XQuery or XSLT whose syntax and semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.] The most common application functions are functions written by users in XQuery or XSLT. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-system-function" title="system function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">System functions</span></b><span class="deltaxml-new" style="background:#90EE90"> include the functions defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, functions defined by the specifications of a host language, </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor functions</span></a><span class="deltaxml-new" style="background:#90EE90"> for atomic types, and any additional functions provided by the implementation. System functions are sometimes called built-in functions.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The behavior of system functions follows the rules given for the individual function in this family of specifications, or in the specification of the particular processor implementation. A system function may have behavior that depends on the static or dynamic context of the caller (for example, comparing strings using the default collation from the </span><span><span class="deltaxml-new" style="background:#90EE90">dynamic</span></span><span class="deltaxml-new" style="background:#90EE90"> context of the caller). Such functions are said to be </span><a title="context dependent" class="termref" href="#dt-context-dependent"><span class="deltaxml-new" style="background:#90EE90">context dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-external-function" title="external function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">External functions</span></b><span class="deltaxml-new" style="background:#90EE90"> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. In XSLT, external functions are called </span><a href="https://www.w3.org/TR/xslt-30/#extension-functions"><span class="deltaxml-new" style="background:#90EE90">Section 24.1 Extension Functions </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XT30</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. ] </span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, an implementation might provide a mechanism allowing external functions to be written in a language such as Java or Python. The way in which argument and return values are converted between the XDM type system and the type system of the external language is implementation-defined. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-context-dependent" title="context dependent"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> is said to be </span><b><span class="deltaxml-new" style="background:#90EE90">context dependent</span></b><span class="deltaxml-new" style="background:#90EE90"> if its result depends on the static or dynamic context of its caller. A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name#0</span></code><span class="deltaxml-new" style="background:#90EE90"> is context-dependent while </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name#1</span></code><span class="deltaxml-new" style="background:#90EE90"> is context-independent.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Some system functions, such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:position</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:last</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:static-base-uri</span></code><span class="deltaxml-new" style="background:#90EE90">, exist for the sole purpose of providing information about the static or dynamic context of their caller.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><a title="application function" class="termref" href="#dt-application-function"><span class="deltaxml-new" style="background:#90EE90">Application functions</span></a><span class="deltaxml-new" style="background:#90EE90"> are context dependent only to the extent that they define optional parameters with default values that are context dependent.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A (possibly empty) set of </span><b><span class="deltaxml-new" style="background:#90EE90">function annotations</span></b></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">In XQuery, function annotations are described in </span><a href="#id-annotations"><b><span class="deltaxml-new" style="background:#90EE90">5.15 Annotations</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A body. The function body contains the logic that enables the function result to be computed from the supplied arguments and information in the static and dynamic context.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> present in the static context are available for reference from a </span><a title="static function call" class="termref" href="#dt-static-function-call"><span class="deltaxml-new" style="background:#90EE90">static function call</span></a><span class="deltaxml-new" style="background:#90EE90">, or from a </span><a title="named function reference" class="termref" href="#dt-named-function-ref"><span class="deltaxml-new" style="background:#90EE90">named function reference</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div><div class="div4"><h5><a id="id-decimal-formats"></a><span class="deltaxml-new" style="background:#90EE90">2.2.1.2 Decimal Formats</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#eval_context"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#static_context"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Several decimal format properties, including minus sign, exponent separator, percent, and per-mille, can now be rendered as arbitrary strings rather than being confined to a single character. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1048"><span class="deltaxml-new" style="background:#90EE90">1048</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1250"><span class="deltaxml-new" style="background:#90EE90">1250</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;3 June 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">Each decimal format defines a set of properties, which control the interpretation of characters in the picture string supplied to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-number</span></code><span class="deltaxml-new" style="background:#90EE90"> function, and also specify characters to be used in the result of formatting the number.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following properties specify characters used both in the picture string, and in the formatted number. In each case the value is a single character:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-decimal-separator" title="decimal-separator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used to separate the integer part of the number from the fractional part, both in the picture string and in the formatted number; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+002E</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">FULL STOP, PERIOD</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-exponent-separator" title="exponent-separator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0065</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LATIN SMALL LETTER E</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">e</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-grouping-separator" title="grouping-separator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character typically used as a thousands separator, both in the picture string and in the formatted number; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+002C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">COMMA</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">,</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-percent" title="percent"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">percent</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-hundred fraction; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0025</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">PERCENT SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">%</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-per-mille" title="per-mille"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">per-mille</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+2030</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">PER MILLE SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">‰</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-zero-digit" title="zero-digit"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used to represent the digit zero; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0030</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">DIGIT ZERO</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">) . This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.] </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In the case of the the properties </span><a title="decimal-separator" class="termref" href="#id-static-decimal-format-decimal-separator"><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="grouping-separator" class="termref" href="#id-static-decimal-format-grouping-separator"><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="exponent-separator" class="termref" href="#id-static-decimal-format-exponent-separator"><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="percent" class="termref" href="#id-static-decimal-format-percent"><span class="deltaxml-new" style="background:#90EE90">percent</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="per-mille" class="termref" href="#id-static-decimal-format-per-mille"><span class="deltaxml-new" style="background:#90EE90">per-mille</span></a><span class="deltaxml-new" style="background:#90EE90">, the property may take the form </span><code><span class="deltaxml-new" style="background:#90EE90">m:r</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><code><span class="deltaxml-new" style="background:#90EE90">m</span></code><span class="deltaxml-new" style="background:#90EE90"> is a single-character marker used in the picture string to indicate where the relevant output should appear, and </span><code><span class="deltaxml-new" style="background:#90EE90">r</span></code><span class="deltaxml-new" style="background:#90EE90"> is the string used to represent the property in the result. For example, setting the </span><a title="percent" class="termref" href="#id-static-decimal-format-percent"><span class="deltaxml-new" style="background:#90EE90">percent</span></a><span class="deltaxml-new" style="background:#90EE90"> property to </span><code><span class="deltaxml-new" style="background:#90EE90">"%:pc"</span></code><span class="deltaxml-new" style="background:#90EE90"> means that the value </span><code><span class="deltaxml-new" style="background:#90EE90">0.10</span></code><span class="deltaxml-new" style="background:#90EE90">, formatted with the picture string </span><code><span class="deltaxml-new" style="background:#90EE90">#0%</span></code><span class="deltaxml-new" style="background:#90EE90">, results in the output </span><code><span class="deltaxml-new" style="background:#90EE90">10pc</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following properties specify characters to be used in the picture string supplied to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-number</span></code><span class="deltaxml-new" style="background:#90EE90"> function, but not in the formatted number. In each case the value must be a single character. </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-digit" title="digit"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">digit</span></b><span class="deltaxml-new" style="background:#90EE90"> is a character used in the picture string to represent an optional digit; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0023</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NUMBER SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">#</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-pattern-separator" title="pattern-separator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is a character used to separate positive and negative sub-pictures in a picture string; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003B</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">SEMICOLON</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">;</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The following properties specify characters or strings that may appear in the result of formatting the number, but not in the picture string:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-infinity" title="infinity"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">infinity</span></b><span class="deltaxml-new" style="background:#90EE90"> is the string used to represent the double value infinity (</span><code><span class="deltaxml-new" style="background:#90EE90">INF</span></code><span class="deltaxml-new" style="background:#90EE90">); the default value is the string </span><code><span class="deltaxml-new" style="background:#90EE90">"Infinity"</span></code><span class="deltaxml-new" style="background:#90EE90"> ] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-NaN" title="NaN"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">NaN</span></b><span class="deltaxml-new" style="background:#90EE90"> is the string used to represent the double value </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> (not a number); the default value is the string </span><code><span class="deltaxml-new" style="background:#90EE90">"NaN"</span></code><span class="deltaxml-new" style="background:#90EE90"> ] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-static-decimal-format-minus-sign" title="minus-sign"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">minus-sign</span></b><span class="deltaxml-new" style="background:#90EE90"> is the single character used to mark negative numbers; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+002D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">HYPHEN-MINUS</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">-</span></code><span class="deltaxml-new" style="background:#90EE90">) .] </span></p></li></ul></div></div><div class="div3"><h4><a id="eval_context"></a><span class="deltaxml-new" style="background:#90EE90">2.2.2 Dynamic Context</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-processing-model"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules regarding the </span><code><span class="deltaxml-new" style="background:#90EE90">document-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property of nodes returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function have been relaxed. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1161"><span class="deltaxml-new" style="background:#90EE90">1161</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1265"><span class="deltaxml-new" style="background:#90EE90">1265</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;11 June 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dynamic-context" title="dynamic context"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></b><span class="deltaxml-new" style="background:#90EE90"> of an expression is defined as information that is needed for the dynamic evaluation of an expression.] If evaluation of an expression relies on some part of the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> that is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In previous versions of the specification, this was classified as a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90">. The change allows the error to be raised during static analysis when possible; for example a function written as </span><code><span class="deltaxml-new" style="background:#90EE90">fn($x) { @code }</span></code><span class="deltaxml-new" style="background:#90EE90"> can now be reported as an error whether or not the function is actually evaluated. The actual error code remains unchanged for backwards compatibility reasons.</span></p><p><span class="deltaxml-new" style="background:#90EE90">There are other cases where static detection of the error is not possible.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The individual components of the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> are described below. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Rules governing the initialization and alteration of these components can be found in </span><a href="#id-xq-evaluation-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.2 Dynamic Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">Further rules governing the semantics of these components can be found in </span><a href="#id-xp-evaluation-context-components"><b><span class="deltaxml-new" style="background:#90EE90">D.2 Dynamic Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> consists of all the components of the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, and the additional components listed below.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-focus" title="focus"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The first three components of the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> (context value, context position, and context size) are called the </span><b><span class="deltaxml-new" style="background:#90EE90">focus</span></b><span class="deltaxml-new" style="background:#90EE90"> of the expression. ] The focus enables the processor to keep track of which items are being processed by the expression. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">If any component in the focus is defined, all components of the focus are defined.</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">If any component in the focus is defined, both the context value and context position are known.</span></span></span></p><div class="xpath note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If any component in the focus is defined, context size is usually defined as well. However, when streaming, the context size cannot be determined without lookahead, so it may be undefined. If so, expressions like </span><code><span class="deltaxml-new" style="background:#90EE90">last()</span></code><span class="deltaxml-new" style="background:#90EE90"> will raise a dynamic error because the context size is undefined.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-fixed-focus" title="fixed focus"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">fixed focus</span></b><span class="deltaxml-new" style="background:#90EE90"> is a focus for an expression that is evaluated once, rather than being applied to a series of values; in a fixed focus, the context value is set to one specific value, the context position is 1, and the context size is 1.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-singleton-focus" title="singleton focus"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">singleton focus</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="fixed focus" class="termref" href="#dt-fixed-focus"><span class="deltaxml-new" style="background:#90EE90">fixed focus</span></a><span class="deltaxml-new" style="background:#90EE90"> in which the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-new" style="background:#90EE90">singleton</span></a><span class="deltaxml-new" style="background:#90EE90"> item.]. With a singleton focus, the context value is a single item, the context position is 1, and the context size is 1. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Certain language constructs, notably the </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-new" style="background:#90EE90">path operator</span></a><code><span class="deltaxml-new" style="background:#90EE90">E1/E2</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><a href="#doc-xpath40-SimpleMapExpr"><span class="deltaxml-new" style="background:#90EE90">simple map operator</span></a><code><span class="deltaxml-new" style="background:#90EE90">E1!E2</span></code><span class="deltaxml-new" style="background:#90EE90">, and the </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new" style="background:#90EE90">predicate</span></a><code><span class="deltaxml-new" style="background:#90EE90">E1[E2]</span></code><span class="deltaxml-new" style="background:#90EE90">, create a new focus for the evaluation of a sub-expression. In these constructs, </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated once for each item in the sequence that results from evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90">. Each time </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, it is evaluated with a different focus. The focus for evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is referred to below as the </span><b><span class="deltaxml-new" style="background:#90EE90">inner focus</span></b><span class="deltaxml-new" style="background:#90EE90">, while the focus for evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> is referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">outer focus</span></b><span class="deltaxml-new" style="background:#90EE90">. The inner focus is used only for the evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90">. Evaluation of E1 continues with its original focus unchanged.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-context-value" title="context value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">context value</span></b><span class="deltaxml-new" style="background:#90EE90"> is the </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-new" style="background:#90EE90">value</span></a><span class="deltaxml-new" style="background:#90EE90"> currently being processed.] In many cases (but not always), the context value will be a single item. [</span><a id="dt-context-node" title="context node"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: When the context value is a single item, it can also be referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">context item</span></b><span class="deltaxml-new" style="background:#90EE90">; when it is a single node, it can also be referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">context node</span></b><span class="deltaxml-new" style="background:#90EE90">.] The context value is returned by an expression consisting of a single dot (</span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90">). When an expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1/E2</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">E1[E2]</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, each item in the sequence obtained by evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> becomes the context value in the inner focus for an evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-initial-context-value" title="initial context value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In the dynamic context of every module in a query, the context value component must have the same setting. If this shared setting is not </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, it is referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">initial context value</span></b><span class="deltaxml-new" style="background:#90EE90">. ] </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-context-position" title="context position"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">context position</span></b><span class="deltaxml-new" style="background:#90EE90"> is the position of the context value within the series of values currently being processed.] It changes whenever the context value changes. When the focus is defined, the value of the context position is an integer greater than zero. The context position is returned by the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:position()</span></code><span class="deltaxml-new" style="background:#90EE90">. When an expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1/E2</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">E1[E2]</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, the context position in the inner focus for an evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is the position of the context value in the sequence obtained by evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90">. The position of the first item in a sequence is always 1 (one). The context position is always less than or equal to the context size.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-context-size" title="context size"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">context size</span></b><span class="deltaxml-new" style="background:#90EE90"> is the number of values in the series of values currently being processed.] Its value is always an integer greater than zero. The context size is returned by the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:last()</span></code><span class="deltaxml-new" style="background:#90EE90">. When an expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1/E2</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">E1[E2]</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, the context size in the inner focus for an evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is the number of items in the sequence obtained by evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-variable-values" title="variable values"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Variable values</span></b><span class="deltaxml-new" style="background:#90EE90">. This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> to value. It contains the same </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> as the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> for the expression. The </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is the name of the variable and the value is the dynamic value of the variable, which includes its </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dynamically-known-function-definitions" title="dynamically known function definitions"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Dynamically known function definitions</span></b><span class="deltaxml-new" style="background:#90EE90">. This is a set of </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">. It includes the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> as a subset, but may include other function definitions that are not known statically. ] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The function definitions in the dynamic context are used primarily by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:function-lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If two function definitions in the </span><a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">dynamically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> have the same name, then their </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity ranges</span></a><span class="deltaxml-new" style="background:#90EE90"> must not overlap.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The reason for allowing named functions to be available dynamically beyond those that are available statically is primarily to allow for cases where the run-time execution environment is significantly different from the compile-time environment. This could happen, for example, if a stylesheet or query is compiled within a web server and then executed in the web browser. The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:function-lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> function allows dynamic discovery of resources that were not available statically.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-date-time" title="current dateTime"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Current dateTime.</span></b><span class="deltaxml-new" style="background:#90EE90"> This information represents an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> point in time during the processing of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, and includes an explicit timezone. It can be retrieved by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:current-dateTime</span></code><span class="deltaxml-new" style="background:#90EE90"> function. If called multiple times during the execution of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, this function always returns the same result.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-timezone" title="implicit timezone"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Implicit timezone.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or arithmetic operation. The implicit timezone is an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90">. See </span><a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones"><span class="deltaxml-new" style="background:#90EE90">Section 3.2.7.3 Timezones </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="deltaxml-new" style="background:#90EE90">Section 3.3.7 dateTime </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> for the range of valid values of a timezone.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-executable-base-uri" title="Executable Base URI"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Executable Base URI.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is an absolute URI used to resolve relative URIs during the evaluation of expressions; it is used, for example, to resolve a relative URI supplied to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-text</span></code><span class="deltaxml-new" style="background:#90EE90"> functions. ] </span></p><p><span class="deltaxml-new" style="background:#90EE90">URIs are resolved as described in </span><a href="#id-resolve-relative-uri"><b><span class="deltaxml-new" style="background:#90EE90">2.5.6 Resolving a Relative URI Reference</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:static-base-uri</span></code><span class="deltaxml-new" style="background:#90EE90">, despite its name, returns the value of the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In many straightforward processing scenarios, the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> in the dynamic context will be the same as the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> for the corresponding expression in the static context. There are situations, however, where they may differ:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Some processors may allow the static analysis of a query or stylesheet to take place on a development machine, while execution of the query or stylesheet happens on a test or production server. In this situation, resources needed during static analysis (such as other modules of the query or stylesheet) will be located on the development machine, by reference to the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">, while resources needed during execution (such as reference data files) will be located on the production machine, accessed via the </span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:static-base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> function is called within the initializing expression of an optional parameter in a function declaration, it returns the executable base URI of the relevant function call. This allows a user-written function to accept two parameters: a required parameter containing a relative URI, and an optional parameter containing a base URI. The optional parameter can be given a default value of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:static-base-uri()</span></code><span class="deltaxml-new" style="background:#90EE90">, allowing the code in the function body to resolve the relative URI against the executable base URI of the caller.</span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-def-collation" title="default collation"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default collation.</span></b><span class="deltaxml-new" style="background:#90EE90"> This identifies one of the collations in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically known collations</span></a><span class="deltaxml-new" style="background:#90EE90"> as the collation to be used by functions and operators for comparing and ordering values of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> (and types derived from them) when no explicit collation is specified.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Although the default collation is defined (in 4.0) as a property of the dynamic context, its value will in nearly all cases be known statically. The reason it is defined in the dynamic context is to allow a call on the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:default-collation</span></code><span class="deltaxml-new" style="background:#90EE90"> function to be used when defining the default value of an optional parameter to a user-defined function. In this situation, the actual value supplied for the parameter is taken from the dynamic context of the relevant function call.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-language" title="default language"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default language.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the natural language used when creating human-readable output (for example, by the functions </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-integer</span></code><span class="deltaxml-new" style="background:#90EE90">) if no other language is requested. The value is a language code as defined by the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:language</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-calendar" title="default calendar"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default calendar.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the calendar used when formatting dates in human-readable output (for example, by the functions </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">) if no other calendar is requested. The value is a string.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-place" title="default place"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default place.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a geographical location used to identify the place where events happened (or will happen) when formatting dates and times using functions such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">, if no other place is specified. It is used when translating timezone offsets to civil timezone names, and when using calendars where the translation from ISO dates/times to a local representation is dependent on geographical location. Possible representations of this information are an ISO country code or an Olson timezone name, but implementations are free to use other representations from which the above information can be derived.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-available-docs" title="available documents"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Available documents.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping of strings to document nodes. Each string represents the absolute URI of a resource. The document node is the root of a tree that represents that resource using the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90">. The document node is returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90"> function when applied to that URI.] The set of available documents may be empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-available-text-resources" title="available text resources"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Available text resources</span></b><span class="deltaxml-new" style="background:#90EE90">. This is a mapping of strings to text resources. Each string represents the absolute URI of a resource. The resource is returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-text</span></code><span class="deltaxml-new" style="background:#90EE90"> function when applied to that URI.] The set of available text resources may be empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-available-collections" title="available item collections"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Available collections.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping of strings to sequences of items. Each string represents the absolute URI of a resource. The sequence of items represents the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function when that URI is supplied as the argument. ] The set of available collections may be empty.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Ideally, for every document node </span><code><span class="deltaxml-new" style="background:#90EE90">D</span></code><span class="deltaxml-new" style="background:#90EE90"> that is in the target of a mapping in </span><a title="available item collections" class="termref" href="#dt-available-collections"><span class="deltaxml-new" style="background:#90EE90">available item collections</span></a><span class="deltaxml-new" style="background:#90EE90">, or that is the root of a tree containing such a node, the document-uri property of </span><code><span class="deltaxml-new" style="background:#90EE90">D</span></code><span class="deltaxml-new" style="background:#90EE90"> should either be absent, or should be a URI </span><code><span class="deltaxml-new" style="background:#90EE90">U</span></code><span class="deltaxml-new" style="background:#90EE90"> such that </span><a title="available documents" class="termref" href="#dt-available-docs"><span class="deltaxml-new" style="background:#90EE90">available documents</span></a><span class="deltaxml-new" style="background:#90EE90"> contains a mapping from </span><code><span class="deltaxml-new" style="background:#90EE90">U</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">D</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">That is to say, the </span><code><span class="deltaxml-new" style="background:#90EE90">document-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property of nodes returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function should be such that calling </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90"> with that URI returns the relevant node.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is not always possible to ensure this, especially in cases where dereferencing of document or collection URIs is configurable using configuration files or user-supplied resolver code.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-collection" title="default collection"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default collection.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the sequence of items that would result from calling the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function with no arguments.] The value of </span><b><span class="deltaxml-new" style="background:#90EE90">default collection</span></b><span class="deltaxml-new" style="background:#90EE90"> may be initialized by the implementation.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-available-uri-collections" title="available uri collections"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Available URI collections.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping of strings to sequences of URIs. The string represents the absolute URI of a resource which can be interpreted as an aggregation of a number of individual resources each of which has its own URI. The sequence of URIs represents the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:uri-collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function when that URI is supplied as the argument. ] There is no implication that the URIs in this sequence can be successfully dereferenced, or that the resources they refer to have any particular media type.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> maintain some consistent relationship between the available collections and the available URI collections, for example by ensuring that the result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:uri-collection(X)!fn:doc(.)</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection(X)</span></code><span class="deltaxml-new" style="background:#90EE90">. However, this is not required. The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:uri-collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function is more general than </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> in that </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> allows access to nodes that might lack individual URIs, for example nodes corresponding to XML fragments stored in the rows of a relational database.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-uri-collection" title="default URI collection"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Default URI collection.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the sequence of URIs that would result from calling the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:uri-collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function with no arguments.] The value of </span><b><span class="deltaxml-new" style="background:#90EE90">default URI collection</span></b><span class="deltaxml-new" style="background:#90EE90"> may be initialized by the implementation.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-environment-variables" title="environment variables"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Environment variables.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from names to values. Both the names and the values are strings. The names are compared using an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> collation, and are unique under this collation. The set of environment variables is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be empty.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A possible implementation is to provide the set of POSIX environment variables (or their equivalent on other operating systems) appropriate to the process in which the </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query is initiated</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expression is evaluated</span></span></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ul></div></div><div class="div2"><h3><a id="id-processing-model"></a><span class="deltaxml-new" style="background:#90EE90">2.3 Processing Model</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-guarded-expressions"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#eval_context"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The static typing option has been dropped. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1343"><span class="deltaxml-new" style="background:#90EE90">1343</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 is defined in terms of the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90"> and the </span><a title="expression context" class="termref" href="#dt-expression-context"><span class="deltaxml-new" style="background:#90EE90">expression context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><span class="deltaxml-new-img"><img style="border: 2px solid green" class="xquery" src="ProcMod-XQuery.gif" alt="Processing                          Model Overview"></span><span class="deltaxml-new-img"><img style="border: 2px solid green" class="xpath" src="ProcMod-XPath.gif" alt="Processing                          Model Overview"></span><p><span class="deltaxml-new" style="background:#90EE90">Figure 1: Processing Model Overview</span></p><p><span class="deltaxml-new" style="background:#90EE90">Figure 1 provides a schematic overview of the processing steps that are discussed in detail below. Some of these steps are completely outside the domain of XQuery 4.0 and XPath 4.0; in Figure 1, these are depicted outside the line that represents the boundaries of the language, an area labeled </span><b><span class="deltaxml-new" style="background:#90EE90">external processing</span></b><span class="deltaxml-new" style="background:#90EE90">. The external processing domain includes generation of </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instances</span></a><span class="deltaxml-new" style="background:#90EE90"> that represent the data to be queried (see </span><a href="#id-data-model-generation"><b><span class="deltaxml-new" style="background:#90EE90">2.3.1 Data Model Generation</span></b></a><span class="deltaxml-new" style="background:#90EE90">), schema import processing (see </span><a href="#id-schema-import-processing"><b><span class="deltaxml-new" style="background:#90EE90">2.3.2 Schema Import Processing</span></b></a><span class="deltaxml-new" style="background:#90EE90">), and serialization</span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-serialization"><b><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></b></a><span class="deltaxml-new" style="background:#90EE90">)</span></span></span><span class="deltaxml-new" style="background:#90EE90">. The area inside the boundaries of the language is known as the </span><span class="xquery"><span class="xquery"><b><span class="deltaxml-new" style="background:#90EE90">query processing domain</span></b></span></span><span class="xpath"><span class="xpath"><b><span class="deltaxml-new" style="background:#90EE90">XPath processing domain</span></b></span></span><span class="deltaxml-new" style="background:#90EE90">, which includes the static analysis and dynamic evaluation phases (see </span><a href="#id-expression-processing"><b><span class="deltaxml-new" style="background:#90EE90">2.3.3 Expression Processing</span></b></a><span class="deltaxml-new" style="background:#90EE90">). Consistency constraints on the </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath</span></span></span><span class="deltaxml-new" style="background:#90EE90"> processing domain are defined in </span><a href="#id-consistency-constraints"><b><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div3"><h4><a id="id-data-model-generation"></a><span class="deltaxml-new" style="background:#90EE90">2.3.1 Data Model Generation</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The input data for </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90"> must be represented as one or more </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instances</span></a><span class="deltaxml-new" style="background:#90EE90">. This process occurs outside the domain of XQuery 4.0 and XPath 4.0, which is why Figure 1 represents it in the external processing domain.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In many cases the input data might originate as XML. Here are some steps by which an XML document might be converted to an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">A document may be parsed using an XML parser that generates an </span><b><span class="deltaxml-new" style="background:#90EE90">XML Information Set</span></b><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#XINFO"><span class="deltaxml-new" style="background:#90EE90">[XML Infoset]</span></a><span class="deltaxml-new" style="background:#90EE90">). The parsed document may then be validated against one or more schemas. This process, which is described in </span><a href="http://www.w3.org/TR/xmlschema-1/"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0 Part 1]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="http://www.w3.org/TR/xmlschema11-1/"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1 Part 1]</span></a><span class="deltaxml-new" style="background:#90EE90">, results in an abstract information structure called the </span><b><span class="deltaxml-new" style="background:#90EE90">Post-Schema Validation Infoset</span></b><span class="deltaxml-new" style="background:#90EE90"> (PSVI). If a document has no associated schema, its Information Set is preserved. (See DM1 in Figure 1)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The Information Set or PSVI may be transformed into an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> by a process described in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. (See DM2 in Figure 1)</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The above steps provide an example of how an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> might be constructed. An XDM instance might also be constructed in some other way (see DM3 in Figure 1), for example it might be synthesized directly from a relational database, or derived by parsing a JSON text or a CSV file. Whatever the origin, XQuery 4.0 and XPath 4.0 is defined in terms of the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90">, but it does not place any constraints on how XDM instances are constructed.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The remainder of this section is concerned with the common case where XML data is being processed.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-type-annotation" title="type annotation"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Each element node and attribute node in an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> has a </span><b><span class="deltaxml-new" style="background:#90EE90">type annotation</span></b><span class="deltaxml-new" style="background:#90EE90"> (described in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types"><span class="deltaxml-new" style="background:#90EE90">Section 2.8 Schema Information</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">). The type annotation of a node is a reference to a </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><span class="deltaxml-new" style="background:#90EE90">. ] The </span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90"> of a node is the name of the type referenced by its </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> (but note that the type annotation can be a reference to an anonymous type). If the </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> was derived from a validated XML document as described in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#const-psvi"><span class="deltaxml-new" style="background:#90EE90">Section 3.3 Construction from a PSVI</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, the type annotations of the element and attribute nodes are derived from schema validation. XQuery 4.0 and XPath 4.0 does not provide a way to directly access the type annotation of an element or attribute node.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The value of an attribute is represented directly within the attribute node. An attribute node whose type is unknown (such as might occur in a schemaless document) is given the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The value of an element is represented by the children of the element node, which may include text nodes and other element nodes. The </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of an element node indicates how the values in its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated with the </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">. An element that has been validated and found to be partially valid is annotated with the schema type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">. If an element node is annotated as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">, all its descendant element nodes are also annotated as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">. However, if an element node is annotated as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">, some of its descendant element nodes may have a more specific </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div3"><h4><a id="id-schema-import-processing"></a><span class="deltaxml-new" style="background:#90EE90">2.3.2 Schema Import Processing</span></h4><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> may be extracted from actual XML schemas (see step SI1 in Figure 1) or may be generated by some other mechanism (see step SI2 in Figure 1). In either case, the result must satisfy the consistency constraints defined in </span><a href="#id-consistency-constraints"><b><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> are provided by the host language (see step SI1 in Figure 1) and must satisfy the consistency constraints defined in </span><a href="#id-consistency-constraints"><b><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div></div><div class="div3"><h4><a id="id-expression-processing"></a><span class="deltaxml-new" style="background:#90EE90">2.3.3 Expression Processing</span></h4><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 defines two phases of processing called the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90"> and the </span><a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation"><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></a><span class="deltaxml-new" style="background:#90EE90"> (see Figure 1). During the static analysis phase, </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static errors</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90">, or </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90"> may be raised. During the dynamic evaluation phase, only </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90"> may be raised. These kinds of errors are defined in </span><a href="#id-kinds-of-errors"><b><span class="deltaxml-new" style="background:#90EE90">2.4.1 Kinds of Errors</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Within each phase, an implementation is free to use any strategy or algorithm whose result conforms to the specifications in this document.</span></p><div class="div4"><h5><a id="id-static-analysis"></a><span class="deltaxml-new" style="background:#90EE90">2.3.3.1 Static Analysis Phase</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-analysis" title="static analysis phase"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></b><span class="deltaxml-new" style="background:#90EE90"> depends on the expression itself and on the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">. The </span><b><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></b><span class="deltaxml-new" style="background:#90EE90"> does not depend on input data (other than schemas).] </span></p><p><span class="deltaxml-new" style="background:#90EE90">During the static analysis phase, the </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath expression</span></span></span><span class="deltaxml-new" style="background:#90EE90"> is typically parsed into an internal representation called the </span><b><span class="deltaxml-new" style="background:#90EE90">operation tree</span></b><span class="deltaxml-new" style="background:#90EE90"> (step SQ1 in Figure 1). A parse error is raised as a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0003" title="err:XPST0003"><span class="deltaxml-new" style="background:#90EE90">err:XPST0003</span></a><span class="deltaxml-new" style="background:#90EE90">]. The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is initialized by the implementation (step SQ2). </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is then changed and augmented based on information in the </span><b><span class="deltaxml-new" style="background:#90EE90">prolog</span></b><span class="deltaxml-new" style="background:#90EE90"> (step SQ3). If the </span><a title="schema aware feature" class="termref" href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> are populated with information from imported schemas. If the </span><a title="module feature" class="termref" href="#dt-module-feature"><span class="deltaxml-new" style="background:#90EE90">Module Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, the static context is extended with function declarations and variable declarations from imported modules.</span></span></span><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is used to resolve schema type names, function names, namespace prefixes, and variable names (step SQ4). If a name of one of these kinds in the </span><b><span class="deltaxml-new" style="background:#90EE90">operation tree</span></b><span class="deltaxml-new" style="background:#90EE90"> is not found in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> ([</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></a><span class="deltaxml-new" style="background:#90EE90">] or [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">]) is raised (however, see exceptions to this rule in </span><a href="#id-element-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7.2 Element Test</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-attribute-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7.4 Attribute Test</span></b></a><span class="deltaxml-new" style="background:#90EE90">.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">operation tree</span></b><span class="deltaxml-new" style="background:#90EE90"> is then typically normalized by making explicit the implicit operations such as </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> and extraction of </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean values</span></a><span class="deltaxml-new" style="background:#90EE90"> (step SQ5).</span></p><p><span class="deltaxml-new" style="background:#90EE90">During the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90">, a processor may perform type analysis. The effect of type analysis is to assign a </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> to each expression in the operation tree. [</span><a id="dt-static-type" title="static type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">static type</span></b><span class="deltaxml-new" style="background:#90EE90"> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.] This specification does not define the rules for type analysis nor the static types that are assigned to particular expressions: the only constraint is that the inferred type must match all possible values that the expression is capable of returning.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples of inferred static types might be:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">For the expression </span><code><span class="deltaxml-new" style="background:#90EE90">concat(a,b)</span></code><span class="deltaxml-new" style="background:#90EE90"> the inferred static type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$a = $v</span></code><span class="deltaxml-new" style="background:#90EE90"> the inferred static type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$s[exp]</span></code><span class="deltaxml-new" style="background:#90EE90"> the inferred static type has the same item type as the static type of </span><code><span class="deltaxml-new" style="background:#90EE90">$s</span></code><span class="deltaxml-new" style="background:#90EE90">, but a cardinality that allows the empty sequence even if the static type of </span><code><span class="deltaxml-new" style="background:#90EE90">$s</span></code><span class="deltaxml-new" style="background:#90EE90"> does not allow an empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The inferred static type of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">data($x)</span></code><span class="deltaxml-new" style="background:#90EE90"> (whether written explicitly or inserted into the operation tree in places where atomization is implicit) depends on the inferred static type of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">: for example, if </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> has type </span><code><span class="deltaxml-new" style="background:#90EE90">element(*, xs:integer)</span></code><span class="deltaxml-new" style="background:#90EE90"> then </span><code><span class="deltaxml-new" style="background:#90EE90">data($x)</span></code><span class="deltaxml-new" style="background:#90EE90"> has static type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In XQuery 1.0 and XPath 2.0, rules for static type inferencing were published normatively in </span><a href="#xquery-semantics"><span class="deltaxml-new" style="background:#90EE90">[XQuery 1.0 and XPath 2.0 Formal Semantics]</span></a><span class="deltaxml-new" style="background:#90EE90">, but implementations were allowed to refine these rules to infer a more precise type where possible. In subsequent versions, the rules for static type inferencing are entirely implementation-dependent.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Every kind of expression also imposes requirements on the type of its operands. For example, with the expression </span><code><span class="deltaxml-new" style="background:#90EE90">substring($a, $b, $c)</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$a</span></code><span class="deltaxml-new" style="background:#90EE90"> must be of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> (or something that can be converted to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> by the function calling rules), while </span><code><span class="deltaxml-new" style="background:#90EE90">$b</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$c</span></code><span class="deltaxml-new" style="background:#90EE90"> must be numeric.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A processor may raise a type error during static analysis if the inferred static type of an expression has no overlap (intersection) with the required type, and cannot be converted to the required type using the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, given the call </span><code><span class="deltaxml-new" style="background:#90EE90">fn:upper-case($s)</span></code><span class="deltaxml-new" style="background:#90EE90">, the processor may raise an error if the declared or inferred type of </span><code><span class="deltaxml-new" style="background:#90EE90">$s</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, but not if it is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">In addition, type analysis may conclude that an expression is </span><code><span class="deltaxml-new" style="background:#90EE90">implausible</span></code><span class="deltaxml-new" style="background:#90EE90">. Implausible expressions may be considered erroneous unless such checks have been disabled. This topic is described further in </span><a href="#id-implausible-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.6 Implausible Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Alternatively, the processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> defer all type checking until the dynamic evaluation phase.</span></p></div><div class="div4"><h5><a id="id-dynamic-evaluation"></a><span class="deltaxml-new" style="background:#90EE90">2.3.3.2 Dynamic Evaluation Phase</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dynamic-evaluation" title="dynamic evaluation phase"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></b><span class="deltaxml-new" style="background:#90EE90"> is the phase during which the value of an expression is computed.] It is dependent on successful completion of the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The dynamic evaluation phase can occur only if no errors were detected during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The dynamic evaluation phase depends on the </span><b><span class="deltaxml-new" style="background:#90EE90">operation tree</span></b><span class="deltaxml-new" style="background:#90EE90"> of the expression being evaluated (step DQ1), on the input data (step DQ4), and on the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> (step DQ5), which in turn draws information from the external environment (step DQ3) and the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4) and it may extend the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> (step DQ5)—for example, by binding values to variables.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dynamic-type" title="dynamic type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Every value matches one or more </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90">. A value is said to have a </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></b><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> if it matches (or </span><b><span class="deltaxml-new" style="background:#90EE90">is an instance of</span></b><span class="deltaxml-new" style="background:#90EE90">) the sequence type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">In many cases (but not all), one of the dynamic types that a value matches will be a subtype of all the others, in which case it makes sense to speak of “the dynamic type” of the value as meaning this single most specific type. In other cases (examples are empty maps and empty arrays) none of the dynamic types is more specific than all the others.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An atomic item has a </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> which will always be a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of all the other types that it matches; we can therefore refer to this as the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the atomic item without ambiguity.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">A value may match a dynamic type that is more specific than the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the expression that computed it (for example, the static type of an expression might be </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer*</span></code><span class="deltaxml-new" style="background:#90EE90">, denoting a sequence of zero or more integers, but at evaluation time its value may be an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, denoting exactly one integer). </span></p><p><span class="deltaxml-new" style="background:#90EE90">If an operand of an expression does not have a </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> that is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> required for that operand, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">Even though static typing can catch many </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90"> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> will result. Similarly, an expression may apply an arithmetic operator to a value whose </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. This is not a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90">, but at run time, if the value cannot be successfully cast to a </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a><span class="deltaxml-new" style="background:#90EE90"> type, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> will be raised.</span></p></div></div><div class="div3"><h4><a id="id-input-sources"></a><span class="deltaxml-new" style="background:#90EE90">2.3.4 Input Sources</span></h4><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 has a set of functions that provide access to XML documents (</span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc-available</span></code><span class="deltaxml-new" style="background:#90EE90">), collections (</span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:uri-collection</span></code><span class="deltaxml-new" style="background:#90EE90">), text files (</span><code><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-text</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-text-lines</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-text-available</span></code><span class="deltaxml-new" style="background:#90EE90">), and environment variables (</span><code><span class="deltaxml-new" style="background:#90EE90">fn:environment-variable</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:available-environment-variables</span></code><span class="deltaxml-new" style="background:#90EE90">). These functions are defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#fns-on-docs"><span class="deltaxml-new" style="background:#90EE90">Section 13.6 Functions giving access to external information</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An expression can access input data either by calling one of these input functions or by referencing some part of the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> that is initialized by the external environment, such as a </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="http://expath.org"><span class="deltaxml-new" style="background:#90EE90">EXPath Community Group</span></a><span class="deltaxml-new" style="background:#90EE90"> has developed a </span><a href="http://expath.org/spec/file"><span class="deltaxml-new" style="background:#90EE90">File Module</span></a><span class="deltaxml-new" style="background:#90EE90">, which some implementations use to perform file system related operations such as reading or writing files and directories. Multiple files can be read or written from a single query.</span></p></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-serialization"></a><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-serialization" title="serialization"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Serialization</span></b><span class="deltaxml-new" style="background:#90EE90"> is the process of converting an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> to a sequence of octets (step DM4 in Figure 1.), as described in </span><a href="#xslt-xquery-serialization-40"><span class="deltaxml-new" style="background:#90EE90">[XSLT and XQuery Serialization 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This definition of serialization is the definition used in this specification. Any form of serialization that is not based on </span><a href="#xslt-xquery-serialization-40"><span class="deltaxml-new" style="background:#90EE90">[XSLT and XQuery Serialization 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> is outside the scope of the XQuery 4.0 and XPath 4.0 specification.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The host language may provide a serialization option.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">An XQuery implementation is not required to provide a serialization interface. For example, an implementation may provide only a DOM interface (see </span><a href="#DOM"><span class="deltaxml-new" style="background:#90EE90">[Document Object Model]</span></a><span class="deltaxml-new" style="background:#90EE90">) or an interface based on an event stream. </span></p></div><div class="xquery"><p class="xquery"><a href="#xslt-xquery-serialization-40"><span class="deltaxml-new" style="background:#90EE90">[XSLT and XQuery Serialization 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> defines a set of </span><b><span class="deltaxml-new" style="background:#90EE90">serialization parameters</span></b><span class="deltaxml-new" style="background:#90EE90"> that govern the serialization process. If an XQuery implementation provides a serialization interface, it may support (and may expose to users) any of the serialization parameters listed (with default values) in </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">. If an implementation does not support one of these parameters, it must ignore it without raising an error.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-output-declaration" title="output declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">output declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> is an option declaration in the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/xslt-xquery-serialization</span></code><span class="deltaxml-new" style="background:#90EE90">; it is used to declare serialization parameters.] Except for </span><code><span class="deltaxml-new" style="background:#90EE90">parameter-document</span></code><span class="deltaxml-new" style="background:#90EE90">, each option corresponds to a serialization parameter element defined in </span><a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#serparams-schema"><span class="deltaxml-new" style="background:#90EE90">Section B Schema for Serialization Parameters</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SE40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. The name of each option is the same as the name of the corresponding serialization parameter element, and the values permitted for each option are the same as the values allowed in the serialization parameter element. For QName values, prefixes are expanded to namespace URIs by means of the statically known namespaces, or if unprefixed, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">There is no output declaration for </span><code><span class="deltaxml-new" style="background:#90EE90">use-character-maps</span></code><span class="deltaxml-new" style="background:#90EE90">, it can be set only by means of a parameter document. When the application requests serialization of the output, the processor may use these parameters to control the way in which the serialization takes place. Processors may also allow external mechanisms for specifying serialization parameters, which may or may not override serialization parameters specified in the query prolog.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the use of declaration options. </span></p><div class="xquery example"><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:encoding "iso-8859-1";
declare option output:indent "yes";
declare option output:parameter-document "file:///home/serialization-parameters.xml";</span></pre></div></div></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">output declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> may appear only in a main module; it is a static error [</span><a href="#ERRXQST0108" title="err:XQST0108"><span class="deltaxml-new" style="background:#90EE90">err:XQST0108</span></a><span class="deltaxml-new" style="background:#90EE90">] if an output declaration appears in a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">. It is a static error [</span><a href="#ERRXQST0110" title="err:XQST0110"><span class="deltaxml-new" style="background:#90EE90">err:XQST0110</span></a><span class="deltaxml-new" style="background:#90EE90">] if the same serialization parameter is declared more than once. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0109" title="err:XQST0109"><span class="deltaxml-new" style="background:#90EE90">err:XQST0109</span></a><span class="deltaxml-new" style="background:#90EE90">] if the local name of an output declaration in the </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/xslt-xquery-serialization</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace is not one of the serialization parameter names listed in </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">parameter-document</span></code><span class="deltaxml-new" style="background:#90EE90">, or if the name of an output declaration is </span><code><span class="deltaxml-new" style="background:#90EE90">use-character-maps</span></code><span class="deltaxml-new" style="background:#90EE90">. The default value for the </span><code><span class="deltaxml-new" style="background:#90EE90">method</span></code><span class="deltaxml-new" style="background:#90EE90"> parameter is </span><code><span class="deltaxml-new" style="background:#90EE90">"xml"</span></code><span class="deltaxml-new" style="background:#90EE90">. An implementation may define additional </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> serialization parameters in its own namespaces. </span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">If the local name of an output declaration in the </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/xslt-xquery-serialization</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace is </span><code><span class="deltaxml-new" style="background:#90EE90">parameter-document</span></code><span class="deltaxml-new" style="background:#90EE90">, the value of the output declaration is treated as a URI literal. The value is a location hint, and identifies an XDM instance in an implementation-defined way. If a processor is performing serialization, it is a static error [</span><a href="#ERRXQST0119" title="err:XQST0119"><span class="deltaxml-new" style="background:#90EE90">err:XQST0119</span></a><span class="deltaxml-new" style="background:#90EE90">] if the implementation is not able to process the value of the </span><code><span class="deltaxml-new" style="background:#90EE90">output:parameter-document</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration to produce an XDM instance.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">If a processor is performing serialization, the XDM instance identified by an </span><code><span class="deltaxml-new" style="background:#90EE90">output:parameter-document</span></code><span class="deltaxml-new" style="background:#90EE90"> output declaration specifies the values of serialization parameters in the manner defined by </span><a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#serparams-in-xdm-instance"><span class="deltaxml-new" style="background:#90EE90">Section 3.1 Setting Serialization Parameters by Means of a Parameter Document</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SE40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. It is a static error [</span><a href="#ERRXQST0115" title="err:XQST0115"><span class="deltaxml-new" style="background:#90EE90">err:XQST0115</span></a><span class="deltaxml-new" style="background:#90EE90">] if this yields a serialization error. The value of any other output declaration overrides any value that might have been specified for the same serialization parameter using an output declaration in the </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/xslt-xquery-serialization</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace with the local name parameter-document declaration.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">A serialization parameter that is not applicable to the chosen output method must be ignored, except that if its value is not a valid value for that parameter, an error may be raised.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">A processor that is performing serialization must raise a serialization error if the values of any serialization parameters that it supports (other than any that are ignored under the previous paragraph) are incorrect.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">A processor that is not performing serialization may report errors if any serialization parameters are incorrect, or may ignore such parameters.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Specifying serialization parameters in a query does not by itself demand that the output be serialized. It merely defines the desired form of the serialized output for use in situations where the processor has been asked to perform serialization. </span></p></div><div class="xquery note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90"> permits an element node to have fewer </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> than its parent. Correct serialization of such an element node would require “undeclaration” of namespaces, which is a feature of </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. An implementation that does not support </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> is permitted to serialize such an element without “undeclaration” of namespaces, which effectively causes the element to inherit the in-scope namespaces of its parent. </span></p></div></div></div><div class="div3"><h4><a id="id-consistency-constraints"></a><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></h4><p><span class="deltaxml-new" style="background:#90EE90">In order for XQuery 4.0 and XPath 4.0 to be well defined, the input </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instances</span></a><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, and the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> must be mutually consistent. The consistency constraints listed below are prerequisites for correct functioning of an XQuery 4.0 and XPath 4.0 implementation. Enforcement of these consistency constraints is beyond the scope of this specification. This specification does not define the result of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90"> under any condition in which one or more of these constraints is not satisfied.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">For every node that has a type annotation, if that type annotation is found in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> (ISSD), then its definition in the ISSD must be </span><span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-new" style="background:#90EE90">compatible</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup></span><span class="deltaxml-new" style="background:#90EE90"> with its definition in the </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema"><span class="deltaxml-new" style="background:#90EE90">schema</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> that was used to validate the node. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every element name, attribute name, or schema type name referenced in </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> must be in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">, unless it is an element name referenced as part of an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> or an attribute name referenced as part of an </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Any reference to a global element, attribute, or type name in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> must have a corresponding element, attribute or type definition in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90"> must match the </span><a title="context value static type" class="termref" href="#dt-context-value-static-type"><span class="deltaxml-new" style="background:#90EE90">context value static type</span></a><span class="deltaxml-new" style="background:#90EE90">, using the matching rules in </span><a href="#id-sequencetype-matching"><b><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For each (variable, type) pair in </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> and the corresponding (variable, value) pair in </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90"> such that the variable names are equal, the value must match the type, using the matching rules in </span><a href="#id-sequencetype-matching"><b><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">For each variable declared as external, if the variable declaration does not include a </span><a href="#doc-xpath40-VarDefaultValue"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a><span class="deltaxml-new" style="background:#90EE90">, the external environment must provide a value for the variable.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For each variable declared as external for which the external environment provides a value: If the variable declaration includes a declared type, the value provided by the external environment must match the declared type, using the matching rules in </span><a href="#id-sequencetype-matching"><b><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></b></a><span class="deltaxml-new" style="background:#90EE90">. If the variable declaration does not include a declared type, the external environment must provide a type to accompany the value provided, using the same matching rules.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">For each function declared as external: the function’s </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">implementation</span></a><span class="deltaxml-new" style="background:#90EE90"> must either return a value that matches the declared result type, using the matching rules in </span><a href="#id-sequencetype-matching"><b><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></b></a><span class="deltaxml-new" style="background:#90EE90">, or raise an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> error.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">For a given query, define a </span><b><span class="deltaxml-new" style="background:#90EE90">participating ISSD</span></b><span class="deltaxml-new" style="background:#90EE90"> as the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of a module that is used in evaluating the query. All participating ISSDs must be </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-new" style="background:#90EE90">compatible</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This rule ensures that when one module </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> imports schema </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90">, and another module </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> imports schema </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90">, then an element node validated against type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> can be safely passed to a function in </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> that expects an argument of type </span><code><span class="deltaxml-new" style="background:#90EE90">element(*, T)</span></code><span class="deltaxml-new" style="background:#90EE90">. The requirement for compatibility does not guarantee that in all cases, validation of an element against the two different schemas will produce exactly the same outcome (there may be differences, for example, in the definition of substitution groups or wildcards), and the processor must allow for such differences.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">In the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> must not be bound to any namespace URI other than </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">, and no prefix other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> may be bound to this namespace URI. The prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> must not be bound to any namespace URI, and no prefix may be bound to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div></div><div class="div2"><h3><a id="errors"></a><span class="deltaxml-new" style="background:#90EE90">2.4 Error Handling</span></h3><div class="div3"><h4><a id="id-kinds-of-errors"></a><span class="deltaxml-new" style="background:#90EE90">2.4.1 Kinds of Errors</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> As described in </span><a href="#id-expression-processing"><b><span class="deltaxml-new" style="background:#90EE90">2.3.3 Expression Processing</span></b></a><span class="deltaxml-new" style="background:#90EE90">, XQuery 4.0 and XPath 4.0 defines a </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90">, which does not depend on input data, and a </span><a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation"><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></a><span class="deltaxml-new" style="background:#90EE90">, which does depend on input data. Errors may be raised during each phase.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-error" title="static error"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An error that can be detected during the static analysis phase, and is not a type error, is a </span><b><span class="deltaxml-new" style="background:#90EE90">static error</span></b><span class="deltaxml-new" style="background:#90EE90">.] A syntax error is an example of a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dynamic-error" title="dynamic error"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></b><span class="deltaxml-new" style="background:#90EE90"> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.] Numeric overflow is an example of a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-type-error" title="type error"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">type error</span></b><span class="deltaxml-new" style="background:#90EE90"> may be raised during the static analysis phase or the dynamic evaluation phase. During the static analysis phase, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs when the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of an expression does not match the expected type of the context in which the expression occurs. During the dynamic evaluation phase, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs when the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of a value does not match the expected type of the context in which the value occurs.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The outcome of the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90"> is either success or one or more </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static errors</span></a><span class="deltaxml-new" style="background:#90EE90">, or statically detected </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90">. The result of the </span><a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation"><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></a><span class="deltaxml-new" style="background:#90EE90"> is either a result value, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90">, or a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If more than one error is present, or if an error condition comes within the scope of more than one error defined in this specification, then any non-empty subset of these errors may be reported.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If an implementation can determine during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90"> that </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a </span><a href="#doc-xpath40-QueryBody"><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></a></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an XPath expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, if evaluated, would necessarily raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> or that an expression, if evaluated, would necessarily raise a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90">, the implementation may (but is not required to) report that error during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation can raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> for </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a </span><a href="#doc-xpath40-QueryBody"><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></a></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an XPath expression</span></span></span><span class="deltaxml-new" style="background:#90EE90"> statically only if the </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expression</span></span></span><span class="deltaxml-new" style="background:#90EE90"> can never execute without raising that error, as in the following example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">error()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following example contains a type error, which can be reported statically even if the implementation can not prove that the expression will actually be evaluated.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">if (empty($arg))
then "cat" * 2
else 0</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-warning" title="warning"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In addition to </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static errors</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90">, an XQuery 4.0 and XPath 4.0 implementation may raise </span><b><span class="deltaxml-new" style="background:#90EE90">warnings</span></b><span class="deltaxml-new" style="background:#90EE90">, either during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90"> or the </span><a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation"><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></a><span class="deltaxml-new" style="background:#90EE90">. The circumstances in which warnings are raised, and the ways in which warnings are handled, are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">In addition to the errors defined in this specification, an implementation may raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> for a reason beyond the scope of this specification. For example, limitations may exist on the maximum numbers or sizes of various objects. </span><span><span class="deltaxml-new" style="background:#90EE90">An error must be raised if such a limitation is exceeded [</span><a href="#ERRXPDY0130" title="err:XPDY0130"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0130</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></span></p></div><div class="div3"><h4><a id="id-identifying-errors"></a><span class="deltaxml-new" style="background:#90EE90">2.4.2 Identifying and Reporting Errors</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The errors defined in this specification are identified by QNames that have the form </span><code class="xpath"><span class="deltaxml-new" style="background:#90EE90">err:XPYYnnnn</span></code><code class="xquery"><span class="deltaxml-new" style="background:#90EE90">err:XXYYnnnn</span></code><span class="deltaxml-new" style="background:#90EE90">, where:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">err</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the namespace for XPath and XQuery errors, </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xqt-errors</span></code><span class="deltaxml-new" style="background:#90EE90">. This binding of the namespace prefix </span><code><span class="deltaxml-new" style="background:#90EE90">err</span></code><span class="deltaxml-new" style="background:#90EE90"> is used for convenience in this document, and is not normative.</span></p></li><li class="xpath"><p><code><span class="deltaxml-new" style="background:#90EE90">XP</span></code><span class="deltaxml-new" style="background:#90EE90"> identifies the error as an XPath error (some errors, originally defined by XQuery and later added to XPath, use the code </span><code><span class="deltaxml-new" style="background:#90EE90">XQ</span></code><span class="deltaxml-new" style="background:#90EE90"> instead).</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">XX</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the language in which the error is defined, using the following encoding:</span></p><ul class="xquery"><li><p><code><span class="deltaxml-new" style="background:#90EE90">XP</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes an error defined by XPath. Such an error may also occur XQuery since XQuery includes XPath as a subset.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">XQ</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes an error defined by XQuery (or an error originally defined by XQuery and later added to XPath).</span></p></li></ul></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">YY</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the error category, using the following encoding:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">ST</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a static error.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">DY</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a dynamic error.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">TY</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a type error.</span></p></li></ul></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">nnnn</span></code><span class="deltaxml-new" style="background:#90EE90"> is a unique numeric code.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The namespace URI for XPath and XQuery errors is not expected to change from one version of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath</span></span></span><span class="deltaxml-new" style="background:#90EE90"> to another. However, the contents of this namespace may be extended to include additional error definitions.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The method by which an XQuery 4.0 and XPath 4.0 processor reports error information to the external environment is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An error can be represented by a URI reference that is derived from the error QName as follows: an error with namespace URI </span><em><code><span class="deltaxml-new" style="background:#90EE90">NS</span></code></em><span class="deltaxml-new" style="background:#90EE90"> and local part </span><em><code><span class="deltaxml-new" style="background:#90EE90">LP</span></code></em><span class="deltaxml-new" style="background:#90EE90"> can be represented as the URI reference </span><em><code><span class="deltaxml-new" style="background:#90EE90">NS</span></code></em><code><span class="deltaxml-new" style="background:#90EE90">#</span></code><em><code><span class="deltaxml-new" style="background:#90EE90">LP</span></code></em><span class="deltaxml-new" style="background:#90EE90">. For example, an error whose QName is </span><code><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></code><span class="deltaxml-new" style="background:#90EE90"> could be represented as </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xqt-errors#XPST0017</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Along with a code identifying an error, implementations may wish to return additional information, such as the location of the error or the processing phase in which it was detected. If an implementation chooses to do so, then the mechanism that it uses to return this information is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="id-handling-dynamic"></a><span class="deltaxml-new" style="background:#90EE90">2.4.3 Handling Dynamic Errors</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Except as noted in this document, if any operand of an expression raises a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90">, the expression also raises a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90">. If an expression can validly return a value or raise a dynamic error, the implementation may choose to return the value or raise the dynamic error (see </span><a href="#id-errors-and-opt"><b><span class="deltaxml-new" style="background:#90EE90">2.4.4 Errors and Optimization</span></b></a><span class="deltaxml-new" style="background:#90EE90">). For example, the logical expression </span><code><span class="deltaxml-new" style="background:#90EE90">expr1 and expr2</span></code><span class="deltaxml-new" style="background:#90EE90"> may return the value </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> if either operand returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, or may raise a dynamic error if either operand raises a dynamic error.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> If more than one operand of an expression raises an error, the implementation may choose which error is raised by the expression. For example, in this expression: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x div $y) + xs:decimal($z)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> both the sub-expressions </span><code><span class="deltaxml-new" style="background:#90EE90">($x div $y)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal($z)</span></code><span class="deltaxml-new" style="background:#90EE90"> may raise an error. The implementation may choose which error is raised by the </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> expression. Once one operand raises an error, the implementation is not required, but is permitted, to evaluate any other operands.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-error-value" title="error value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called </span><b><span class="deltaxml-new" style="background:#90EE90">error values</span></b><span class="deltaxml-new" style="background:#90EE90">.] An implementation may provide a mechanism whereby an application-defined error handler can process error values and produce diagnostic messages. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1 provides standard error handling via </span><a href="https://qt4cg.org/specifications/xquery-40/xquery-40.html#id-try-catch"><span class="deltaxml-new" style="background:#90EE90">Section 4.20 Try/Catch Expressions</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XQ40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">The host language may also provide error handling mechanisms.</span></span></span></p><p><span class="deltaxml-new" style="background:#90EE90">A dynamic error may be raised by a </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system function</span></a><span class="deltaxml-new" style="background:#90EE90"> or operator. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90"> operator raises an error if its operands are </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> values and its second operand is equal to zero. Errors raised by system functions and operators are defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or the host language.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A dynamic error can also be raised explicitly by calling the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:error</span></code><span class="deltaxml-new" style="background:#90EE90"> function, which always raises a dynamic error and never returns a value. This function is defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-error"><span class="deltaxml-new" style="background:#90EE90">Section 3.1.1 fn:error</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. For example, the following function call raises a dynamic error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">app</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a namespace containing application-defined error codes):</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">error(xs:QName("app:err057"), "Unexpected value", string($v))</span></pre></div></div></div><div class="div3"><h4><a id="id-errors-and-opt"></a><span class="deltaxml-new" style="background:#90EE90">2.4.4 Errors and Optimization</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Because different implementations may choose to evaluate or optimize an expression in different ways, certain aspects of raising </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90"> are </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in this section.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation is always free to evaluate the operands of an operator in any order.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In some cases, a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of </span><a title="filter expression" class="termref" href="#dt-filter-expression"><span class="deltaxml-new" style="background:#90EE90">filter expressions</span></a><span class="deltaxml-new" style="background:#90EE90"> suggests that </span><code><span class="deltaxml-new" style="background:#90EE90">$s[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> should be evaluated by examining all the items in sequence </span><code><span class="deltaxml-new" style="background:#90EE90">$s</span></code><span class="deltaxml-new" style="background:#90EE90">, and selecting all those that satisfy the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">position()=1</span></code><span class="deltaxml-new" style="background:#90EE90">. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If </span><code><span class="deltaxml-new" style="background:#90EE90">$s</span></code><span class="deltaxml-new" style="background:#90EE90"> is defined by an expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">//book[author eq 'Berners-Lee']</span></code><span class="deltaxml-new" style="background:#90EE90">, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a </span><code><span class="deltaxml-new" style="background:#90EE90">book</span></code><span class="deltaxml-new" style="background:#90EE90"> element in the input data with more than one </span><code><span class="deltaxml-new" style="background:#90EE90">author</span></code><span class="deltaxml-new" style="background:#90EE90"> subelement.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The extent to which a processor may optimize its access to data, at the cost of not raising errors, is defined by the following rules.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Consider an expression </span><em><span class="deltaxml-new" style="background:#90EE90">Q</span></em><span class="deltaxml-new" style="background:#90EE90"> that has an operand (sub-expression) </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90">. In general the value of </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90"> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating </span><em><span class="deltaxml-new" style="background:#90EE90">Q</span></em><span class="deltaxml-new" style="background:#90EE90">, namely the value </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> or an error, then the processor may deliver the result </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> without evaluating further items in the operand </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90">. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</span></p><p><span class="deltaxml-new" style="background:#90EE90">There is an exception to this rule: If a processor evaluates an operand </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90"> (wholly or in part), then it is required to establish that the actual value of the operand </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90"> does not violate any constraints on its cardinality. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$e eq 0</span></code><span class="deltaxml-new" style="background:#90EE90"> results in a type error if the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> and finding it equal to zero, that the only possible outcomes are the value </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or a type error caused by the cardinality violation. It must establish that the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> contains no more than one item.</span></p><p><span class="deltaxml-new" style="background:#90EE90">These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands </span><em><span class="deltaxml-new" style="background:#90EE90">E1</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">E2</span></em><span class="deltaxml-new" style="background:#90EE90">, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The rules cascade: if </span><em><span class="deltaxml-new" style="background:#90EE90">A</span></em><span class="deltaxml-new" style="background:#90EE90"> is an operand of </span><em><span class="deltaxml-new" style="background:#90EE90">B</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">B</span></em><span class="deltaxml-new" style="background:#90EE90"> is an operand of </span><em><span class="deltaxml-new" style="background:#90EE90">C</span></em><span class="deltaxml-new" style="background:#90EE90">, then the processor needs to evaluate only a sufficient sample of </span><em><span class="deltaxml-new" style="background:#90EE90">B</span></em><span class="deltaxml-new" style="background:#90EE90"> to determine the value of </span><em><span class="deltaxml-new" style="background:#90EE90">C</span></em><span class="deltaxml-new" style="background:#90EE90">, and needs to evaluate only a sufficient sample of </span><em><span class="deltaxml-new" style="background:#90EE90">A</span></em><span class="deltaxml-new" style="background:#90EE90"> to determine this sample of </span><em><span class="deltaxml-new" style="background:#90EE90">B</span></em><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> as the result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">S1 = S2</span></code><span class="deltaxml-new" style="background:#90EE90"> as soon as it finds a pair of equal values from the two sequences.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if an empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not an empty sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If an implementation can find (for example, by using an index) that at least one item returned by </span><code><span class="deltaxml-new" style="background:#90EE90">$expr1</span></code><span class="deltaxml-new" style="background:#90EE90"> in the following example has the value </span><code><span class="deltaxml-new" style="background:#90EE90">47</span></code><span class="deltaxml-new" style="background:#90EE90">, it is allowed to return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> as the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, without searching for another item returned by </span><code><span class="deltaxml-new" style="background:#90EE90">$expr1</span></code><span class="deltaxml-new" style="background:#90EE90"> that would raise an error if it were evaluated. </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">some $x in $expr1 satisfies $x = 47</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">In the following example, if an implementation can find (for example, by using an index) the </span><code><span class="deltaxml-new" style="background:#90EE90">product</span></code><span class="deltaxml-new" style="background:#90EE90"> element-nodes that have an </span><code><span class="deltaxml-new" style="background:#90EE90">id</span></code><span class="deltaxml-new" style="background:#90EE90"> child with the value </span><code><span class="deltaxml-new" style="background:#90EE90">47</span></code><span class="deltaxml-new" style="background:#90EE90">, it is allowed to return these nodes as the result of the </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-new" style="background:#90EE90">path expression</span></a><span class="deltaxml-new" style="background:#90EE90">, without searching for another </span><code><span class="deltaxml-new" style="background:#90EE90">product</span></code><span class="deltaxml-new" style="background:#90EE90"> node that would raise an error because it has an </span><code><span class="deltaxml-new" style="background:#90EE90">id</span></code><span class="deltaxml-new" style="background:#90EE90"> child whose value is not an integer.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">//product[id = 47]</span></pre></div></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">For a variety of reasons, including optimization, implementations may rewrite expressions into a different form. There are a number of rules that limit the extent of this freedom: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> Other than the raising or not raising of errors, the result of evaluating a rewritten expression must conform to the semantics defined in this specification for the original expression. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> This allows an implementation to return a result in cases where the original expression would have raised an error, or to raise an error in cases where the original expression would have returned a result. The main cases where this is likely to arise in practice are (a) where a rewrite changes the order of evaluation, such that a subexpression causing an error is evaluated when the expression is written one way and is not evaluated when the expression is written a different way, and (b) where intermediate results of the evaluation cause overflow or other out-of-range conditions. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> This rule does not mean that the result of the expression will always be the same in non-error cases as if it had not been rewritten, because there are many cases where the result of an expression is to some degree </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules described in </span><a href="#id-guarded-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.5 Guarded Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90"> ensure that for certain kinds of expression (for example conditional expressions), changing the order of evaluation of subexpressions does not result in dynamic errors that would not otherwise occur.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Expressions must not be rewritten in such a way as to create or remove static errors. The static errors in this specification are defined for the original expression, and must be preserved if the expression is rewritten.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> As stated earlier, an expression must not be rewritten to dispense with a required cardinality check: for example, </span><code><span class="deltaxml-new" style="background:#90EE90">string-length(//title)</span></code><span class="deltaxml-new" style="background:#90EE90"> must raise an error if the document contains more than one title element. </span></p></li></ul></div><div class="div3"><h4><a id="id-guarded-expressions"></a><span class="deltaxml-new" style="background:#90EE90">2.4.5 Guarded Expressions</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-implausible-expressions"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-processing-model"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of </span><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><span class="deltaxml-new" style="background:#90EE90">, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-guarded" title="guarded"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An expression </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is said to be </span><b><span class="deltaxml-new" style="background:#90EE90">guarded</span></b><span class="deltaxml-new" style="background:#90EE90"> by some governing condition </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> if evaluation of </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is not allowed to fail with a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> except when </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> applies.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, in a conditional expression </span><code><span class="deltaxml-new" style="background:#90EE90">if (P) then T else F</span></code><span class="deltaxml-new" style="background:#90EE90">, the subexpression </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is guarded by </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90">, and the subexpression </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> is guarded by </span><code><span class="deltaxml-new" style="background:#90EE90">not(P)</span></code><span class="deltaxml-new" style="background:#90EE90">. One way an implementation can satisfy this rule is by not evaluating </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> unless </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90"> is true, and likewise not evaluating </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> unless </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90"> is false. Another way of satisfying the rule is for the implementation to evaluate all the subexpressions, but to catch any errors that occur in a guarded subexpression so they are not propagated. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The existence of this rule enables errors to be prevented by writing expressions such as </span><code><span class="deltaxml-new" style="background:#90EE90">if ($y eq 0) then "N/A" else ($x div $y)</span></code><span class="deltaxml-new" style="background:#90EE90">. This example will never fail with a divide-by-zero error because the </span><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><span class="deltaxml-new" style="background:#90EE90"> branch of the conditional is </span><a title="guarded" class="termref" href="#dt-guarded"><span class="deltaxml-new" style="background:#90EE90">guarded</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, in the mapping expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1!E2</span></code><span class="deltaxml-new" style="background:#90EE90">, the subexpression </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the existence of an item from </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90">. This means, for example, that the expression </span><code><span class="deltaxml-new" style="background:#90EE90">(1 to $n)!doc('bad.xml')</span></code><span class="deltaxml-new" style="background:#90EE90"> must not raise a dynamic error if </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is zero. The rule governing evaluation of guarded expressions is phrased so as not to disallow “loop-lifting” or “constant-folding” optimizations whose aim is to avoid repeated evaluation of a common subexpression; but such optimizations must not result in errors that would not otherwise occur.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The complete list of expressions that have guarded subexpressions is as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">In a conditional expression (</span><a href="#doc-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">IfExpr</span></a><span class="deltaxml-new" style="background:#90EE90">) the </span><code><span class="deltaxml-new" style="background:#90EE90">then</span></code><span class="deltaxml-new" style="background:#90EE90"> branch is guarded by the condition being true, and the </span><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><span class="deltaxml-new" style="background:#90EE90"> branch is guarded by the condition being false.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-SwitchExpr"><span class="deltaxml-new" style="background:#90EE90">SwitchExpr</span></a><span class="deltaxml-new" style="background:#90EE90">), the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> expression of a particular </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the condition for that case matching, and no earlier case matching.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-TypeswitchExpr"><span class="deltaxml-new" style="background:#90EE90">TypeswitchExpr</span></a><span class="deltaxml-new" style="background:#90EE90">), the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> expression of a particular </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the condition for that case matching, and no earlier case matching.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In an </span><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">AndExpr</span></a><span class="deltaxml-new" style="background:#90EE90">), the second operand is guarded by the value of the first operand being true.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In an </span><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-OrExpr"><span class="deltaxml-new" style="background:#90EE90">OrExpr</span></a><span class="deltaxml-new" style="background:#90EE90">), the second operand is guarded by the value of the first operand being false.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In an </span><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">OtherwiseExpr</span></a><span class="deltaxml-new" style="background:#90EE90">), the second operand is guarded by the value of the first operand being an empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In a path expression of the form </span><code><span class="deltaxml-new" style="background:#90EE90">E1/E2</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">E1//E2</span></code><span class="deltaxml-new" style="background:#90EE90">, and in a mapping expression of the form </span><code><span class="deltaxml-new" style="background:#90EE90">E1!E2</span></code><span class="deltaxml-new" style="background:#90EE90">, the right-hand operand </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the existence of at least one item in the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This rule applies even if </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> does not reference the context value. For example, no dynamic error can be thrown by the expression </span><code><span class="deltaxml-new" style="background:#90EE90">(1 to $n)!doc('bad.xml')</span></code><span class="deltaxml-new" style="background:#90EE90"> in the case where </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is zero.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In a filter expression of the form </span><code><span class="deltaxml-new" style="background:#90EE90">E[P]</span></code><span class="deltaxml-new" style="background:#90EE90">, the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">P</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the existence of at least one item in the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This rule has the consequence that in a filter expression with multiple predicates, such as </span><code><span class="deltaxml-new" style="background:#90EE90">E[P1][P2]</span></code><span class="deltaxml-new" style="background:#90EE90">, evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">P2</span></code><span class="deltaxml-new" style="background:#90EE90"> must not raise a dynamic error unless </span><code><span class="deltaxml-new" style="background:#90EE90">P1</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">. This rule does not prevent reordering of predicates (for example, to take advantage of indexes), but it does require that any such reordering must not result in errors that would not otherwise occur.</span></p></li><li><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90">) such as </span><code><span class="deltaxml-new" style="background:#90EE90">for $x in S return E</span></code><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the existence of an item bound to </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">FLWOR</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-FLWORExpr"><span class="deltaxml-new" style="background:#90EE90">FLWORExpr</span></a><span class="deltaxml-new" style="background:#90EE90">), an expression that is logically dependent on the tuples in the tuple stream is guarded by the existence of a relevant tuple. This applies even where the expression does not actually reference any of the variable bindings in the tuple stream. For example, in the expression </span><code><span class="deltaxml-new" style="background:#90EE90">for $x in S return E</span></code><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the existence of an item bound to </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">This means that the expression </span><code><span class="deltaxml-new" style="background:#90EE90">for $x in 1 to $n return doc('bad.xml')</span></code><span class="deltaxml-new" style="background:#90EE90"> must not raise a dynamic error in the case where </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is zero.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">quantified</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (</span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><span class="deltaxml-new" style="background:#90EE90">) such as </span><code><span class="deltaxml-new" style="background:#90EE90">some $x in S satisfies P</span></code><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">P</span></code><span class="deltaxml-new" style="background:#90EE90"> is guarded by the existence of an item bound to </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The fact that an expression is </span><a title="guarded" class="termref" href="#dt-guarded"><span class="deltaxml-new" style="background:#90EE90">guarded</span></a><span class="deltaxml-new" style="background:#90EE90"> does not remove the obligation to report </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static errors</span></a><span class="deltaxml-new" style="background:#90EE90"> in the expression; nor does it remove the option to report statically detectable </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">These rules do not constrain the order of evaluation of subexpressions. For example, given an expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">//person[@first = "Winston"][@last = "Churchill"]</span></code><span class="deltaxml-new" style="background:#90EE90">, or equivalently </span><code><span class="deltaxml-new" style="background:#90EE90">//person[@first = "Winston" and @last = "Churchill"]</span></code><span class="deltaxml-new" style="background:#90EE90">, an implementation might use an index on the value of </span><code><span class="deltaxml-new" style="background:#90EE90">@last</span></code><span class="deltaxml-new" style="background:#90EE90"> to select items that satisfy the second condition, and then filter these items on the value of the first condition. Alternatively, it might evaluate both predicates in parallel. Or it might interpose an additional redundant condition: </span><code><span class="deltaxml-new" style="background:#90EE90">//person[string-length(@first) + string-length(@last) = 16][@first = "Winston"][@last = "Churchill"]</span></code><span class="deltaxml-new" style="background:#90EE90">. But implementations must ensure that such rewrites do not result in dynamic errors being reported that would not occur if the predicates were evaluated in order as written.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Although the rules for guarded expressions prevent optimizations resulting in spurious errors, they do not prevent optimizations whose effect is to mask errors. For example, the rules guarantee that </span><code><span class="deltaxml-new" style="background:#90EE90">("A", 3)[. instance of xs:integer][. eq 3]</span></code><span class="deltaxml-new" style="background:#90EE90"> will not raise an error caused by the comparison </span><code><span class="deltaxml-new" style="background:#90EE90">("A" eq 3)</span></code><span class="deltaxml-new" style="background:#90EE90">, but they do not guarantee the converse: the expression </span><code><span class="deltaxml-new" style="background:#90EE90">("A", 3)[. eq 3][. instance of xs:integer]</span></code><span class="deltaxml-new" style="background:#90EE90"> may or may not raise a dynamic error.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The rules in this section do not disallow all expression rewrites that might result in dynamic errors. For example, rewriting </span><code><span class="deltaxml-new" style="background:#90EE90">($x - $y + $z)</span></code><span class="deltaxml-new" style="background:#90EE90"> as </span><code><span class="deltaxml-new" style="background:#90EE90">($x + $z - $y)</span></code><span class="deltaxml-new" style="background:#90EE90"> is permitted even though it might result in an arithmetic overflow.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Some implementations allow calls on external functions that have side-effects. The semantics of such function calls are entirely </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation defined</span></a><span class="deltaxml-new" style="background:#90EE90">. Processors </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> choose to reference the rules for </span><a title="guarded" class="termref" href="#dt-guarded"><span class="deltaxml-new" style="background:#90EE90">guarded</span></a><span class="deltaxml-new" style="background:#90EE90"> expressions when defining the behavior of such function calls, but this is outside the scope of the language specification.</span></p></div></div><div class="div3"><h4><a id="id-implausible-expressions"></a><span class="deltaxml-new" style="background:#90EE90">2.4.6 Implausible Expressions</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-choice-item-types"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-guarded-expressions"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as </span><code><span class="deltaxml-new" style="background:#90EE90">@price/@value</span></code><span class="deltaxml-new" style="background:#90EE90">, even though dynamic evaluation is defined to return an empty sequence rather than an error. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/602"><span class="deltaxml-new" style="background:#90EE90">602</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/603"><span class="deltaxml-new" style="background:#90EE90">603</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;25 July 2023]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-implausible" title="implausible"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Certain expressions, while not erroneous, are classified as being </span><b><span class="deltaxml-new" style="background:#90EE90">implausible</span></b><span class="deltaxml-new" style="background:#90EE90">, because they achieve no useful effect.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">An example of an implausible expression is </span><code><span class="deltaxml-new" style="background:#90EE90">@code/text()</span></code><span class="deltaxml-new" style="background:#90EE90">. This expression will always evaluate to an empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different; if they wanted to an expression that evaluated to an empty sequence, there would be easier ways to write it.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Where an expression is classified (by rules in this specification) as being </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90">, a processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> (but is not </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">required</span></span><span class="deltaxml-new" style="background:#90EE90"> to) raise a static error.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For reasons of backwards compatibility and interoperability, and to facilitate automatic generation of XQuery 4.0 and XPath 4.0 code, a processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90"> provide a mode of operation in which </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> expressions are not treated as static errors, but are evaluated with the defined semantics for the expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Some other examples of implausible expressions include:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">round(tokenize($input))</span></code><span class="deltaxml-new" style="background:#90EE90">. The result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:tokenize</span></code><span class="deltaxml-new" style="background:#90EE90"> is a sequence of strings (</span><code><span class="deltaxml-new" style="background:#90EE90">xs:string*</span></code><span class="deltaxml-new" style="background:#90EE90">), while the required type for the first argument of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:round</span></code><span class="deltaxml-new" style="background:#90EE90"> is optional numeric (</span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric?</span></code><span class="deltaxml-new" style="background:#90EE90">). The expression can succeed only in the exceptional case where the result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:tokenize</span></code><span class="deltaxml-new" style="background:#90EE90"> is an empty sequence, in which case the result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:round</span></code><span class="deltaxml-new" style="background:#90EE90"> will also be an empty sequence; it is therefore highly likely that the expression was written in error.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">parse-csv($input)?column-names</span></code><span class="deltaxml-new" style="background:#90EE90">. The signature of the </span><code><span class="deltaxml-new" style="background:#90EE90">parse-csv</span></code><span class="deltaxml-new" style="background:#90EE90"> function declares its return type as </span><code><span class="deltaxml-new" style="background:#90EE90">record(columns, rows)</span></code><span class="deltaxml-new" style="background:#90EE90">. There is no field in this record named </span><code><span class="deltaxml-new" style="background:#90EE90">column-names</span></code><span class="deltaxml-new" style="background:#90EE90">, and therefore the lookup expression will always return an empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The specification is deliberately conservative in the choice of constructs that have been classified as implausible. Constructs have not been classified as implausible merely because there are better ways of writing the same thing, but only in cases where it is considered that no user in full understanding of the specification would intentionally write such a construct. All these cases correspond to situations that would be classed as errors in a language with stricter static typing rules.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In many cases the classification of constructs as implausible is designed to protect users from usability problems that have been found with earlier versions of the language. without introducing backwards incompatibilities.</span></p></div></div></div><div class="div2"><h3><a id="id-important-concepts"></a><span class="deltaxml-new" style="background:#90EE90">2.5 Concepts</span></h3><p><span class="deltaxml-new" style="background:#90EE90">This section explains some concepts that are important to the processing of XQuery 4.0 and XPath 4.0 expressions.</span></p><div class="div3"><h4><a id="id-document-order"></a><span class="deltaxml-new" style="background:#90EE90">2.5.1 Document Order</span></h4><p><span class="deltaxml-new" style="background:#90EE90">An ordering called </span><b><span class="deltaxml-new" style="background:#90EE90">document order</span></b><span class="deltaxml-new" style="background:#90EE90"> is defined among all the nodes accessible during processing of a given </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, which may consist of one or more </span><b><span class="deltaxml-new" style="background:#90EE90">trees</span></b><span class="deltaxml-new" style="background:#90EE90"> (documents or fragments). Document order is defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#document-order"><span class="deltaxml-new" style="background:#90EE90">Section 2.5 Document Order</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, and its definition is repeated here for convenience. Document order is a total ordering, although the relative order of some nodes is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-document-order" title="document order"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Informally, </span><b><span class="deltaxml-new" style="background:#90EE90">document order</span></b><span class="deltaxml-new" style="background:#90EE90"> is the order in which nodes appear in the XML serialization of a document.] [</span><a id="stable" title="stable"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Document order is </span><b><span class="deltaxml-new" style="background:#90EE90">stable</span></b><span class="deltaxml-new" style="background:#90EE90">, which means that the relative order of two nodes will not change during the processing of a given </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, even if this order is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.] [</span><a id="dt-reverse-document-order" title="reverse document order"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The node ordering that is the reverse of document order is called </span><b><span class="deltaxml-new" style="background:#90EE90">reverse document order</span></b><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Within a tree, document order satisfies the following constraints:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The root node is the first node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every node occurs before all of its children and descendants.</span></p></li><li class="xpath"><p><span class="deltaxml-new" style="background:#90EE90">Namespace nodes immediately follow the element node with which they are associated. The relative order of namespace nodes is stable but </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Attribute nodes immediately follow the </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">namespace nodes of the </span></span></span><span class="deltaxml-new" style="background:#90EE90"> element node with which they are associated. The relative order of attribute nodes is stable but </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The relative order of siblings is the order in which they occur in the </span><code><span class="deltaxml-new" style="background:#90EE90">children</span></code><span class="deltaxml-new" style="background:#90EE90"> property of their parent node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Children and descendants occur before following siblings.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The relative order of nodes in distinct trees is stable but </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">, subject to the following constraint: If any node in a given tree T1 is before any node in a different tree T2, then all nodes in tree T1 are before all nodes in tree T2.</span></p></div><div class="div3"><h4><a id="id-typed-value"></a><span class="deltaxml-new" style="background:#90EE90">2.5.2 Typed Value and String Value</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Every node has a </span><b><span class="deltaxml-new" style="background:#90EE90">typed value</span></b><span class="deltaxml-new" style="background:#90EE90"> and a </span><b><span class="deltaxml-new" style="background:#90EE90">string value</span></b><span class="deltaxml-new" style="background:#90EE90">, except for nodes whose value is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-typed-value" title="typed value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">typed value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a node is a sequence of atomic items and can be extracted by applying the </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data"><span class="deltaxml-new" style="background:#90EE90">Section 2.1.4 fn:data</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> function to the node.] [</span><a id="dt-string-value" title="string value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">string value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a node is a string and can be extracted by applying the </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-string"><span class="deltaxml-new" style="background:#90EE90">Section 2.1.3 fn:string</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> function to the node.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation may store both the </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> and the </span><a title="string value" class="termref" href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string value</span></a><span class="deltaxml-new" style="background:#90EE90"> of a node, or it may store only one of these and derive the other as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">30</span></code><span class="deltaxml-new" style="background:#90EE90">, its string value might be </span><code><span class="deltaxml-new" style="background:#90EE90">"30"</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">"0030"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="string value" class="termref" href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string value</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of a node are closely related. If the node was created by mapping from an Infoset or PSVI, the relationships among these properties are defined by rules in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types"><span class="deltaxml-new" style="background:#90EE90">Section 2.8 Schema Information</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="string value" class="termref" href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string value</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of a node are closely related, and are defined by rules found in the following locations:</span></p></div><ul class="xquery"><li><p><span class="deltaxml-new" style="background:#90EE90">If the node was created by mapping from an Infoset or PSVI, see rules in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types"><span class="deltaxml-new" style="background:#90EE90">Section 2.8 Schema Information</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the node was created by an XQuery node constructor, see rules in </span><a href="#id-element-constructor"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#id-computedElements"><b><span class="deltaxml-new" style="background:#90EE90">4.12.3.1 Computed Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">, or </span><a href="#id-computedAttributes"><b><span class="deltaxml-new" style="background:#90EE90">4.12.3.2 Computed Attribute Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the node was created by a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, see rules in </span><a href="#id-validate"><b><span class="deltaxml-new" style="background:#90EE90">4.24 Validate Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The relationship between </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="string value" class="termref" href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string value</span></a><span class="deltaxml-new" style="background:#90EE90"> for various kinds of nodes is summarized and illustrated by examples below.</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">For text and document nodes, the typed value of the node is the same as its string value, as an instance of the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. The string value of a document node is formed by concatenating the string values of all its descendant text nodes, in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The typed value of a comment</span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">, namespace,</span></span></span><span class="deltaxml-new" style="background:#90EE90"> or processing instruction node is the same as its string value. It is an instance of the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The typed value of an attribute node with the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><code><span class="deltaxml-new" style="background:#90EE90">xs:anySimpleType</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as its string value, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of an attribute node with any other type annotation is derived from its string value and type annotation using the lexical-to-value-space mapping defined in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> Part 2 for the relevant type.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: A1 is an attribute having string value </span><code><span class="deltaxml-new" style="background:#90EE90">"3.14E-2"</span></code><span class="deltaxml-new" style="background:#90EE90"> and type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of A1 is the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> value whose lexical representation is </span><code><span class="deltaxml-new" style="background:#90EE90">3.14E-2</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: A2 is an attribute with type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">xs:IDREFS</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a list datatype whose item type is the atomic datatype </span><code><span class="deltaxml-new" style="background:#90EE90">xs:IDREF</span></code><span class="deltaxml-new" style="background:#90EE90">. Its string value is </span><code><span class="deltaxml-new" style="background:#90EE90">"bar baz faz"</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of A2 is a sequence of three atomic items (</span><code><span class="deltaxml-new" style="background:#90EE90">"bar"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"baz"</span></code><span class="deltaxml-new" style="background:#90EE90">", </span><code><span class="deltaxml-new" style="background:#90EE90">"faz"</span></code><span class="deltaxml-new" style="background:#90EE90">"), each of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:IDREF</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of a node is never treated as an instance of a named list type. Instead, if the type annotation of a node is a list type (such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:IDREFS</span></code><span class="deltaxml-new" style="background:#90EE90">), its typed value is treated as a sequence of the </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> from which it is derived (such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:IDREF</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For an element node, the relationship between typed value and string value depends on the node’s </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90">, as follows:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If the type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anySimpleType</span></code><span class="deltaxml-new" style="background:#90EE90"> or denotes a complex type with mixed content (including </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">), then the typed value of the node is equal to its string value, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. However, if the </span><code><span class="deltaxml-new" style="background:#90EE90">nilled</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the node is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, then its typed value is the empty sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: E1 is an element node having type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> and string value </span><code><span class="deltaxml-new" style="background:#90EE90">"1999-05-31"</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of E1 is </span><code><span class="deltaxml-new" style="background:#90EE90">"1999-05-31"</span></code><span class="deltaxml-new" style="background:#90EE90">, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: E2 is an element node with the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">formula</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a complex type with mixed content. The content of E2 consists of the character </span><code><span class="deltaxml-new" style="background:#90EE90">H</span></code><span class="deltaxml-new" style="background:#90EE90">, a child element named </span><code><span class="deltaxml-new" style="background:#90EE90">subscript</span></code><span class="deltaxml-new" style="background:#90EE90"> with string value </span><code><span class="deltaxml-new" style="background:#90EE90">"2"</span></code><span class="deltaxml-new" style="background:#90EE90">, and the character </span><code><span class="deltaxml-new" style="background:#90EE90">O</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of E2 is </span><code><span class="deltaxml-new" style="background:#90EE90">"H2O"</span></code><span class="deltaxml-new" style="background:#90EE90"> as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the type annotation denotes a simple type or a complex type with simple content, then the typed value of the node is derived from its string value and its type annotation in a way that is consistent with schema validation. However, if the </span><code><span class="deltaxml-new" style="background:#90EE90">nilled</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the node is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, then its typed value is the empty sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: E3 is an element node with the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">cost</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a complex type that has several attributes and a simple content type of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">. The string value of E3 is </span><code><span class="deltaxml-new" style="background:#90EE90">"74.95"</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of E3 is </span><code><span class="deltaxml-new" style="background:#90EE90">74.95</span></code><span class="deltaxml-new" style="background:#90EE90">, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: E4 is an element node with the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">hatsizelist</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a simple type derived from the </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><code><span class="deltaxml-new" style="background:#90EE90">hatsize</span></code><span class="deltaxml-new" style="background:#90EE90">, which in turn is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. The string value of E4 is </span><code><span class="deltaxml-new" style="background:#90EE90">"7 8 9"</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of E4 is a sequence of three values (</span><code><span class="deltaxml-new" style="background:#90EE90">7</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">8</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">9</span></code><span class="deltaxml-new" style="background:#90EE90">), each of type </span><code><span class="deltaxml-new" style="background:#90EE90">hatsize</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: E5 is an element node with the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">my:integer-or-string</span></code><span class="deltaxml-new" style="background:#90EE90"> which is a union type with member types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">. The string value of E5 is </span><code><span class="deltaxml-new" style="background:#90EE90">"47"</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of E5 is </span><code><span class="deltaxml-new" style="background:#90EE90">47</span></code><span class="deltaxml-new" style="background:#90EE90"> as a </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, since </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If an implementation stores only the string value of a node, and the type annotation of the node is a union type, the implementation must be able to deliver the typed value of the node as an instance of the appropriate member type.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the type annotation denotes a complex type with empty content, then the typed value of the node is the empty sequence and its string value is the zero-length string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the type annotation denotes a complex type with element-only content, then the typed value of the node is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:data</span></code><span class="deltaxml-new" style="background:#90EE90"> function raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0012" title="err:FOTY0012"><span class="deltaxml-new" style="background:#90EE90">err:FOTY0012</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: E6 is an element node with the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">weather</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a complex type whose content type specifies </span><code><span class="deltaxml-new" style="background:#90EE90">element-only</span></code><span class="deltaxml-new" style="background:#90EE90">. E6 has two child elements named </span><code><span class="deltaxml-new" style="background:#90EE90">temperature</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">precipitation</span></code><span class="deltaxml-new" style="background:#90EE90">. The typed value of E6 is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, and the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:data</span></code><span class="deltaxml-new" style="background:#90EE90"> function applied to E6 raises an error. </span></p></li></ol></li></ol></div><div class="div3"><h4><a id="id-atomization"></a><span class="deltaxml-new" style="background:#90EE90">2.5.3 Atomization</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The semantics of some XQuery 4.0 and XPath 4.0 operators depend on a process called </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomization</span></a><span class="deltaxml-new" style="background:#90EE90">. Atomization is applied to a value when the value is used in a context in which a sequence of atomic items is required. The result of atomization is either a sequence of atomic items or a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0012" title="err:FOTY0012"><span class="deltaxml-new" style="background:#90EE90">err:FOTY0012</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-atomization" title="atomization"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Atomization</span></b><span class="deltaxml-new" style="background:#90EE90"> of a sequence is defined as the result of invoking the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:data</span></code><span class="deltaxml-new" style="background:#90EE90"> function, as defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data"><span class="deltaxml-new" style="background:#90EE90">Section 2.1.4 fn:data</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The semantics of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:data</span></code><span class="deltaxml-new" style="background:#90EE90"> are repeated here for convenience. The result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:data</span></code><span class="deltaxml-new" style="background:#90EE90"> is the sequence of atomic items produced by applying the following rules to each item in the input sequence:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the item is an atomic item, it is returned.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the item is a node, its </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> is returned (a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0012" title="err:FOTY0012"><span class="deltaxml-new" style="background:#90EE90">err:FOTY0012</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> is raised if the node has no typed value.)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the item is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> (other than an array) or map a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOTY0013" title="err:FOTY0013"><span class="deltaxml-new" style="background:#90EE90">err:FOTY0013</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> is raised.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the item is an array </span><code><span class="deltaxml-new" style="background:#90EE90">$a</span></code><span class="deltaxml-new" style="background:#90EE90">, atomization is defined as </span><code><span class="deltaxml-new" style="background:#90EE90">$a?* ! fn:data(.)</span></code><span class="deltaxml-new" style="background:#90EE90">, which is equivalent to atomizing the members of the array.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This definition recursively atomizes members that are arrays. Hence, the result of atomizing the array </span><code><span class="deltaxml-new" style="background:#90EE90">[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]</span></code><span class="deltaxml-new" style="background:#90EE90"> is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3, 4, 5, 6)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Atomization is used in processing the following types of expressions: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Arithmetic expressions</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparison expressions</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Function calls and returns</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Cast expressions</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Constructor expressions for various kinds of nodes</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses in FLWOR expressions</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses in FLWOR expressions</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Switch expressions</span></p></li></ul></div><div class="div3"><h4><a id="id-ebv"></a><span class="deltaxml-new" style="background:#90EE90">2.5.4 Effective Boolean Value</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Under certain circumstances (listed below), it is necessary to find the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of a value. [</span><a id="dt-ebv" title="effective boolean value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a value is defined as the result of applying the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> function to the value, as defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-boolean"><span class="deltaxml-new" style="background:#90EE90">Section 7.3.1 fn:boolean</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The dynamic semantics of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> are repeated here for convenience:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If its operand is an empty sequence, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If its operand is a sequence whose first item is a node, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If its operand is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-new" style="background:#90EE90">singleton</span></a><span class="deltaxml-new" style="background:#90EE90"> value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> or derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the value of its operand unchanged.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If its operand is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-new" style="background:#90EE90">singleton</span></a><span class="deltaxml-new" style="background:#90EE90"> value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, or a type derived from one of these, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> if the operand value has zero length; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If its operand is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-new" style="background:#90EE90">singleton</span></a><span class="deltaxml-new" style="background:#90EE90"> value of any </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a><span class="deltaxml-new" style="background:#90EE90"> type or derived from a numeric type, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> if the operand value is </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> or is numerically equal to zero; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In all other cases, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a type error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0006" title="err:FORG0006"><span class="deltaxml-new" style="background:#90EE90">err:FORG0006</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">For instance, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a type error if the operand is a function, a map, or an array.</span></p></div></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of a sequence is computed implicitly during processing of the following types of expressions: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Logical expressions (</span><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:not</span></code><span class="deltaxml-new" style="background:#90EE90"> function</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause of a FLWOR expression</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Certain types of </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new" style="background:#90EE90">predicates</span></a><span class="deltaxml-new" style="background:#90EE90">, such as </span><code><span class="deltaxml-new" style="background:#90EE90">a[b]</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Conditional expressions (</span><code><span class="deltaxml-new" style="background:#90EE90">if</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Quantified expressions (</span><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li class="xpath"><p><span class="deltaxml-new" style="background:#90EE90">General comparisons, in </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> in </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The definition of </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><em><span class="deltaxml-new" style="background:#90EE90">not</span></em><span class="deltaxml-new" style="background:#90EE90"> used when casting a value to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, for example in a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression or when passing a value to a function whose expected parameter is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="id-uri-literals"></a><span class="deltaxml-new" style="background:#90EE90">2.5.5 URI Literals</span></h4><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 requires a statically known, valid URI in </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span></span></span><span class="deltaxml-new" style="background:#90EE90">a </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">. An implementation may raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0046" title="err:XQST0046"><span class="deltaxml-new" style="background:#90EE90">err:XQST0046</span></a><span class="deltaxml-new" style="background:#90EE90">] if the value of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a URI Literal or</span></span></span><span class="deltaxml-new" style="background:#90EE90"> a Braced URI Literal is of nonzero length and is neither an absolute URI nor a relative URI.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">As in a string literal, any </span><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference"><span class="deltaxml-new" style="background:#90EE90">predefined entity reference</span></a><span class="deltaxml-new" style="background:#90EE90"> (such as </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;amp;</span></code><span class="deltaxml-new" style="background:#90EE90">), </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character reference</span></a><span class="deltaxml-new" style="background:#90EE90"> (such as </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#x2022;</span></code><span class="deltaxml-new" style="background:#90EE90">), or </span><a href="#doc-xpath40-EscapeQuot"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-EscapeApos"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a><span class="deltaxml-new" style="background:#90EE90"> (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">""</span></code><span class="deltaxml-new" style="background:#90EE90">) is replaced by its appropriate expansion. Certain characters, notably the ampersand, can only be represented using a </span><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference"><span class="deltaxml-new" style="background:#90EE90">predefined entity reference</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character reference</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> type is designed to anticipate the introduction of Internationalized Resource Identifiers (IRIs) as defined in </span><a href="#RFC3987"><span class="deltaxml-new" style="background:#90EE90">[RFC3987]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Whitespace is normalized using the whitespace normalization rules of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:normalize-space</span></code><span class="deltaxml-new" style="background:#90EE90">. If the result of whitespace normalization contains only whitespace, the corresponding URI consists of the empty string. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Whitespace normalization is done after the expansion of </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character references</span></a><span class="deltaxml-new" style="background:#90EE90">, so writing a newline (for example) as </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#xA;</span></code><span class="deltaxml-new" style="background:#90EE90"> does not prevent its being normalized to a space character.</span></span></span></p><p><span class="deltaxml-new" style="background:#90EE90">A Braced URI Literal or URI Literal is not subjected to percent-encoding or decoding as defined in </span><a href="#RFC3986"><span class="deltaxml-new" style="background:#90EE90">[RFC3986]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div3"><h4><a id="id-resolve-relative-uri"></a><span class="deltaxml-new" style="background:#90EE90">2.5.6 Resolving a Relative URI Reference</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-resolve-relative-uri" title="resolve"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: To </span><b><span class="deltaxml-new" style="background:#90EE90">resolve a relative URI</span></b><code><span class="deltaxml-new" style="background:#90EE90">$rel</span></code><span class="deltaxml-new" style="background:#90EE90"> against a base URI </span><code><span class="deltaxml-new" style="background:#90EE90">$base</span></code><span class="deltaxml-new" style="background:#90EE90"> is to expand it to an absolute URI, as if by calling the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:resolve-uri($rel, $base)</span></code><span class="deltaxml-new" style="background:#90EE90">.] During static analysis, the base URI is the Static Base URI. During dynamic evaluation, the base URI used to resolve a relative URI reference depends on the semantics of the expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Any process that attempts to </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolve a URI</span></a><span class="deltaxml-new" style="background:#90EE90"> against a base URI, or to dereference the URI, may apply percent-encoding or decoding as defined in the relevant RFCs.</span></p></div></div></div><div class="div1"><h2><a id="id-types"></a><span class="deltaxml-new" style="background:#90EE90">3 Types</span></h2><p><span class="deltaxml-new" style="background:#90EE90">As noted in </span><a href="#id-values"><b><span class="deltaxml-new" style="background:#90EE90">2.1.1 Values</span></b></a><span class="deltaxml-new" style="background:#90EE90">, every value in XQuery 4.0 and XPath 4.0 is regarded as a </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-new" style="background:#90EE90">sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> of zero, one, or more </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">. The type system of XQuery 4.0 and XPath 4.0, described in this section, classifies the kinds of value that the language can handle, and the operations permitted on different kinds of value.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The type system of XQuery 4.0 and XPath 4.0 is related to the type system of </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> in two ways:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">atomic items in XQuery 4.0 and XPath 4.0 (which are one kind of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">item</span></a><span class="deltaxml-new" style="background:#90EE90">) have </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic types</span></a><span class="deltaxml-new" style="background:#90EE90"> such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. These types are taken directly from their definitions in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Nodes (which are another kind of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">item</span></a><span class="deltaxml-new" style="background:#90EE90">) have a property called a </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> which determines the type of their content. The type annotation is a </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><span class="deltaxml-new" style="background:#90EE90">. The type annotation of a node must not be confused with the item type of the node. For example, an element </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;age&gt;23&lt;/age&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> might have been validated against a schema that defines this element as having </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> content. If this is the case, the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the node will be </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, and in the XQuery 4.0 and XPath 4.0 type system, the node will match the </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><code><span class="deltaxml-new" style="background:#90EE90">element(age, xs:integer)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">This chapter of the specification starts by defining </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item types</span></a><span class="deltaxml-new" style="background:#90EE90">, which describe the range of </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-new" style="background:#90EE90">values</span></a><span class="deltaxml-new" style="background:#90EE90"> that can be bound to variables, used in expressions, or passed to functions. It then describes how these relate to </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema types</span></a><span class="deltaxml-new" style="background:#90EE90">, that is, the simple and complex types defined in an XSD schema.</span></p><div class="div2"><h3><a id="id-sequencetype-syntax"></a><span class="deltaxml-new" style="background:#90EE90">3.1 Sequence Types</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-sequence-type" title="sequence type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">sequence type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a type that can be expressed using the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax. Sequence types are used whenever it is necessary to refer to a type in an XQuery 4.0 and XPath 4.0 expression. The term </span><b><span class="deltaxml-new" style="background:#90EE90">sequence type</span></b><span class="deltaxml-new" style="background:#90EE90"> suggests that this syntax is used to describe the type of an XQuery 4.0 and XPath 4.0 value, which is always a sequence.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-item-type" title="item type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a type that can be expressed using the </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax, which forms part of the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax. Item types match individual </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">.] In most cases, the set of items matched by an item type consists either exclusively of </span><a title="atomic item" class="termref" href="#dt-atomic-item"><span class="deltaxml-new" style="background:#90EE90">atomic items</span></a><span class="deltaxml-new" style="background:#90EE90">, exclusively of </span><a title="node" class="termref" href="#dt-node"><span class="deltaxml-new" style="background:#90EE90">nodes</span></a><span class="deltaxml-new" style="background:#90EE90">, or exclusively of </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function items</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. Exceptions include the generic types </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90">, which matches all items, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90">, which matches no items, and </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item types</span></a><span class="deltaxml-new" style="background:#90EE90">, which can match any combination of types. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Whenever it is necessary to refer to a type in an XQuery 4.0 and XPath 4.0 expression, the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax is used.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SequenceType" id="doc-xpath40-SequenceType"></a><span class="deltaxml-new" style="background:#90EE90">[229]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("empty-sequence" "(" ")")</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90">?)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ItemType" id="doc-xpath40-ItemType"></a><span class="deltaxml-new" style="background:#90EE90">[231]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyItemTest"><span class="deltaxml-new" style="background:#90EE90">AnyItemTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ArrayTest"><span class="deltaxml-new" style="background:#90EE90">ArrayTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OccurrenceIndicator" id="doc-xpath40-OccurrenceIndicator"></a><span class="deltaxml-new" style="background:#90EE90">[230]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"?" | "*" | "+"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-occurrence-indicators"><span class="deltaxml-new" style="background:#90EE90">xgc: occurrence-indicators</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">In many situations the terms </span><b><span class="deltaxml-new" style="background:#90EE90">item type</span></b><span class="deltaxml-new" style="background:#90EE90"> and </span><b><span class="deltaxml-new" style="background:#90EE90">sequence type</span></b><span class="deltaxml-new" style="background:#90EE90"> are used interchangeably to refer either to the type itself, or to the syntactic construct that designates the type: so in the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$x instance of xs:string*</span></code><span class="deltaxml-new" style="background:#90EE90">, the construct </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string*</span></code><span class="deltaxml-new" style="background:#90EE90"> uses the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax to designate a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90"> whose instances are sequences of strings. When more precision is required, the specification is careful to use the terms </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90"> to refer to the actual types, while using the production names </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> to refer to the syntactic designators of these types.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-sequence-type-designator" title="sequence type designator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">sequence type designator</span></b><span class="deltaxml-new" style="background:#90EE90"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">. A sequence type designator is said to </span><b><span class="deltaxml-new" style="background:#90EE90">designate</span></b><span class="deltaxml-new" style="background:#90EE90"> a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-item-type-designator" title="item type designator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">item type designator</span></b><span class="deltaxml-new" style="background:#90EE90"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">. An item type designator is said to </span><b><span class="deltaxml-new" style="background:#90EE90">designate</span></b><span class="deltaxml-new" style="background:#90EE90"> an </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Two </span><a title="item type designator" class="termref" href="#dt-item-type-designator"><span class="deltaxml-new" style="background:#90EE90">item type designators</span></a><span class="deltaxml-new" style="background:#90EE90"> may designate the same item type. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">element()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">element(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> are equivalent, as are </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(A)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(A, xs:anySimpleType)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">With the exception of the special type </span><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence()</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90"> consists of an </span><b><span class="deltaxml-new" style="background:#90EE90">item type</span></b><span class="deltaxml-new" style="background:#90EE90"> that constrains the type of each item in the sequence, and a </span><b><span class="deltaxml-new" style="background:#90EE90">cardinality</span></b><span class="deltaxml-new" style="background:#90EE90"> that constrains the number of items in the sequence. Apart from the item type </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90">, which permits any kind of item, item types divide into </span><b><span class="deltaxml-new" style="background:#90EE90">node types</span></b><span class="deltaxml-new" style="background:#90EE90"> (such as </span><code><span class="deltaxml-new" style="background:#90EE90">element()</span></code><span class="deltaxml-new" style="background:#90EE90">), </span><b><span class="deltaxml-new" style="background:#90EE90">generalized atomic types</span></b><span class="deltaxml-new" style="background:#90EE90"> (such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">) and function types (such as </span><code><span class="deltaxml-new" style="background:#90EE90">function() as item()*</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">Lexical QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> appearing in a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90"> have their prefixes expanded to namespace URIs by means of the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> and (where applicable) the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">. Equality of QNames is defined by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Item types representing element and attribute nodes may specify the required </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotations</span></a><span class="deltaxml-new" style="background:#90EE90"> of those nodes in the form of a </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><span class="deltaxml-new" style="background:#90EE90">. Thus the item type </span><code><span class="deltaxml-new" style="background:#90EE90">element(*, us:address)</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes any element node whose type annotation is (or is derived from) the schema type named </span><code><span class="deltaxml-new" style="background:#90EE90">us:address</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The occurrence indicators </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> bind to the last </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in the </span><a href="#parse-note-occurrence-indicators"><span class="deltaxml-new" style="background:#90EE90">occurrence-indicators</span></a><span class="deltaxml-new" style="background:#90EE90"> constraint.</span></p><div class="div3"><h4><a id="id-sequence-type-examples"></a><span class="deltaxml-new" style="background:#90EE90">3.1.1 Examples of Sequence Types</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90"> that might be used in XQuery 4.0 and XPath 4.0:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to the built-in atomic schema type named </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute()?</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to an optional attribute node</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element()</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to any element node</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(po:shipto, po:address)</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to an element node that has the name </span><code><span class="deltaxml-new" style="background:#90EE90">po:shipto</span></code><span class="deltaxml-new" style="background:#90EE90"> and has the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">po:address</span></code><span class="deltaxml-new" style="background:#90EE90"> (or a schema type derived from </span><code><span class="deltaxml-new" style="background:#90EE90">po:address</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(*, po:address)</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to an element node of any name that has the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">po:address</span></code><span class="deltaxml-new" style="background:#90EE90"> (or a type derived from </span><code><span class="deltaxml-new" style="background:#90EE90">po:address</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(customer)</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to an element node named </span><code><span class="deltaxml-new" style="background:#90EE90">customer</span></code><span class="deltaxml-new" style="background:#90EE90"> with any type annotation</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">schema-element(customer)</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to an element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">customer</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is in the substitution group headed by </span><code><span class="deltaxml-new" style="background:#90EE90">customer</span></code><span class="deltaxml-new" style="background:#90EE90">) and whose type annotation matches the schema type declared for a </span><code><span class="deltaxml-new" style="background:#90EE90">customer</span></code><span class="deltaxml-new" style="background:#90EE90"> element in the </span><a title="in-scope element declarations" class="termref" href="#dt-is-elems"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">node()*</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to a sequence of zero or more nodes of any kind</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">item()+</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to a sequence of one or more </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to any </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, regardless of arity or type</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(node()) as xs:string*</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> that takes a single argument whose value is a single node, and returns a sequence of zero or more </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> values</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">(fn(node()) as xs:string)*</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to a sequence of zero or more </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function items</span></a><span class="deltaxml-new" style="background:#90EE90">, each of which takes a single argument whose value is a single node, and returns as its result a single </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> value</span></p></li></ul></div><div class="div3"><h4><a id="id-sequencetype-matching"></a><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-sequencetype-matching" title="SequenceType matching"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></b><span class="deltaxml-new" style="background:#90EE90"> compares a value with an expected </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">. ] For example, an </span><code><span class="deltaxml-new" style="background:#90EE90">instance of</span></code><span class="deltaxml-new" style="background:#90EE90"> expression returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if a given value matches a given </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> if it does not.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An XQuery 4.0 and XPath 4.0 implementation must be able to determine relationships among the types in type annotations in an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> and the types in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> (ISSD). </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">An XQuery 4.0 and XPath 4.0 implementation must be able to determine relationships among the types in ISSDs used in different modules of the same query.</span></span></span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-subtype-substitution" title="subtype substitution"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The use of a value that has a </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> that is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of the expected type is known as </span><b><span class="deltaxml-new" style="background:#90EE90">subtype substitution</span></b><span class="deltaxml-new" style="background:#90EE90">.] Subtype substitution does not change the actual type of a value. For example, if an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value is used where an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> value is expected, the value retains its type as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The definition of </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a><span class="deltaxml-new" style="background:#90EE90"> relies on a pseudo-function named </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span></code><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90">, </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90">, which takes an actual simple or complex schema type </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> and an expected simple or complex schema type </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90">, and either returns a boolean value or raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">]. This function is defined as follows:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span></code><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90">, </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] if </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90"> is not present in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> (ISSD). </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span></code><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90">, </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if any of the following conditions applies: </span></p><ul><li><p><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> is </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90"> is the base type of </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90"> is a pure union type of which </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> is a member type</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">There is a type </span><em><span class="deltaxml-new" style="background:#90EE90">MT</span></em><span class="deltaxml-new" style="background:#90EE90"> such that </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span></code><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90">, </span><em><span class="deltaxml-new" style="background:#90EE90">MT</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span></code><em><span class="deltaxml-new" style="background:#90EE90">MT</span></em><span class="deltaxml-new" style="background:#90EE90">, </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span></code><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90">, </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The rules for </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a><span class="deltaxml-new" style="background:#90EE90"> are given below, with examples (the examples are for purposes of illustration, and do not cover all possible cases).</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a value that is the empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> with no </span><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90"> matches any value that contains exactly one item if the </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> matches that item (see </span><a href="#id-matching-item"><b><span class="deltaxml-new" style="background:#90EE90">3.2 Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> with an </span><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90"> matches a value if the number of items in the value matches the </span><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90"> and the </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> matches each of the items in the value.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">An </span><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90"> specifies the number of items in a sequence, as follows:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> matches zero or one items</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> matches zero or more items</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> matches one or more items</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">As a consequence of these rules, any </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90"> whose </span><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a value that is an empty sequence.</span></p></div></div><div class="div2"><h3><a id="id-matching-item"></a><span class="deltaxml-new" style="background:#90EE90">3.2 Item Types</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5858.doc-xpath40-ItemType" id="noid_d4e5858.doc-xpath40-ItemType"></a><span class="deltaxml-new" style="background:#90EE90">[231]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyItemTest"><span class="deltaxml-new" style="background:#90EE90">AnyItemTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ArrayTest"><span class="deltaxml-new" style="background:#90EE90">ArrayTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnyItemTest" id="doc-xpath40-AnyItemTest"></a><span class="deltaxml-new" style="background:#90EE90">[232]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyItemTest"><span class="deltaxml-new" style="background:#90EE90">AnyItemTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"item" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypeName" id="doc-xpath40-TypeName"></a><span class="deltaxml-new" style="background:#90EE90">[247]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-KindTest" id="doc-xpath40-KindTest"></a><span class="deltaxml-new" style="background:#90EE90">[233]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DocumentTest"><span class="deltaxml-new" style="background:#90EE90">DocumentTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-PITest"><span class="deltaxml-new" style="background:#90EE90">PITest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CommentTest"><span class="deltaxml-new" style="background:#90EE90">CommentTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-TextTest"><span class="deltaxml-new" style="background:#90EE90">TextTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-NamespaceNodeTest"><span class="deltaxml-new" style="background:#90EE90">NamespaceNodeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-AnyKindTest"><span class="deltaxml-new" style="background:#90EE90">AnyKindTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DocumentTest" id="doc-xpath40-DocumentTest"></a><span class="deltaxml-new" style="background:#90EE90">[235]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DocumentTest"><span class="deltaxml-new" style="background:#90EE90">DocumentTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"document-node" "(" (</span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5863.doc-xpath40-ElementTest" id="noid_d4e5863.doc-xpath40-ElementTest"></a><span class="deltaxml-new" style="background:#90EE90">[242]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"element" "(" (</span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"?)?)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5864.doc-xpath40-SchemaElementTest" id="noid_d4e5864.doc-xpath40-SchemaElementTest"></a><span class="deltaxml-new" style="background:#90EE90">[243]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"schema-element" "(" </span><a href="#doc-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5865.doc-xpath40-AttributeTest" id="noid_d4e5865.doc-xpath40-AttributeTest"></a><span class="deltaxml-new" style="background:#90EE90">[240]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"attribute" "(" (</span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">)?)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5866.doc-xpath40-SchemaAttributeTest" id="noid_d4e5866.doc-xpath40-SchemaAttributeTest"></a><span class="deltaxml-new" style="background:#90EE90">[241]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"schema-attribute" "(" </span><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ElementName" id="doc-xpath40-ElementName"></a><span class="deltaxml-new" style="background:#90EE90">[245]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AttributeName" id="doc-xpath40-AttributeName"></a><span class="deltaxml-new" style="background:#90EE90">[244]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PITest" id="doc-xpath40-PITest"></a><span class="deltaxml-new" style="background:#90EE90">[239]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PITest"><span class="deltaxml-new" style="background:#90EE90">PITest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"processing-instruction" "(" (</span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CommentTest" id="doc-xpath40-CommentTest"></a><span class="deltaxml-new" style="background:#90EE90">[237]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CommentTest"><span class="deltaxml-new" style="background:#90EE90">CommentTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"comment" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NamespaceNodeTest" id="doc-xpath40-NamespaceNodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[238]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NamespaceNodeTest"><span class="deltaxml-new" style="background:#90EE90">NamespaceNodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"namespace-node" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TextTest" id="doc-xpath40-TextTest"></a><span class="deltaxml-new" style="background:#90EE90">[236]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TextTest"><span class="deltaxml-new" style="background:#90EE90">TextTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"text" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnyKindTest" id="doc-xpath40-AnyKindTest"></a><span class="deltaxml-new" style="background:#90EE90">[234]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyKindTest"><span class="deltaxml-new" style="background:#90EE90">AnyKindTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"node" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5875.doc-xpath40-FunctionTest" id="noid_d4e5875.doc-xpath40-FunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[248]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#doc-xpath40-AnyFunctionTest"><span class="deltaxml-new" style="background:#90EE90">AnyFunctionTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5876.doc-xpath40-AnyFunctionTest" id="noid_d4e5876.doc-xpath40-AnyFunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[249]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyFunctionTest"><span class="deltaxml-new" style="background:#90EE90">AnyFunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("function" | "fn") "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5877.doc-xpath40-TypedFunctionTest" id="noid_d4e5877.doc-xpath40-TypedFunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[250]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("function" | "fn") "(" (</span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)*)? ")" "as" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ChoiceItemType" id="doc-xpath40-ChoiceItemType"></a><span class="deltaxml-new" style="background:#90EE90">[264]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5879.doc-xpath40-MapTest" id="noid_d4e5879.doc-xpath40-MapTest"></a><span class="deltaxml-new" style="background:#90EE90">[251]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyMapTest"><span class="deltaxml-new" style="background:#90EE90">AnyMapTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypedMapTest"><span class="deltaxml-new" style="background:#90EE90">TypedMapTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5881.doc-xpath40-RecordTest" id="noid_d4e5881.doc-xpath40-RecordTest"></a><span class="deltaxml-new" style="background:#90EE90">[254]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyRecordTest"><span class="deltaxml-new" style="background:#90EE90">AnyRecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypedRecordTest"><span class="deltaxml-new" style="background:#90EE90">TypedRecordTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5882.doc-xpath40-ArrayTest" id="noid_d4e5882.doc-xpath40-ArrayTest"></a><span class="deltaxml-new" style="background:#90EE90">[261]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrayTest"><span class="deltaxml-new" style="background:#90EE90">ArrayTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyArrayTest"><span class="deltaxml-new" style="background:#90EE90">AnyArrayTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypedArrayTest"><span class="deltaxml-new" style="background:#90EE90">TypedArrayTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e5884.doc-xpath40-EnumerationType" id="noid_d4e5884.doc-xpath40-EnumerationType"></a><span class="deltaxml-new" style="background:#90EE90">[260]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"enum" "(" </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">This section defines the syntax and semantics of different </span><code><span class="deltaxml-new" style="background:#90EE90">ItemTypes</span></code><span class="deltaxml-new" style="background:#90EE90"> in terms of the values that they match.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><a title="item type designator" class="termref" href="#dt-item-type-designator"><span class="deltaxml-new" style="background:#90EE90">item type designator</span></a><span class="deltaxml-new" style="background:#90EE90"> written simply as an </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> (that is, a </span><code><span class="deltaxml-new" style="background:#90EE90">TypeName</span></code><span class="deltaxml-new" style="background:#90EE90">) is interpreted as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the name is written as a lexical QName, then it is expanded using the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">. If the name is an unprefixed </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, then it is expanded according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the name matches a </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, then it is taken as a reference to the corresponding item type. The rules that apply are the rules for the expanded item type definition.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, it must match the name of a type in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">: specifically, an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a><span class="deltaxml-new" style="background:#90EE90">. See </span><a href="#id-predefined-types"><b><span class="deltaxml-new" style="background:#90EE90">3.5 Schema Types</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for details. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A name in the </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace will always fall into this category, since the namespace is reserved. See </span><a href="#id-namespaces-and-qnames"><b><span class="deltaxml-new" style="background:#90EE90">2.1.2 Namespaces and QNames</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the name cannot be resolved to a type, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPST0051" title="err:XPST0051"><span class="deltaxml-new" style="background:#90EE90">err:XPST0051</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><div class="div3"><h4><a id="general-item-types"></a><span class="deltaxml-new" style="background:#90EE90">3.2.1 General item types</span></h4><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any single </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">item</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches the atomic item </span><code><span class="deltaxml-new" style="background:#90EE90">1</span></code><span class="deltaxml-new" style="background:#90EE90">, the element </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;a/&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, or the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#3</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> lists a number of alternative item types in parentheses, separated by </span><code><span class="deltaxml-new" style="background:#90EE90">"|"</span></code><span class="deltaxml-new" style="background:#90EE90">. An item matches a </span><code><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></code><span class="deltaxml-new" style="background:#90EE90"> it if matches any of the alternatives.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, </span><code><span class="deltaxml-new" style="background:#90EE90">(map(*) | array(*))</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any item that is a map or an array.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If there is only one alternative, the </span><code><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></code><span class="deltaxml-new" style="background:#90EE90"> designates the same </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><span class="deltaxml-new" style="background:#90EE90"> as the </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> that is in parentheses. A singleton choice (that is, a parenthesized item type) is used primarily when defining nested item types in a function signature. For example, a sequence of functions that each return a single boolean might be denoted </span><code><span class="deltaxml-new" style="background:#90EE90">(fn() as xs:boolean)*</span></code><span class="deltaxml-new" style="background:#90EE90">. In this example the parentheses are needed to indicate where the occurrence indicator belongs.</span></p></div></li></ul></div><div class="div3"><h4><a id="id-atomic-types"></a><span class="deltaxml-new" style="background:#90EE90">3.2.2 Atomic Types</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Atomic types in the XQuery 4.0 and XPath 4.0 type system correspond directly to atomic types as defined in the </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> type system.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Atomic types are either built-in atomic types such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, or user-defined atomic types imported from a schema. Atomic types are identified by a QName: see </span><a href="#id-namespaces-and-qnames"><b><span class="deltaxml-new" style="background:#90EE90">2.1.2 Namespaces and QNames</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A schema may also include anonymous atomic types. Such types are not usable directly in XQuery 4.0 and XPath 4.0, though they may appear as the values of </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotations</span></a><span class="deltaxml-new" style="background:#90EE90"> on nodes.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-generalized-atomic-type" title="generalized atomic type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></b><span class="deltaxml-new" style="background:#90EE90"> is an item type whose instances are all atomic items. Generalized atomic types include (a) </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic types</span></a><span class="deltaxml-new" style="background:#90EE90">, either built-in (for example </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">) or imported from a schema, (b) </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union types</span></a><span class="deltaxml-new" style="background:#90EE90">, either built-in (</span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90">) or imported from a schema, (c) </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item types</span></a><span class="deltaxml-new" style="background:#90EE90"> if their alternatives are all generalized atomic types, and (d) </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration types</span></a><span class="deltaxml-new" style="background:#90EE90">. ].</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> may be designated by an </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> in any of the following ways:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Using the QName of a type in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> that is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Using a QName that identifies a </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><span class="deltaxml-new" style="background:#90EE90"> that resolves to a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Using a </span><a href="#doc-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> where every alternative is itself a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Using an </span><a href="#doc-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a><span class="deltaxml-new" style="background:#90EE90"> as described below.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">An atomic item </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> matches the </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><var><span class="deltaxml-new" style="background:#90EE90">GAT</span></var><span class="deltaxml-new" style="background:#90EE90"> if the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> (call it </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">) satisfies the condition </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from(T, GAT)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: The </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">. It also matches any value of type </span><code><span class="deltaxml-new" style="background:#90EE90">shoesize</span></code><span class="deltaxml-new" style="background:#90EE90">, if </span><code><span class="deltaxml-new" style="background:#90EE90">shoesize</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: Suppose </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><code><span class="deltaxml-new" style="background:#90EE90">dress-size</span></code><span class="deltaxml-new" style="background:#90EE90"> is a union type that allows either </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> values for numeric sizes (for example: 4, 6, 10, 12), or one of an enumerated set of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:strings</span></code><span class="deltaxml-new" style="background:#90EE90"> (for example: </span><code><span class="deltaxml-new" style="background:#90EE90">small</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">medium</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">large</span></code><span class="deltaxml-new" style="background:#90EE90">). The </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><code><span class="deltaxml-new" style="background:#90EE90">dress-size</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any of these values.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The names of </span><span><span class="deltaxml-new" style="background:#90EE90">list</span></span><span class="deltaxml-new" style="background:#90EE90"> types such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:IDREFS</span></code><span class="deltaxml-new" style="background:#90EE90"> are not accepted in this context, but can often be replaced by a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> with an occurrence indicator, such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:IDREF+</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="id-union-types"></a><span class="deltaxml-new" style="background:#90EE90">3.2.3 Union Types</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Union types, as defined in XSD, are a variety of simple types. The membership of a union type in XSD may include list types as well as atomic types and other union types.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-pure-union-type" title="pure union type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">pure union type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><span><b><span class="deltaxml-new" style="background:#90EE90">simple type</span></b></span><span class="deltaxml-new" style="background:#90EE90"> that satisfies the following constraints: (a) </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90">, (b) the </span><code><span class="deltaxml-new" style="background:#90EE90">{facets}</span></code><span class="deltaxml-new" style="background:#90EE90"> property is empty, (c) no type in the transitive membership of the union type has </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><code><span class="deltaxml-new" style="background:#90EE90">list</span></code><span class="deltaxml-new" style="background:#90EE90">, and (d) no type in the transitive membership of the union type is a type with </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90"> having a non-empty </span><code><span class="deltaxml-new" style="background:#90EE90">{facets}</span></code><span class="deltaxml-new" style="background:#90EE90"> property].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The definition of </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a><span class="deltaxml-new" style="background:#90EE90"> excludes union types derived by non-trivial restriction from other union types, as well as union types that include list types in their membership. Pure union types have the property that every instance of an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> defined as one of the member types of the union is also a valid instance of the union type.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The current (second) edition of XML Schema 1.0 contains an error in respect of the substitutability of a union type by one of its members: it fails to recognize that this is unsafe if the union is derived by restriction from another union.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This problem is fixed in XSD 1.1, but the effect of the resolution is that an atomic item labeled with an atomic type cannot be treated as being substitutable for a union type without explicit validation. This specification therefore allows union types to be used as item types only if they are defined directly as the union of a number of atomic types.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Local union types (see </span><a href="#id-choice-item-types"><b><span class="deltaxml-new" style="background:#90EE90">3.2.5 Choice Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">) and </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration types</span></a><span class="deltaxml-new" style="background:#90EE90"> cannot be used as the target for schema validation.</span></p></div></div><div class="div3"><h4><a id="id-namespace-sensitive"></a><span class="deltaxml-new" style="background:#90EE90">3.2.4 Namespace-sensitive Types</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-namespace-sensitive" title="namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></b><span class="deltaxml-new" style="background:#90EE90"> types are </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90">, types derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90">, list types that have a namespace-sensitive item type, and union types with a namespace-sensitive type in their transitive membership.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">It is not possible to preserve the type of a </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90"> value without also preserving the namespace binding that defines the meaning of each namespace prefix used in the value. Therefore, XQuery 4.0 and XPath 4.0 defines some error conditions that occur only with </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90"> values. For instance, casting to a </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90"> type raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFONS0004" title="err:FONS0004"><span class="deltaxml-new" style="background:#90EE90">err:FONS0004</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> if the namespace bindings for the result cannot be determined. </span></p></div><div class="div3"><h4><a id="id-choice-item-types"></a><span class="deltaxml-new" style="background:#90EE90">3.2.5 Choice Item Types</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-enumeration-types"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-implausible-expressions"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Choice item types (an item type allowing a set of alternative item types) are introduced. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/122"><span class="deltaxml-new" style="background:#90EE90">122</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1132"><span class="deltaxml-new" style="background:#90EE90">1132</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;9 April 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-choice-item-type" title="choice item type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">choice item type</span></b><span class="deltaxml-new" style="background:#90EE90"> defines an item type that is the union of a number of alternatives. For example the type </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:hexBinary | xs:base64Binary)</span></code><span class="deltaxml-new" style="background:#90EE90"> defines the union of these two primitive </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic types</span></a><span class="deltaxml-new" style="background:#90EE90">, while the type </span><code><span class="deltaxml-new" style="background:#90EE90">(map(*) | array(*))</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any item that is either a map or an array.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">An item matches a </span><code><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></code><span class="deltaxml-new" style="background:#90EE90"> if it matches any of the alternatives listed within the parentheses.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the type </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:NCName | enum(""))</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any value that is either an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, or a zero-length string. This might be a suitable type for a variable that holds a namespace prefix.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If all the alternatives are </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic types</span></a><span class="deltaxml-new" style="background:#90EE90"> then the </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item type</span></a><span class="deltaxml-new" style="background:#90EE90"> is itself a generalized atomic type, which means, for example, that it can be used as the target of a cast expression.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item type</span></a><span class="deltaxml-new" style="background:#90EE90"> in which all the alternatives are atomic behaves in most respects like a schema-defined </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a><span class="deltaxml-new" style="background:#90EE90">. However, because it can be defined at the point of use (for example, within a function signature), it may be more convenient than defining the type in an imported schema.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Choice item types are particularly useful in function signatures, allowing a function to take arguments of a variety of types. If the choice item type is a local union type, then the semantics are identical to using a named union type, but a local union type is more convenient because it does not need to be defined in a schema, and does not require a schema-aware processor.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A local union type can also be used in a cast expression: </span><code><span class="deltaxml-new" style="background:#90EE90">cast @when as (xs:date | xs:dateTime)</span></code><span class="deltaxml-new" style="background:#90EE90"> allows the attribute </span><code><span class="deltaxml-new" style="background:#90EE90">@when</span></code><span class="deltaxml-new" style="background:#90EE90"> to be either an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">, or an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><code><span class="deltaxml-new" style="background:#90EE90">instance of</span></code><span class="deltaxml-new" style="background:#90EE90"> expression can be used to test whether a value belongs to one of a number of specified types: </span><code><span class="deltaxml-new" style="background:#90EE90">$x instance of (xs:string | xs:anyURI | xs:untypedAtomic)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> is an instance of any of these three atomic types, while </span><code><span class="deltaxml-new" style="background:#90EE90">$x instance of (map(*) | array(*))</span></code><span class="deltaxml-new" style="background:#90EE90"> tests whether </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> is a map or array.</span></p></div></div><div class="div3"><h4><a id="id-enumeration-types"></a><span class="deltaxml-new" style="background:#90EE90">3.2.6 Enumeration Types</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#node-types"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-choice-item-types"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">Enumeration types are added as a new kind of </span><code><span class="deltaxml-new" style="background:#90EE90">ItemType</span></code><span class="deltaxml-new" style="background:#90EE90">, constraining the value space of strings.</span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-enumeration-type" title="enumeration type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></b><span class="deltaxml-new" style="background:#90EE90"> accepts a fixed set of string values.] </span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EnumerationType" id="doc-xpath40-EnumerationType"></a><span class="deltaxml-new" style="background:#90EE90">[260]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"enum" "(" </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">An </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration type</span></a><span class="deltaxml-new" style="background:#90EE90"> has a value space consisting of a set of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> values. When matching strings against an enumeration type, strings are always compared using the Unicode codepoint collation.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, if an argument of a function declares the required type as </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90">, then the string </span><code><span class="deltaxml-new" style="background:#90EE90">"green"</span></code><span class="deltaxml-new" style="background:#90EE90"> is accepted, while </span><code><span class="deltaxml-new" style="background:#90EE90">"yellow"</span></code><span class="deltaxml-new" style="background:#90EE90"> is rejected with a type error.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Technically, enumeration types are defined as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">An enumeration type with a single enumerated value (such as </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red")</span></code><span class="deltaxml-new" style="background:#90EE90">) is an anonymous </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> by restriction using an enumeration facet that permits only the value </span><code><span class="deltaxml-new" style="background:#90EE90">"red"</span></code><span class="deltaxml-new" style="background:#90EE90">. This is referred to as a </span><b><span class="deltaxml-new" style="background:#90EE90">singleton enumeration type</span></b><span class="deltaxml-new" style="background:#90EE90">. It is equivalent to the XSD-defined type:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;xs:simpleType&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:enumeration value="red"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Two singleton enumeration types are the same type if and only if they have the same (single) enumerated value, as determined using the Unicode codepoint collation.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An enumeration type with multiple enumerated values is a union of singleton enumeration types, so </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">(enum("red") | enum("green") | enum("blue"))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In consequence, an enumeration type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a subtype of an enumeration type </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90"> if the enumerated values of </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> are a subset of the enumerated values of </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">: see </span><a href="#id-itemtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2 Subtypes of Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">An enumeration type is thus a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It follows from these rules that an atomic item will only satisfy an </span><code><span class="deltaxml-new" style="background:#90EE90">instance of</span></code><span class="deltaxml-new" style="background:#90EE90"> test if it has the correct type annotation, and this can only be achieved using an explicit cast or constructor function. So the expression </span><code><span class="deltaxml-new" style="background:#90EE90">"red" instance of enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. However, the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> ensure that where a variable or function declaration specifies an enumeration type as the required type, a string (or indeed an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> value) equal to one of the enumerated values will be accepted.</span></p></div><div class="div3"><h4><a id="node-types"></a><span class="deltaxml-new" style="background:#90EE90">3.2.7 Node Types</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-element-test"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-enumeration-types"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Element and attribute tests can include alternative names: </span><code><span class="deltaxml-new" style="background:#90EE90">element(chapter|section)</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(role|class)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></code><span class="deltaxml-new" style="background:#90EE90"> in an </span><code><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></code><span class="deltaxml-new" style="background:#90EE90"> now allows alternatives: </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor::(section|appendix)</span></code></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">Some of the constructs described in this section include a </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">. This appears as </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> in:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(N, T)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(N, T)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">document-node(element(N, T))</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In these constructs, the type name </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is expanded using the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, using the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> if it is unprefixed. The resulting QName must identify a type in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">. This can be any </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><span class="deltaxml-new" style="background:#90EE90">: either a simple type, or (except in the case of attributes) a complex type. If it is a simple type then it can be an atomic, union, or list type. It can be a built-in type (such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">) or a user-defined type. It must however be the name of a type defined in a schema; it cannot be a </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div4"><h5><a id="id-simple-node-tests"></a><span class="deltaxml-new" style="background:#90EE90">3.2.7.1 Simple Node Tests</span></h5><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">node()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">text()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any text node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any processing-instruction node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction(</span></code><em><span class="deltaxml-new" style="background:#90EE90">N</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any processing-instruction node whose PITarget is equal to </span><code><span class="deltaxml-new" style="background:#90EE90">fn:normalize-space(N)</span></code><span class="deltaxml-new" style="background:#90EE90">. If the result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:normalize-space(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> is not in the lexical space of NCName, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction(xml-stylesheet)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any processing instruction whose PITarget is </span><code><span class="deltaxml-new" style="background:#90EE90">xml-stylesheet</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For backward compatibility with XPath 1.0, the PITarget of a processing instruction may also be expressed as a string literal, as in this example: </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction("xml-stylesheet")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the specified PITarget is not a syntactically valid NCName, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">comment()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any comment node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">namespace-node()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any namespace node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">document-node()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any document node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">document-node(</span></code><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any document node that contains exactly one element node, optionally accompanied by one or more comment and processing instruction nodes, if </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90"> is an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> that matches the element node (see </span><a href="#id-element-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7.2 Element Test</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-schema-element-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7.3 Schema Element Test</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example: </span><code><span class="deltaxml-new" style="background:#90EE90">document-node(element(book))</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a document node containing exactly one element node that is matched by the ElementTest </span><code><span class="deltaxml-new" style="background:#90EE90">element(book)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> that is an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90">, or </span><a href="#doc-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches an item as described in the following sections. </span></p></li></ul></div><div class="div4"><h5><a id="id-element-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.7.2 Element Test</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-attribute-test"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#node-types"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Element and attribute tests of the form </span><code><span class="deltaxml-new" style="background:#90EE90">element(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> now allow </span><code><span class="deltaxml-new" style="background:#90EE90">N</span></code><span class="deltaxml-new" style="background:#90EE90"> to be any </span><code><span class="deltaxml-new" style="background:#90EE90">NameTest</span></code><span class="deltaxml-new" style="background:#90EE90">, including a wildcard. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Setting the default namespace for elements and types to the special value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90"> causes an unprefixed element name to act as a wildcard, matching by local name regardless of namespace. </span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ElementTest" id="doc-xpath40-ElementTest"></a><span class="deltaxml-new" style="background:#90EE90">[242]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"element" "(" (</span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"?)?)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NameTestUnion" id="doc-xpath40-NameTestUnion"></a><span class="deltaxml-new" style="background:#90EE90">[106]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e6695.doc-xpath40-NameTest" id="noid_d4e6695.doc-xpath40-NameTest"></a><span class="deltaxml-new" style="background:#90EE90">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e6696.doc-xpath40-Wildcard" id="noid_d4e6696.doc-xpath40-Wildcard"></a><span class="deltaxml-new" style="background:#90EE90">[151]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"*"</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> ":*")</span><br><span class="deltaxml-new" style="background:#90EE90">| ("*:" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90">)</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> "*")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e6697.doc-xpath40-TypeName" id="noid_d4e6697.doc-xpath40-TypeName"></a><span class="deltaxml-new" style="background:#90EE90">[247]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> An </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> is used to match an element node by its name and/or </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">An unprefixed </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> within the </span><code><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></code><span class="deltaxml-new" style="background:#90EE90"> is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">. The name need not be present in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> has the special value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, then an unprefixed name </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is interpreted as a wildcard </span><code><span class="deltaxml-new" style="background:#90EE90">*:</span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is always possible to match no-namespace names explicitly by using the form </span><code><span class="deltaxml-new" style="background:#90EE90">Q{}</span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var></code></p><p><span class="deltaxml-new" style="background:#90EE90">An unprefixed </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">. The </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> must be present in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></a><span class="deltaxml-new" style="background:#90EE90">] </span></p><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> has the special value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, then an unprefixed type name </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is interpreted as </span><code><span class="deltaxml-new" style="background:#90EE90">Q{http://www.w3.org/2001/XMLSchema}</span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><a title="substitution group" class="termref" href="#dt-substitution-group"><span class="deltaxml-new" style="background:#90EE90">Substitution groups</span></a><span class="deltaxml-new" style="background:#90EE90"> do not affect the semantics of </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">An </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">ET</span></var><span class="deltaxml-new" style="background:#90EE90"> matches an item </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> if the following conditions are satisfied:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is an element node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">ET</span></var><span class="deltaxml-new" style="background:#90EE90"> includes a </span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90">, then the name of the element node </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> matches one or more of the </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTests</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90">. A name </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> matches a </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> if one of the following conditions is true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">*:</span><em><span class="deltaxml-new" style="background:#90EE90">local</span></em></code><span class="deltaxml-new" style="background:#90EE90"> and the local part of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">local</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><em><span class="deltaxml-new" style="background:#90EE90">prefix</span></em><span class="deltaxml-new" style="background:#90EE90">:*</span></code><span class="deltaxml-new" style="background:#90EE90"> and the namespace URI of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> matches the namespace URI bound to </span><var><span class="deltaxml-new" style="background:#90EE90">prefix</span></var><span class="deltaxml-new" style="background:#90EE90"> in the static context.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><em><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></em><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> and the namespace URI of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> matches the namespace URI found in the </span><code><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> equal to </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">ET</span></var><span class="deltaxml-new" style="background:#90EE90"> includes a </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">, then the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the element node </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is either the schema type identified by that type name, or a type derived from that type by restriction.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> has the </span><code><span class="deltaxml-new" style="background:#90EE90">nilled</span></code><span class="deltaxml-new" style="background:#90EE90"> property, then </span><var><span class="deltaxml-new" style="background:#90EE90">ET</span></var><span class="deltaxml-new" style="background:#90EE90"> either includes no </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">, or includes a </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by the symbol </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTests</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumar"><li><p><code><span class="deltaxml-new" style="background:#90EE90">element()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">element(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> match any single element node, regardless of its name or type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(person)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90">, in the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(doctor|nurse)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">doctor</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">nurse</span></code><span class="deltaxml-new" style="background:#90EE90">, in the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(xhtml:*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is in the namespace bound to the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xhtml</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(xhtml:*|svg:*|mathml|*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is one of the three namespaces identified, specifically the namespaces bound to the prefixes </span><code><span class="deltaxml-new" style="background:#90EE90">xhtml</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">svg</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">mathml</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(Q{http://www.w3.org/2000/svg}*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is in the SVG namespace.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(*:html)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose local name is </span><code><span class="deltaxml-new" style="background:#90EE90">"html"</span></code><span class="deltaxml-new" style="background:#90EE90">, in any namespace.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(person, surgeon)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a non-nilled element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90"> and whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90">). </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(person, surgeon?)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a nilled or non-nilled element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90"> and whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(*, surgeon)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any non-nilled element node whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90">), regardless of its name.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(*, surgeon?)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any nilled or non-nilled element node whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90">), regardless of its name.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90"> Where a </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> is included in an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, and element node will only match the test if it has been validated against a schema that defines type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">; furthermore, </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> must be present in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of the static context of the </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">. Although it is guaranteed that type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> will have </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-new" style="background:#90EE90">compatible</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> definitions in the schema that was used for validation and in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">, it is not guaranteed that revalidation using the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> would succeed. For example, if substitution group membership varies between the two schemas, the element node may contain children or descendants that the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> would not allow. </span></p></div><div class="div4"><h5><a id="id-schema-element-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.7.3 Schema Element Test</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SchemaElementTest" id="doc-xpath40-SchemaElementTest"></a><span class="deltaxml-new" style="background:#90EE90">[243]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"schema-element" "(" </span><a href="#doc-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e7082.doc-xpath40-ElementName" id="noid_d4e7082.doc-xpath40-ElementName"></a><span class="deltaxml-new" style="background:#90EE90">[245]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> A </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches an element node against a corresponding element declaration found in the </span><a title="in-scope element declarations" class="termref" href="#dt-is-elems"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a href="#doc-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a><span class="deltaxml-new" style="background:#90EE90"> of a </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> has its prefixes expanded to a namespace URI by means of the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, or if unprefixed, the is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">. If this has the special value </span><code><span class="deltaxml-new" style="background:#90EE90">"##any"</span></code><span class="deltaxml-new" style="background:#90EE90">, an unprefixed name represents a name in no namespace. If the </span><a href="#doc-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a><span class="deltaxml-new" style="background:#90EE90"> specified in the </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> is not found in the </span><a title="in-scope element declarations" class="termref" href="#dt-is-elems"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> A </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches a candidate element node if all of the following conditions are satisfied: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Either:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">The name </span><em><span class="deltaxml-new" style="background:#90EE90">N</span></em><span class="deltaxml-new" style="background:#90EE90"> of the candidate node matches the specified </span><a href="#doc-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a><span class="deltaxml-new" style="background:#90EE90">, or</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The name </span><em><span class="deltaxml-new" style="background:#90EE90">N</span></em><span class="deltaxml-new" style="background:#90EE90"> of the candidate node matches the name of an element declaration that is a member of the actual substitution group headed by the declaration of element </span><a href="#doc-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The term “actual substitution group” is defined in </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. The actual substitution group of an element declaration </span><em><span class="deltaxml-new" style="background:#90EE90">H</span></em><span class="deltaxml-new" style="background:#90EE90"> includes those element declarations </span><em><span class="deltaxml-new" style="background:#90EE90">P</span></em><span class="deltaxml-new" style="background:#90EE90"> that are declared to have </span><em><span class="deltaxml-new" style="background:#90EE90">H</span></em><span class="deltaxml-new" style="background:#90EE90"> as their direct or indirect substitution group head, provided that </span><em><span class="deltaxml-new" style="background:#90EE90">P</span></em><span class="deltaxml-new" style="background:#90EE90"> is not declared as abstract, and that </span><em><span class="deltaxml-new" style="background:#90EE90">P</span></em><span class="deltaxml-new" style="background:#90EE90"> is validly substitutable for </span><em><span class="deltaxml-new" style="background:#90EE90">H</span></em><span class="deltaxml-new" style="background:#90EE90">, which means that there must be no blocking constraints that prevent substitution.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The schema element declaration named </span><em><span class="deltaxml-new" style="background:#90EE90">N</span></em><span class="deltaxml-new" style="background:#90EE90"> is not abstract.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">derives-from( AT, ET )</span></code><span class="deltaxml-new" style="background:#90EE90"> is true, where </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> is the type annotation of the candidate node and </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90"> is the schema type declared in the schema element declaration named </span><em><span class="deltaxml-new" style="background:#90EE90">N</span></em><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the schema element declaration named </span><em><span class="deltaxml-new" style="background:#90EE90">N</span></em><span class="deltaxml-new" style="background:#90EE90"> is not nillable, then the nilled property of the candidate node is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Example: The </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><code><span class="deltaxml-new" style="background:#90EE90">schema-element(customer)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a candidate element node in the following two situations: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is customer; the element declaration of customer is not abstract; the type annotation of the candidate node is the same as or derived from the schema type declared in the customer element declaration; and either the candidate node is not nilled, or customer is declared to be nillable.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is client; client is an actual (non-abstract and non-blocked) member of the substitution group of customer; the type annotation of the candidate node is the same as or derived from the schema type declared for the client element; and either the candidate node is not nilled, or client is declared to be nillable.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90"> In the case where the schema </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90"> used to validate an element node </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> (whose name is </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">) differs from the schema </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90"> represented by the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context of the </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">, the following considerations apply:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">In applying the test </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from( AT, ET )</span></code><span class="deltaxml-new" style="background:#90EE90">, note that </span><var><span class="deltaxml-new" style="background:#90EE90">AT</span></var><span class="deltaxml-new" style="background:#90EE90"> will necessarily be present in </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90">, but not necessarily in </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90">. However, </span><var><span class="deltaxml-new" style="background:#90EE90">ET</span></var><span class="deltaxml-new" style="background:#90EE90"> will necessarily be present in both; and because the two schemas must be </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-new" style="background:#90EE90">compatible</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">ET</span></var><span class="deltaxml-new" style="background:#90EE90"> will be the present in both schemas, will have the same definition in both, and will be the declared type of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> in both. The test can therefore be applied from knowledge of type </span><var><span class="deltaxml-new" style="background:#90EE90">AT</span></var><span class="deltaxml-new" style="background:#90EE90"> as defined in schema </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The test as to whether the element name </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is a member of the actual substitution group is performed entirely by reference to schema </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90">. Although the two schemas are compatible, substitution group membership can vary.</span></p></li></ul></div><div class="div4"><h5><a id="id-attribute-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.7.4 Attribute Test</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-function-test"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-element-test"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Element and attribute tests of the form </span><code><span class="deltaxml-new" style="background:#90EE90">element(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> now allow </span><code><span class="deltaxml-new" style="background:#90EE90">N</span></code><span class="deltaxml-new" style="background:#90EE90"> to be any </span><code><span class="deltaxml-new" style="background:#90EE90">NameTest</span></code><span class="deltaxml-new" style="background:#90EE90">, including a wildcard. </span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AttributeTest" id="doc-xpath40-AttributeTest"></a><span class="deltaxml-new" style="background:#90EE90">[240]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"attribute" "(" (</span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">)?)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e7274.doc-xpath40-NameTestUnion" id="noid_d4e7274.doc-xpath40-NameTestUnion"></a><span class="deltaxml-new" style="background:#90EE90">[106]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e7275.doc-xpath40-NameTest" id="noid_d4e7275.doc-xpath40-NameTest"></a><span class="deltaxml-new" style="background:#90EE90">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e7276.doc-xpath40-Wildcard" id="noid_d4e7276.doc-xpath40-Wildcard"></a><span class="deltaxml-new" style="background:#90EE90">[151]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"*"</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> ":*")</span><br><span class="deltaxml-new" style="background:#90EE90">| ("*:" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90">)</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> "*")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e7277.doc-xpath40-TypeName" id="noid_d4e7277.doc-xpath40-TypeName"></a><span class="deltaxml-new" style="background:#90EE90">[247]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> An </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> is used to match an attribute node by its name and/or </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">An unprefixed </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> within the </span><code><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to a name in no namespace. The name need not be present in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-new" style="background:#90EE90">in-scope attribute declarations</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An unprefixed </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">. The </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> must be present in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></a><span class="deltaxml-new" style="background:#90EE90">] </span></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">AT</span></var><span class="deltaxml-new" style="background:#90EE90"> matches an item </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> if the following conditions are satisfied:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is an attribute node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">AT</span></var><span class="deltaxml-new" style="background:#90EE90"> includes a </span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90">, then the name of the attribute node </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> matches one or more of the </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTests</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90">. A name </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> matches a </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> if one of the following conditions is true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">*:</span><em><span class="deltaxml-new" style="background:#90EE90">local</span></em></code><span class="deltaxml-new" style="background:#90EE90"> and the local part of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> matches </span><var><span class="deltaxml-new" style="background:#90EE90">local</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><em><span class="deltaxml-new" style="background:#90EE90">prefix</span></em><span class="deltaxml-new" style="background:#90EE90">:*</span></code><span class="deltaxml-new" style="background:#90EE90"> and the namespace URI of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> matches the namespace URI bound to </span><var><span class="deltaxml-new" style="background:#90EE90">prefix</span></var><span class="deltaxml-new" style="background:#90EE90"> in the static context.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><em><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></em><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> and the namespace URI of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> matches the namespace URI found in the </span><code><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">NT</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> equal to </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">AT</span></var><span class="deltaxml-new" style="background:#90EE90"> includes a </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">, then the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the attribute node </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is either the schema type identified by that type name, or a type derived from that type by restriction.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTests</span></a><span class="deltaxml-new" style="background:#90EE90">: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> match any single attribute node, regardless of its name or type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(price)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">price</span></code><span class="deltaxml-new" style="background:#90EE90"> (in no namespace), regardless of its type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(price|discount)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">price</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">discount</span></code><span class="deltaxml-new" style="background:#90EE90"> (in no namespace).</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(xlink:*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose name is in the namespace bound to the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xlink</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(Q{http://www.w3.org/2000/svg}*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose name is in the SVG namespace.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(*:default-collation)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose local name is </span><code><span class="deltaxml-new" style="background:#90EE90">default-collation</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of namespace, and regardless of type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(*:price|*:discount)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose local name is </span><code><span class="deltaxml-new" style="background:#90EE90">price</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">discount</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of namespace, and regardless of type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(price, currency)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches an attribute node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">price</span></code><span class="deltaxml-new" style="background:#90EE90"> (in no namespace) and whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">currency</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">currency</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(xlink:*, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose name is in the namespace bound to the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xlink</span></code><span class="deltaxml-new" style="background:#90EE90">, and whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or a type derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(*, currency)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">currency</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">currency</span></code><span class="deltaxml-new" style="background:#90EE90">), regardless of its name.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> Unlike the situation with an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">, few problems arise if the attribute was validated using a different schema. This is because simple types can never be derived by extension, and attributes do not have substitution groups.</span></p></div><div class="div4"><h5><a id="id-schema-attribute-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.7.5 Schema Attribute Test</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SchemaAttributeTest" id="doc-xpath40-SchemaAttributeTest"></a><span class="deltaxml-new" style="background:#90EE90">[241]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"schema-attribute" "(" </span><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e7549.doc-xpath40-AttributeName" id="noid_d4e7549.doc-xpath40-AttributeName"></a><span class="deltaxml-new" style="background:#90EE90">[244]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> A </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches an attribute node against a corresponding attribute declaration found in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-new" style="background:#90EE90">in-scope attribute declarations</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90"> of a </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> has its prefixes expanded to a namespace URI by means of the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">. If unprefixed, an </span><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90"> is in no namespace. If the </span><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90"> specified in the </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> is not found in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-new" style="background:#90EE90">in-scope attribute declarations</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> A </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches a candidate attribute node if both of the following conditions are satisfied: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The name of the candidate node matches the specified </span><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span></code><em><span class="deltaxml-new" style="background:#90EE90">AT, ET</span></em><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> is the type annotation of the candidate node and </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90"> is the schema type declared for attribute </span><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-new" style="background:#90EE90">in-scope attribute declarations</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Example: The </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><code><span class="deltaxml-new" style="background:#90EE90">schema-attribute(color)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a candidate attribute node if </span><code><span class="deltaxml-new" style="background:#90EE90">color</span></code><span class="deltaxml-new" style="background:#90EE90"> is a top-level attribute declaration in the </span><a title="in-scope attribute declarations" class="termref" href="#dt-is-attrs"><span class="deltaxml-new" style="background:#90EE90">in-scope attribute declarations</span></a><span class="deltaxml-new" style="background:#90EE90">, the name of the candidate node is </span><code><span class="deltaxml-new" style="background:#90EE90">color</span></code><span class="deltaxml-new" style="background:#90EE90">, and the type annotation of the candidate node is the same as or derived from the schema type declared for the </span><code><span class="deltaxml-new" style="background:#90EE90">color</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> Unlike the situation with a </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">, few problems arise if the attribute was validated using a different schema. This is because attributes do not have substitution groups.</span></p></div></div><div class="div3"><h4><a id="id-function-map-array-tests"></a><span class="deltaxml-new" style="background:#90EE90">3.2.8 Function, Map, and Array Tests</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The following sections describe the syntax for </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item types</span></a><span class="deltaxml-new" style="background:#90EE90"> for functions, including arrays and maps.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> relation among these types is described in the various subsections of </span><a href="#id-itemtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2 Subtypes of Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div4"><h5><a id="id-function-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.8.1 Function Test</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-record-test"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-attribute-test"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">The keyword </span><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed as a synonym for </span><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><span class="deltaxml-new" style="background:#90EE90"> in function tests, to align with changes to inline function declarations.</span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FunctionTest" id="doc-xpath40-FunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[248]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#doc-xpath40-AnyFunctionTest"><span class="deltaxml-new" style="background:#90EE90">AnyFunctionTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnyFunctionTest" id="doc-xpath40-AnyFunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[249]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyFunctionTest"><span class="deltaxml-new" style="background:#90EE90">AnyFunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("function" | "fn") "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypedFunctionTest" id="doc-xpath40-TypedFunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[250]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("function" | "fn") "(" (</span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)*)? ")" "as" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches selected </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function items</span></a><span class="deltaxml-new" style="background:#90EE90">, potentially checking their </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-signature"><span class="deltaxml-new" style="background:#90EE90">signature</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> (which includes the types of the arguments and results</span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">, and also their annotations, as described in </span><a href="#id-annotations"><b><span class="deltaxml-new" style="background:#90EE90">5.15 Annotations</span></b></a><span class="deltaxml-new" style="background:#90EE90">)</span></span></span><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><a href="#doc-xpath40-AnyFunctionTest"><span class="deltaxml-new" style="background:#90EE90">AnyFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches any item that is a function.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches an item if it is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> and the function’s type signature (as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-new" style="background:#90EE90">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">) is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><a href="#doc-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The keywords </span><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90"> are synonymous.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">In addition, a </span><a href="#doc-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> may match certain maps and arrays, as described in </span><a href="#id-map-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.2 Map Test</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-array-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.5 Array Test</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Here are some examples of </span><a href="#doc-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90">s: </span></p><ol class="enumar"><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any function, including maps and arrays.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This can also be written </span><code><span class="deltaxml-new" style="background:#90EE90">fn(*)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">%my:assertion function(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function</span></a><span class="deltaxml-new" style="background:#90EE90"> if the implementation-defined function assertion </span><code><span class="deltaxml-new" style="background:#90EE90">%my:assertion</span></code><span class="deltaxml-new" style="background:#90EE90"> is satisfied. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:int, xs:int) as xs:int</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> with the function signature </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:int, xs:int) as xs:int</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This can also be written </span><code><span class="deltaxml-new" style="background:#90EE90">fn(xs:int, xs:int) as xs:int</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">%my:assertion function(xs:int, xs:int) as xs:int</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> with the function signature </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:int, xs:int) as xs:int</span></code><span class="deltaxml-new" style="background:#90EE90"> if the implementation-defined function assertion </span><code><span class="deltaxml-new" style="background:#90EE90">%my:assertion</span></code><span class="deltaxml-new" style="background:#90EE90"> is satisfied. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:anyAtomicType) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any map, or any function with the required signature.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any array, or any function with the required signature.</span></p></li></ol><div class="xquery"><p id="id-function-assertion" class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-function-assertion" title="function assertion"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">function assertion</span></b><span class="deltaxml-new" style="background:#90EE90"> is a predicate that restricts the set of functions matched by a FunctionTest. It uses the same syntax as </span><a href="#id-annotations"><b><span class="deltaxml-new" style="background:#90EE90">5.15 Annotations</span></b></a><span class="deltaxml-new" style="background:#90EE90">.] XQuery 4.0 and XPath 4.0 does not currently define any function assertions, but future versions may. Other specifications in the XQuery family may also use function assertions in the future.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">An unprefixed QName is taken to refer to the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2012/xquery</span></code><span class="deltaxml-new" style="background:#90EE90">. Since this is a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></a><span class="deltaxml-new" style="background:#90EE90">, and no assertions are currently defined in this namespace, this means that in practice, use of an unprefixed QName is always an error. </span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Implementations are free to define their own function assertions, whose behavior is completely implementation-defined. Implementations may also provide a way for users to define their own function assertions.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">An implementation may raise implementation-defined errors or warnings for function assertions, for example if the parameters are not correct for a given assertion. If the namespace URI of a function assertion’s </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is not recognized by an implementation, it is ignored, and has no effect on the semantics of the function test.</span></p></div><div class="xquery note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation is free to raise warnings for function assertions that it does not recognize.</span></p></div><div class="xquery note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Although function assertions use the same syntax as annotations, they are not directly related to annotations. If an implementation defines the annotation </span><code><span class="deltaxml-new" style="background:#90EE90">blue</span></code><span class="deltaxml-new" style="background:#90EE90"> and uses it in function declarations, there is no guarantee that it will also define a function assertion </span><code><span class="deltaxml-new" style="background:#90EE90">blue</span></code><span class="deltaxml-new" style="background:#90EE90">, or that a function assertion named </span><code><span class="deltaxml-new" style="background:#90EE90">blue</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a function declared with the annotation </span><code><span class="deltaxml-new" style="background:#90EE90">blue</span></code><span class="deltaxml-new" style="background:#90EE90">. Of course, an implementation that does so may be more intuitive to users.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> Implementations must not define function assertions in </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">; it is is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0045" title="err:XQST0045"><span class="deltaxml-new" style="background:#90EE90">err:XQST0045</span></a><span class="deltaxml-new" style="background:#90EE90">] for a user to define a function assertion in a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div></div><div class="div4"><h5><a id="id-map-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.8.2 Map Test</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MapTest" id="doc-xpath40-MapTest"></a><span class="deltaxml-new" style="background:#90EE90">[251]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyMapTest"><span class="deltaxml-new" style="background:#90EE90">AnyMapTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypedMapTest"><span class="deltaxml-new" style="background:#90EE90">TypedMapTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnyMapTest" id="doc-xpath40-AnyMapTest"></a><span class="deltaxml-new" style="background:#90EE90">[252]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyMapTest"><span class="deltaxml-new" style="background:#90EE90">AnyMapTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"map" "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypedMapTest" id="doc-xpath40-TypedMapTest"></a><span class="deltaxml-new" style="background:#90EE90">[253]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypedMapTest"><span class="deltaxml-new" style="background:#90EE90">TypedMapTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"map" "(" </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> "," </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#doc-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any map. The </span><a href="#doc-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a><code><span class="deltaxml-new" style="background:#90EE90">map(K, V)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any map where every key is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">K</span></code><span class="deltaxml-new" style="background:#90EE90"> and every value is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">V</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Although the grammar for </span><code><span class="deltaxml-new" style="background:#90EE90">TypedMapTest</span></code><span class="deltaxml-new" style="background:#90EE90"> allows the key to be described using the full </span><code><span class="deltaxml-new" style="background:#90EE90">ItemType</span></code><span class="deltaxml-new" style="background:#90EE90"> syntax, the item type used must be a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90">. [TODO: error code].</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><p><span class="deltaxml-new" style="background:#90EE90">Given a map </span><code><span class="deltaxml-new" style="background:#90EE90">$M</span></code><span class="deltaxml-new" style="background:#90EE90"> whose keys are integers and whose results are strings, such as </span><code><span class="deltaxml-new" style="background:#90EE90">{ 0: "no", 1: "yes" }</span></code><span class="deltaxml-new" style="background:#90EE90">, consider the results of the following expressions: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of map(xs:integer, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of map(xs:decimal, xs:anyAtomicType)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">not($M instance of map(xs:int, xs:string))</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">not($M instance of map(xs:integer, xs:token))</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">A map is also a function item, and therefore matches certain function tests. Specifically, a map that matches </span><code><span class="deltaxml-new" style="background:#90EE90">map(K, V)</span></code><span class="deltaxml-new" style="background:#90EE90"> also matches a function test of the form </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:anyAtomicType) as R</span></code><span class="deltaxml-new" style="background:#90EE90"> provided that both the following conditions are satisfied:</span></p><ul><li><p><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence()</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">To understand this rule, consider the use of a map </span><code><span class="deltaxml-new" style="background:#90EE90">$M</span></code><span class="deltaxml-new" style="background:#90EE90"> in a function call </span><code><span class="deltaxml-new" style="background:#90EE90">$M($K)</span></code><span class="deltaxml-new" style="background:#90EE90">, which is equivalent to the function call </span><code><span class="deltaxml-new" style="background:#90EE90">map:get($M, $K)</span></code><span class="deltaxml-new" style="background:#90EE90">. This function accepts any atomic item for the argument </span><code><span class="deltaxml-new" style="background:#90EE90">$K</span></code><span class="deltaxml-new" style="background:#90EE90">, and hence satisfies a function test that requires an argument type of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90">. If the key </span><code><span class="deltaxml-new" style="background:#90EE90">$K</span></code><span class="deltaxml-new" style="background:#90EE90"> is present in the map, the result of the function will be a value of type </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">; if not, it will be an empty sequence. The map is therefore substitutable for the function test provided that the function test allows both a value of type </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> and the empty sequence as possible results.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The key type </span><var><span class="deltaxml-new" style="background:#90EE90">K</span></var><span class="deltaxml-new" style="background:#90EE90"> does not enter into this rule. That is because in the function call </span><code><span class="deltaxml-new" style="background:#90EE90">$M($K)</span></code><span class="deltaxml-new" style="background:#90EE90">, the sought key </span><code><span class="deltaxml-new" style="background:#90EE90">$K</span></code><span class="deltaxml-new" style="background:#90EE90"> does not have to be of the same type as the keys actually present in the map.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The transitivity rules for item type matching mean that if an item </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> matches a type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, and </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> also matches type </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">. So the fact that a map from integers to strings (</span><code><span class="deltaxml-new" style="background:#90EE90">map(xs:integer, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">) matches </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:anyAtomicType) as xs:string?</span></code><span class="deltaxml-new" style="background:#90EE90"> means that it will also match other function tests such as </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:string?</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:decimal) as xs:anyAtomicType?</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Furthermore, the rules for </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type </span><code><span class="deltaxml-new" style="background:#90EE90">map(xs:integer, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90"> can be coerced to a function of type </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">; in this situation a type error will occur only if a call on the function actually returns an empty sequence. </span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of fn(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of fn(xs:anyAtomicType) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of fn(xs:integer) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of fn(xs:int) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$M instance of fn(xs:string) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">not($M instance of fn(xs:integer) as xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The last case might seem surprising; however, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> ensures that </span><code><span class="deltaxml-new" style="background:#90EE90">$M</span></code><span class="deltaxml-new" style="background:#90EE90"> can be used successfully anywhere that the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">fn(xs:integer) as xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Rules defining whether one map type is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of another are given in </span><a href="#id-item-subtype-maps"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2.8 Maps</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div4"><h5><a id="id-record-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.8.3 Record Test</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-sequencetype-subtype"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-function-test"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Record types are added as a new kind of </span><code><span class="deltaxml-new" style="background:#90EE90">ItemType</span></code><span class="deltaxml-new" style="background:#90EE90">, constraining the value space of maps. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The syntax </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed; it matches any map. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/52"><span class="deltaxml-new" style="background:#90EE90">52</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/728"><span class="deltaxml-new" style="background:#90EE90">728</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;10 October 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-RecordTest" id="doc-xpath40-RecordTest"></a><span class="deltaxml-new" style="background:#90EE90">[254]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyRecordTest"><span class="deltaxml-new" style="background:#90EE90">AnyRecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypedRecordTest"><span class="deltaxml-new" style="background:#90EE90">TypedRecordTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnyRecordTest" id="doc-xpath40-AnyRecordTest"></a><span class="deltaxml-new" style="background:#90EE90">[255]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyRecordTest"><span class="deltaxml-new" style="background:#90EE90">AnyRecordTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"record" "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypedRecordTest" id="doc-xpath40-TypedRecordTest"></a><span class="deltaxml-new" style="background:#90EE90">[256]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypedRecordTest"><span class="deltaxml-new" style="background:#90EE90">TypedRecordTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"record" "(" </span><a href="#doc-xpath40-FieldDeclaration"><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-FieldDeclaration"><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">)* </span><a href="#doc-xpath40-ExtensibleFlag"><span class="deltaxml-new" style="background:#90EE90">ExtensibleFlag</span></a><span class="deltaxml-new" style="background:#90EE90">? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FieldDeclaration" id="doc-xpath40-FieldDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[257]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FieldDeclaration"><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FieldName"><span class="deltaxml-new" style="background:#90EE90">FieldName</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"? ("as" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FieldName" id="doc-xpath40-FieldName"></a><span class="deltaxml-new" style="background:#90EE90">[258]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FieldName"><span class="deltaxml-new" style="background:#90EE90">FieldName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ExtensibleFlag" id="doc-xpath40-ExtensibleFlag"></a><span class="deltaxml-new" style="background:#90EE90">[259]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ExtensibleFlag"><span class="deltaxml-new" style="background:#90EE90">ExtensibleFlag</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"," "*"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches maps that meet specific criteria.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></code><code><span class="deltaxml-new" style="background:#90EE90">record(r as xs:double, i as xs:double)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a map if the map has exactly two entries: an entry with key </span><code><span class="deltaxml-new" style="background:#90EE90">"r"</span></code><span class="deltaxml-new" style="background:#90EE90"> whose value is a singleton </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> value, and an entry with key </span><code><span class="deltaxml-new" style="background:#90EE90">"i"</span></code><span class="deltaxml-new" style="background:#90EE90"> whose value is also a singleton </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> value.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the list of fields ends with </span><code><span class="deltaxml-new" style="background:#90EE90">",*"</span></code><span class="deltaxml-new" style="background:#90EE90"> then the record test is said to be </span><b><span class="deltaxml-new" style="background:#90EE90">extensible</span></b><span class="deltaxml-new" style="background:#90EE90">. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></code><code><span class="deltaxml-new" style="background:#90EE90">record(e as element(Employee), *)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a map if it has an entry with key </span><code><span class="deltaxml-new" style="background:#90EE90">"e"</span></code><span class="deltaxml-new" style="background:#90EE90"> whose value matches </span><code><span class="deltaxml-new" style="background:#90EE90">element(Employee)</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless what other entries the map might contain.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For generality, the syntax </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> defines an extensible record type that has no explicit field declarations. The item type denoted by </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to the item type </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90">: that is, it allows any map. </span></p><p><span class="deltaxml-new" style="background:#90EE90">A record test can constrain only those entries whose keys are strings, but when the record test is marked as extensible, then other entries may be present in the map with non-string keys. Entries whose key is a string can be expressed using an (unquoted) NCName if the key conforms to NCName syntax, or using a (quoted) string literal otherwise.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Lookup expressions have been extended in 4.0 so that non-NCName keys can be used without parentheses: </span><code><span class="deltaxml-new" style="background:#90EE90">employee?"middle name"</span></code></p></div><p><span class="deltaxml-new" style="background:#90EE90">If the type declaration for a field is omitted, then </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> is assumed: that is, the map entry may have any type.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the field name is followed by a question mark, then the value must have the specified type if it is present, but it may also be absent. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></code><code><span class="deltaxml-new" style="background:#90EE90">record(first as xs:string, middle? as xs:string, last as xs:string, *)</span></code><span class="deltaxml-new" style="background:#90EE90"> requires the map to have string-valued entries with keys </span><code><span class="deltaxml-new" style="background:#90EE90">"first"</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">"last"</span></code><span class="deltaxml-new" style="background:#90EE90">; it also declares that if the map has an entry with key </span><code><span class="deltaxml-new" style="background:#90EE90">"middle"</span></code><span class="deltaxml-new" style="background:#90EE90">, the value of that entry must be a single </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">. Declaring the type as </span><code><span class="deltaxml-new" style="background:#90EE90">record(first as xs:string, middle? as xs:string?, last as xs:string, *)</span></code><span class="deltaxml-new" style="background:#90EE90"> also allows the entry with key </span><code><span class="deltaxml-new" style="background:#90EE90">"middle"</span></code><span class="deltaxml-new" style="background:#90EE90"> to be present but empty.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Within an extensible record test, a </span><code><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></code><span class="deltaxml-new" style="background:#90EE90"> that is marked optional and has no declared type does not constrain the map in any way, so it serves no practical purpose, but it is permitted because it may have documentary value.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Record tests describe a subset of the value space of maps. They do not define any new kinds of values, or any additional operations. They are useful in many cases to describe more accurately the type of a variable, function parameter, or function result, giving benefits both in the readability of the code, and in the ability of the processor to detect and diagnose type errors and to optimize execution.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a variable </span><code><span class="deltaxml-new" style="background:#90EE90">$rec</span></code><span class="deltaxml-new" style="background:#90EE90"> is known to conform to a particular record type, then when a lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">$rec?field</span></code><span class="deltaxml-new" style="background:#90EE90"> is used, (a) the processor can report a type error if </span><code><span class="deltaxml-new" style="background:#90EE90">$rec</span></code><span class="deltaxml-new" style="background:#90EE90"> cannot contain an entry with name </span><code><span class="deltaxml-new" style="background:#90EE90">field</span></code><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-implausible-lookup-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3.4 Implausible Lookup Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">), and (b) the processor can make static type inferences about the type of value returned by </span><code><span class="deltaxml-new" style="background:#90EE90">$rec?field</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">(TODO: change function signatures as suggested here!) A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90">, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record tests offers the possibility of improving this: for example, the options argument of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:parse-json</span></code><span class="deltaxml-new" style="background:#90EE90">, previously given as </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90">, can now be expressed as </span><code><span class="deltaxml-new" style="background:#90EE90">record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as fn(xs:string) as xs:string, *)</span></code><span class="deltaxml-new" style="background:#90EE90">. In principle the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> type used to describe the </span><code><span class="deltaxml-new" style="background:#90EE90">duplicates</span></code><span class="deltaxml-new" style="background:#90EE90"> option could also be replaced by a schema-defined subtype of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> that enumerates the permitted values (</span><code><span class="deltaxml-new" style="background:#90EE90">"reject"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"use-first"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"use-last"</span></code><span class="deltaxml-new" style="background:#90EE90">). </span></p><p><span class="deltaxml-new" style="background:#90EE90">The use of a record test in the signature of such a function causes the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> to be invoked. So, for example, if the function expects an entry in the map to be an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> value, it becomes possible to supply a map in which the corresponding entry has type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Greater precision in defining the types of such arguments also enables better type checking, better diagnostics, better optimization, better documentation, and better syntax-directed editing tools.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">One of the motivations for introducing record tests is to enable better pattern matching in XSLT when processing JSON input. With XML input, patterns are often based around XML element names. JSON has no direct equivalent of XML’s element names; matching a JSON object such as </span><code><span class="deltaxml-new" style="background:#90EE90">{longitude: 130.2, latitude: 53.4}</span></code><span class="deltaxml-new" style="background:#90EE90"> relies instead on recognizing the property names appearing in the object. XSLT 4.0, by integrating record tests into pattern matching syntax, allows such an object to be matched with a pattern of the form </span><code><span class="deltaxml-new" style="background:#90EE90">match="record(longitude, latitude)"</span></code></p></div><p><span class="deltaxml-new" style="background:#90EE90">Rules defining whether one record test is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of another are given in </span><a href="#id-item-subtype-records"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2.10 Record Tests</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div4"><h5><a id="id-recursive-record-tests"></a><span class="deltaxml-new" style="background:#90EE90">3.2.8.4 Recursive Record Tests</span></h5><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is said to be recursive if its definition includes a direct or indirect reference to </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the following XQuery declaration defines a linked list:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare item type my:list as record(value as item()*, next? as my:list);</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The equivalent in XSLT is:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;xsl:item-type name="my:list" 
               as="record(value as item()*, next? as my:list)"/&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">A recursive named item type </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is permitted only if it satisfies all the following conditions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The item type must be a record test.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Within the record test, every item type reference </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> that refers directly or indirectly to </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> must satisfy one or more of the following conditions, where </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> is the field declaration of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> in which </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> appears:</span></p><ul><li><p><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> is an optional field declaration: for example </span><code><span class="deltaxml-new" style="background:#90EE90">next? as N</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The SequenceType of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> has an occurrence indicator of </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">: for example </span><code><span class="deltaxml-new" style="background:#90EE90">next as N?</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">next as N*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The item type of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> is a function test, map test, or array test: for example </span><code><span class="deltaxml-new" style="background:#90EE90">next as (fn() as N)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">next as array(N)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">These conditions are designed to ensure that finite instances of </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> can be constructed.</span></p></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Instances of recursive record types can be constructed and interrogated in the normal way. For example a list of length 3 can be constructed as:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{ "value": 1, "next": { "value": 2, "next": { "value": 3 } } }</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">and the third value in the map can be retrieved as </span><code><span class="deltaxml-new" style="background:#90EE90">$list?next?next?value</span></code><span class="deltaxml-new" style="background:#90EE90">. In practice, recursive data structures are usually manipulated using recursive functions.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">For an example of a practical use of recursive record types, see the specification of the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:random-number-generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Recursive type definitions need to be handled specially by the subtyping rules; a naïve approach of simply replacing each reference to a named item type with its definition would make the assessment of the subtype relationship non-terminating. For details see </span><a href="#id-itemtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2 Subtypes of Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="example"><div class="exampleHeader"><a id="e-binary-tree"></a><span class="deltaxml-new" style="background:#90EE90">Example: A Binary Tree</span></div><p><span class="deltaxml-new" style="background:#90EE90">A record used to represent a node in a binary tree might be represented (using XQuery syntax) as:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare item-type t:binary-tree 
  as record(left? as t:binary-tree, value, right? as t:binary-tree)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">A function to walk this tree and enumerate all the values in depth-first order might be written (again using XQuery syntax) as:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function t:values($tree as t:binary-tree?) as item()* {
  $tree ! (t:values(?left), ?value, t:values(?right))   
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="e-arbitrary-tree"></a><span class="deltaxml-new" style="background:#90EE90">Example: An Arbitrary Tree</span></div><p><span class="deltaxml-new" style="background:#90EE90">A record used to represent a node in a tree where each node has an arbitrary number of children might be represented (using XQuery syntax) as:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare item-type t:tree as record(value, children as t:tree*);</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">A function to walk this tree and enumerate all the values in order might be written as:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function t:flatten($tree as t:tree) as item()* {
  $tree?value, $tree?children ! t:flatten(.))   
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="e-mutually-recursive-types"></a><span class="deltaxml-new" style="background:#90EE90">Example: Mutually Recursive Types</span></div><p><span class="deltaxml-new" style="background:#90EE90">The usual textbook example of mutually-recursive types is that of a </span><em><span class="deltaxml-new" style="background:#90EE90">forest</span></em><span class="deltaxml-new" style="background:#90EE90"> consisting of a list of </span><em><span class="deltaxml-new" style="background:#90EE90">trees</span></em><span class="deltaxml-new" style="background:#90EE90">, where each </span><em><span class="deltaxml-new" style="background:#90EE90">tree</span></em><span class="deltaxml-new" style="background:#90EE90"> is a record comprising a value and a </span><em><span class="deltaxml-new" style="background:#90EE90">forest</span></em><span class="deltaxml-new" style="background:#90EE90">. As the previous example shows, this structure can be defined straightforwardly in XQuery 4.0 and XPath 4.0 without recourse to mutual recursion.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A more realistic example where mutual recursion is needed is for the schema component model used in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. Simplifying greatly, the data representing an element declaration in XSD may contain references to a complex type, which in turn will typically contain references to further element declarations. The structure therefore involves mutual recursion.</span></p></div></div><div class="div4"><h5><a id="id-array-test"></a><span class="deltaxml-new" style="background:#90EE90">3.2.8.5 Array Test</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArrayTest" id="doc-xpath40-ArrayTest"></a><span class="deltaxml-new" style="background:#90EE90">[261]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrayTest"><span class="deltaxml-new" style="background:#90EE90">ArrayTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyArrayTest"><span class="deltaxml-new" style="background:#90EE90">AnyArrayTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypedArrayTest"><span class="deltaxml-new" style="background:#90EE90">TypedArrayTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnyArrayTest" id="doc-xpath40-AnyArrayTest"></a><span class="deltaxml-new" style="background:#90EE90">[262]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyArrayTest"><span class="deltaxml-new" style="background:#90EE90">AnyArrayTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"array" "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypedArrayTest" id="doc-xpath40-TypedArrayTest"></a><span class="deltaxml-new" style="background:#90EE90">[263]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypedArrayTest"><span class="deltaxml-new" style="background:#90EE90">TypedArrayTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"array" "(" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#doc-xpath40-AnyArrayTest"><span class="deltaxml-new" style="background:#90EE90">AnyArrayTest</span></a><code><span class="deltaxml-new" style="background:#90EE90">array(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any array. The </span><a href="#doc-xpath40-TypedArrayTest"><span class="deltaxml-new" style="background:#90EE90">TypedArrayTest</span></a><code><span class="deltaxml-new" style="background:#90EE90">array(X)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any array in which every array member matches the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><code><span class="deltaxml-new" style="background:#90EE90">X</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ 1, 2 ] instance array(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[] instance of array(xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ "foo" ] instance of array(xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ "foo" ] instance of array(xs:integer)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ (1, 2), (3, 4) ] instance of array(xs:integer)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ (1, 2), (3, 4) ] instance of array(xs:integer+)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">An array also matches certain other </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item types</span></a><span class="deltaxml-new" style="background:#90EE90">, including:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as item()*</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">An array that matches </span><code><span class="deltaxml-new" style="background:#90EE90">array(T)</span></code><span class="deltaxml-new" style="background:#90EE90"> also matches the function test </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as T</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">To understand this rule, consider the use of an array </span><code><span class="deltaxml-new" style="background:#90EE90">$A</span></code><span class="deltaxml-new" style="background:#90EE90"> in a function call </span><code><span class="deltaxml-new" style="background:#90EE90">$A($I)</span></code><span class="deltaxml-new" style="background:#90EE90">, which is equivalent to the function call </span><code><span class="deltaxml-new" style="background:#90EE90">array:get($A, $I)</span></code><span class="deltaxml-new" style="background:#90EE90">. This function accepts any integer for the argument </span><code><span class="deltaxml-new" style="background:#90EE90">$I</span></code><span class="deltaxml-new" style="background:#90EE90">, and the result will either be an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, or an error.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The transitivity rules for item type matching mean that if an item </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> matches a type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, and </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> also matches type </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">. So the fact that an array of strings (</span><code><span class="deltaxml-new" style="background:#90EE90">array(xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">) matches </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> means that it will also match other function tests such as </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:long) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Furthermore, the rules for </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> mean that any array can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example an array of type </span><code><span class="deltaxml-new" style="background:#90EE90">array(node())</span></code><span class="deltaxml-new" style="background:#90EE90"> can be coerced to a function of type </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as element()</span></code><span class="deltaxml-new" style="background:#90EE90">; in this situation a type error will occur only if a call on the function actually returns a node that is not an element node.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Rules defining whether one array type is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of another are given in </span><a href="#id-item-subtype-arrays"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2.9 Arrays</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="id-xs-error"></a><span class="deltaxml-new" style="background:#90EE90">3.2.9 xs:error</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> has an empty value space; it never appears as a dynamic type or as the content type of a dynamic element or attribute type. It was defined in XML Schema in the interests of making the type system complete and closed, and it is also available in XQuery 4.0 and XPath 4.0 for similar reasons.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Even though it cannot occur in an instance, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> is a valid type name in a sequence type. The practical uses of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> as a sequence type are limited, but they do exist. For instance, an error-handling function that always raises a dynamic error never returns a value, so </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> is a good choice for the return type of the function.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The semantics of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> are well defined as a consequence of the fact that </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> is defined as a union type with no member types. For example:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$x instance of xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> always returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$x cast as xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> fails dynamically with error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001" title="err:FORG0001"><span class="deltaxml-new" style="background:#90EE90">err:FORG0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, regardless of the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$x cast as xs:error?</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001" title="err:FORG0001"><span class="deltaxml-new" style="background:#90EE90">err:FORG0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> if </span><code><span class="deltaxml-new" style="background:#90EE90">exists($x)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, and evaluates to the empty sequence if </span><code><span class="deltaxml-new" style="background:#90EE90">empty($x)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:error($x)</span></code><span class="deltaxml-new" style="background:#90EE90"> has the same semantics as </span><code><span class="deltaxml-new" style="background:#90EE90">$x cast as xs:error?</span></code><span class="deltaxml-new" style="background:#90EE90"> (see the previous bullet point)</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$x castable as xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$x treat as xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0050</span></a><span class="deltaxml-new" style="background:#90EE90">] if evaluated, regardless of the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">. It never fails statically.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">let $x as xs:error := 1 return 2</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">], which can be raised statically or dynamically, and need not be raised if the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> is never evaluated by the query processor.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">declare function ns:f($arg as xs:error) {...};</span></code><span class="deltaxml-new" style="background:#90EE90"> is a valid function declaration, but it always raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] if the function is called.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">All of the above examples assume that </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> is actually evaluated. The rules specified in </span><a href="#id-errors-and-opt"><b><span class="deltaxml-new" style="background:#90EE90">2.4.4 Errors and Optimization</span></b></a><span class="deltaxml-new" style="background:#90EE90"> permit an implementation to avoid evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> if the result of the query does not depend upon the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> and thus to avoid raising an error.</span></p></div></div></div><div class="div2"><h3><a id="id-sequencetype-subtype"></a><span class="deltaxml-new" style="background:#90EE90">3.3 Subtype Relationships</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-record-test"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.</span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-subtype" title="subtype"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Given two </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item types</span></a><span class="deltaxml-new" style="background:#90EE90">, the rules in this section determine if one is a </span><b><span class="deltaxml-new" style="background:#90EE90">subtype</span></b><span class="deltaxml-new" style="background:#90EE90"> of the other. If a type </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a subtype of type </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, it follows that every value matched by </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is also matched by </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The relationship </span><code><span class="deltaxml-new" style="background:#90EE90">subtype(A, A)</span></code><span class="deltaxml-new" style="background:#90EE90"> is always true: every type is a subtype of itself.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The converse is not necessarily true: we cannot infer that if every value matched by </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is also matched by </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a subtype of type </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">. For example, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> might be defined as the set of strings matching the regular expression </span><code><span class="deltaxml-new" style="background:#90EE90">[A-Z]*</span></code><span class="deltaxml-new" style="background:#90EE90">, while </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is the set of strings matching the regular expression </span><code><span class="deltaxml-new" style="background:#90EE90">[A-Za-z]*</span></code><span class="deltaxml-new" style="background:#90EE90">; no subtype relationship holds between these types.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The rules for deciding whether one </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90"> is a subtype of another are given in </span><a href="#id-seqtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.1 Subtypes of Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The rules for deciding whether one </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><span class="deltaxml-new" style="background:#90EE90"> is a subtype of another are given in </span><a href="#id-itemtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2 Subtypes of Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The subtype relationship is not acyclic. There are cases where </span><code><span class="deltaxml-new" style="background:#90EE90">subtype(A, B)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">subtype(B, A)</span></code><span class="deltaxml-new" style="background:#90EE90"> are both true. This implies that </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> have the same value space, but they can still be different types. For example this applies when </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a union type with member types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, while </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is a union type with member types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">. These are different types (</span><code><span class="deltaxml-new" style="background:#90EE90">"23" cast as A</span></code><span class="deltaxml-new" style="background:#90EE90"> produces a string, while </span><code><span class="deltaxml-new" style="background:#90EE90">"23" cast as B</span></code><span class="deltaxml-new" style="background:#90EE90"> produces an integer, because casting is attempted to each member type in order) but both types have the same value space. </span></p></div><div class="div3"><h4><a id="id-seqtype-subtype"></a><span class="deltaxml-new" style="background:#90EE90">3.3.1 Subtypes of Sequence Types</span></h4><p><span class="deltaxml-new" style="background:#90EE90">We use the notation </span><code><span class="deltaxml-new" style="background:#90EE90">A ⊑ B</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">subtype(A, B)</span></code><span class="deltaxml-new" style="background:#90EE90"> to indicate that a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of a sequence type </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90">. This section defines the rules for deciding whether any two sequence types have this relationship.</span></p><p><span class="deltaxml-new" style="background:#90EE90">To define the rules, we divide sequence types into six categories:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The category </span><code><span class="deltaxml-new" style="background:#90EE90">empty</span></code><span class="deltaxml-new" style="background:#90EE90"> includes the sequence types </span><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence()</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error*</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error?</span></code><span class="deltaxml-new" style="background:#90EE90">. All these sequence types match the empty sequence as their only instance.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The category </span><code><span class="deltaxml-new" style="background:#90EE90">void</span></code><span class="deltaxml-new" style="background:#90EE90"> includes the sequence types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error+</span></code><span class="deltaxml-new" style="background:#90EE90">, which have no instances (not even the empty sequence).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The categories </span><code><span class="deltaxml-new" style="background:#90EE90">X?</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">X*</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">X</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">X+</span></code><span class="deltaxml-new" style="background:#90EE90"> includes all sequence types having an item type </span><code><span class="deltaxml-new" style="background:#90EE90">X</span></code><span class="deltaxml-new" style="background:#90EE90"> other than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90">, together with an occurrence indicator of </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> (zero or more), </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> (one or more), absent (exactly one), or </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> (one or more) respectively. We use the notation </span><var><span class="deltaxml-new" style="background:#90EE90">X</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> to indicate the item type of such a sequence type.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The judgement </span><code><span class="deltaxml-new" style="background:#90EE90">A ⊑ B</span></code><span class="deltaxml-new" style="background:#90EE90"> is then determined by the categories of the two sequence types, as defined in the table below. In many cases this depends on the relationship between the item types of </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90">. This is denoted using the notation </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code><span class="deltaxml-new" style="background:#90EE90">, as defined in </span><a href="#id-itemtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2 Subtypes of Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="medium"><table class="medium"><tbody><tr><th rowspan="2" colspan="2"></th><th colspan="6"><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">Sequence type</span></a><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></th></tr><tr><th><code><span class="deltaxml-new" style="background:#90EE90">empty</span></code></th><th><code><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90">?</span></code></th><th><code><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90">*</span></code></th><th><code><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></th><th><code><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90">+</span></code></th><th><code><span class="deltaxml-new" style="background:#90EE90">void</span></code></th></tr><tr><th rowspan="6"><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">Sequence type</span></a><var><span class="deltaxml-new" style="background:#90EE90">A</span></var></th><th><code><span class="deltaxml-new" style="background:#90EE90">empty</span></code></th><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td></tr><tr><th><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90">?</span></code></th><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td></tr><tr><th><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90">*</span></code></th><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td></tr><tr><th><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></th><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td></tr><tr><th><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90">+</span></code></th><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td><td><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">i</span></sub></var></code></td><td><span class="deltaxml-new" style="background:#90EE90">false</span></td></tr><tr><th><code><span class="deltaxml-new" style="background:#90EE90">void</span></code></th><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">true</span></td><td><span class="deltaxml-new" style="background:#90EE90">true</span></td></tr></tbody></table></div></div><div class="div3"><h4><a id="id-itemtype-subtype"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2 Subtypes of Item Types</span></h4><p><span class="deltaxml-new" style="background:#90EE90">We use the notation </span><code><span class="deltaxml-new" style="background:#90EE90">A ⊆ B</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">itemtype-subtype(A, B)</span></code><span class="deltaxml-new" style="background:#90EE90"> to indicate that an </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of an item type </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90">. This section defines the rules for deciding whether any two item types have this relationship.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The rules in this section apply to </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item types</span></a><span class="deltaxml-new" style="background:#90EE90">, not to </span><a title="item type designator" class="termref" href="#dt-item-type-designator"><span class="deltaxml-new" style="background:#90EE90">item type designators</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, if the name </span><code><span class="deltaxml-new" style="background:#90EE90">STR</span></code><span class="deltaxml-new" style="background:#90EE90"> has been defined in the static context as a </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><span class="deltaxml-new" style="background:#90EE90"> referring to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, then anything said here about the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> applies equally whether it is designated as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or as </span><code><span class="deltaxml-new" style="background:#90EE90">STR</span></code><span class="deltaxml-new" style="background:#90EE90">, or indeed as the parenthesized forms </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">(STR)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">References to </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item types</span></a><span class="deltaxml-new" style="background:#90EE90"> are handled as described in </span><a href="#id-itemtype-subtype-aliases"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2.11 Named Item Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The relationship </span><code><span class="deltaxml-new" style="background:#90EE90">A ⊆ B</span></code><span class="deltaxml-new" style="background:#90EE90"> is true if and only if at least one of the conditions listed in the following subsections applies:</span></p><div class="div4"><h5><a id="id-item-subtype-general"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.1 General Rules</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item types</span></a><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> are the same </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">There is an </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90"> such that </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90">. (This is referred to below as the </span><b><span class="deltaxml-new" style="background:#90EE90">transitivity rule</span></b><span class="deltaxml-new" style="background:#90EE90">).</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The first rule is technically redundant: it is implied by the second rule in </span><a href="#id-item-subtype-atomic"><b><span class="deltaxml-new" style="background:#90EE90">3.3.2.3 Atomic and Union Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> is defined as a union type with no member types; therefore it is automatically true that every member type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> satisfies </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div4"><h5><a id="id-item-subtype-choice"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.2 Choice Item Types</span></h5><p><span class="deltaxml-new" style="background:#90EE90">The following rules determine whether </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true in the case where either </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> or </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> or both is a </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Firstly, if one of the operands is </span><em><span class="deltaxml-new" style="background:#90EE90">not</span></em><span class="deltaxml-new" style="background:#90EE90"> a choice item type, then it is treated as a choice item type with a single member type. The rule is then:</span></p><p><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if for every member type </span><var><span class="deltaxml-new" style="background:#90EE90">a</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">, there is a member type </span><var><span class="deltaxml-new" style="background:#90EE90">b</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> such that </span><code><var><span class="deltaxml-new" style="background:#90EE90">a</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">b</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:int | xs:long)</span></code><span class="deltaxml-new" style="background:#90EE90"> is a subtype of </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:decimal | xs:date)</span></code><span class="deltaxml-new" style="background:#90EE90"> because both </span><code><span class="deltaxml-new" style="background:#90EE90">xs:int</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:long</span></code><span class="deltaxml-new" style="background:#90EE90"> are subtypes of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Because an </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration type</span></a><span class="deltaxml-new" style="background:#90EE90"> is defined as a choice type of singleton enumerations, these rules have the consequence, for example, that </span><code><span class="deltaxml-new" style="background:#90EE90">enum("A", "B")</span></code><span class="deltaxml-new" style="background:#90EE90"> is a subtype of </span><code><span class="deltaxml-new" style="background:#90EE90">enum("A", "B", "C")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:int</span></code><span class="deltaxml-new" style="background:#90EE90"> is not a subtype of </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:negativeInteger | xs:nonNegativeInteger)</span></code><span class="deltaxml-new" style="background:#90EE90">, because it does not satisfy this rule. This is despite the fact that the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:int</span></code><span class="deltaxml-new" style="background:#90EE90"> is a subset of the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:negativeInteger | xs:nonNegativeInteger)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div4"><h5><a id="id-item-subtype-atomic"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.3 Atomic and Union Types</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> are </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic types</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">derives-from</span></code><span class="deltaxml-new" style="background:#90EE90"> relationship is defined in </span><a href="#id-sequencetype-matching"><b><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="example"><div class="exampleHeader"><a id="d5e10296"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:integer ⊆ xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> because </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal ⊆ xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90"> because </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90"> is a pure union type that includes </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> as a member type.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">enum("red") ⊆ xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> because the singleton enumeration type </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red")</span></code><span class="deltaxml-new" style="background:#90EE90"> is defined to be an atomic type derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">enum("red") ⊆ enum("red", "green")</span></code><span class="deltaxml-new" style="background:#90EE90"> because the enumeration type </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green")</span></code><span class="deltaxml-new" style="background:#90EE90"> is defined to be a union type that has the generalized atomic type </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red")</span></code><span class="deltaxml-new" style="background:#90EE90"> as a member type.</span></p></li></ul></div></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a><span class="deltaxml-new" style="background:#90EE90">, and every type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> in the transitive membership of </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> satisfies </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="example"><div class="exampleHeader"><a id="d5e10365"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">(xs:short | xs:long) ⊆ xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> because </span><code><span class="deltaxml-new" style="background:#90EE90">xs:short ⊆ xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:long ⊆ xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">(P | Q) ⊆ (P | Q | R)</span></code><span class="deltaxml-new" style="background:#90EE90"> because </span><code><span class="deltaxml-new" style="background:#90EE90">P ⊆ (P | Q | R)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">Q ⊆ (P | Q | R)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green") ⊆ xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> because the enumeration type </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red") ⊆ xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">enum("green") ⊆ xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green") ⊆ enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> because </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red") ⊆ enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">enum("green") ⊆ enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green", "blue") ⊆ (enum("red", "green") | enum("blue"))</span></code><span class="deltaxml-new" style="background:#90EE90"> because each of the types </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red")</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">enum("green")</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">enum("blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> is a subtype of one of the two members of the union type.</span></p></li></ul></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-nodes"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.4 Node Types: General Rules</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a href="#doc-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">node()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="example"><div class="exampleHeader"><a id="d5e10461"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">comment() ⊆ node()</span></code></p></div></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction(</span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> for any name </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">, and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="example"><div class="exampleHeader"><a id="d5e10485"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction('pi') ⊆ processing-instruction()</span></code></p></div></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">document-node(</span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> for any </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90">, and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">document-node()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="example"><div class="exampleHeader"><a id="d5e10513"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">document-node(element(chap)) ⊆ document-node()</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">document-node(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">e</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">document-node(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">e</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><code><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">e</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">e</span></sub></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e10553"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">document-node(element(title)) ⊆ document-node(element(*))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-elements"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.5 Node Types: Element Tests</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-wildcard-matches" title="wildcard-matches"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In these rules, if </span><var><span class="deltaxml-new" style="background:#90EE90">MU</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">NU</span></var><span class="deltaxml-new" style="background:#90EE90"> are </span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnions</span></a><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">MU</span></var><b><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></b><var><span class="deltaxml-new" style="background:#90EE90">NU</span></var><span class="deltaxml-new" style="background:#90EE90"> is true if every name that matches </span><var><span class="deltaxml-new" style="background:#90EE90">MU</span></var><span class="deltaxml-new" style="background:#90EE90"> also matches </span><var><span class="deltaxml-new" style="background:#90EE90">NU</span></var><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">More specifically, this is the case if for every </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">MU</span></var><span class="deltaxml-new" style="background:#90EE90"> there is a </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">NU</span></var><span class="deltaxml-new" style="background:#90EE90"> where at least one of the following applies:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> are the same </span><code><span class="deltaxml-new" style="background:#90EE90">NameTest</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a href="#doc-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a><span class="deltaxml-new" style="background:#90EE90"> that matches </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is the </span><a href="#doc-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply.</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">element()</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">element(*)</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">?)</span></code><span class="deltaxml-new" style="background:#90EE90"> for any type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, xs:anyType?)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches"><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></a><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e10722"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title) ⊆ element(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title, xs:string) ⊆ element(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title|heading, xs:string) ⊆ element(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title, xs:string) ⊆ element(title|heading)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title, xs:string?) ⊆ element(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title|heading, xs:string) ⊆ element(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title) ⊆ element(title, xs:anyType?)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title, xs:integer) ⊆ element(title|heading, xs:anyType?)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(title, xs:string?) ⊆ element(title, xs:anyType?)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(my:title|your:title) ⊆ element(*:title)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(my:title|my:heading) ⊆ element(my:*)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches"><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></a><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e10837"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(size, xs:integer) ⊆ element(size, xs:decimal)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(size, xs:integer) ⊆ element(size|größe, xs:decimal)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(size, xs:integer) ⊆ element(*, xs:decimal)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(*, xs:integer) ⊆ element(*, xs:decimal)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(my:*, xs:integer) ⊆ element(*, xs:decimal)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">?)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">element(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">?)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches"><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></a><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e10923"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(size, xs:integer) ⊆ element(size, xs:decimal?)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(size, xs:integer?) ⊆ element(*, xs:decimal?)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(*, xs:integer) ⊆ element(*, xs:decimal?)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(my:*, xs:integer?) ⊆ element(*, xs:decimal?)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">schema-element(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">schema-element(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every element declaration that is an actual member of the substitution group of </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> is also an actual member of the substitution group of </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The fact that </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90"> is a member of the substitution group of </span><var><span class="deltaxml-new" style="background:#90EE90">Q</span></var><span class="deltaxml-new" style="background:#90EE90"> does not mean that every element declaration in the substitution group of </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90"> is also in the substitution group of </span><var><span class="deltaxml-new" style="background:#90EE90">Q</span></var><span class="deltaxml-new" style="background:#90EE90">. For example, </span><var><span class="deltaxml-new" style="background:#90EE90">Q</span></var><span class="deltaxml-new" style="background:#90EE90"> might block substitution of elements whose type is derived by extension, while </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90"> does not.</span></p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-attributes"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.6 Node Types: Attribute Tests</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">attribute()</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(*)</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> for any type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(Bn)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, xs:anyAtomicType)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches"><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></a><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11074"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(code) ⊆ attribute(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(code|status) ⊆ attribute(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(code, xs:untypedAtomic) ⊆ attribute(*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(code|status, xs:string) ⊆ attribute(code, xs:anyAtomicType)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(my:code|your:code) ⊆ attribute(*:code)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(my:code|my:status) ⊆ attribute(my:*)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><a title="wildcard-matches" class="termref" href="#dt-wildcard-matches"><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></a><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">derives-from(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">t</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11159"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(*, xs:ID) ⊆ attribute(*, xs:string)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(my:*, xs:ID) ⊆ attribute(*, xs:string)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(code, xs:ID) ⊆ attribute(code|status, xs:string)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(code, xs:ID) ⊆ attribute(*, xs:string)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(code, xs:ID) ⊆ attribute(*:code, xs:ID)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(my:code|my:status, xs:ID) ⊆ attribute(my:*, xs:string)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">schema-attribute(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">schema-attribute(</span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> equals the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">B</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var></p></li></ol></li></ol></div><div class="div4"><h5><a id="id-item-subtype-functions"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.7 Functions</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a href="#doc-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> with annotations </span><code><span class="deltaxml-new" style="background:#90EE90">[AnnotationsA]</span></code></span></span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">[AnnotationsB]</span></span></span><span class="deltaxml-new" style="background:#90EE90"> function(*)</span></code></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions(AnnotationsA, AnnotationsB)</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><code><span class="deltaxml-new" style="background:#90EE90">[AnnotationsB]</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">[AnnotationsA]</span></code><span class="deltaxml-new" style="background:#90EE90"> are optional lists of one or more annotations.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11292"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:string ⊆ function(*)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationsA </span></span></span><span class="deltaxml-new" style="background:#90EE90">function(</span><var><span class="deltaxml-new" style="background:#90EE90">a</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">a</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ... </span><var><span class="deltaxml-new" style="background:#90EE90">a</span><sub><span class="deltaxml-new" style="background:#90EE90">M</span></sub></var><span class="deltaxml-new" style="background:#90EE90">) as </span><var><span class="deltaxml-new" style="background:#90EE90">R</span><sub><span class="deltaxml-new" style="background:#90EE90">A</span></sub></var></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationsB </span></span></span><span class="deltaxml-new" style="background:#90EE90">function(</span><var><span class="deltaxml-new" style="background:#90EE90">b</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">b</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ... </span><var><span class="deltaxml-new" style="background:#90EE90">b</span><sub><span class="deltaxml-new" style="background:#90EE90">N</span></sub></var><span class="deltaxml-new" style="background:#90EE90">) as </span><var><span class="deltaxml-new" style="background:#90EE90">R</span><sub><span class="deltaxml-new" style="background:#90EE90">B</span></sub></var></code></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">[AnnotationsB]</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">[AnnotationsA]</span></code><span class="deltaxml-new" style="background:#90EE90"> are optional lists of one or more annotations;</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> (the arity of </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">) equals </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> (the arity of </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">) </span></p></li><li><p><code><var><span class="deltaxml-new" style="background:#90EE90">R</span><sub><span class="deltaxml-new" style="background:#90EE90">A</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">R</span><sub><span class="deltaxml-new" style="background:#90EE90">B</span></sub></var></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For all values of </span><var><span class="deltaxml-new" style="background:#90EE90">p</span></var><span class="deltaxml-new" style="background:#90EE90"> between 1 and </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">b</span><sub><span class="deltaxml-new" style="background:#90EE90">p</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">a</span><sub><span class="deltaxml-new" style="background:#90EE90">p</span></sub></var></code><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions(AnnotationsA, AnnotationsB)</span></code></span></span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11390"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:string ⊆ function(xs:long) as xs:string</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:ID ⊆ function(xs:integer) as xs:string</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:ID ⊆ function(xs:long) as xs:string</span></code></p></li></ul></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Function return types are covariant because this rule requires </span><code><var><span class="deltaxml-new" style="background:#90EE90">R</span><sub><span class="deltaxml-new" style="background:#90EE90">A</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">R</span><sub><span class="deltaxml-new" style="background:#90EE90">B</span></sub></var></code><span class="deltaxml-new" style="background:#90EE90"> for return types. Function parameter types are contravariant because this rule requires </span><code><var><span class="deltaxml-new" style="background:#90EE90">b</span><sub><span class="deltaxml-new" style="background:#90EE90">p</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">a</span><sub><span class="deltaxml-new" style="background:#90EE90">p</span></sub></var></code><span class="deltaxml-new" style="background:#90EE90"> for parameter types.</span></p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-maps"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.8 Maps</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Both of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(</span><var><span class="deltaxml-new" style="background:#90EE90">K</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90">, for any </span><var><span class="deltaxml-new" style="background:#90EE90">K</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11471"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">map(xs:integer, item()*) ⊆ map(*)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(</span><var><span class="deltaxml-new" style="background:#90EE90">K</span><sub><span class="deltaxml-new" style="background:#90EE90">a</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">a</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(</span><var><span class="deltaxml-new" style="background:#90EE90">K</span><sub><span class="deltaxml-new" style="background:#90EE90">b</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">b</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><code><var><span class="deltaxml-new" style="background:#90EE90">K</span><sub><span class="deltaxml-new" style="background:#90EE90">a</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">K</span><sub><span class="deltaxml-new" style="background:#90EE90">b</span></sub></var></code></p></li><li><p><code><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">a</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">b</span></sub></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11525"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">map(xs:long, item()) ⊆ map(xs:integer, item()+)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Both the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> (or, because of the transitivity rules, any other map type)</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">function(*)</span></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11551"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">map(xs:long, xs:string?) ⊆ function(*)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Both the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> (or, because of the transitivity rules, any other map type)</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:anyAtomicType) as item()*</span></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11577"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">map(xs:long, xs:string?) ⊆ function(xs:anyAtomicType) as item()*</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(</span><var><span class="deltaxml-new" style="background:#90EE90">K</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:anyAtomicType) as </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence()</span></code><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11624"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">map(xs:int, node()) ⊆ function(xs:anyAtomicType) as node()?</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">map(xs:int, node()+) ⊆ function(xs:anyAtomicType) as node()*</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The function accepts type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90"> rather than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:int</span></code><span class="deltaxml-new" style="background:#90EE90">, because </span><code><span class="deltaxml-new" style="background:#90EE90">$M("xyz")</span></code><span class="deltaxml-new" style="background:#90EE90"> is a valid call on a map (treated as a function) even when all the keys in the map are integers.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The return type of the function is extended from </span><code><span class="deltaxml-new" style="background:#90EE90">node()</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">node()+</span></code><span class="deltaxml-new" style="background:#90EE90"> to allow an empty sequence because </span><code><span class="deltaxml-new" style="background:#90EE90">$M("xyz")</span></code><span class="deltaxml-new" style="background:#90EE90"> can return an empty sequence even if none of the entries in the map contains an empty sequence.</span></p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-arrays"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.9 Arrays</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Both the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">array(</span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">array(*)</span></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11698"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">array(xs:integer) ⊆ array(*)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">array(</span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">array(</span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><code><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11738"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">array(xs:integer) ⊆ array(xs:decimal+)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Both the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">array(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> (or, because of the transitivity rules, any other array type)</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">function(*)</span></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11764"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">array(xs:integer) ⊆ function(*)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Both the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">array(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> (or, because of the transitivity rules, any other array type)</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as item()*</span></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11790"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">array(*) ⊆ function(xs:integer) as item()*</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Both the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">array(</span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11820"></a><span class="deltaxml-new" style="background:#90EE90">Example:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">array(xs:string) ⊆ function(xs:integer) as xs:string</span></code></p></div></li></ol></div><div class="div4"><h5><a id="id-item-subtype-records"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.10 Record Tests</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Given item types </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><code><span class="deltaxml-new" style="background:#90EE90">⊆</span></code><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is true if any of the following apply:</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">All of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a record test.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11875"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">record(longitude, latitude)</span></code><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code></p><p><code><span class="deltaxml-new" style="background:#90EE90">record(longitude, latitude, *)</span></code><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code></p><p><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a non-extensible record test</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(</span><var><span class="deltaxml-new" style="background:#90EE90">K</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">K</span></var><span class="deltaxml-new" style="background:#90EE90"> is either </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">, where </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is the declared type of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> (or its default, </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">), </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e11954"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x, y)</span></code><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><code><span class="deltaxml-new" style="background:#90EE90">map(xs:string, item()*)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x as xs:double, y as xs:double)</span></code><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><code><span class="deltaxml-new" style="background:#90EE90">map(xs:string, xs:double)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a non-extensible record test.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is a non-extensible record test.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every field in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is also declared in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every mandatory field in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is also declared as mandatory in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field that is declared in both </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, where the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> and the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e12025"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x, y as xs:integer) ⊆ record(x, y as xs:decimal)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x, y) ⊆ record(x, y, z?)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is an extensible record test</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is an extensible record test</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every mandatory field in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is also declared as mandatory in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field that is declared in both </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, where the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> and the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field that is declared in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> but not in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">, the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e12095"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x, y, z, *) ⊆ record(x, y, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x?, y?, z?, *) ⊆ record(x, y, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x as xs:integer, y as xs:integer, *) ⊆ record(x as xs:decimal, y as xs:integer*, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x as xs:integer, *) ⊆ record(x as xs:decimal, y as item(), *)</span></code></p></li></ul></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">All of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a non-extensible record test.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is an extensible record test.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every mandatory field in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is also declared as mandatory in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field that is declared in both </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, where the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> and the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e12166"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x, y as xs:integer) ⊆ record(x, y as xs:decimal, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(y as xs:integer) ⊆ record(x?, y as xs:decimal, *)</span></code></p></li></ul></div></li></ol></div><div class="div4"><h5><a id="id-itemtype-subtype-aliases"></a><span class="deltaxml-new" style="background:#90EE90">3.3.2.11 Named Item Types</span></h5><p><span class="deltaxml-new" style="background:#90EE90">This section describes how references to </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item types</span></a><span class="deltaxml-new" style="background:#90EE90"> are handled when evaluating the subtype relationship.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Named item types can be classified as recursive or non-recursive. A recursive type is one that references itself, directly or indirectly. Only record tests are allowed to be recursive.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Where an item type contains a reference to a named item type that is non-recursive, the reference is expanded, recursively, as the first step in evaluating the subtype relationship. For example this means that if </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90"> is a named item type with the expansion </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:integer | xs:double)</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer ⊆ U</span></code><span class="deltaxml-new" style="background:#90EE90"> is true, because </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer ⊆ (xs:integer | xs:double)</span></code><span class="deltaxml-new" style="background:#90EE90"> is true.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Recursive types are considered to be, in the terminology of the computer science literature, </span><b><span class="deltaxml-new" style="background:#90EE90">iso-recursive</span></b><span class="deltaxml-new" style="background:#90EE90"> (rather than </span><b><span class="deltaxml-new" style="background:#90EE90">equi-recursive</span></b><span class="deltaxml-new" style="background:#90EE90">). This means that a recursive type name is not treated as being equivalent to its expansion (at any depth). For example, if the named item type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> has the expansion </span><code><span class="deltaxml-new" style="background:#90EE90">record(A as item()*, B as T?)</span></code><span class="deltaxml-new" style="background:#90EE90">, then the type </span><code><span class="deltaxml-new" style="background:#90EE90">array(T)</span></code><span class="deltaxml-new" style="background:#90EE90"> is not considered to be equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">array(record(A as item()*, B as T?))</span></code><span class="deltaxml-new" style="background:#90EE90">, despite the fact that the two types have exactly the same instances.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The rules are therefore defined as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is a reference to a recursive named item type, then </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is true if and only if </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> are references to the same named item type.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a reference to a recursive named item type, then </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊆ </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is true if either:</span></p><ul><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> are references to the same named item type.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(*) ⊆ B</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This is because only record tests are allowed to be recursive.</span></p></div></li></ul></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The decision to make recursive types iso-recursive rather than equi-recursive was made largely because it saves a great deal of implementation complexity without any serious adverse effects for users. In practice, problems can be avoided by using named item type references consistently (for example, avoiding having two named item types with different names but identical definitions).</span></p></div></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-assertions-subtype"></a><span class="deltaxml-new" style="background:#90EE90">3.3.3 The judgement </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions(AnnotationsA, AnnotationsB)</span></code></h4><p><span class="deltaxml-new" style="background:#90EE90"> The judgement </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions(AnnotationsA, AnnotationsB)</span></code><span class="deltaxml-new" style="background:#90EE90"> determines if </span><code><span class="deltaxml-new" style="background:#90EE90">AnnotationsA</span></code><span class="deltaxml-new" style="background:#90EE90"> is a subtype of </span><code><span class="deltaxml-new" style="background:#90EE90">AnnotationsB</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><code><span class="deltaxml-new" style="background:#90EE90">AnnotationsA</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">AnnotationsB</span></code><span class="deltaxml-new" style="background:#90EE90"> are annotation lists from two FunctionTests. It is defined to ignore function assertions in namespaces not understood by the XQuery implementation. For assertions that are understood, their effect on the result of </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions()</span></code><span class="deltaxml-new" style="background:#90EE90"> is implementation defined. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The following examples are some possible ways to define </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions()</span></code><span class="deltaxml-new" style="background:#90EE90"> for some implementation defined assertions in the </span><code><span class="deltaxml-new" style="background:#90EE90">local</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace. These examples assume that some implementation uses annotations to label functions as deterministic or nondeterministic, and treats deterministic functions as a subset of nondeterministic functions. In this implementation, nondeterministic functions are not a subset of deterministic functions. </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> AnnotationsA is </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">%local:inline</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90"> It has no influence on the outcome of </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> AnnotationsA is </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">%local:deterministic</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90"> AnnotationsB is </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">%local:nondeterministic</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90"> Since deterministic functions are a subset of nondeterministic functions, </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions()</span></code><span class="deltaxml-new" style="background:#90EE90"> is true. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> AnnotationsA contains </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">%local:nondeterministic</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90"> AnnotationsB is empty. If FunctionTests without the </span><code><span class="deltaxml-new" style="background:#90EE90">%local:nondeterministic</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation only match deterministic functions, </span><code><span class="deltaxml-new" style="background:#90EE90">subtype-assertions()</span></code><span class="deltaxml-new" style="background:#90EE90"> must be false. </span></p></li></ul></div></div></div><div class="div2"><h3><a id="id-coercion-rules"></a><span class="deltaxml-new" style="background:#90EE90">3.4 Coercion Rules</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-function-coercion"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-sequencetype-subtype"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/117"><span class="deltaxml-new" style="background:#90EE90">117</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/254"><span class="deltaxml-new" style="background:#90EE90">254</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;29 November 2022]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-coercion-rules" title="coercion rules"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></b><span class="deltaxml-new" style="background:#90EE90"> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. ] The required type is expressed as a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">. The effect of the coercion rules may be to accept the value as supplied, to convert it to a value that matches the required type, or to reject it with a type error.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This section defines how the coercion rules operate; the situations in which the rules apply are defined elsewhere, by reference to this section.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In previous versions of this specification, the coercion rules were referred to as the </span><em><span class="deltaxml-new" style="background:#90EE90">function conversion</span></em><span class="deltaxml-new" style="background:#90EE90"> rules. The terminology has changed because the rules are not exclusively associated with functions or function calling.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">If the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence()</span></code><span class="deltaxml-new" style="background:#90EE90">, no coercion takes place (the supplied value must be an empty sequence, or a type error occurs).</span></p><p><span class="deltaxml-new" style="background:#90EE90">In all other cases, the required </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> comprises a required </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> and an optional occurrence indicator. The coercion rules are then applied to a supplied value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> and the required type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> as follows:</span></p><ol class="enumar"><li class="xpath"><p><span class="deltaxml-new" style="background:#90EE90">If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is not an instance of the required type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, then the conversions defined in </span><a href="#id-xpath-10-compatibility"><b><span class="deltaxml-new" style="background:#90EE90">3.4.1 XPath 1.0 Compatibility Rules</span></b></a><span class="deltaxml-new" style="background:#90EE90"> are applied to </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">. Then:</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each item in </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is processed against the required item type </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> using the item coercion rules defined in </span><a href="#id-item-coercion-rules"><b><span class="deltaxml-new" style="background:#90EE90">3.4.2 Item Coercion Rules</span></b></a><span class="deltaxml-new" style="background:#90EE90">, and the results are sequence-concatenated into a single sequence </span><var><span class="deltaxml-new" style="background:#90EE90">V′</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A type error is raised if the cardinality of </span><var><span class="deltaxml-new" style="background:#90EE90">V′</span></var><span class="deltaxml-new" style="background:#90EE90"> does not match the required cardinality of </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><div class="xpath"><div class="div3 xpath"><h4><a id="id-xpath-10-compatibility"></a><span class="deltaxml-new" style="background:#90EE90">3.4.1 XPath 1.0 Compatibility Rules</span></h4><p><span class="deltaxml-new" style="background:#90EE90">These rules are used to process a value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> against a required sequence type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> when </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the occurrence indicator of </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is either absent or </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> (examples: </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string?</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic?</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">node()</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">node()?</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">item()?</span></code><span class="deltaxml-new" style="background:#90EE90">), then </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is effectively replaced by </span><code><span class="deltaxml-new" style="background:#90EE90">V[1]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string?</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is effectively replaced by </span><code><span class="deltaxml-new" style="background:#90EE90">fn:string(V)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This rule does not apply where </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string?</span></code><span class="deltaxml-new" style="background:#90EE90">, because derived types did not arise in XPath 1.0.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double?</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">V</span></code><span class="deltaxml-new" style="background:#90EE90"> is effectively replaced by </span><code><span class="deltaxml-new" style="background:#90EE90">fn:number(V)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This rule does not apply where </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double?</span></code><span class="deltaxml-new" style="background:#90EE90">, because derived types did not arise in XPath 1.0.</span></p></div></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> The special rules for </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> are used for converting the arguments of a static function call, and in certain XSLT constructs. They are not invoked in other contexts such as dynamic function calls, for converting the result of an inline function to its required type, for partial function application, or for implicit function calls such as occur when evaluating functions such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:for-each</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:filter</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div></div><div class="div3"><h4><a id="id-item-coercion-rules"></a><span class="deltaxml-new" style="background:#90EE90">3.4.2 Item Coercion Rules</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The rules in this section are used to process each item </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> in a supplied sequence, given a required </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> (for example, if it is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a><span class="deltaxml-new" style="background:#90EE90">, or an </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration type</span></a><span class="deltaxml-new" style="background:#90EE90">), and </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is not an atomic item, then: </span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is atomized to produce a sequence of atomic items </span><var><span class="deltaxml-new" style="background:#90EE90">JJ</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each atomic item in </span><var><span class="deltaxml-new" style="background:#90EE90">JJ</span></var><span class="deltaxml-new" style="background:#90EE90"> is coerced to the required type </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> by recursive application of the item coercion rules (the rules in this section) to produce a value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result is the sequence-concatenation of the </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> values.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">For example, if </span><code><span class="deltaxml-new" style="background:#90EE90">J</span></code><span class="deltaxml-new" style="background:#90EE90"> is an element with type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">R</span></code><span class="deltaxml-new" style="background:#90EE90"> is the union type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90">, then the effect is to atomize the element to an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, and then to coerce the resulting </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90"> (which leaves the integer unchanged). This is not the same as attempting to coerce the element to each of the alternatives of the union type in turn, which would deliver an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, if </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item type</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a><span class="deltaxml-new" style="background:#90EE90"> (which includes the case where it is an </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration type</span></a><span class="deltaxml-new" style="background:#90EE90">), then:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> matches (is an instance of) one of the alternatives in </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">, then:</span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">If the first alternative in </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> that </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> matches is a typed function test (see </span><a href="#id-function-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.1 Function Test</span></b></a><span class="deltaxml-new" style="background:#90EE90">), then function coercion is applied to coerce </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> to that function type, as described in </span><a href="#id-function-coercion"><b><span class="deltaxml-new" style="background:#90EE90">3.4.4 Function Coercion</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is used as is.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the item coercion rules (the rules in this section) are applied to </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> recursively with </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> set to each of the alternatives in the choice or union item type, in order, until an alternative is found that does not result in a type error; a type error is raised only if all alternatives fail.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The error code used in the event of failure should be the error code arising from the first unsuccessful matching attempt. (The diagnostic information associated with the error may also describe how further attempts failed.)</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Suppose the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:integer | element(e))*</span></code><span class="deltaxml-new" style="background:#90EE90"> and the supplied value is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(&lt;e&gt;22&lt;/e&gt;, 23, &lt;f&gt;24&lt;/f&gt;)</span></code><span class="deltaxml-new" style="background:#90EE90">. Item coercion is applied independently to each of the three items in this sequence. The first item matches one of the alternatives, namely </span><code><span class="deltaxml-new" style="background:#90EE90">element(e)</span></code><span class="deltaxml-new" style="background:#90EE90">, so it is returned unchanged as an element node. The second item (the integer 23) also matches one of the alternatives, and is returned unchanged as an integer. The third item does not match any of the alternatives, so coercion is attempted to each one in turn. Coercion to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> succeeds (by virtue of atomization and untyped atomic conversion), so the final result is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(&lt;e&gt;22&lt;/e&gt;, 23, 24)</span></code></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Suppose the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> and the supplied value is </span><code><span class="deltaxml-new" style="background:#90EE90">"green"</span></code><span class="deltaxml-new" style="background:#90EE90">. The enumeration type is defined as a choice item type whose alternatives are singleton enumerations, so the rules are applied first to the type </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red")</span></code><span class="deltaxml-new" style="background:#90EE90"> (which fails), and then to the type </span><code><span class="deltaxml-new" style="background:#90EE90">enum("green")</span></code><span class="deltaxml-new" style="background:#90EE90"> (which succeeds). The strings in an enumeration type are required to be distinct so the order of checking is in this case immaterial. The supplied value will be accepted, and will be relabeled as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">enum("green")</span></code><span class="deltaxml-new" style="background:#90EE90">, which is treated as a schema type equivalent to a type derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> by restriction.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Schema-defined union types behave in exactly the same way as </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item types.</span></a></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="atomic item" class="termref" href="#dt-atomic-item"><span class="deltaxml-new" style="background:#90EE90">atomic item</span></a><span class="deltaxml-new" style="background:#90EE90">, then:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> then it is used unchanged.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is an instance of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> then:</span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration type</span></a><span class="deltaxml-new" style="background:#90EE90"> then </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90"> then a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0117" title="err:XPTY0117"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0117</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is cast to type </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If there is an entry (</span><var><span class="deltaxml-new" style="background:#90EE90">from</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">to</span></var><span class="deltaxml-new" style="background:#90EE90">) in the following table such that </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">from</span></var><span class="deltaxml-new" style="background:#90EE90">, and </span><var><span class="deltaxml-new" style="background:#90EE90">to</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is cast to type </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="medium"><table style="border:1px solid" class="medium"><caption><span class="deltaxml-new" style="background:#90EE90">Implicit Casting</span></caption><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">from</span></th><th><span class="deltaxml-new" style="background:#90EE90">to</span></th></tr></thead><tbody><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code></td></tr></tbody></table></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The item type in the </span><var><span class="deltaxml-new" style="background:#90EE90">to</span></var><span class="deltaxml-new" style="background:#90EE90"> column must match </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> exactly; however, </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> may belong to a subtype of the type in the </span><var><span class="deltaxml-new" style="background:#90EE90">from</span></var><span class="deltaxml-new" style="background:#90EE90"> column.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90"> will be cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">, but an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> will not be cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> will be cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">, but an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> will not be cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is derived from some primitive atomic type </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><b><span class="deltaxml-new" style="background:#90EE90">relabeled</span></b><span class="deltaxml-new" style="background:#90EE90"> as an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> if it satisfies all the following conditions:</span></p><ul><li><p><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is not an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum"><span class="deltaxml-new" style="background:#90EE90">datum</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is within the value space of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Relabeling an atomic item changes the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> but not the </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum"><span class="deltaxml-new" style="background:#90EE90">datum</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value 3 can be relabeled as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:unsignedByte</span></code><span class="deltaxml-new" style="background:#90EE90">, because the datum is within the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:unsignedByte</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Relabeling is not the same as casting. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> value 10.1 can be cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, but it cannot be relabeled as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, because its datum not within the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The effect of this rule is that if, for example, a function parameter is declared with an expected type of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">, then a call that supplies the literal value 3 will succeed, whereas a call that supplies -3 will fail.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This differs from previous versions of this specification, where both these calls would fail.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This change allows the arguments of existing functions to be defined with a more precise type. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90"> argument of </span><code><span class="deltaxml-new" style="background:#90EE90">array:get</span></code><span class="deltaxml-new" style="background:#90EE90"> could be defined as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90"> rather than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a union type with members </span><code><span class="deltaxml-new" style="background:#90EE90">xs:negativeInteger</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger)*</span></code><span class="deltaxml-new" style="background:#90EE90"> and the supplied value is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(20, -20)</span></code><span class="deltaxml-new" style="background:#90EE90">, then the effect of these rules is that the first item </span><code><span class="deltaxml-new" style="background:#90EE90">20</span></code><span class="deltaxml-new" style="background:#90EE90"> is relabeled as type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90"> and the second item </span><code><span class="deltaxml-new" style="background:#90EE90">-20</span></code><span class="deltaxml-new" style="background:#90EE90">is relabeled as type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:negativeInteger</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Promotion (for example of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">) occurs only when </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a primitive type. Relabeling occurs only when </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a derived type. Promotion and relabeling are therefore never combined.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A singleton enumeration type such as </span><code><span class="deltaxml-new" style="background:#90EE90">enum("green")</span></code><span class="deltaxml-new" style="background:#90EE90"> is treated as an atomic type derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">; so if the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">"green"</span></code><span class="deltaxml-new" style="background:#90EE90"> is supplied in a context where the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90">, the value will be accepted and will be relabeled as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">enum("green")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a href="#doc-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is a map, then </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is converted to a new map as follows:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">The keys in the supplied map are unchanged.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In any map entry whose key is an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> equal to the name of one of the field declarations in </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">, the corresponding value is converted to the required type defined by that field declaration, by applying the coercion rules recursively (but with XPath 1.0 compatibility mode treated as false).</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">For example, if the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">record(longitude as xs:double, latitude as xs:double)</span></code><span class="deltaxml-new" style="background:#90EE90"> and the supplied value is </span><code><span class="deltaxml-new" style="background:#90EE90">{ "longitude": 0, "latitude": 53.2 }</span></code><span class="deltaxml-new" style="background:#90EE90">, then the map is converted to </span><code><span class="deltaxml-new" style="background:#90EE90">{ "longitude": 0.0e0, "latitude": 53.2e0 }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a href="#doc-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is a function item, then </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Function coercion applies even if </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is already an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Maps and arrays are functions, so function coercion applies to them as well.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If, after the above conversions, the resulting item does not match the expected item type </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> according to the rules for </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType Matching</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Under the general rules for type errors (see </span><a href="#id-kinds-of-errors"><b><span class="deltaxml-new" style="background:#90EE90">2.4.1 Kinds of Errors</span></b></a><span class="deltaxml-new" style="background:#90EE90">), a processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> report a type error during static analysis if it will necessarily occur when the expression is evaluated. For example, the function call </span><code><span class="deltaxml-new" style="background:#90EE90">fn:abs("beer")</span></code><span class="deltaxml-new" style="background:#90EE90"> will necessarily fail when evaluated, because the function requires a numeric value as its argument; this </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be detected and reported as a static error.</span></p></div></li></ol></div><div class="div3"><h4><a id="id-implausible-coercions"></a><span class="deltaxml-new" style="background:#90EE90">3.4.3 Implausible Coercions</span></h4><p><span class="deltaxml-new" style="background:#90EE90">An expression is deemed to be </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0006" title="err:XPTY0006"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0006</span></a><span class="deltaxml-new" style="background:#90EE90">] if the static type of the expression, after applying all necessary coercions, is </span><b><span class="deltaxml-new" style="background:#90EE90">substantively disjoint</span></b><span class="deltaxml-new" style="background:#90EE90"> with the required type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-substantively-disjoint" title="substantively disjoint"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Two </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90"> are deemed to be </span><b><span class="deltaxml-new" style="background:#90EE90">substantively disjoint</span></b><span class="deltaxml-new" style="background:#90EE90"> if (a) neither is a subtype of the other (see </span><a href="#id-seqtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.1 Subtypes of Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">) and (b) the only values that are instances of both types are one or more of the following: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The empty sequence, </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The empty map, </span><code><span class="deltaxml-new" style="background:#90EE90">{}</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The empty array, </span><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="closetermdef"><p><span class="deltaxml-new" style="background:#90EE90">]</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Examples of pairs of sequence types that are substantively disjoint include:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:integer*</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string*</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">map(xs:integer, node())</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">map(xs:string, node())</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array(xs:integer)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">array(xs:string)</span></code></p></li></ul></div><p><span class="deltaxml-new" style="background:#90EE90">For example, supplying a value whose static type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer*</span></code><span class="deltaxml-new" style="background:#90EE90"> when the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string*</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90">, because it can succeed only in the special case where the actual value supplied is an empty sequence.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The case where the supplied type and the required type are completely disjoint (for example </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">array(*)</span></code><span class="deltaxml-new" style="background:#90EE90">) is covered by the general rules for type errors: that case can always be reported as a static error.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Examples of implausible coercions include the following:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">round(timezone-from-time($now))</span></code><span class="deltaxml-new" style="background:#90EE90">. The result of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:timezone-from-time</span></code><span class="deltaxml-new" style="background:#90EE90"> is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration?</span></code><span class="deltaxml-new" style="background:#90EE90">, which is substantively disjoint with the required type of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:round</span></code><span class="deltaxml-new" style="background:#90EE90">, namely </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric?</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function($x as xs:integer) as array(xs:string) { array { 1 to $x } }</span></code><span class="deltaxml-new" style="background:#90EE90">. The type of the function body is </span><code><span class="deltaxml-new" style="background:#90EE90">array(xs:integer)</span></code><span class="deltaxml-new" style="background:#90EE90">, which is substantively disjoint with the required type </span><code><span class="deltaxml-new" style="background:#90EE90">array(xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">: the function can succeed only in the exceptional case where the function body delivers an empty array.</span></p></li></ul></div><div class="div3"><h4><a id="id-function-coercion"></a><span class="deltaxml-new" style="background:#90EE90">3.4.4 Function Coercion</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-numeric-literals"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Function coercion now allows a function with arity </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> to be supplied where a function of arity greater than </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is expected. For example this allows the function </span><code><span class="deltaxml-new" style="background:#90EE90">true#0</span></code><span class="deltaxml-new" style="background:#90EE90"> to be supplied where a predicate function is required. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> It has been clarified that function coercion applies even when the supplied function item matches the required function type. This is to ensure that arguments supplied when calling the function are checked against the signature of the required function type, which might be stricter than the signature of the supplied function item. </span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> Function coercion is a transformation applied to </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function items</span></a><span class="deltaxml-new" style="background:#90EE90"> during application of the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-function-coercion" title="function coercion"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Function coercion</span></b><span class="deltaxml-new" style="background:#90EE90"> wraps a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Given a function </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">, and an expected function type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> proceeds as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> has higher arity than </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> has lower arity than </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> is wrapped in a new function that declares and ignores the additional argument; the following steps are then applied to this new function.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, if </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">function(node(), xs:boolean) as xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, and the supplied function is </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name#1</span></code><span class="deltaxml-new" style="background:#90EE90">, then the supplied function is effectively replaced by </span><code><span class="deltaxml-new" style="background:#90EE90">function($n as node(), $b as xs:boolean) as xs:string {fn:name($n)}</span></code></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This mechanism makes it easier to design versatile and extensible higher-order functions. For example, in previous versions of this specification, the second argument of the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:filter</span></code><span class="deltaxml-new" style="background:#90EE90"> function expected an argument of type </span><code><span class="deltaxml-new" style="background:#90EE90">function(item()) as xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">. This has now been extended to </span><code><span class="deltaxml-new" style="background:#90EE90">function(item(), xs:integer) as xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, but existing code continues to work, because callback functions that are not interested in the value of the second argument simply ignore it. </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] if, for any parameter type, or for the result type, the relevant type in the signature of the supplied function and the relevant type in the expected function type are </span><a title="substantively disjoint" class="termref" href="#dt-substantively-disjoint"><span class="deltaxml-new" style="background:#90EE90">substantively disjoint</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> are substantively disjoint, so a function with signature </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:integer) as xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> cannot be supplied where the expected type is </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:string) as xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Function coercion then returns a new </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> with the following properties (as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-new" style="background:#90EE90">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">): </span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">name</span></b><span class="deltaxml-new" style="background:#90EE90">: The name of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span><span class="deltaxml-new" style="background:#90EE90">(if not absent)</span></span><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">identity</span></b><span class="deltaxml-new" style="background:#90EE90">: A new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">See also </span><a href="#id-function-identity"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.7 Function Identity</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">parameter names</span></b><span class="deltaxml-new" style="background:#90EE90">: The parameter names of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">signature</span></b><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">Annotations</span></code><span class="deltaxml-new" style="background:#90EE90"> is set to the annotations of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">. </span><code><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></code><span class="deltaxml-new" style="background:#90EE90"> is set to the expected type. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">implementation</span></b><span class="deltaxml-new" style="background:#90EE90">: In effect, a </span><code><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></code><span class="deltaxml-new" style="background:#90EE90"> that calls </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">, passing it the parameters of this new function, in order. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">nonlocal variable bindings</span></b><span class="deltaxml-new" style="background:#90EE90">: An empty mapping. </span></p></li></ul></li></ol><p><span class="deltaxml-new" style="background:#90EE90"> These rules have the following consequences: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">SequenceType matching of the function’s arguments and result are delayed until that function is called. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When the coerced function is called, the supplied arguments must match the parameter typed defined in </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">; it is not sufficient to match the parameter types defined in </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> rules applied to the function’s arguments and result are defined by the SequenceType it has most recently been coerced to. Additional coercion rules could apply when the wrapped function is called. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If an implementation has static type information about a function, that can be used to type check the function’s argument and return types during static analysis. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When function coercion is applied to a map or an array, the resulting function is not a map or array, and cannot be used as such. For example, the expression </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $f as function(xs:integer) as xs:boolean := { 0: false(), 1: true() }
return $f?0</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">raises a type error, because a lookup expression requires the left hand operand to be a map or array, and </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> is neither.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When function types are used as alternatives in a </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item type</span></a><span class="deltaxml-new" style="background:#90EE90">, the supplied function is coerced to the first alternative for which coercion does not raise a type error. In this situation it is important to write the alternatives in order, with the most specific first. </span></p></li></ul><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> For instance, consider the following query: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:filter(
  $s as item()*, 
  $p as function(xs:string) as xs:boolean
) as item()* {
  $s[$p(.)]
};
let $f := function($a) { starts-with($a, "E") }
return local:filter(("Ethel", "Enid", "Gertrude"), $f)</span></pre></div></div></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> The function </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> has a static type of </span><code><span class="deltaxml-new" style="background:#90EE90">function(item()*) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90">. When the </span><code><span class="deltaxml-new" style="background:#90EE90">local:filter()</span></code><span class="deltaxml-new" style="background:#90EE90"> function is called, the following occurs to the function: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> result in applying </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">, wrapping $f in a new function (</span><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90">) with the signature </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:string) as xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90"> is matched against the SequenceType of </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:string) as xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, and succeeds. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> When </span><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90"> is called inside the predicate, </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> and SequenceType matching rules are applied to the context value argument, resulting in an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> value or a type error. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> is called with the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, which returns an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90"> applies </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> to the result sequence from </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">, which already matches its declared return type of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ol></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> The semantics of </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> are specified in terms of wrapping the functions. Static typing may be able to reduce the number of places where this is actually necessary. However, it cannot be assumed that because a supplied function is an instance of the required function type, no function coercion is necessary: the supplied function might not perform all required checks on the types of its arguments. </span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Since maps and arrays are also functions in XQuery 4.0 and XPath 4.0, </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> applies to them as well. For instance, consider the following expression: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $m := {
  "Monday" : true(),
  "Wednesday" : false(),
  "Friday" : true()
}
let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
return filter($days, $m)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> The map </span><code><span class="deltaxml-new" style="background:#90EE90">$m</span></code><span class="deltaxml-new" style="background:#90EE90"> is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">function(xs:anyAtomicType?) as item()*</span></code><span class="deltaxml-new" style="background:#90EE90">. When the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:filter()</span></code><span class="deltaxml-new" style="background:#90EE90"> function is called, the following occurs to the map: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The map </span><code><span class="deltaxml-new" style="background:#90EE90">$m</span></code><span class="deltaxml-new" style="background:#90EE90"> is treated as a function equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">map:get($m, ?)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> result in applying </span><a title="function coercion" class="termref" href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> to this function, wrapping it in a new function (</span><var><span class="deltaxml-new" style="background:#90EE90">M′</span></var><span class="deltaxml-new" style="background:#90EE90">) with the signature </span><code><span class="deltaxml-new" style="background:#90EE90">function(item(), xs:integer) as xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When </span><var><span class="deltaxml-new" style="background:#90EE90">M′</span></var><span class="deltaxml-new" style="background:#90EE90"> is called by </span><code><span class="deltaxml-new" style="background:#90EE90">fn:filter()</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion</span></a><span class="deltaxml-new" style="background:#90EE90"> and SequenceType matching rules are applied to the argument, resulting in an </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90"> value (</span><code><span class="deltaxml-new" style="background:#90EE90">$a</span></code><span class="deltaxml-new" style="background:#90EE90">) or a type error.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The function </span><code><span class="deltaxml-new" style="background:#90EE90">map:get($m, ?)</span></code><span class="deltaxml-new" style="background:#90EE90"> is called with </span><code><span class="deltaxml-new" style="background:#90EE90">$a</span></code><span class="deltaxml-new" style="background:#90EE90"> as the argument; this returns either an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> or the empty sequence (call the result </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The wrapper function </span><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90"> applies the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> to </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90">. If </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> the matching succeeds. When it is an empty sequence (in particular, </span><code><span class="deltaxml-new" style="background:#90EE90">$m</span></code><span class="deltaxml-new" style="background:#90EE90"> does not contain a key for </span><code><span class="deltaxml-new" style="background:#90EE90">"Tuesday"</span></code><span class="deltaxml-new" style="background:#90EE90">), a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">], since the expected type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> and the actual type is an empty sequence.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Consider the following expression: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">
let $m := {
   "Monday" : true(),
   "Wednesday" : false(),
   "Friday" : true(),
}
let $days := ("Monday", "Wednesday", "Friday")
return filter($days, $m)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">In this case the result of the expression is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">("Monday", "Friday")</span></code><span class="deltaxml-new" style="background:#90EE90">. But if the input sequence included the string </span><code><span class="deltaxml-new" style="background:#90EE90">"Tuesday"</span></code><span class="deltaxml-new" style="background:#90EE90">, the filter operation would fail with a type error. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Function coercion applies even if the supplied function matches the required type.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, consider this case:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:filter(
  $s as item()*, 
  $p as function(xs:string) as xs:boolean
) as item()* {
  $s[$p(.)]
};

let $f := function($a) { $a mod 2 = 0 }
return local:filter(1 to 10, $f)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Here the supplied function </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> is an instance of the required type, because its signature defaults the argument type to </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a supertype of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">. The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$s[$p(.)]</span></code><span class="deltaxml-new" style="background:#90EE90"> could in principle succeed. However, function coercion ensures that the supplied function is wrapped in a function that requires the argument to be of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, so the call fails with a type error when the wrapping function is invoked supplying an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> as the argument.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">This has the consequence that in XQuery 4.0, there is a backwards incompatibility introduced because coercion rules now apply to global variable declarations (</span><code><span class="deltaxml-new" style="background:#90EE90">declare variable</span></code><span class="deltaxml-new" style="background:#90EE90">) and local variable bindings (for example </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses). Previously the following would execute without error:</span></p></div><div class="xquery"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $f as function(xs:integer) as item()* := function($x) { $x + 1 }
return $f(12.3)</span></pre></div></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">With XQuery 4.0, as a consequence of function coercion, this fails with a type error because the argument supplied in the function call is not of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div></div><div class="div3"><h4><a id="id-coercion-examples"></a><span class="deltaxml-new" style="background:#90EE90">3.4.5 Examples of Coercions</span></h4><p><span class="deltaxml-new" style="background:#90EE90">This section illustrates the effect of the coercion rules with examples.</span></p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-string"></a><span class="deltaxml-new" style="background:#90EE90">Example: Coercion to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code></div><p><span class="deltaxml-new" style="background:#90EE90">Consider the case where the required type (of a variable, or a function argument) is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">. For example, the second argument of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:matches</span></code><span class="deltaxml-new" style="background:#90EE90">, which expects a regular expression. The table below illustrates the values that might be supplied, and the coercions that are applied.</span></p><div class="medium"><table class="medium"><thead><tr><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Supplied Value</span></th><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Coercion</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">"[0-9]"</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">None; the supplied value is an instance of the required type.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">default-language()</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">None; the supplied value is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:language</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a subtype of the required type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;[0-9]&lt;/a&gt;</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied element node is atomized. Unless it has been schema-validated, the typed value will be an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, which is accepted when the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Supplying an element whose type annotation is (say) </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90"> will fail with a type error.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The effect is subtly different if XPath 1.0 compatibility mode is enabled. In this case coercion takes the string value of the element node. This differs from the typed value only in the case where the element has been schema-validated and has a type annotation other than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI("urn:dummy")</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Supplying an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> where the expected type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> is permitted; this is one of the pairs of types where implicit casting is allowed.</span></p></td></tr><tr class="xpath"><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">17.2</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Supplying a number where a string is expected raises a type error.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">However, if XPath 1.0 compatibility mode is enabled, the number is converted to a string as if by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:string</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p></div></td></tr><tr class="xpath"><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">//author/@id</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Supplying a sequence of nodes where a single string is expected will raise a type error unless either there is only one node in the sequence. In this case the typed value of the node will be used (this must be of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">If XPath 1.0 compatibility mode is enabled, however, all strings after the first are discarded, and the string value of the first node is used; if the sequence is empty, a zero-length string is supplied.</span></p></div></td></tr><tr class="xpath"><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">("red", "green", "blue")</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Supplying a sequence of strings where a single string is expected raises a type error.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">If XPath 1.0 compatibility mode is enabled, however, all strings after the first are discarded; the effect is as if the supplied value were </span><code><span class="deltaxml-new" style="background:#90EE90">"red"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></td></tr><tr class="xpath"><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Supplying an empty sequence where a single string is expected will fail.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">If XPath 1.0 compatibility mode is enabled, however, the value is coerced by applying the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:string(())</span></code><span class="deltaxml-new" style="background:#90EE90">, which delivers the zero-length string.</span></p></div></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">["a|b"]</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Supplying an array holding a single string succeeds, because the rules cause the array to be atomized, and the value after atomization is a single string.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Supplying an array holding multiple strings would fail.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">In XPath 1.0 compatibility mode, supplying an array will fail, regardless of the array contents, because the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:string</span></code><span class="deltaxml-new" style="background:#90EE90"> function does not accept arrays.</span></p></div></td></tr></tbody></table></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-decimal"></a><span class="deltaxml-new" style="background:#90EE90">Example: Coercion to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal?</span></code></div><p><span class="deltaxml-new" style="background:#90EE90">Consider the case where the required type (of a variable, or a function argument) is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal?</span></code><span class="deltaxml-new" style="background:#90EE90">. For example, the first argument of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:seconds</span></code><span class="deltaxml-new" style="background:#90EE90">, which expects a decimal number of seconds. The table below illustrates the values that might be supplied, and the coercions that are applied.</span></p><div class="medium"><table class="medium"><thead><tr><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Supplied Value</span></th><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Coercion</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">12.4</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">None; the supplied value is an instance of the required type.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">None; an empty sequence is an instance of the required type.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">42</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">None; the supplied value is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a subtype of the required type.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">math:pi()</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">, which can be converted to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> under the coercion rules.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">("a", "b")[.="c"]</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is an empty sequence, which is a valid instance of the required type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal?</span></code><span class="deltaxml-new" style="background:#90EE90">. However, the processor may (optionally) reject this as an implausible coercion, on the grounds that it can only succeed in one special case, namely where the filter expression selects no values. </span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">(1.5, 2.5, 3.5)</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">A type error is raised</span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">, except in the case where XPath 1.0 compatibility is enabled, in which case all values after the first are discarded</span></span></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;3.14159&lt;/a&gt;</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The element node is atomized; unless it has been schema-validated, the result will be </span><code><span class="deltaxml-new" style="background:#90EE90">"3.14159"</span></code><span class="deltaxml-new" style="background:#90EE90"> as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. This is converted to an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> following the rules of the </span><code><span class="deltaxml-new" style="background:#90EE90">cast as</span></code><span class="deltaxml-new" style="background:#90EE90"> operator.</span></p></td></tr><tr class="xpath"><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">"12.2"</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Supplying a string where an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> is a type error</span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">, even if XPath 1.0 compatibility mode is enabled. The rules for compatibility mode would allow conversion if the required type were </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">, but not for </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></span></span><span class="deltaxml-new" style="background:#90EE90">. </span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">[1.5]</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The array is atomized, and the result is a valid instance of the required type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal?</span></code></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The array is atomized, and the result is an empty sequence, which is a valid instance of the required type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal?</span></code></p></td></tr></tbody></table></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-positive-integer"></a><span class="deltaxml-new" style="background:#90EE90">Example: Coercion to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positive-integer</span></code></div><p><span class="deltaxml-new" style="background:#90EE90">Consider the case where the required type (of a variable, or a function argument) is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positive-integer</span></code><span class="deltaxml-new" style="background:#90EE90">. The table below illustrates the values that might be supplied, and the coercions that are applied.</span></p><div class="medium"><table class="medium"><thead><tr><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Supplied Value</span></th><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Coercion</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">12</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. Because the supplied value and the required type, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">, both come under the primitive type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, and the value </span><code><span class="deltaxml-new" style="background:#90EE90">12</span></code><span class="deltaxml-new" style="background:#90EE90"> is within the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">, the value is relabeled as an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90"> and the call succeeds.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">12.1</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">This fails with a type error, because the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">12.1</span></code><span class="deltaxml-new" style="background:#90EE90"> is not a value in the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">. This is so even though casting to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90"> would succeed.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">math:pi()</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">This fails with a type error. A value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> is accepted where the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, but not where it is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;1200&lt;/a&gt;</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied element node is atomized. If the element has not been schema-validated, the result will be an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> item, which is successfully cast to the required type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">. If the element has been validated against a schema, then coercion succeeds if the typed value would itself be acceptable, for example if it is an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">, or some other </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> within the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr></tbody></table></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-union"></a><span class="deltaxml-new" style="background:#90EE90">Example: Coercion to a union type</span></div><p><span class="deltaxml-new" style="background:#90EE90">Consider the first parameter of the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:char</span></code><span class="deltaxml-new" style="background:#90EE90">, whose declared type is </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:string | xs:positiveInteger)</span></code><span class="deltaxml-new" style="background:#90EE90">. The rules are the same as if it were a union typed declared in an imported schema.</span></p><div class="medium"><table class="medium"><thead><tr><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Supplied Value</span></th><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Coercion</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">"amp"</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, which is one of the allowed types. The call therefore succeeds.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">"#"</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, which is one of the allowed types. As far as the coercion rules are concerned, the call therefore succeeds. Under the semantic rules for the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:char</span></code><span class="deltaxml-new" style="background:#90EE90"> function, however, this value is not accepted; a dynamic error (as distinct from a type error) is therefore raised.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">0x25</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. Although this is not one of the allowed types, it is acceptable because coercion of the value to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90"> succeeds. The value is relabeled as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;0x25&lt;/a&gt;</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied element node is atomized. Assuming that the node has not been schema-validated, the result is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. The member types of the choice are tested in order. Conversion to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> with the value "0x25" succeeds, so the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:char</span></code><span class="deltaxml-new" style="background:#90EE90"> function is called supplying this string; but the function rejects this string as semantically invalid. The same would happen if the value were, say, &lt;a&gt;37&lt;/a&gt;. Supplying such a value requires an explicit cast, for example </span><code><span class="deltaxml-new" style="background:#90EE90">fn:char( xs:positiveInteger( ./a ))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr></tbody></table></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-choice"></a><span class="deltaxml-new" style="background:#90EE90">Example: Coercion to a choice type</span></div><p><span class="deltaxml-new" style="background:#90EE90">Suppose the required type is </span><code><span class="deltaxml-new" style="background:#90EE90">(record(x as xs:decimal, y as xs:decimal, *) | record(size as enum("S", "M", "L", "XL"), *))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="medium"><table class="medium"><thead><tr><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Supplied Value</span></th><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Coercion</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">{"x":1, "y":2, "z":3}</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is an instance of the first record type: no coercion is necessary.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">{"size":"M"}</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is an instance of the second record type: no coercion is necessary.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">{"x":1, "y":2, "size":"XL"}</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is an instance of both record types: no coercion is necessary.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">{"x":1.0e0, "y":2.0e0, "size":"XL"}</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is not an instance of the first record type because the fields are of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> rather than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">. It is however an instance of the second record type. It is therefore accepted </span><em><span class="deltaxml-new" style="background:#90EE90">as is</span></em><span class="deltaxml-new" style="background:#90EE90">; the fields </span><code><span class="deltaxml-new" style="background:#90EE90">x</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">y</span></code><span class="deltaxml-new" style="background:#90EE90"> are not converted from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">{"x":1.0e0, "y":2.0e0, "size":"XXL"}</span></code></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">The supplied value is not an instance of the first record type because the fields are of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> rather than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, and it is not an instance of the second record type because the </span><code><span class="deltaxml-new" style="background:#90EE90">size</span></code><span class="deltaxml-new" style="background:#90EE90"> value does not match the enumeration type. Coercion is therefore attempted to the first record type, and succeeds. The </span><code><span class="deltaxml-new" style="background:#90EE90">x</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">y</span></code><span class="deltaxml-new" style="background:#90EE90"> fields are coerced to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, and the </span><code><span class="deltaxml-new" style="background:#90EE90">size</span></code><span class="deltaxml-new" style="background:#90EE90"> field is accepted </span><em><span class="deltaxml-new" style="background:#90EE90">as is</span></em><span class="deltaxml-new" style="background:#90EE90">.</span></p></td></tr></tbody></table></div></div></div></div><div class="div2"><h3><a id="id-predefined-types"></a><span class="deltaxml-new" style="background:#90EE90">3.5 Schema Types</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-schema-type" title="schema type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">schema type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a complex type or simple type as defined in the </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> specifications, including built-in types as well as user-defined types.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Every schema type is either a </span><b><span class="deltaxml-new" style="background:#90EE90">complex type</span></b><span class="deltaxml-new" style="background:#90EE90"> or a </span><b><span class="deltaxml-new" style="background:#90EE90">simple type</span></b><span class="deltaxml-new" style="background:#90EE90">; simple types are further subdivided into </span><b><span class="deltaxml-new" style="background:#90EE90">list types</span></b><span class="deltaxml-new" style="background:#90EE90">, </span><b><span class="deltaxml-new" style="background:#90EE90">union types</span></b><span class="deltaxml-new" style="background:#90EE90">, and </span><b><span class="deltaxml-new" style="background:#90EE90">atomic types</span></b><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> for definitions and explanations of these terms.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">A schema type can appear as a type annotation on an element or attribute node. The type annotation on an element node can be a complex type or a simple type; the type annotation on an attribute node is always a simple type. Non-instantiable types such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90"> never appear as type annotations, but their derived types can be so used. Union types never appear as type annotations; when an element or attribute is validated against a union type, the resulting type annotation will be one of the types in the transitive membership of the union type.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-atomic-type" title="atomic type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">atomic type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a simple </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><span class="deltaxml-new" style="background:#90EE90"> whose </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">atomic</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">atomic type</span></b><span class="deltaxml-new" style="background:#90EE90"> is either a built-in atomic type (defined either in the XSD specification or in this specification), or it is a user-defined atomic type included in an imported schema.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> are initialized with a set of predefined schema types that is determined by the host language. This set may include some or all of the schema types in the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema</span></code><span class="deltaxml-new" style="background:#90EE90">, represented in this document by the namespace prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90">. The schema types in this namespace are defined in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> and augmented by additional types defined in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. An implementation that has based its type system on </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> is not required to support the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dateTimeStamp</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> types.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The schema types defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types-predefined"><span class="deltaxml-new" style="background:#90EE90">Section 2.8.3 Predefined Types</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> are summarized below.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> are initialized with certain predefined schema types, including the built-in schema types in the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema</span></code><span class="deltaxml-new" style="background:#90EE90">, which has the predefined namespace prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90">. The schema types in this namespace are defined in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> and augmented by additional types defined in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. Element and attribute declarations in the </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace are not implicitly included in the static context. The schema types defined in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> are summarized below.</span></p></div><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-untyped" title="xs:untyped"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> is used as the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of an element node that has not been validated, or has been validated in </span><code><span class="deltaxml-new" style="background:#90EE90">skip</span></code><span class="deltaxml-new" style="background:#90EE90"> mode.] No predefined schema types are derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-untypedAtomic" title="xs:untypedAtomic"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.] An attribute that has been validated in </span><code><span class="deltaxml-new" style="background:#90EE90">skip</span></code><span class="deltaxml-new" style="background:#90EE90"> mode is represented in the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90"> by an attribute node with the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. No predefined schema types are derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dayTimeDuration" title="xs:dayTimeDuration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></code><span class="deltaxml-new" style="background:#90EE90">. The lexical representation of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is restricted to contain only day, hour, minute, and second components.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-yearMonthDuration" title="xs:yearMonthDuration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></code><span class="deltaxml-new" style="background:#90EE90">. The lexical representation of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is restricted to contain only year and month components.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-anyAtomicType" title="xs:anyAtomicType"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> that includes all atomic items (and no values that are not atomic). Its base type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anySimpleType</span></code><span class="deltaxml-new" style="background:#90EE90"> from which all simple types, including atomic, list, and union types, are derived. All primitive atomic types, such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, have </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90"> as their base type.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90"> will not appear as the type of an actual value in an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-xs-error" title="xs:error"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> is a simple type with no value space. It is defined in </span><a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error"><span class="deltaxml-new" style="background:#90EE90">Section 3.16.7.3 xs:error </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-1</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> and can be used in the </span><a href="#id-sequencetype-syntax"><b><span class="deltaxml-new" style="background:#90EE90">3.1 Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90"> to raise errors.] </span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The relationships among the schema types in the </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace are illustrated in Figure 2. A more complete description of the XQuery 4.0 and XPath 4.0 type hierarchy can be found in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#datatypes"><span class="deltaxml-new" style="background:#90EE90">Section 1.8 Type System</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><span class="deltaxml-new-img"><img style="border: 2px solid green" src="types.jpg" alt="Type Hierarchy Diagram"></span><p><span class="deltaxml-new" style="background:#90EE90">Figure 2: Hierarchy of Schema Types used in XQuery 4.0 and XPath 4.0.</span></p></div></div><div class="div1"><h2><a id="id-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4 Expressions</span></h2><p><span class="deltaxml-new" style="background:#90EE90">This section discusses each of the basic kinds of expression. Each kind of expression has a name such as </span><code><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></code><span class="deltaxml-new" style="background:#90EE90">, which is introduced on the left side of the grammar production that defines the expression. Since XQuery 4.0 and XPath 4.0 is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions. For the complete grammar, see Appendix [</span><a href="#nt-bnf"><b><span class="deltaxml-new" style="background:#90EE90">A XQuery 4.0 and XPath 4.0 Grammar</span></b></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">The highest-level symbol in the XPath grammar is XPath.</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-query" title="query"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">query</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of one or more </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">modules</span></a><span class="deltaxml-new" style="background:#90EE90">.] If a query is executable, one of its modules has a </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a><span class="deltaxml-new" style="background:#90EE90"> containing an expression whose value is the result of the query. An expression is represented in the XQuery grammar by the symbol </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-XPath" id="doc-xpath40-XPath"></a><span class="deltaxml-new" style="background:#90EE90">[1]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-XPath"><span class="deltaxml-new" style="background:#90EE90">XPath</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Expr" id="doc-xpath40-Expr"></a><span class="deltaxml-new" style="background:#90EE90">[45]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StandaloneExpr" id="doc-xpath40-StandaloneExpr"></a><span class="deltaxml-new" style="background:#90EE90">[46]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ExprSingle" id="doc-xpath40-ExprSingle"></a><span class="deltaxml-new" style="background:#90EE90">[47]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-FLWORExpr"><span class="deltaxml-new" style="background:#90EE90">FLWORExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-SwitchExpr"><span class="deltaxml-new" style="background:#90EE90">SwitchExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-TypeswitchExpr"><span class="deltaxml-new" style="background:#90EE90">TypeswitchExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">IfExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-TryCatchExpr"><span class="deltaxml-new" style="background:#90EE90">TryCatchExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-OrExpr"><span class="deltaxml-new" style="background:#90EE90">OrExpr</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The XQuery 4.0 and XPath 4.0 operator that has lowest precedence is the </span><a title="comma operator" class="termref" href="#dt-comma-operator"><span class="deltaxml-new" style="background:#90EE90">comma operator</span></a><span class="deltaxml-new" style="background:#90EE90">, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (</span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">) can consist of multiple </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> operands, separated by commas. A </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> in turn is either an </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a href="#doc-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The presence of </span><a href="#doc-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> at this level of the grammar allows the </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword of a map constructor expression to be omitted if the expression appears in a context where this creates no ambiguity. See </span><a href="#id-map-constructors"><b><span class="deltaxml-new" style="background:#90EE90">4.14.1.1 Map Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for details.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The name </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> denotes an expression that does not contain a top-level </span><a title="comma operator" class="termref" href="#dt-comma-operator"><span class="deltaxml-new" style="background:#90EE90">comma operator</span></a><span class="deltaxml-new" style="background:#90EE90"> (despite its name, an </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> may evaluate to a sequence containing more than one item.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">The symbols </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> are used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be a </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, because commas are used to separate the arguments of a function call.</span></p><p><span class="deltaxml-new" style="background:#90EE90">After the comma, the expressions that have next lowest precedence are </span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-FLWORExpr"><span class="deltaxml-new" style="background:#90EE90">FLWORExpr</span></a><span class="deltaxml-new" style="background:#90EE90">,</span></span></span><span class="xpath"><span class="xpath"><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, </span></span></span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-SwitchExpr"><span class="deltaxml-new" style="background:#90EE90">SwitchExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-TypeswitchExpr"><span class="deltaxml-new" style="background:#90EE90">TypeswitchExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, </span></span></span><a href="#doc-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">IfExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-TryCatchExpr"><span class="deltaxml-new" style="background:#90EE90">TryCatchExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, </span></span></span><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-OrExpr"><span class="deltaxml-new" style="background:#90EE90">OrExpr</span></a><span class="deltaxml-new" style="background:#90EE90">. Each of these expressions is described in a separate section of this document.</span></p><div class="div2"><h3><a id="comments"></a><span class="deltaxml-new" style="background:#90EE90">4.1 Comments</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Comment" id="doc-xpath40-Comment"></a><span class="deltaxml-new" style="background:#90EE90">[283]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(:" (</span><a href="#doc-xpath40-CommentContents"><span class="deltaxml-new" style="background:#90EE90">CommentContents</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90">)* ":)"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-comments"><span class="deltaxml-new" style="background:#90EE90">gn: comments</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CommentContents" id="doc-xpath40-CommentContents"></a><span class="deltaxml-new" style="background:#90EE90">[296]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CommentContents"><span class="deltaxml-new" style="background:#90EE90">CommentContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">+ - (Char* ('(:' | ':)') Char*))</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Comments may be used to provide information relevant to programmers who read </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query, either in the </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> or in the </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">. Comments are lexical constructs only, and do not affect </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expression</span></span></span><span class="deltaxml-new" style="background:#90EE90"> processing.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Comments are strings, delimited by the symbols </span><code><span class="deltaxml-new" style="background:#90EE90">(:</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">:)</span></code><span class="deltaxml-new" style="background:#90EE90">. Comments may be nested.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A comment may be used anywhere </span><a title="ignorable whitespace" class="termref" href="#IgnorableWhitespace"><span class="deltaxml-new" style="background:#90EE90">ignorable whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> is allowed (see </span><a href="#DefaultWhitespaceHandling"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5.1 Default Whitespace Handling</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following is an example of a comment:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(: Houston, we have a problem :)</span></pre></div></div><div class="div2"><h3><a id="id-primary-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.2 Primary Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-primary-expression" title="primary expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Primary expressions</span></b><span class="deltaxml-new" style="background:#90EE90"> are the basic primitives of the language. They include literals, variable references, context value references, </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">constructors, </span></span></span><span class="deltaxml-new" style="background:#90EE90"> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.] </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Node Constructors are described in </span><a href="#id-constructors"><b><span class="deltaxml-new" style="background:#90EE90">4.12 Node Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="deltaxml-new" style="background:#90EE90">Map and Array Constructors are described in </span><a href="#id-maps-and-arrays"><b><span class="deltaxml-new" style="background:#90EE90">4.14 Maps and Arrays</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">String Constructors are described in </span><a href="#id-string-constructors"><b><span class="deltaxml-new" style="background:#90EE90">4.9.3 String Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PrimaryExpr" id="doc-xpath40-PrimaryExpr"></a><span class="deltaxml-new" style="background:#90EE90">[170]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PrimaryExpr"><span class="deltaxml-new" style="background:#90EE90">PrimaryExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Literal"><span class="deltaxml-new" style="background:#90EE90">Literal</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-ContextValueRef"><span class="deltaxml-new" style="background:#90EE90">ContextValueRef</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-FunctionCall"><span class="deltaxml-new" style="background:#90EE90">FunctionCall</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-OrderedExpr"><span class="deltaxml-new" style="background:#90EE90">OrderedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-UnorderedExpr"><span class="deltaxml-new" style="background:#90EE90">UnorderedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-NodeConstructor"><span class="deltaxml-new" style="background:#90EE90">NodeConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-FunctionItemExpr"><span class="deltaxml-new" style="background:#90EE90">FunctionItemExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-MapConstructor"><span class="deltaxml-new" style="background:#90EE90">MapConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-ArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">ArrayConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-StringConstructor"><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-UnaryLookup"><span class="deltaxml-new" style="background:#90EE90">UnaryLookup</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FunctionItemExpr" id="doc-xpath40-FunctionItemExpr"></a><span class="deltaxml-new" style="background:#90EE90">[209]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionItemExpr"><span class="deltaxml-new" style="background:#90EE90">FunctionItemExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NamedFunctionRef"><span class="deltaxml-new" style="background:#90EE90">NamedFunctionRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-InlineFunctionExpr"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a></code></td></tr></tbody></table><div class="div3"><h4><a id="id-literals"></a><span class="deltaxml-new" style="background:#90EE90">4.2.1 Literals</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Literal" id="doc-xpath40-Literal"></a><span class="deltaxml-new" style="background:#90EE90">[171]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Literal"><span class="deltaxml-new" style="background:#90EE90">Literal</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NumericLiteral"><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-literal" title="literal"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">literal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a direct syntactic representation of an atomic item.] XQuery 4.0 and XPath 4.0 supports two kinds of literals: numeric literals and string literals.</span></p><div class="div4"><h5><a id="id-numeric-literals"></a><span class="deltaxml-new" style="background:#90EE90">4.2.1.1 Numeric Literals</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-filter-expression"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-function-coercion"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Numeric literals can now be written in hexadecimal or binary notation; and underscores can be included for readability. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/429"><span class="deltaxml-new" style="background:#90EE90">429</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/433"><span class="deltaxml-new" style="background:#90EE90">433</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;25 April 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NumericLiteral" id="doc-xpath40-NumericLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[172]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NumericLiteral"><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-BinaryIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-DecimalLiteral"><span class="deltaxml-new" style="background:#90EE90">DecimalLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-DoubleLiteral"><span class="deltaxml-new" style="background:#90EE90">DoubleLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-IntegerLiteral" id="doc-xpath40-IntegerLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[267]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-HexIntegerLiteral" id="doc-xpath40-HexIntegerLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[268]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"0x" </span><a href="#doc-xpath40-HexDigits"><span class="deltaxml-new" style="background:#90EE90">HexDigits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BinaryIntegerLiteral" id="doc-xpath40-BinaryIntegerLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[269]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BinaryIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"0b" </span><a href="#doc-xpath40-BinaryDigits"><span class="deltaxml-new" style="background:#90EE90">BinaryDigits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DecimalLiteral" id="doc-xpath40-DecimalLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[270]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DecimalLiteral"><span class="deltaxml-new" style="background:#90EE90">DecimalLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("." </span><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">) | (</span><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90"> "." </span><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">?)</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DoubleLiteral" id="doc-xpath40-DoubleLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[271]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DoubleLiteral"><span class="deltaxml-new" style="background:#90EE90">DoubleLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(("." </span><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">) | (</span><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90"> ("." </span><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">?)?)) [eE] [+-]? </span><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Digits" id="doc-xpath40-Digits"></a><span class="deltaxml-new" style="background:#90EE90">[290]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> ((</span><a href="#doc-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> | "_")* </span><a href="#doc-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DecDigit" id="doc-xpath40-DecDigit"></a><span class="deltaxml-new" style="background:#90EE90">[291]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">[0-9]</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-HexDigits" id="doc-xpath40-HexDigits"></a><span class="deltaxml-new" style="background:#90EE90">[292]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-HexDigits"><span class="deltaxml-new" style="background:#90EE90">HexDigits</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> ((</span><a href="#doc-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> | "_")* </span><a href="#doc-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-HexDigit" id="doc-xpath40-HexDigit"></a><span class="deltaxml-new" style="background:#90EE90">[293]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">[0-9a-fA-F]</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BinaryDigits" id="doc-xpath40-BinaryDigits"></a><span class="deltaxml-new" style="background:#90EE90">[294]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BinaryDigits"><span class="deltaxml-new" style="background:#90EE90">BinaryDigits</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> ((</span><a href="#doc-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> | "_")* </span><a href="#doc-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BinaryDigit" id="doc-xpath40-BinaryDigit"></a><span class="deltaxml-new" style="background:#90EE90">[295]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">[01]</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The value of a numeric literal is determined as follows (taking the rules in order):</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Underscore characters are stripped out. Underscores may be included in a numeric literal to aid readability, but have no effect on the value. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">1_000_000</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">1000000</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Underscores must not appear at the beginning or end of a sequence of digits, only in intermediate positions. Multiple adjacent underscores are allowed.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></code><span class="deltaxml-new" style="background:#90EE90"> represents a non-negative integer expressed in hexadecimal: for example </span><code><span class="deltaxml-new" style="background:#90EE90">0xffff</span></code><span class="deltaxml-new" style="background:#90EE90"> represents the integer 65535, and </span><code><span class="deltaxml-new" style="background:#90EE90">0xFFFF_FFFF</span></code><span class="deltaxml-new" style="background:#90EE90"> represents the integer 4294967295.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></code><span class="deltaxml-new" style="background:#90EE90"> represents a non-negative integer expressed in binary: for example </span><code><span class="deltaxml-new" style="background:#90EE90">0b101</span></code><span class="deltaxml-new" style="background:#90EE90"> represents the integer 5, and </span><code><span class="deltaxml-new" style="background:#90EE90">0b1111_1111</span></code><span class="deltaxml-new" style="background:#90EE90"> represents the integer 255.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The value of a </span><b><span class="deltaxml-new" style="background:#90EE90">numeric literal</span></b><span class="deltaxml-new" style="background:#90EE90"> containing no </span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90"> and no </span><code><span class="deltaxml-new" style="background:#90EE90">e</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> character is an atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">; the value is obtained by casting from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#casting-from-strings"><span class="deltaxml-new" style="background:#90EE90">Section 20.2 Casting from xs:string and xs:untypedAtomic</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The value of a numeric literal containing </span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90"> but no </span><code><span class="deltaxml-new" style="background:#90EE90">e</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> character is an atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">; the value is obtained by casting from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#casting-from-strings"><span class="deltaxml-new" style="background:#90EE90">Section 20.2 Casting from xs:string and xs:untypedAtomic</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The value of a numeric literal containing an </span><code><span class="deltaxml-new" style="background:#90EE90">e</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> character is an atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">; the value is obtained by casting from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#casting-from-strings"><span class="deltaxml-new" style="background:#90EE90">Section 20.2 Casting from xs:string and xs:untypedAtomic</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The value of a numeric literal is always non-negative. An expression may appear to include a negative number such as </span><code><span class="deltaxml-new" style="background:#90EE90">-1</span></code><span class="deltaxml-new" style="background:#90EE90">, but this is technically an arithmetic expression comprising a unary minus operator followed by a numeric literal.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The effect of the above rules is that in the case of an integer or decimal literal, a dynamic error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAR0002" title="err:FOAR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOAR0002</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> will generally be raised if the literal is outside the range of values supported by the implementation (other options are available: see </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#op.numeric"><span class="deltaxml-new" style="background:#90EE90">Section 4.2 Arithmetic operators on numeric values</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> for details.)</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The limits of numeric datatypes are specified in </span><a href="#id-data-model-conformance"><b><span class="deltaxml-new" style="background:#90EE90">6.3 Data Model Conformance</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The XML Schema specification allows implementations to impose a limit (which must not be less than 18 digits) on the size of integer and decimal values. The full range of values of built-in subtypes of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:long</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:unsignedLong</span></code><span class="deltaxml-new" style="background:#90EE90">, can be supported only if the limit is 20 digits or higher. Negative numbers such as the minimum value of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:long</span></code><span class="deltaxml-new" style="background:#90EE90"> (</span><code><span class="deltaxml-new" style="background:#90EE90">-9223372036854775808</span></code><span class="deltaxml-new" style="background:#90EE90">) are technically unary expressions rather than literals, but implementations may prefer to ensure that they are expressible.</span></p></div></div><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of numeric literals:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">12</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value twelve.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">1_000_000</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value one million.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">12.5</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> value twelve and one half.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">3.14159_26535_89793e0</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> value representing the mathematical constant </span><var><span class="deltaxml-new" style="background:#90EE90">π</span></var><span class="deltaxml-new" style="background:#90EE90"> to 15 decimal places. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">125E2</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> value twelve thousand, five hundred.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">0xffff</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value 65535.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">0b1000_0001</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value 129.</span></p></li></ul></div><div class="div4"><h5><a id="id-string-literal"></a><span class="deltaxml-new" style="background:#90EE90">4.2.1.2 String Literals</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringLiteral" id="doc-xpath40-StringLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[272]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AposStringLiteral"><span class="deltaxml-new" style="background:#90EE90">AposStringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-QuotStringLiteral"><span class="deltaxml-new" style="background:#90EE90">QuotStringLiteral</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AposStringLiteral" id="doc-xpath40-AposStringLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[273]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AposStringLiteral"><span class="deltaxml-new" style="background:#90EE90">AposStringLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"'" (</span><a href="#doc-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EscapeApos"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a><span class="deltaxml-new" style="background:#90EE90"> | [^'&amp;])* "'"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-QuotStringLiteral" id="doc-xpath40-QuotStringLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[274]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QuotStringLiteral"><span class="deltaxml-new" style="background:#90EE90">QuotStringLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">'"' (</span><a href="#doc-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EscapeQuot"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a><span class="deltaxml-new" style="background:#90EE90"> | [^"&amp;])* '"'</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PredefinedEntityRef" id="doc-xpath40-PredefinedEntityRef"></a><span class="deltaxml-new" style="background:#90EE90">[277]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos") ";"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CharRef" id="doc-xpath40-CharRef"></a><span class="deltaxml-new" style="background:#90EE90">[285]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-CharRef"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml#NT-CharRef]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XML</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EscapeQuot" id="doc-xpath40-EscapeQuot"></a><span class="deltaxml-new" style="background:#90EE90">[278]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EscapeQuot"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">'""'</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EscapeApos" id="doc-xpath40-EscapeApos"></a><span class="deltaxml-new" style="background:#90EE90">[279]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EscapeApos"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"''"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The value of a </span><b><span class="deltaxml-new" style="background:#90EE90">string literal</span></b><span class="deltaxml-new" style="background:#90EE90"> is an atomic item whose type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> and whose value is the string denoted by the characters between the delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-predefined-entity-reference" title="predefined entity reference"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">predefined entity reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.] Each predefined entity reference is replaced by the character it represents when the string literal is processed. The predefined entity references recognized by XPath and XQuery are as follows:</span></p></div><div class="xquery"><div class="medium"><table style="width:60%; border:1px solid" class="medium"><tbody><tr><th style="text-align:center"><span class="deltaxml-new" style="background:#90EE90">Entity Reference</span></th><th style="text-align:center"><span class="deltaxml-new" style="background:#90EE90">Character Represented</span></th></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&amp;lt;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&amp;gt;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&amp;amp;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&amp;</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&amp;quot;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">"</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">&amp;apos;</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">'</span></code></td></tr></tbody></table></div></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-character-reference" title="character reference"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">character reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is an XML-style reference to a </span><a href="#Unicode"><span class="deltaxml-new" style="background:#90EE90">[Unicode]</span></a><span class="deltaxml-new" style="background:#90EE90"> character, identified by its decimal or hexadecimal codepoint.] For example, the character </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+20AC</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">EURO SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">€</span></code><span class="deltaxml-new" style="background:#90EE90">) can be represented by the character reference </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#8364;</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#x20ac;</span></code><span class="deltaxml-new" style="background:#90EE90">. Character references are normatively defined in Section 4.1 of the XML specification (it is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> whether the rules in </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> apply.) A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0090" title="err:XQST0090"><span class="deltaxml-new" style="background:#90EE90">err:XQST0090</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised if a character reference does not identify a valid character in the version of XML that is in use.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of string literals:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">"He said, ""I don't like it."""</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a string containing two quotation marks and one apostrophe.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">"Ben &amp;amp; Jerry&amp;apos;s"</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">"Ben &amp; Jerry's"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">"&amp;#8364;99.50"</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">"€99.50"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In XQuery, the string literal </span><code><span class="deltaxml-new" style="background:#90EE90">"&amp;lt;"</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a string of length 1 containing the single character </span><code><span class="deltaxml-new" style="background:#90EE90">"&lt;"</span></code><span class="deltaxml-new" style="background:#90EE90">. In XPath, the string literal </span><code><span class="deltaxml-new" style="background:#90EE90">"&amp;lt;"</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a string of length 4 containing the four characters </span><code><span class="deltaxml-new" style="background:#90EE90">"&amp;"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"l"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"t"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">";"</span></code><span class="deltaxml-new" style="background:#90EE90">. (However, when the XPath expression is embedded in an XML document, the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">"&amp;lt;"</span></code><span class="deltaxml-new" style="background:#90EE90"> will typically have already been converted to </span><code><span class="deltaxml-new" style="background:#90EE90">"&lt;"</span></code><span class="deltaxml-new" style="background:#90EE90"> by the XML parser.)</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">When XPath or XQuery expressions are embedded in contexts where quotation marks have special significance, such as inside XML attributes, or in string literals in a host language such as Java or C#, then additional escaping may be needed.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Fixed string values can also be written as string templates: see </span><a href="#id-string-templates"><b><span class="deltaxml-new" style="background:#90EE90">4.9.2 String Templates</span></b></a><span class="deltaxml-new" style="background:#90EE90">. A string template with no enclosed expressions, such as </span><code><span class="deltaxml-new" style="background:#90EE90">`Jamaica`</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the same value as the string literals </span><code><span class="deltaxml-new" style="background:#90EE90">"Jamaica"</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">'Jamaica'</span></code><span class="deltaxml-new" style="background:#90EE90">. A string template can contain both single and double quotation marks: </span><code><span class="deltaxml-new" style="background:#90EE90">`He said: "I don't like it"`</span></code><span class="deltaxml-new" style="background:#90EE90">. However, there there are some subtle differences:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">In string literals, the treatment of character and entity references such as </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;amp;</span></code><span class="deltaxml-new" style="background:#90EE90"> varies between XQuery and XPath; in string templates, such references are not expanded in either language.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">String templates can only be used where an expression is expected. String literals are also used in some non-expression contexts, for example in defining an enumeration type: see </span><a href="#id-enumeration-types"><b><span class="deltaxml-new" style="background:#90EE90">3.2.6 Enumeration Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Curly braces (</span><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><span class="deltaxml-new" style="background:#90EE90">) and backticks (</span><code><span class="deltaxml-new" style="background:#90EE90">`</span></code><span class="deltaxml-new" style="background:#90EE90">) have a reserved meaning in string templates.</span></p></li></ul></div></div><div class="div4"><h5><a id="id-constants-other-types"></a><span class="deltaxml-new" style="background:#90EE90">4.2.1.3 Constants of Other Types</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> values </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> can be constructed by calls to the </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system functions</span></a><code><span class="deltaxml-new" style="background:#90EE90">fn:true()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:false()</span></code><span class="deltaxml-new" style="background:#90EE90">, respectively. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Values of other simple types can be constructed by calling the </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor function</span></a><span class="deltaxml-new" style="background:#90EE90"> for the given type. The constructor functions for XML Schema built-in types are defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#constructor-functions-for-xsd-types"><span class="deltaxml-new" style="background:#90EE90">Section 19.1 Constructor functions for XML Schema built-in atomic types</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For example:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:integer("12")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the integer value twelve.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:date("2001-08-25")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns an item whose type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90"> and whose value represents the date 25th August 2001.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration("PT5H")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns an item whose type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> and whose value represents a duration of five hours.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Constructor functions can also be used to create special values that have no literal representation, as in the following examples: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:float("NaN")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the special floating-point value, "Not a Number."</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:double("INF")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the special double-precision value, "positive infinity."</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Constructor functions are available for all simple types, including union types. For example, if </span><code><span class="deltaxml-new" style="background:#90EE90">my:dt</span></code><span class="deltaxml-new" style="background:#90EE90"> is a user-defined union type whose member types are </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:time</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">, then the expression </span><code><span class="deltaxml-new" style="background:#90EE90">my:dt("2011-01-10")</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">. The rules follow XML Schema validation rules for union types: the effect is to choose the first member type that accepts the given string in its lexical space.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is also possible to construct values of various types by using a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression. For example:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">9 cast as hatsize</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the atomic item </span><code><span class="deltaxml-new" style="background:#90EE90">9</span></code><span class="deltaxml-new" style="background:#90EE90"> whose type is </span><code><span class="deltaxml-new" style="background:#90EE90">hatsize</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div></div><div class="div3"><h4><a id="id-variables"></a><span class="deltaxml-new" style="background:#90EE90">4.2.2 Variable References</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-VarRef" id="doc-xpath40-VarRef"></a><span class="deltaxml-new" style="background:#90EE90">[173]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-VarName" id="doc-xpath40-VarName"></a><span class="deltaxml-new" style="background:#90EE90">[174]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-variable-reference" title="variable reference"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">variable reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is an EQName preceded by a $-sign.] An unprefixed variable reference is in no namespace. Two variable references are equivalent if their </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> are equal (as defined by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator). The scope of a variable binding is defined separately for each kind of expression that can bind variables.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Every variable reference must match a name in the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Every variable binding has a static scope. The scope defines where references to the variable can validly occur. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></a><span class="deltaxml-new" style="background:#90EE90">] to reference a variable that is not in scope. If a variable is bound in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> for an expression, that variable is in scope for the entire expression except where it is occluded by another binding that uses the same name within that scope.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">A reference to a variable that was declared </span><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><span class="deltaxml-new" style="background:#90EE90">, but was not bound to a value by the external environment, raises a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> At evaluation time, the value of a variable reference is the value to which the relevant variable is bound.</span></p></div><div class="div3"><h4><a id="id-context-value-references"></a><span class="deltaxml-new" style="background:#90EE90">4.2.3 Context Value References</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ContextValueRef" id="doc-xpath40-ContextValueRef"></a><span class="deltaxml-new" style="background:#90EE90">[176]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ContextValueRef"><span class="deltaxml-new" style="background:#90EE90">ContextValueRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"."</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">context value reference</span></b><span class="deltaxml-new" style="background:#90EE90"> evaluates to the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In many syntactic contexts, the context value will be a single item. For example this applies on the right-hand side of the </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90"> operators, or within a </span><a href="#doc-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, a context value reference raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Being absent is not the same thing as being empty.</span></p></div></div><div class="div3"><h4><a id="id-paren-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.2.4 Parenthesized Expressions</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ParenthesizedExpr" id="doc-xpath40-ParenthesizedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[175]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Parentheses may be used to override the precedence rules. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">(2 + 4) * 5</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to thirty, since the parenthesized expression </span><code><span class="deltaxml-new" style="background:#90EE90">(2 + 4)</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated first and its result is multiplied by five. Without parentheses, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">2 + 4 * 5</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to twenty-two, because the multiplication operator has higher precedence than the addition operator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Empty parentheses are used to denote an empty sequence, as described in </span><a href="#construct_seq"><b><span class="deltaxml-new" style="background:#90EE90">4.7.1 Sequence Concatenation</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div3"><h4><a id="id-enclosed-expr"></a><span class="deltaxml-new" style="background:#90EE90">4.2.5 Enclosed Expressions</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EnclosedExpr" id="doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-enclosed-expression" title="enclosed expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">enclosed expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is an instance of the </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> production, which allows an optional expression within curly braces.] [</span><a id="dt-content-expression" title="content expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In an </span><a title="enclosed expression" class="termref" href="#dt-enclosed-expression"><span class="deltaxml-new" style="background:#90EE90">enclosed expression</span></a><span class="deltaxml-new" style="background:#90EE90">, the optional expression enclosed in curly braces is called the </span><b><span class="deltaxml-new" style="background:#90EE90">content expression</span></b><span class="deltaxml-new" style="background:#90EE90">.] If the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is not provided explicitly, the content expression is </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Despite the name, an enclosed expression is not actually an expression in its own right; rather it is a construct that is used in the grammar of many other expressions.</span></p></div></div></div><div class="div2"><h3><a id="id-postfix-expression"></a><span class="deltaxml-new" style="background:#90EE90">4.3 Postfix Expressions</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PostfixExpr" id="doc-xpath40-PostfixExpr"></a><span class="deltaxml-new" style="background:#90EE90">[153]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PrimaryExpr"><span class="deltaxml-new" style="background:#90EE90">PrimaryExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-FilterExpr"><span class="deltaxml-new" style="background:#90EE90">FilterExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-DynamicFunctionCall"><span class="deltaxml-new" style="background:#90EE90">DynamicFunctionCall</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-LookupExpr"><span class="deltaxml-new" style="background:#90EE90">LookupExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-FilterExprAM"><span class="deltaxml-new" style="background:#90EE90">FilterExprAM</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e14946.doc-xpath40-FilterExpr" id="noid_d4e14946.doc-xpath40-FilterExpr"></a><span class="deltaxml-new" style="background:#90EE90">[152]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FilterExpr"><span class="deltaxml-new" style="background:#90EE90">FilterExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#doc-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e14947.doc-xpath40-DynamicFunctionCall" id="noid_d4e14947.doc-xpath40-DynamicFunctionCall"></a><span class="deltaxml-new" style="background:#90EE90">[154]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DynamicFunctionCall"><span class="deltaxml-new" style="background:#90EE90">DynamicFunctionCall</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#doc-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e14948.doc-xpath40-LookupExpr" id="noid_d4e14948.doc-xpath40-LookupExpr"></a><span class="deltaxml-new" style="background:#90EE90">[161]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LookupExpr"><span class="deltaxml-new" style="background:#90EE90">LookupExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#doc-xpath40-Lookup"><span class="deltaxml-new" style="background:#90EE90">Lookup</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A postfix expression takes one of the following forms:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-filter-expression" title="filter expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">filter expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression in the form </span><code><span class="deltaxml-new" style="background:#90EE90">E1[E2]</span></code><span class="deltaxml-new" style="background:#90EE90">: its effect is to return those items from the value of </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> that satisfy the predicate in E2.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Filter expressions are described in </span><a href="#id-filter-expression"><b><span class="deltaxml-new" style="background:#90EE90">4.4 Filter Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An example of a filter expression is </span><code><span class="deltaxml-new" style="background:#90EE90">(1 to 100)[. mod 2 = 0]</span></code><span class="deltaxml-new" style="background:#90EE90"> which returns all even numbers in the range 1 to 100.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The base expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> can itself be a postfix expression, so multiple predicates are allowed, in the form </span><code><span class="deltaxml-new" style="background:#90EE90">E1[E2][E3][E4]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An expression (other than a raw EQName) followed by an argument list in parentheses (that is, </span><code><span class="deltaxml-new" style="background:#90EE90">E1(E2, E3, ...)</span></code><span class="deltaxml-new" style="background:#90EE90">) is referred to as a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-invocation"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a><span class="deltaxml-new" style="background:#90EE90">. Its effect is to evaluate </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> to obtain a function, and then call that function, with </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">E3</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">...</span></code><span class="deltaxml-new" style="background:#90EE90"> as arguments. Dynamic function calls are described in </span><a href="#id-dynamic-function-invocation"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.1 Dynamic Function Calls</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An example of a dynamic function call is </span><code><span class="deltaxml-new" style="background:#90EE90">$f("a", 2)</span></code><span class="deltaxml-new" style="background:#90EE90"> where the value of variable </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> must be a function item.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">lookup-expression</span></code><span class="deltaxml-new" style="background:#90EE90"> takes the form </span><code><span class="deltaxml-new" style="background:#90EE90">E1?K</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> is an expression returning a sequence of maps or arrays, and </span><code><span class="deltaxml-new" style="background:#90EE90">K</span></code><span class="deltaxml-new" style="background:#90EE90"> is a key specifier, which indicates which entries in a map, or members in an array, should be selected.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Lookup expressions are described in </span><a href="#id-postfix-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3.1 Postfix Lookup Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An example of a lookup expression is </span><code><span class="deltaxml-new" style="background:#90EE90">$emp?name</span></code><span class="deltaxml-new" style="background:#90EE90">, where the value of variable </span><code><span class="deltaxml-new" style="background:#90EE90">$emp</span></code><span class="deltaxml-new" style="background:#90EE90"> is a map, and the string </span><code><span class="deltaxml-new" style="background:#90EE90">"name"</span></code><span class="deltaxml-new" style="background:#90EE90"> is the key of one of the entries in the map.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Postfix expressions are evaluated from left-to-right. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$E1[E2]?(E3)(E4)</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated by first evaluating the filter expression </span><code><span class="deltaxml-new" style="background:#90EE90">$E1[E2]</span></code><span class="deltaxml-new" style="background:#90EE90"> to produce a sequence of maps and arrays (say </span><code><span class="deltaxml-new" style="background:#90EE90">$S</span></code><span class="deltaxml-new" style="background:#90EE90">), then evaluating the lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">$S?(E3)</span></code><span class="deltaxml-new" style="background:#90EE90"> to produce a function item (say </span><code><span class="deltaxml-new" style="background:#90EE90">$F</span></code><span class="deltaxml-new" style="background:#90EE90">), then evaluating the dynamic function call </span><code><span class="deltaxml-new" style="background:#90EE90">$F(E4)</span></code><span class="deltaxml-new" style="background:#90EE90"> to produce the final result.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The grammar for postfix expressions is defined here in a way designed to link clearly to the semantics of the different kinds of expression. For parsing purposes, the equivalent production rule:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr := PrimaryExpr (Predicate | PositionalArgumentList | Lookup)*</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">(as used in XPath 3.1) is probably more convenient.</span></p></div></div><div class="div2"><h3><a id="id-filter-expression"></a><span class="deltaxml-new" style="background:#90EE90">4.4 Filter Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-static-functions"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-numeric-literals"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The value of a predicate in a filter expression can now be a sequence of integers. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/816"><span class="deltaxml-new" style="background:#90EE90">816</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/996"><span class="deltaxml-new" style="background:#90EE90">996</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;6 February 2024]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e15077.doc-xpath40-FilterExpr" id="noid_d4e15077.doc-xpath40-FilterExpr"></a><span class="deltaxml-new" style="background:#90EE90">[152]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FilterExpr"><span class="deltaxml-new" style="background:#90EE90">FilterExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#doc-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Predicate" id="doc-xpath40-Predicate"></a><span class="deltaxml-new" style="background:#90EE90">[160]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"[" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "]"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A filter expression consists of a base expression followed by a predicate, which is an expression written in square brackets. The result of the filter expression consists of the items returned by the base expression, filtered by applying the predicate to each item in turn. The ordering of the items returned by a filter expression is the same as their order in the result of the primary expression.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Where the expression before the square brackets is a </span><a href="#doc-xpath40-ReverseStep"><span class="deltaxml-new" style="background:#90EE90">ReverseStep</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-ForwardStep"><span class="deltaxml-new" style="background:#90EE90">ForwardStep</span></a><span class="deltaxml-new" style="background:#90EE90">, the expression is technically not a filter expression but an </span><a href="#doc-xpath40-AxisStep"><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></a><span class="deltaxml-new" style="background:#90EE90">. There are minor differences in the semantics: see </span><a href="#id-predicate"><b><span class="deltaxml-new" style="background:#90EE90">4.6.5 Predicates within Steps</span></b></a></p></div><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of filter expressions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Given a sequence of products in a variable, return only those products whose price is greater than 100.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$products[price gt 100]</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">List all the integers from 1 to 100 that are divisible by 5. (See </span><a href="#construct_seq"><b><span class="deltaxml-new" style="background:#90EE90">4.7.1 Sequence Concatenation</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for an explanation of the </span><code><span class="deltaxml-new" style="background:#90EE90">to</span></code><span class="deltaxml-new" style="background:#90EE90"> operator.)</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(1 to 100)[. mod 5 eq 0]</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the following expression is the integer 25:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(21 to 29)[5]</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example returns the fifth through ninth items in the sequence bound to variable </span><code><span class="deltaxml-new" style="background:#90EE90">$orders</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$orders[5 to 9]</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the use of a filter expression as a </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-new" style="background:#90EE90">step</span></a><span class="deltaxml-new" style="background:#90EE90"> in a </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-new" style="background:#90EE90">path expression</span></a><span class="deltaxml-new" style="background:#90EE90">. It returns the last chapter or appendix within the book bound to variable </span><code><span class="deltaxml-new" style="background:#90EE90">$book</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$book/(chapter | appendix)[last()]</span></pre></div></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">For each item in the input sequence, the predicate expression is evaluated using an </span><b><span class="deltaxml-new" style="background:#90EE90">inner focus</span></b><span class="deltaxml-new" style="background:#90EE90">, defined as follows: The context value is the item currently being tested against the predicate. The context size is the number of items in the input sequence. The context position is the position of the context value within the input sequence. </span></p><p><span class="deltaxml-new" style="background:#90EE90">For each item in the input sequence, the result of the predicate expression is coerced to an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> value, called the </span><a title="predicate truth value" class="termref" href="#dt-predicate-truth-value"><span class="deltaxml-new" style="background:#90EE90">predicate truth value</span></a><span class="deltaxml-new" style="background:#90EE90">, as described below. Those items for which the predicate truth value is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> are retained, and those for which the predicate truth value is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> are discarded.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-predicate-truth-value" title="predicate truth value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">predicate truth value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a value </span><code><span class="deltaxml-new" style="background:#90EE90">$V</span></code><span class="deltaxml-new" style="background:#90EE90"> is the result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">if ($V instance of xs:numeric+) then ($V = position()) else fn:boolean($V)</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Expanding this definition, the predicate truth value can be obtained by applying the following rules, in order:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> of the predicate expression is a sequence whose first item is an instance of the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90">, then:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> must be an instance of the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric+</span></code><span class="deltaxml-new" style="background:#90EE90"> (that is, every item in </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> must be numeric). A type error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0006" title="err:FORG0006"><span class="deltaxml-new" style="background:#90EE90">err:FORG0006</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> is raised if this is not the case.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The predicate truth value is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is equal (by the </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90"> operator) to the </span><b><span class="deltaxml-new" style="background:#90EE90">context position</span></b><span class="deltaxml-new" style="background:#90EE90">, and is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> otherwise.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">In effect this means that an item in the input sequence is selected if its position in the sequence is equal to one or more of the numeric values in the predicate. For example, the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[3 to 5]</span></code><span class="deltaxml-new" style="background:#90EE90"> is true for the third, fourth, and fifth items in the input sequence.</span></p><p><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">[</span><a id="dt-numeric-predicate" title="numeric predicate"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A predicate whose predicate expression returns a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric+</span></code><span class="deltaxml-new" style="background:#90EE90"> is called a </span><b><span class="deltaxml-new" style="background:#90EE90">numeric predicate</span></b><span class="deltaxml-new" style="background:#90EE90">.]</span></span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">It is possible, though not generally useful, for the value of a numeric predicate to depend on the focus, and thus to differ for different items in the input sequence. For example, the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[xs:integer(@seq)]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects those items in the input sequence whose </span><code><span class="deltaxml-new" style="background:#90EE90">@seq</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is numerically equal to their position in the input sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is also possible, and again not generally useful, for the value of the predicate to be numeric for some items in the input sequence, and boolean for others. For example, the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[@special otherwise last()]</span></code><span class="deltaxml-new" style="background:#90EE90"> is true for an item that either has an </span><code><span class="deltaxml-new" style="background:#90EE90">@special</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute, or is the last item in the input sequence.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The truth value of a numeric predicate does not depend on the order of the numbers in </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">. The predicates </span><code><span class="deltaxml-new" style="background:#90EE90">[ 1, 2, 3 ]</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">[ 3, 2, 1 ]</span></code><span class="deltaxml-new" style="background:#90EE90"> have exactly the same effect. The items in the result of a filter expression always retain the ordering of the input sequence.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The truth value of a numeric predicate whose value is non-integral or non-positive is always false.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Beware that using boolean operators (</span><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">not()</span></code><span class="deltaxml-new" style="background:#90EE90">) with numeric values may not have the intended effect. For example the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[1 or last()]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects every item in the sequence, because </span><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><span class="deltaxml-new" style="background:#90EE90"> operates on the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of its operands. The required effect can be achieved with the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[1, last()]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the predicate truth value is the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the predicate expression.</span></p></li></ol></div><div class="div2"><h3><a id="id-functions"></a><span class="deltaxml-new" style="background:#90EE90">4.5 Functions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">Functions in XQuery 4.0 and XPath 4.0 arise in two ways:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> contains information about a family of functions with the same name and a defined arity range. These functions are in most cases known statically (they appear in the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">), but there may be further function definitions that are known only dynamically (appearing in the </span><a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">dynamically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">Function items</span></a><span class="deltaxml-new" style="background:#90EE90"> are XDM items that can be called using a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-call"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a><span class="deltaxml-new" style="background:#90EE90">. They are values that can be bound to variables, passed as arguments, returned as function results, and generally manipulated in the same way as other XDM values.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The functions defined by a statically known </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> can be invoked using a </span><a title="static function call" class="termref" href="#dt-static-function-call"><span class="deltaxml-new" style="background:#90EE90">static function call</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">Function items</span></a><span class="deltaxml-new" style="background:#90EE90"> corresponding to these definitions can also be obtained, as dynamic values, by evaluating a </span><a title="named function reference" class="termref" href="#dt-named-function-ref"><span class="deltaxml-new" style="background:#90EE90">named function reference</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">Function items</span></a><span class="deltaxml-new" style="background:#90EE90"> can also be obtained using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:function-lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> function: in this case the function name and arity do not need to be known statically, and the function definition need not be present in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, so long as it is in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Static and dynamic function calls are described in the following sections.</span></p><div class="div3"><h4><a id="id-static-functions"></a><span class="deltaxml-new" style="background:#90EE90">4.5.1 Static Function Calls</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-function-calls"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-filter-expression"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Functions may be declared to be variadic. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/161"><span class="deltaxml-new" style="background:#90EE90">161</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1137"><span class="deltaxml-new" style="background:#90EE90">1137</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;23 April 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> for an expression includes a set of </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">. Every </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context has a name (which is an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">) and an </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a><span class="deltaxml-new" style="background:#90EE90">, which is a range of permitted arities for calls on that function. Two </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> having the same name must not have overlapping arity ranges. This means that for a given static function call, it is possible to identify the target function definition in the static context unambiguously from knowledge of the function name and the number of supplied arguments.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static function call" class="termref" href="#dt-static-function-call"><span class="deltaxml-new" style="background:#90EE90">static function call</span></a><span class="deltaxml-new" style="background:#90EE90"> is bound to a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context by matching the name and arity. If the function call has </span><var><span class="deltaxml-new" style="background:#90EE90">P</span></var><span class="deltaxml-new" style="background:#90EE90"> positional arguments followed by </span><var><span class="deltaxml-new" style="background:#90EE90">K</span></var><span class="deltaxml-new" style="background:#90EE90"> keyword arguments, then the required arity is </span><var><span class="deltaxml-new" style="background:#90EE90">P+K</span></var><span class="deltaxml-new" style="background:#90EE90">, and the static context must include a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> whose name matches the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> in the function call, and whose </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a><span class="deltaxml-new" style="background:#90EE90"> includes this required arity. This is the function chosen to be called. The result of the function is obtained by evaluating the expression that forms its implementation, with a dynamic context that provides values for all the declared parameters, initialized as described in </span><a href="#id-eval-static-function-call"><b><span class="deltaxml-new" style="background:#90EE90">4.5.1.2 Evaluating Static Function Calls</span></b></a><span class="deltaxml-new" style="background:#90EE90"> below.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, a function reference of the form </span><code><span class="deltaxml-new" style="background:#90EE90">f#N</span></code><span class="deltaxml-new" style="background:#90EE90"> binds to a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context whose name matches </span><var><span class="deltaxml-new" style="background:#90EE90">f</span></var><span class="deltaxml-new" style="background:#90EE90"> where </span><code><span class="deltaxml-new" style="background:#90EE90">MinP ≤ N and MaxP ≥ N</span></code><span class="deltaxml-new" style="background:#90EE90">. The result of evaluating a function reference is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> which can be called using a dynamic function call. Function items are never variadic and their arguments are always supplied positionally. For example, the function reference </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#3</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function item with arity 3, which is always called by supplying three positional arguments, and whose effect is the same as a static call on </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat</span></code><span class="deltaxml-new" style="background:#90EE90"> with three positional arguments. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The detailed rules for evaluating static function calls and function references are defined in subsequent sections.</span></p><div class="div4"><h5><a id="id-function-calls"></a><span class="deltaxml-new" style="background:#90EE90">4.5.1.1 Static Function Call Syntax</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-inline-func"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-static-functions"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Keyword arguments are allowed on static function calls, as well as positional arguments. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/155"><span class="deltaxml-new" style="background:#90EE90">155</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/159"><span class="deltaxml-new" style="background:#90EE90">159</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;30 September 2020]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FunctionCall" id="doc-xpath40-FunctionCall"></a><span class="deltaxml-new" style="background:#90EE90">[179]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionCall"><span class="deltaxml-new" style="background:#90EE90">FunctionCall</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#doc-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-reserved-function-names"><span class="deltaxml-new" style="background:#90EE90">xgc: reserved-function-names</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-parens"><span class="deltaxml-new" style="background:#90EE90">gn: parens</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArgumentList" id="doc-xpath40-ArgumentList"></a><span class="deltaxml-new" style="background:#90EE90">[155]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" ((</span><a href="#doc-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)?) | </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e15400.doc-xpath40-PositionalArguments" id="noid_d4e15400.doc-xpath40-PositionalArguments"></a><span class="deltaxml-new" style="background:#90EE90">[157]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Argument" id="doc-xpath40-Argument"></a><span class="deltaxml-new" style="background:#90EE90">[180]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArgumentPlaceholder" id="doc-xpath40-ArgumentPlaceholder"></a><span class="deltaxml-new" style="background:#90EE90">[181]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"?"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e15403.doc-xpath40-KeywordArguments" id="noid_d4e15403.doc-xpath40-KeywordArguments"></a><span class="deltaxml-new" style="background:#90EE90">[158]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-KeywordArgument"><span class="deltaxml-new" style="background:#90EE90">KeywordArgument</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-KeywordArgument"><span class="deltaxml-new" style="background:#90EE90">KeywordArgument</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-KeywordArgument" id="doc-xpath40-KeywordArgument"></a><span class="deltaxml-new" style="background:#90EE90">[159]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KeywordArgument"><span class="deltaxml-new" style="background:#90EE90">KeywordArgument</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ":=" </span><a href="#doc-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-static-function-call" title="static function call"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">static function call</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of an EQName followed by a parenthesized list of zero or more arguments.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The argument list consists of zero or more positional arguments, followed by zero or more keyword arguments.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-arg-expr" title="argument expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An argument to a function call is either an </span><b><span class="deltaxml-new" style="background:#90EE90">argument expression</span></b><span class="deltaxml-new" style="background:#90EE90"> or an </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90">); in both cases it may either be supplied positionally, or identified by a name (called a keyword).] </span></p><p><span class="deltaxml-new" style="background:#90EE90">This section is concerned with static function calls in which none of the arguments are </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholders</span></a><span class="deltaxml-new" style="background:#90EE90">. Calls using one or more </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholders</span></a><span class="deltaxml-new" style="background:#90EE90"> are covered in the section </span><a href="#id-partial-function-application"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.3 Partial Function Application</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the function name supplied in a static function call is an unprefixed </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, it is expanded using the </span><a title="default function namespace" class="termref" href="#dt-default-function-namespace"><span class="deltaxml-new" style="background:#90EE90">default function namespace</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> used as the function name and the number of arguments used in the static function call (the required arity) must match the name and arity range of a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span><span class="deltaxml-new" style="background:#90EE90"> using the rules defined in the previous section</span></span><span class="deltaxml-new" style="background:#90EE90">; if there is no match, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Evaluation of static function calls is described in </span><a href="#id-eval-static-function-call"><b><span class="deltaxml-new" style="background:#90EE90">4.5.1.2 Evaluating Static Function Calls</span></b></a><span class="deltaxml-new" style="background:#90EE90"> .</span></p><p><span class="deltaxml-new" style="background:#90EE90">Since the arguments of a function call are separated by commas, any </span><a title="argument expression" class="termref" href="#dt-arg-expr"><span class="deltaxml-new" style="background:#90EE90">argument expression</span></a><span class="deltaxml-new" style="background:#90EE90"> that contains a top-level </span><a title="comma operator" class="termref" href="#dt-comma-operator"><span class="deltaxml-new" style="background:#90EE90">comma operator</span></a><span class="deltaxml-new" style="background:#90EE90"> must be enclosed in parentheses. Here are some illustrative examples of static function calls:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">my:three-argument-function(1, 2, 3)</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a static function call with three </span><span><span class="deltaxml-new" style="background:#90EE90">positional</span></span><span class="deltaxml-new" style="background:#90EE90"> arguments. </span><span><span class="deltaxml-new" style="background:#90EE90">The corresponding function declaration must define at least three parameters, and may define more, provided they are optional.</span></span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">my:two-argument-function((1,2), 3)</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a static function call with two arguments, the first of which is a sequence of two values. </span><span><span class="deltaxml-new" style="background:#90EE90">The corresponding function declaration must define at least two parameters, and may define more, provided they are optional.</span></span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">my:two-argument-function(1, ())</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a static function call with two arguments, the second of which is an empty sequence.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">my:one-argument-function((1, 2, 3))</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a static function call with one argument that is a sequence of three values. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">my:one-argument-function(( ))</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a static function call with one argument that is an empty sequence.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">my:zero-argument-function( )</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes a static function call with zero arguments.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">lang(node := $n, language := 'de')</span></code><span class="deltaxml-new" style="background:#90EE90"> is a static function call with two keyword arguments. The corresponding function declaration defines two parameters, a required parameter </span><code><span class="deltaxml-new" style="background:#90EE90">language</span></code><span class="deltaxml-new" style="background:#90EE90"> and an optional parameter </span><code><span class="deltaxml-new" style="background:#90EE90">node</span></code><span class="deltaxml-new" style="background:#90EE90">. This call supplies values for both parameters. It is equivalent to the call </span><code><span class="deltaxml-new" style="background:#90EE90">fn:lang('de', $n)</span></code><span class="deltaxml-new" style="background:#90EE90">. Note that the keyword arguments are in a different order from the parameter declarations. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">sort(//employee, key := fn($e) { xs:decimal($e/salary) })</span></code><span class="deltaxml-new" style="background:#90EE90"> is a static function call with one positional argument and one keyword argument. The corresponding function declaration defines three parameters, a required parameter </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90">, an optional parameter </span><code><span class="deltaxml-new" style="background:#90EE90">$collation</span></code><span class="deltaxml-new" style="background:#90EE90">, and an optional parameter </span><code><span class="deltaxml-new" style="background:#90EE90">$key</span></code><span class="deltaxml-new" style="background:#90EE90"> This call supplies values for the first and third parameters, leaving the second parameter (</span><code><span class="deltaxml-new" style="background:#90EE90">$collation</span></code><span class="deltaxml-new" style="background:#90EE90">) to take its default value. The default value of the </span><code><span class="deltaxml-new" style="background:#90EE90">$collation</span></code><span class="deltaxml-new" style="background:#90EE90"> parameter is given as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:default-collation()</span></code><span class="deltaxml-new" style="background:#90EE90">, so the value supplied to the function is the default collation from the dynamic context of the caller. It is equivalent to the call </span><code><span class="deltaxml-new" style="background:#90EE90">fn:sort(//employee, fn:default-collation(), fn($e) { xs:decimal($e/salary) })</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">An </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> in a </span><code><span class="deltaxml-new" style="background:#90EE90">KeywordArgument</span></code><span class="deltaxml-new" style="background:#90EE90"> is expanded to a QName value; if there is no prefix, then the name is in no namespace (otherwise the prefix is resolved in the usual way). The keywords used in a function call (after expansion to QNames) must be distinct [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">]; [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div4"><h5><a id="id-eval-static-function-call"></a><span class="deltaxml-new" style="background:#90EE90">4.5.1.2 Evaluating Static Function Calls</span></h5><p><span class="deltaxml-new" style="background:#90EE90">This section applies to static function calls where none of the arguments is an </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></code><span class="deltaxml-new" style="background:#90EE90">. For function calls involving placeholders, see </span><a href="#id-partial-function-application"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.3 Partial Function Application</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> When a static function call </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90"> is evaluated with respect to a static context </span><var><span class="deltaxml-new" style="background:#90EE90">SC</span></var><span class="deltaxml-new" style="background:#90EE90"> and a dynamic context </span><var><span class="deltaxml-new" style="background:#90EE90">DC</span></var><span class="deltaxml-new" style="background:#90EE90">, the result is obtained as follows: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> to be used is found in the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><var><span class="deltaxml-new" style="background:#90EE90">SC</span></var><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">required arity</span></b><span class="deltaxml-new" style="background:#90EE90"> is the total number of arguments in the function call, including both positional and keyword arguments.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> There can be at most one </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> component of </span><var><span class="deltaxml-new" style="background:#90EE90">SC</span></var><span class="deltaxml-new" style="background:#90EE90"> whose function name matches the expanded QName in </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90"> and whose </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a><span class="deltaxml-new" style="background:#90EE90"> includes the arity of </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90">’s </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">If there is no such </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90">, a static error [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each parameter in the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is matched to an argument expression as follows:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If there are </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> positional arguments in the function call </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90">, and </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is not </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90">, then the corresponding argument expressions are matched pairwise to the first </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> parameters in the declaration. For this purpose the required parameters and optional parameters in </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> are concatenated into a single list, in order.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If there are </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> positional arguments and no keyword arguments in the function call </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90">, and </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90"> with </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> declared parameters, then:</span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> = </span><var><span class="deltaxml-new" style="background:#90EE90">M-1</span></var><span class="deltaxml-new" style="background:#90EE90">, then the </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> supplied arguments are matched to the first </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> declared parameters, and the </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">th parameter is bound to an empty sequence (which might cause a type error if the declared type does not allow an empty sequence).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> = </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">, then the </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> supplied arguments are matched to the first </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> declared parameters.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> &gt; </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">, the values of the </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">th and subsequent arguments are sequence-concatenated into a single value, which is matched to the </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">th declared parameter. This means, for example, that if a variadic function </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> with two declared parameters is called using a static function call of the form </span><code><span class="deltaxml-new" style="background:#90EE90">F(a, b, c)</span></code><span class="deltaxml-new" style="background:#90EE90">, then the call is effectively equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">F(a, (b, c))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The combined value </span><code><span class="deltaxml-new" style="background:#90EE90">(b, c)</span></code><span class="deltaxml-new" style="background:#90EE90"> must satisfy the required type for the relevant parameter, after the coercion rules are applied.</span></p></div></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">Any keyword arguments in </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90"> are then matched to parameters (whether required or optional) in </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> by comparing the keyword used in </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90"> with the paramater name declared in </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">. Each keyword must match the name of a declared parameter [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">], and this must be one that has not already been matched to a positional argument. [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If any required parameter has not been matched to any argument in </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90"> by applying the above rules, a static error is reported [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If any optional parameter has not been matched to any argument in </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90"> by applying the above rules, then the parameter is matched to the default value expression for that parameter in </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Each argument expression established by the above rules is evaluated with respect to DC. The order of argument evaluation is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> and it is not required that an argument be evaluated if the function body can be evaluated without evaluating that argument.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">All argument expressions, including default value expressions, are evaluated in the dynamic context of the function call. It is therefore possible to use a default value expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">fn:current-dateTime()</span></code><span class="deltaxml-new" style="background:#90EE90">, whose value depends on the dynamic context of the function call.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">If the expression used for the default value of a parameter has no dependencies on the dynamic context, then an implementation </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> choose to reuse the same value on repeated function calls rather than re-evaluating it on each function call.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This is relevant, for example, if the expression constructs new nodes.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of evaluating the argument expression is converted to the required type (the declared type associated with the corresponding parameter in the function declaration, defaulting to </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">) by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span><span class="deltaxml-new" style="background:#90EE90">This applies both to explicitly supplied arguments, and to values obtained by evaluating default value expressions. In both cases a type error will be raised if the value (after coercion) does not match the required type.</span></span></p><p><span class="deltaxml-new" style="background:#90EE90">In the case of a </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90"> function, the coercion rules are applied to the sequence-concatenation of any supplied arguments that are combined to provide a value for the parameter.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the function call is obtained as follows:</span></p><ul><li><p><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">’s </span><span><span class="deltaxml-new" style="background:#90EE90">body</span></span><span class="deltaxml-new" style="background:#90EE90"> is invoked in an implementation-dependent way. The processor makes the following information available to that invocation: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The converted argument values;</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the function is </span><a title="context dependent" class="termref" href="#dt-context-dependent"><span class="deltaxml-new" style="background:#90EE90">context dependent</span></a><span class="deltaxml-new" style="background:#90EE90">, the static context </span><var><span class="deltaxml-new" style="background:#90EE90">SC</span></var><span class="deltaxml-new" style="background:#90EE90"> and dynamic context </span><var><span class="deltaxml-new" style="background:#90EE90">DC</span></var><span class="deltaxml-new" style="background:#90EE90"> of the function call. </span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result is converted to the required type (the declared return type in the function declaration, defaulting to </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">) by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The result of applying the coercion rules is either an instance of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">’s return type or a dynamic error. This result is then the result of evaluating </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A host language may define alternative rules for processing the result, especially in the case of external functions implemented using a non-XDM type system.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Errors raised by system functions are defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90"> Errors raised by external functions are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-consistency-constraints"><b><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></b></a><span class="deltaxml-new" style="background:#90EE90">). </span></p></li><li class="xpath"><p><span class="deltaxml-new" style="background:#90EE90"> Errors raised by host-language-dependent functions are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><div class="example"><div class="exampleHeader"><a id="d5e17117"></a><span class="deltaxml-new" style="background:#90EE90">Example: A System Function</span></div><p><span class="deltaxml-new" style="background:#90EE90">The following function call uses the function </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-base-uri"><span class="deltaxml-new" style="background:#90EE90">Section 2.1.5 fn:base-uri</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. Use of </span><code><span class="deltaxml-new" style="background:#90EE90">SC</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">DC</span></code><span class="deltaxml-new" style="background:#90EE90"> and errors raised by this function are all defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">base-uri()</span></pre></div></div></div></li></ol></div></div><div class="div3"><h4><a id="id-dynamic-functions"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2 Function Items</span></h4><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> is an XDM value that can be bound to a variable, or manipulated in various ways by XQuery 4.0 and XPath 4.0 expressions. The most significant such expression is a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-call"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a><span class="deltaxml-new" style="background:#90EE90">, which supplies values of arguments and evaluates the function to produce a result.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The syntax of dynamic function calls is defined in </span><a href="#id-dynamic-function-invocation"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.1 Dynamic Function Calls</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A number of constructs can be used to produce a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, notably:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">named function reference</span></b><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-named-function-ref"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.4 Named Function References</span></b></a><span class="deltaxml-new" style="background:#90EE90">) constructs a function item by reference to </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:node-name#1</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function item whose effect is to call the static </span><code><span class="deltaxml-new" style="background:#90EE90">fn:node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> function with one argument.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">inline function</span></b><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-inline-func"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.5 Inline Function Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90"> ) constructs a function item whose </span><span><span class="deltaxml-new" style="background:#90EE90">body</span></span><span class="deltaxml-new" style="background:#90EE90"> is defined locally. For example, the construct </span><code><span class="deltaxml-new" style="background:#90EE90">fn($x) { $x + 1 }</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function item whose effect is to increment the value of the supplied argument.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">partial function application</span></b><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-partial-function-application"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.3 Partial Function Application</span></b></a><span class="deltaxml-new" style="background:#90EE90">) derives one function item from another by supplying the values of some of its arguments. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:ends-with(?, ".txt")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function item with one argument that tests whether the supplied string ends with the substring </span><code><span class="deltaxml-new" style="background:#90EE90">".txt"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Maps and arrays are also function items. See </span><a href="#id-map-constructors"><b><span class="deltaxml-new" style="background:#90EE90">4.14.1.1 Map Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-array-constructors"><b><span class="deltaxml-new" style="background:#90EE90">4.14.2.1 Array Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:function-lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> function can be called to discover functions that are present in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:load-xquery-module</span></code><span class="deltaxml-new" style="background:#90EE90"> function can be called to load functions dynamically from an external XQuery library module.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Some system functions such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:random-number-generator</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:op</span></code><span class="deltaxml-new" style="background:#90EE90"> return a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> as their result.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">These constructs are described in detail in the following sections, or in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div4"><h5><a id="id-dynamic-function-invocation"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2.1 Dynamic Function Calls</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DynamicFunctionCall" id="doc-xpath40-DynamicFunctionCall"></a><span class="deltaxml-new" style="background:#90EE90">[154]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DynamicFunctionCall"><span class="deltaxml-new" style="background:#90EE90">DynamicFunctionCall</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#doc-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PositionalArgumentList" id="doc-xpath40-PositionalArgumentList"></a><span class="deltaxml-new" style="background:#90EE90">[156]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a><span class="deltaxml-new" style="background:#90EE90">? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PositionalArguments" id="doc-xpath40-PositionalArguments"></a><span class="deltaxml-new" style="background:#90EE90">[157]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e15993.doc-xpath40-Argument" id="noid_d4e15993.doc-xpath40-Argument"></a><span class="deltaxml-new" style="background:#90EE90">[180]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e15994.doc-xpath40-ArgumentPlaceholder" id="noid_d4e15994.doc-xpath40-ArgumentPlaceholder"></a><span class="deltaxml-new" style="background:#90EE90">[181]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"?"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dynamic-function-invocation" title="dynamic function call"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of a base expression that returns the function and a parenthesized list of zero or more arguments (</span><a title="argument expression" class="termref" href="#dt-arg-expr"><span class="deltaxml-new" style="background:#90EE90">argument expressions</span></a><span class="deltaxml-new" style="background:#90EE90"> or ArgumentPlaceholders).] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> A dynamic function call is evaluated as described in </span><a href="#id-eval-dynamic-function-call"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.2 Evaluating Dynamic Function Calls</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following are examples of some dynamic function calls:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example calls the function contained in </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">, passing the arguments 2 and 3: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$f(2, 3)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example fetches the second item from sequence </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">, treats it as a function and calls it, passing an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> argument: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$f[2]("Hi there")</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example calls the function </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> passing no arguments, and filters the result with a positional predicate: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$f()[2]</span></pre></div></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Arguments in a dynamic function call are always supplied positionally.</span></p></div></div><div class="div4"><h5><a id="id-eval-dynamic-function-call"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2.2 Evaluating Dynamic Function Calls</span></h5><p><span class="deltaxml-new" style="background:#90EE90">This section applies to dynamic function calls whose arguments do not include an </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></code><span class="deltaxml-new" style="background:#90EE90">. For function calls that include a placeholder, see </span><a href="#id-partial-function-application"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.3 Partial Function Application</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-dynamic-function-call" title="dynamic function call"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression that is evaluated by calling a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, which is typically obtained dynamically.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> When a dynamic function call </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90"> is evaluated, the result is obtained as follows: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> to be called is obtained by evaluating the base expression of the function call. If this yields a sequence consisting of a single function item whose arity matches the number of arguments in the </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></code><span class="deltaxml-new" style="background:#90EE90">, let </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> denote that function item. Otherwise, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Keyword arguments are not allowed in a dynamic function call.</span></p></div></li><li><p><a title="argument expression" class="termref" href="#dt-arg-expr"><span class="deltaxml-new" style="background:#90EE90">Argument expressions</span></a><span class="deltaxml-new" style="background:#90EE90"> are evaluated, producing </span><b><span class="deltaxml-new" style="background:#90EE90">argument values</span></b><span class="deltaxml-new" style="background:#90EE90">. The order of argument evaluation is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> and an argument need not be evaluated if the function body can be evaluated without evaluating that argument.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Each argument value is converted to the corresponding parameter type in </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">’s signature by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, resulting in a </span><b><span class="deltaxml-new" style="background:#90EE90">converted argument value</span></b></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> is a map, it is evaluated as described in </span><a href="#id-map-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.1.2 Map Lookup using Function Call Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> is an array, it is evaluated as described in </span><a href="#id-array-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.2.2 Array Lookup using Function Call Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">’s </span><span><span class="deltaxml-new" style="background:#90EE90">body</span></span><span class="deltaxml-new" style="background:#90EE90"> is an XQuery 4.0 and XPath 4.0 expression (for example, if </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a </span><a title="user-defined function" class="termref" href="#dt-udf"><span class="deltaxml-new" style="background:#90EE90">user-defined function</span></a><span class="deltaxml-new" style="background:#90EE90"> or</span></span></span><span class="deltaxml-new" style="background:#90EE90"> an </span><a title="anonymous function" class="termref" href="#dt-anonymous-function"><span class="deltaxml-new" style="background:#90EE90">anonymous function</span></a><span class="deltaxml-new" style="background:#90EE90">, or a </span><a title="partially applied function" class="termref" href="#dt-partially-applied-function"><span class="deltaxml-new" style="background:#90EE90">partial application</span></a><span class="deltaxml-new" style="background:#90EE90"> of such a function): </span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">’s </span><span><span class="deltaxml-new" style="background:#90EE90">body</span></span><span class="deltaxml-new" style="background:#90EE90"> is evaluated. The static context for this evaluation is the static context of the XQuery 4.0 and XPath 4.0 expression. The dynamic context for this evaluation is obtained by taking the dynamic context of the </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">module</span></span></span><span class="xpath"><span class="xpath"><code><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></code></span></span><span class="deltaxml-new" style="background:#90EE90"> that contains the </span><code><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></code><span class="deltaxml-new" style="background:#90EE90">, and making the following changes: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="focus" class="termref" href="#dt-focus"><span class="deltaxml-new" style="background:#90EE90">focus</span></a><span class="deltaxml-new" style="background:#90EE90"> (context value, context position, and context size) is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> In the </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90"> component of the dynamic context, each converted argument value is bound to the corresponding parameter name. </span></p><p><span><span class="deltaxml-new" style="background:#90EE90">When this is done, the converted argument values retain their </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic types</span></a><span class="deltaxml-new" style="background:#90EE90">, even where these are </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtypes</span></a><span class="deltaxml-new" style="background:#90EE90"> of the declared parameter types.</span></span><span class="deltaxml-new" style="background:#90EE90"> For example, a function with a parameter </span><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90"> of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> can be called with an argument of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, which is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">. During the processing of this function call, the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$p</span></code><span class="deltaxml-new" style="background:#90EE90"> inside the body of the function retains its </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">’s nonlocal variable bindings are also added to the </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90">. (Note that the names of the nonlocal variables are by definition disjoint from the parameter names, so there can be no conflict.) </span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The value returned by evaluating the function body is then converted to the declared return type of </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. The result is then the result of evaluating </span><var><span class="deltaxml-new" style="background:#90EE90">FC</span></var><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> As with argument values, the value returned by a function retains its </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90">, which may be a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of the declared return type of </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">. For example, a function that has a declared return type of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> may in fact return a value of dynamic type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d5e17519"></a><span class="deltaxml-new" style="background:#90EE90">Example: Derived Types and Nonlocal Variable Bindings</span></div><p><code><span class="deltaxml-new" style="background:#90EE90">$incr</span></code><span class="deltaxml-new" style="background:#90EE90"> is a nonlocal variable that is available within the function because its variable binding has been added to the variable values of the function.. Even though the parameter and return type of this function are both </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, the more specific type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> is preserved in both cases.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $incr := 1
let $f := function($i as xs:decimal) as xs:decimal { $i + $incr }
return $f(5)</span></pre></div></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="d5e17534"></a><span class="deltaxml-new" style="background:#90EE90">Example: Using the Context Value in an Anonymous Function</span></div><p><span class="deltaxml-new" style="background:#90EE90">The following example will raise a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></a><span class="deltaxml-new" style="background:#90EE90">]:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $vat := function() { @vat + @price }
return doc('wares.xml')/shop/article/$vat()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Instead, the context value can be used as an argument to the anonymous function:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $vat := function($art) { $art/@vat + $art/@price }
return doc('wares.xml')/shop/article/$vat(.)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Alternatively, the value can be referenced as a nonlocal variable binding:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $ctx := doc('wares.xml')/shop/article
let $vat := function() { for $a in $ctx return $a/@vat + $a/@price }
return $vat()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Finally, a </span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-new" style="background:#90EE90">focus function</span></a><span class="deltaxml-new" style="background:#90EE90"> can be used. This binds the value of the argument to the context value within the function body:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $vat := function { @vat + @price }
return $vat(doc('wares.xml')/shop/article)</span></pre></div></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the implementation of </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> is not an XQuery 4.0 and XPath 4.0 expression (for example, </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system function</span></a><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">or an </span><a title="external function" class="termref" href="#dt-external-function"><span class="deltaxml-new" style="background:#90EE90">external function</span></a><span class="deltaxml-new" style="background:#90EE90">, </span></span></span><span class="deltaxml-new" style="background:#90EE90"> the </span><span><span class="deltaxml-new" style="background:#90EE90">body</span></span><span class="deltaxml-new" style="background:#90EE90"> of the function is evaluated, and the result is converted to the declared return type, in the same way as for a static function call (see </span><a href="#id-function-calls"><b><span class="deltaxml-new" style="background:#90EE90">4.5.1.1 Static Function Call Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">Errors may be raised in the same way.</span></p></li></ol></div><div class="div4"><h5><a id="id-partial-function-application"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2.3 Partial Function Application</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-partial-function-application" title="partial function application"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A static or </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-invocation"><span class="deltaxml-new" style="background:#90EE90">dynamic</span></a><span class="deltaxml-new" style="background:#90EE90"> function call is a </span><b><span class="deltaxml-new" style="background:#90EE90">partial function application</span></b><span class="deltaxml-new" style="background:#90EE90"> if one or more arguments is an </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The rules for partial function application in static function calls and dynamic function calls have a great deal in common, but they are stated separately below for clarity.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In each case, the result of a partial function application is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, whose arity is equal to the number of placeholders in the call.</span></p><p><span class="deltaxml-new" style="background:#90EE90">More specifically, the result of the partial function application is a </span><a title="partially applied function" class="termref" href="#dt-partially-applied-function"><span class="deltaxml-new" style="background:#90EE90">partially applied function</span></a><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-partially-applied-function" title="partially applied function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">partially applied function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function created by </span><a title="partial function application" class="termref" href="#dt-partial-function-application"><span class="deltaxml-new" style="background:#90EE90">partial function application</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">For static function calls, the result is obtained as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> to be partially applied is determined in the same way as for a static function call without placeholders, as described in </span><a href="#id-function-calls"><b><span class="deltaxml-new" style="background:#90EE90">4.5.1.1 Static Function Call Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">. For this purpose an </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></code><span class="deltaxml-new" style="background:#90EE90"> contributes to the count of arguments.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90">, and the function call has no keyword arguments, then the static function call </span><code><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">(</span><var><span class="deltaxml-new" style="background:#90EE90">ARGS</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> is transformed into the dynamic call </span><code><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">#</span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">(</span><var><span class="deltaxml-new" style="background:#90EE90">ARGS</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is the number of supplied arguments.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">For example, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat('[', ?, ']')</span></code><span class="deltaxml-new" style="background:#90EE90"> is transformed into the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#3('[', ?, ']')</span></code><span class="deltaxml-new" style="background:#90EE90">. For the meaning of a named function reference applied to a variadic function, see </span><a href="#id-named-function-ref"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.4 Named Function References</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90">, and the function call does have keyword arguments, then a static error is raised [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In other cases, the parameters of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> are classified into three categories:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Parameters that map to a placeholder, referred to as </span><b><span class="deltaxml-new" style="background:#90EE90">placeholder parameters</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Parameters for which an explicit value is given in the function call (either positionally or by keyword), referred to as </span><b><span class="deltaxml-new" style="background:#90EE90">explicitly supplied parameters</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Parameters (which are necessarily optional parameters) for which no corresponding argument is supplied, either as a placeholder or with an explicit value. These are referred to as </span><b><span class="deltaxml-new" style="background:#90EE90">defaulted parameters</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A partial function application need not have any explicitly supplied parameters. For example, the partial function application </span><code><span class="deltaxml-new" style="background:#90EE90">fn:string(?)</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed; it has exactly the same effect as the named function reference </span><code><span class="deltaxml-new" style="background:#90EE90">fn:string#1</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Explicitly supplied parameters and defaulted parameters are evaluated and converted to the required type using the rules for a static function call. This may result in an error being raised.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A type error is raised if any of the explicitly supplied or defaulted parameters, after applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, does not match the required type of the corresponding parameter.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In addition, a dynamic error </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be raised if any of the explicitly supplied or defaulted parameters does not match other constraints on the value of that parameter (for example, if the value supplied for a parameter expecting a regular expression is not a valid regular expression); or if the processor is able to establish that evaluation of the resulting function will fail for any other reason (for example, if an error is raised while evaluating a subexpression in the function body that depends only on explicitly supplied and defaulted parameters).</span></p><p><span class="deltaxml-new" style="background:#90EE90">In all cases the error code is the same as for a static function call supplying the same invalid value(s).</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the particular case where all the supplied arguments are placeholders, the error behavior </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should</span></span><span class="deltaxml-new" style="background:#90EE90"> be the same as for an equivalent </span><a title="named function reference" class="termref" href="#dt-named-function-ref"><span class="deltaxml-new" style="background:#90EE90">named function reference</span></a><span class="deltaxml-new" style="background:#90EE90">: for example, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:id#1</span></code><span class="deltaxml-new" style="background:#90EE90"> fails if there is no context node, and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:id(?)</span></code><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should</span></span><span class="deltaxml-new" style="background:#90EE90"> fail likewise.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The result is a </span><a title="partially applied function" class="termref" href="#dt-partially-applied-function"><span class="deltaxml-new" style="background:#90EE90">partially applied function</span></a><span class="deltaxml-new" style="background:#90EE90"> having the following properties (which are defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-new" style="background:#90EE90">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">): </span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">name</span></b><span class="deltaxml-new" style="background:#90EE90">: The name of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> if all parameters map to placeholders, that is, if the partial function application is equivalent to the corresponding </span><a title="named function reference" class="termref" href="#dt-named-function-ref"><span class="deltaxml-new" style="background:#90EE90">named function reference</span></a><span class="deltaxml-new" style="background:#90EE90">. Otherwise, the name is absent. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">identity</span></b><span class="deltaxml-new" style="background:#90EE90">: A new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">See also </span><a href="#id-function-identity"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.7 Function Identity</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">arity</span></b><span class="deltaxml-new" style="background:#90EE90">: The number of placeholders in the function call.</span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">parameter names</span></b><span class="deltaxml-new" style="background:#90EE90">: The names of the parameters of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A partial function application can be used to change the order of parameters, for example </span><code><span class="deltaxml-new" style="background:#90EE90">fn:contains(substring := ?, value := ?)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function item that is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">fn:contains#2</span></code><span class="deltaxml-new" style="background:#90EE90">, but with the order of arguments reversed.</span></p></div></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">signature</span></b><span class="deltaxml-new" style="background:#90EE90">: The parameters in the returned function are the parameters of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> that have been identified as placeholder parameters, retaining the order in which the placeholders appear in the function call. The result type of the returned function is the same as the result type of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation which can determine a more specific signature (for example, through use of type analysis) is permitted to do so. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">body</span></b><span class="deltaxml-new" style="background:#90EE90">: The body of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">captured context</span></b><span class="deltaxml-new" style="background:#90EE90">: The static and dynamic context of the function call, augmented, for each explicitly supplied parameter and each defaulted parameter, with a binding of the converted argument value to the corresponding parameter name. </span></p></li></ul><div class="example"><div class="exampleHeader"><a id="d5e17799"></a><span class="deltaxml-new" style="background:#90EE90">Example: Partial Application of a System Function</span></div><p><span class="deltaxml-new" style="background:#90EE90">The following partial function application creates a function item that computes the sum of squares of a sequence.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $sum-of-squares := fold-right(?, 0, function($a, $b) { $a*$a + $b })
return $sum-of-squares(1 to 3)</span></pre></div></div><p><code><span class="deltaxml-new" style="background:#90EE90">$sum-of-squares</span></code><span class="deltaxml-new" style="background:#90EE90"> is an anonymous function. It has one parameter, named </span><code><span class="deltaxml-new" style="background:#90EE90">$seq</span></code><span class="deltaxml-new" style="background:#90EE90">, which is taken from the corresponding parameter in </span><code><span class="deltaxml-new" style="background:#90EE90">fn:fold-right</span></code><span class="deltaxml-new" style="background:#90EE90"> (the other two parameters are fixed). The implementation is the implementation of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:fold-right</span></code><span class="deltaxml-new" style="background:#90EE90">, which is a context-independent system function. The nonlocal bindings contain the fixed bindings for the second and third parameters of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:fold-right</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ol><p><span class="deltaxml-new" style="background:#90EE90">For dynamic function calls, the result is obtained as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> to be partially applied is determined in the same way as for a dynamic function call without placeholders, as described in </span><a href="#id-dynamic-function-invocation"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.1 Dynamic Function Calls</span></b></a><span class="deltaxml-new" style="background:#90EE90">. For this purpose an </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></code><span class="deltaxml-new" style="background:#90EE90"> contributes to the count of arguments.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The parameters of </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> are classified into two categories:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Parameters that map to a placeholder, referred to as </span><b><span class="deltaxml-new" style="background:#90EE90">placeholder parameters</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Parameters for which an explicit value is given in the function call, referred to as </span><b><span class="deltaxml-new" style="background:#90EE90">supplied parameters</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A partial function application need not have any explicitly supplied parameters. For example, if </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> is a function with arity 2, then the partial function application </span><code><span class="deltaxml-new" style="background:#90EE90">$f(?, ?)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function that has exactly the same effect as </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Arguments corresponding to supplied parameters are evaluated and converted to the required type of the parameter, using the rules for dynamic function calls.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A type error is raised if any of the supplied parameters, after applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, does not match the required type.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In addition, a dynamic error </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be raised if any of the supplied parameters does not match other constraints on the value of that parameter (for example, if the value supplied for a parameter expecting a regular expression is not a valid regular expression); or if the processor is able to establish that evaluation of the resulting function will fail for any other reason (for example, if an error is raised while evaluating a subexpression in the function body that depends only on explicitly supplied parameters).</span></p><p><span class="deltaxml-new" style="background:#90EE90">In both cases the error code is the same as for a dynamic function call supplying the same invalid value.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The result of the partial function application is a </span><a title="partially applied function" class="termref" href="#dt-partially-applied-function"><span class="deltaxml-new" style="background:#90EE90">partially applied function</span></a><span class="deltaxml-new" style="background:#90EE90"> with the following properties (which are defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-new" style="background:#90EE90">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">): </span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">name</span></b><span class="deltaxml-new" style="background:#90EE90">: Absent. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">arity</span></b><span class="deltaxml-new" style="background:#90EE90">: The number of placeholders in the function call.</span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">parameter names</span></b><span class="deltaxml-new" style="background:#90EE90">: The names of parameters in </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> that have been identified as placeholder parameters, in order. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In a dynamic partial function application, argument keywords are not available, so it is not possible to change the order of parameters.</span></p></div></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">signature</span></b><span class="deltaxml-new" style="background:#90EE90">: The signature of </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">, removing the types of supplied parameters. An implementation which can determine a more specific signature (for example, through use of type analysis) is permitted to do so. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">body</span></b><span class="deltaxml-new" style="background:#90EE90">: The body of </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">captured context</span></b><span class="deltaxml-new" style="background:#90EE90">: the captured context of </span><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90">, augmented, for each supplied parameter, with a binding of the converted argument value to the corresponding parameter name. </span></p></li></ul><div class="example"><div class="exampleHeader"><a id="d5e17924"></a><span class="deltaxml-new" style="background:#90EE90">Example: Partial Application of an Anonymous Function</span></div><p><span class="deltaxml-new" style="background:#90EE90">In the following example, </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> is an anonymous function, and </span><code><span class="deltaxml-new" style="background:#90EE90">$paf</span></code><span class="deltaxml-new" style="background:#90EE90"> is a partially applied function created from </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $f := function($seq, $delim) { fold-left($seq, "", concat(?, $delim, ?)) }
let $paf := $f(?, ".")
return $paf(1 to 5)</span></pre></div></div><p><code><span class="deltaxml-new" style="background:#90EE90">$paf</span></code><span class="deltaxml-new" style="background:#90EE90"> is also an anonymous function. It has one parameter, named </span><code><span class="deltaxml-new" style="background:#90EE90">$delim</span></code><span class="deltaxml-new" style="background:#90EE90">, which is taken from the corresponding parameter in </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> (the other parameter is fixed). The implementation of </span><code><span class="deltaxml-new" style="background:#90EE90">$paf</span></code><span class="deltaxml-new" style="background:#90EE90"> is the implementation of </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">, which is </span><code><span class="deltaxml-new" style="background:#90EE90">fn:fold-left($seq, "", fn:concat(?, $delim, ?))</span></code><span class="deltaxml-new" style="background:#90EE90">. This implementation is associated with the </span><code><span class="deltaxml-new" style="background:#90EE90">SC</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">DC</span></code><span class="deltaxml-new" style="background:#90EE90"> of the original expression in </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">. The nonlocal bindings associate the value </span><code><span class="deltaxml-new" style="background:#90EE90">"."</span></code><span class="deltaxml-new" style="background:#90EE90"> with the parameter </span><code><span class="deltaxml-new" style="background:#90EE90">$delim</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Partial function application never returns a map or an array. If </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90"> is a map or an array, then </span><code><span class="deltaxml-new" style="background:#90EE90">$f(?)</span></code><span class="deltaxml-new" style="background:#90EE90"> is a partial function application that returns a function, but the function it returns is neither a map nor an array.</span></p><div class="example"><div class="exampleHeader"><a id="d5e17983"></a><span class="deltaxml-new" style="background:#90EE90">Example: Partial Application of a Map</span></div><p><span class="deltaxml-new" style="background:#90EE90">The following partial function application converts a map to an equivalent function that is not a map.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $a := map{ "A": 1, "B": 2 }(?)
return $a("A")</span></pre></div></div></div></div><div class="div4"><h5><a id="id-named-function-ref"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2.4 Named Function References</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NamedFunctionRef" id="doc-xpath40-NamedFunctionRef"></a><span class="deltaxml-new" style="background:#90EE90">[210]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NamedFunctionRef"><span class="deltaxml-new" style="background:#90EE90">NamedFunctionRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> "#" </span><a href="#doc-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-reserved-function-names"><span class="deltaxml-new" style="background:#90EE90">xgc: reserved-function-names</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e16715.doc-xpath40-EQName" id="noid_d4e16715.doc-xpath40-EQName"></a><span class="deltaxml-new" style="background:#90EE90">[266]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-named-function-ref" title="named function reference"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">named function reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression (written </span><code><span class="deltaxml-new" style="background:#90EE90">name#arity</span></code><span class="deltaxml-new" style="background:#90EE90">) which evaluates to a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><span><span class="deltaxml-new" style="background:#90EE90">the details of the function item being based on the properties of a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a></span><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The name and arity of the required function are known statically.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the EQName is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, it is expanded using the </span><a title="default function namespace" class="termref" href="#dt-default-function-namespace"><span class="deltaxml-new" style="background:#90EE90">default function namespace</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The expanded QName and arity must correspond to a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> present in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><span><span class="deltaxml-new" style="background:#90EE90">More specifically, for a named function reference </span><code><span class="deltaxml-new" style="background:#90EE90">F#N</span></code><span class="deltaxml-new" style="background:#90EE90">, there must be a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> whose name matches </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90">, and whose </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a><span class="deltaxml-new" style="background:#90EE90"> includes </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var></span><span class="deltaxml-new" style="background:#90EE90">. Call this </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="context dependent" class="termref" href="#dt-context-dependent"><span class="deltaxml-new" style="background:#90EE90">context dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> for the given arity, then the returned function item has a captured context comprising the static and dynamic context of the named function reference.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In practice, it is necessary to retain only those parts of the static and dynamic context that can affect the outcome. These means it is unnecessary to retain parts of the context that no </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system function</span></a><span class="deltaxml-new" style="background:#90EE90"> depends on (for example, local variables), or parts that are invariant within an execution scope (for example, the implicit timezone).</span></p></div><div class="example"><div class="exampleHeader"><a id="d5e18087"></a><span class="deltaxml-new" style="background:#90EE90">Example: A Context-Dependent Named Function Reference</span></div><p><span class="deltaxml-new" style="background:#90EE90">Consider:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $f := &lt;foo/&gt;/fn:name#0 return &lt;bar/&gt;/$f()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name()</span></code><span class="deltaxml-new" style="background:#90EE90">, with no arguments, returns the name of the context node. The function item delivered by evaluating the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name#0</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the name of the element that was the context node at the point where the function reference was evaluated (that is, the </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;foo&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> element). This expression therefore returns </span><code><span class="deltaxml-new" style="background:#90EE90">"foo"</span></code><span class="deltaxml-new" style="background:#90EE90">, not </span><code><span class="deltaxml-new" style="background:#90EE90">"bar"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">An error is raised if the identified function depends on components of the static or dynamic context that are not present, or that have unsuitable values. For example [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised for the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name#0</span></code><span class="deltaxml-new" style="background:#90EE90"> if the context item is absent, and [</span><a href="https://www.w3.org/TR/xpath-functions/#ERRFODC0001" title="err:FODC0001"><span class="deltaxml-new" style="background:#90EE90">err:FODC0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> is raised for the call </span><code><span class="deltaxml-new" style="background:#90EE90">fn:id#1</span></code><span class="deltaxml-new" style="background:#90EE90"> if the context item is not a node in a tree that is rooted at a document node. The error that is raised is the same as the error that would be raised by the corresponding function if called with the same static and dynamic context.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> and arity in a named function reference do not match the name and </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a><span class="deltaxml-new" style="background:#90EE90"> of a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context, a static error is raised [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90"> The value of a </span><code><span class="deltaxml-new" style="background:#90EE90">NamedFunctionRef</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><var><span class="deltaxml-new" style="background:#90EE90">FI</span></var><span class="deltaxml-new" style="background:#90EE90"> obtained from </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> as follows: </span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">name</span></b><span class="deltaxml-new" style="background:#90EE90">: The name of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">identity</span></b><span class="deltaxml-new" style="background:#90EE90">:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="context dependent" class="termref" href="#dt-context-dependent"><span class="deltaxml-new" style="background:#90EE90">context dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> for the given arity, then a new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In the general case, a function reference to a context-dependent function will produce different results every time it is evaluated, because the resulting function item has a </span><b><span class="deltaxml-new" style="background:#90EE90">captured context</span></b><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-new" style="background:#90EE90">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">) that includes the dynamic context of the particular evaluation. Optimizers, however, are allowed to detect cases where the captured context happens to be the same, or where any variations are immaterial, and where it is therefore safe to return the same function item each time. This might be the case, for example, where the only context dependency of a function is on the default collation, and the default collation for both evaluations is known to be the same.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, a function identity that is the same as that produced by the evaluation of any other named function reference with the same function name and arity.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This rule applies even across different </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope"><span class="deltaxml-new" style="background:#90EE90">execution scopes</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">: for example if a parameter to a call to </span><code><span class="deltaxml-new" style="background:#90EE90">fn:transform</span></code><span class="deltaxml-new" style="background:#90EE90"> is set to the result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:abs#1</span></code><span class="deltaxml-new" style="background:#90EE90">, then the function item passed as the parameter value will be identical to that obtained by evaluating the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:abs#1</span></code><span class="deltaxml-new" style="background:#90EE90"> within the target XSLT stylesheet.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This rule also applies when the target function definition is </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic"><span class="deltaxml-new" style="background:#90EE90">nondeterministic</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. For example all evaluations of the named function reference </span><code><span class="deltaxml-new" style="background:#90EE90">map:keys#2</span></code><span class="deltaxml-new" style="background:#90EE90"> return identical function items, even though two evaluations of </span><code><span class="deltaxml-new" style="background:#90EE90">map:keys</span></code><span class="deltaxml-new" style="background:#90EE90"> with the same arguments may produce different results.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">See also </span><a href="#id-function-identity"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.7 Function Identity</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">arity</span></b><span class="deltaxml-new" style="background:#90EE90">: As specified in the named function reference.</span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">parameter names</span></b><span class="deltaxml-new" style="background:#90EE90">: The first </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> parameter names of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">, where </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is the required arity.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the case where </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> exceeds the number of declared parameters in </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">, the parameter names are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation defined</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">signature</span></b><span class="deltaxml-new" style="background:#90EE90">: Formed from the required types of the first </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> parameters of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">, and the function result type of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the case where </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> exceeds the number of declared parameters in </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">, the required type of each excess parameter in the result is the same as the required type of the last declared parameter of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The required type of each parameter of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#3</span></code><span class="deltaxml-new" style="background:#90EE90"> is thus </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType*</span></code><span class="deltaxml-new" style="background:#90EE90">, which means that a call such as </span><code><span class="deltaxml-new" style="background:#90EE90">concat#3(("a","b"), ("c","d"), ())</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed.</span></p></div></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">body</span></b><span class="deltaxml-new" style="background:#90EE90">: The body of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">captured context</span></b><span class="deltaxml-new" style="background:#90EE90">: Comprises the static and dynamic context of the named function reference, augmented with bindings of the names of parameters of </span><var><span class="deltaxml-new" style="background:#90EE90">FD</span></var><span class="deltaxml-new" style="background:#90EE90"> beyond the </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">’th parameter, to their respective default values.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In practice, it is necessary to retain only the parts of the context that the function actually depends on (if any).</span></p></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Consider the system function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90">, which has an arity range of 2 to 5. The named function reference </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date#3</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function item whose three parameters correspond to the first three parameters of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90">; the remaining two arguments will take their default values. To obtain an arity-3 function that binds to arguments 1, 2, and 5 of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90">, use the partial function application </span><code><span class="deltaxml-new" style="background:#90EE90">format-date(?, ?, place := ?)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The following are examples of named function references: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">fn:abs#1</span></code><span class="deltaxml-new" style="background:#90EE90"> references the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:abs</span></code><span class="deltaxml-new" style="background:#90EE90"> function which takes a single argument.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#5</span></code><span class="deltaxml-new" style="background:#90EE90"> references the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat</span></code><span class="deltaxml-new" style="background:#90EE90"> function which takes 5 arguments.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">local:myfunc#2</span></code><span class="deltaxml-new" style="background:#90EE90"> references a function named </span><code><span class="deltaxml-new" style="background:#90EE90">local:myfunc</span></code><span class="deltaxml-new" style="background:#90EE90"> which takes 2 arguments.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Function items, as values in the data model, have a fixed arity, and a dynamic function call always supplies the arguments positionally. Although the base function referred to may be variadic, the result of evaluating the function reference is a function that has fixed arity. In effect, the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">my:func#3</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of evaluating the inline function expression </span><code><span class="deltaxml-new" style="background:#90EE90">function($x, $y, $z) { my:func($x, $y, $z) }</span></code><span class="deltaxml-new" style="background:#90EE90">, except that the returned function has a name (it retains the name </span><code><span class="deltaxml-new" style="background:#90EE90">my:func</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></div></div><div class="div4"><h5><a id="id-inline-func"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2.5 Inline Function Expressions</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-variadic-functions-overview"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-function-calls"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> In inline function expressions, the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><span class="deltaxml-new" style="background:#90EE90"> may be abbreviated as </span><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">New abbreviated syntax is introduced (</span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-new" style="background:#90EE90">focus function</span></a><span class="deltaxml-new" style="background:#90EE90">) for simple inline functions taking a single argument. An example is </span><code><span class="deltaxml-new" style="background:#90EE90">fn { ../@code }</span></code></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-InlineFunctionExpr" id="doc-xpath40-InlineFunctionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[211]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InlineFunctionExpr"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* ("function" | "fn") </span><a href="#doc-xpath40-FunctionSignature"><span class="deltaxml-new" style="background:#90EE90">FunctionSignature</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-FunctionBody"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e17064.doc-xpath40-Annotation" id="noid_d4e17064.doc-xpath40-Annotation"></a><span class="deltaxml-new" style="background:#90EE90">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"%" </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ("(" </span><a href="#doc-xpath40-AnnotationValue"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-AnnotationValue"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")")?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e17065.doc-xpath40-AnnotationValue" id="noid_d4e17065.doc-xpath40-AnnotationValue"></a><span class="deltaxml-new" style="background:#90EE90">[29]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnnotationValue"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("-"? </span><a href="#doc-xpath40-NumericLiteral"><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("true" "(" ")") | ("false" "(" ")")</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FunctionSignature" id="doc-xpath40-FunctionSignature"></a><span class="deltaxml-new" style="background:#90EE90">[35]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionSignature"><span class="deltaxml-new" style="background:#90EE90">FunctionSignature</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-ParamList"><span class="deltaxml-new" style="background:#90EE90">ParamList</span></a><span class="deltaxml-new" style="background:#90EE90">? ")" </span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ParamList" id="doc-xpath40-ParamList"></a><span class="deltaxml-new" style="background:#90EE90">[38]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ParamList"><span class="deltaxml-new" style="background:#90EE90">ParamList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Param"><span class="deltaxml-new" style="background:#90EE90">Param</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-Param"><span class="deltaxml-new" style="background:#90EE90">Param</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Param" id="doc-xpath40-Param"></a><span class="deltaxml-new" style="background:#90EE90">[39]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Param"><span class="deltaxml-new" style="background:#90EE90">Param</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypeDeclaration" id="doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e17070.doc-xpath40-FunctionBody" id="noid_d4e17070.doc-xpath40-FunctionBody"></a><span class="deltaxml-new" style="background:#90EE90">[40]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionBody"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-inline-func" title="inline function expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">inline function expression</span></b><span><span class="deltaxml-new" style="background:#90EE90">, when evaluated,</span></span><span class="deltaxml-new" style="background:#90EE90"> creates an </span><a title="anonymous function" class="termref" href="#dt-anonymous-function"><span class="deltaxml-new" style="background:#90EE90">anonymous function</span></a><span class="deltaxml-new" style="background:#90EE90"> defined directly in the inline function expression.] An inline function expression specifies the names and SequenceTypes of the parameters to the function, the SequenceType of the result, and the body of the function.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><a title="inline function expression" class="termref" href="#dt-inline-func"><span class="deltaxml-new" style="background:#90EE90">inline function expression</span></a><span class="deltaxml-new" style="background:#90EE90"> whose </span><a href="#doc-xpath40-FunctionSignature"><span class="deltaxml-new" style="background:#90EE90">FunctionSignature</span></a><span class="deltaxml-new" style="background:#90EE90"> is omitted is known as a </span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-new" style="background:#90EE90">focus function</span></a><span class="deltaxml-new" style="background:#90EE90">. Focus functions are described in </span><a href="#id-focus-functions"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.6 Focus Functions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-anonymous-function" title="anonymous function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">anonymous function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> with no name. Anonymous functions may be created, for example, by evaluating an inline function expression or by partial function application.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The keywords </span><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90"> are synonymous.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The syntax allows the names and types of the function argument to be declared, along with the type of the result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">function($x as xs:integer, $y as xs:integer) as xs:integer { $x + $y }</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The types can be omitted</span><span><span class="deltaxml-new" style="background:#90EE90">, and the keyword can be abbreviated</span></span><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">fn($x, $y) { $x + $y }</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">A zero-arity function can be written as, for example, </span><code><span class="deltaxml-new" style="background:#90EE90">fn() { current-date() }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> If a function parameter is declared using a name but no type, its default type is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">. If the result type is omitted, its default result type is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The parameters of an inline function expression are considered to be variables whose scope is the function body. It is a static error [</span><a href="#ERRXQST0039" title="err:XQST0039"><span class="deltaxml-new" style="background:#90EE90">err:XQST0039</span></a><span class="deltaxml-new" style="background:#90EE90">] for an inline function expression to have more than one parameter with the same name. </span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">An inline function expression may have annotations. XQuery 4.0 and XPath 4.0 does not define annotations that apply to inline function expressions, in particular it is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0125" title="err:XQST0125"><span class="deltaxml-new" style="background:#90EE90">err:XQST0125</span></a><span class="deltaxml-new" style="background:#90EE90">] if an inline function expression is annotated as </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90">. An implementation can define annotations, in its own namespace, to support functionality beyond the scope of this specification.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> The static context for the function body is inherited from the location of the inline function expression, with the exception of the static type of the context value which is initially </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The variables in scope for the function body include all variables representing the function parameters, as well as all variables that are in scope for the inline function expression.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> Function parameter names can mask variables that would otherwise be in scope for the function body. </span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The result of an inline function expression is a single function </span><span><span class="deltaxml-new" style="background:#90EE90">item</span></span><span class="deltaxml-new" style="background:#90EE90"> with the following properties (as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#function-items"><span class="deltaxml-new" style="background:#90EE90">Section 2.9.4 Function Items</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">):</span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">name</span></b><span class="deltaxml-new" style="background:#90EE90">: Absent. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">identity</span></b><span class="deltaxml-new" style="background:#90EE90">: A new function identity distinct from the identity of any other function item.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">See also </span><a href="#id-function-identity"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.7 Function Identity</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">parameter names</span></b><span class="deltaxml-new" style="background:#90EE90">: The parameter names in the </span><code><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></code><span class="deltaxml-new" style="background:#90EE90">’s </span><code><span class="deltaxml-new" style="background:#90EE90">ParamList</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">signature</span></b><span class="deltaxml-new" style="background:#90EE90">: A </span><code><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></code><span class="deltaxml-new" style="background:#90EE90"> constructed from the </span><span class="xquery"><span class="xquery"><code><span class="deltaxml-new" style="background:#90EE90">Annotation</span></code><span class="deltaxml-new" style="background:#90EE90">s and</span></span></span><code><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></code><span class="deltaxml-new" style="background:#90EE90">s in the </span><code><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></code><span class="deltaxml-new" style="background:#90EE90">. An implementation which can determine a more specific signature (for example, through use of type analysis of the function’s body) is permitted to do so. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">body</span></b><span class="deltaxml-new" style="background:#90EE90">: The </span><code><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></code><span class="deltaxml-new" style="background:#90EE90">’s </span><code><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><b><span class="deltaxml-new" style="background:#90EE90">captured context</span></b><span class="deltaxml-new" style="background:#90EE90">: the static context is the static context of the inline function expression, with the exception of the static context value type which is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. The dynamic context has an absent </span><a title="focus" class="termref" href="#dt-focus"><span class="deltaxml-new" style="background:#90EE90">focus</span></a><span class="deltaxml-new" style="background:#90EE90">, and a set of variable bindings comprising the </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90"> component of the dynamic context of the </span><code><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The following are examples of some inline function expressions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example creates a function that takes no arguments and returns a sequence of the first 6 primes: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example creates a function that takes two </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> arguments and returns their product: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">fn($a as xs:double, $b as xs:double) as xs:double { $a * $b }</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example creates and invokes a function that captures the value of a local variable in its scope: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $incrementors := (
  for $x in 1 to 10
  return function($y) as xs:integer { $x + $y }
)
return $incrementors[2](4)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this expression is </span><code><span class="deltaxml-new" style="background:#90EE90">6</span></code></p></li></ul></div><div class="div4"><h5><a id="id-focus-functions"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2.6 Focus Functions</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-focus-function" title="focus function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">focus function</span></b><span class="deltaxml-new" style="background:#90EE90"> is an inline function expression in which the function signature is implicit: the function takes a single argument of type </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> (that is, any value), and binds this to the context value when evaluating the function body, which returns a result of type </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of focus functions:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">fn { @age }</span></code><span class="deltaxml-new" style="background:#90EE90"> - a function that expects a node as its argument, and returns the </span><code><span class="deltaxml-new" style="background:#90EE90">@age</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute of that node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">fn { . + 1 }</span></code><span class="deltaxml-new" style="background:#90EE90"> - a function that expects a number as its argument, and returns that number plus one.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function { `${ . }` }</span></code><span class="deltaxml-new" style="background:#90EE90"> - a function that expects a string as its argument, and prepends a </span><code><span class="deltaxml-new" style="background:#90EE90">"$"</span></code><span class="deltaxml-new" style="background:#90EE90"> character.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">function { head(.) + foot(.) }</span></code><span class="deltaxml-new" style="background:#90EE90"> - a function that expects a sequence of numbers as its argument, and returns the sum of the first and last items in the sequence.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Focus functions are often useful as arguments to simple higher-order functions such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:sort</span></code><span class="deltaxml-new" style="background:#90EE90">. For example, to sort employees by salary, write </span><code><span class="deltaxml-new" style="background:#90EE90">sort(//employee, (), fn { +@salary })</span></code><span class="deltaxml-new" style="background:#90EE90">. (The unary plus has the effect of converting the attribute’s value to a number, for numeric sorting).</span></p><p><span class="deltaxml-new" style="background:#90EE90">Focus functions can also be useful on the right-hand side of the </span><a title="sequence arrow operator" class="termref" href="#dt-sequence-arrow-operator"><span class="deltaxml-new" style="background:#90EE90">sequence arrow operator</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="mapping arrow operator" class="termref" href="#dt-mapping-arrow-operator"><span class="deltaxml-new" style="background:#90EE90">mapping arrow operator</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">$s =&gt; tokenize() =!&gt; fn { `"{.}"` }()</span></code><span class="deltaxml-new" style="background:#90EE90"> first tokenizes the string </span><code><span class="deltaxml-new" style="background:#90EE90">$s</span></code><span class="deltaxml-new" style="background:#90EE90">, then wraps each token in double quotation marks.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The result of calling the </span><code><span class="deltaxml-new" style="background:#90EE90">function { EXPR }</span></code><span class="deltaxml-new" style="background:#90EE90"> (or </span><code><span class="deltaxml-new" style="background:#90EE90">fn { EXPR }</span></code><span class="deltaxml-new" style="background:#90EE90">), with a single argument whose value is </span><var><span class="deltaxml-new" style="background:#90EE90">$Z</span></var><span class="deltaxml-new" style="background:#90EE90"> arguments, is obtained by evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">EXPR</span></code><span class="deltaxml-new" style="background:#90EE90"> with a dynamic context in which the context value is </span><var><span class="deltaxml-new" style="background:#90EE90">$Z</span></var><span class="deltaxml-new" style="background:#90EE90">, the context position is 1 (one), and the context size is 1 (one).</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">every(1 to 10, fn{. gt 0})</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div4"><h5><a id="id-function-identity"></a><span class="deltaxml-new" style="background:#90EE90">4.5.2.7 Function Identity</span></h5><p><span class="deltaxml-new" style="background:#90EE90">It is sometimes useful to be able to establish whether two variables refer to the same function or to different functions. For this purpose, every function item has an identity. Functions with the same identity are indistinguishable in every way; in particular, any function call with identical arguments will produce an identical result.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In general, evaluation of an expression that returns a function item other than one that was present in its operands delivers a function item whose identity is unique, and thus distinct from any other function item. There are two exceptions to this rule:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Evaluating a function reference such as </span><code><span class="deltaxml-new" style="background:#90EE90">count#1</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the same function every time. Specifically, if the function name identifies a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> that is not </span><a title="context dependent" class="termref" href="#dt-context-dependent"><span class="deltaxml-new" style="background:#90EE90">context dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> (which is the most usual case), then all function references using this function name and arity return the same function. For more details see </span><a href="#id-named-function-ref"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.4 Named Function References</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An optimizer is permitted to rewrite expressions in such a way that repeated evaluation is avoided if it can be established that the result will be the same each time, and this may be done without consideration of function identity. For example, if the expression </span><code><span class="deltaxml-new" style="background:#90EE90">contains(?, "e")</span></code><span class="deltaxml-new" style="background:#90EE90"> appears within the body of a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, or if the same expression is written repeatedly in a query, then an optimizer may decide to evaluate it once only, and thus return the same function item each time.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, optimizers are allowed to replace any expression with an equivalent expression; for example, </span><code><span class="deltaxml-new" style="background:#90EE90">count(?)</span></code><span class="deltaxml-new" style="background:#90EE90"> may be rewritten as </span><code><span class="deltaxml-new" style="background:#90EE90">count#1</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div></div><div class="div3"><h4><a id="id-variadic-functions-overview"></a><span class="deltaxml-new" style="background:#90EE90">4.5.3 Variadic Functions</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#node-tests"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-inline-func"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Functions may be declared to be variadic. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/161"><span class="deltaxml-new" style="background:#90EE90">161</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1137"><span class="deltaxml-new" style="background:#90EE90">1137</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;23 April 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">This section summarizes the way </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90"> functions work in XQuery 4.0 and XPath 4.0. The detailed rules are distributed around the relevant sections of the specification, but this section attempts to provide an overview in one place for convenience.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> can be declared to be </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90">. Specifically:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Some </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system functions</span></a><span class="deltaxml-new" style="background:#90EE90"> such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:codepoints-to-string</span></code><span class="deltaxml-new" style="background:#90EE90"> are defined to be variadic.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">User-written functions defined in XQuery can be defined as variadic by use of the annotation </span><code><span class="deltaxml-new" style="background:#90EE90">%variadic</span></code><span class="deltaxml-new" style="background:#90EE90"> on the function declaration.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">User written functions defined in XSLT can be defined as variadic by adding the attribute </span><code><span class="deltaxml-new" style="background:#90EE90">variadic="yes"</span></code><span class="deltaxml-new" style="background:#90EE90"> to the </span><code><span class="deltaxml-new" style="background:#90EE90">xsl:function</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In many cases a variadic function definition will declare a single parameter, which will normally have a required type whose occurrence indicator is </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">. The parameter has an implicit default of </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90">, but this is only useful if the occurrence indicator is </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90">; in other cases omitting the relevant argument and invoking the default will lead inevitably to a type error. </span></p><p><span class="deltaxml-new" style="background:#90EE90">It is also possible to define other parameters before the final variadic parameter. If present these must be required parameters.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In static function calls the effect of defining a function as variadic is that the value for the (single or final) parameter can be spread across multiple arguments rather than being supplied as a single argument. For example a sequence of strings can be supplied to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat</span></code><span class="deltaxml-new" style="background:#90EE90"> function either as a single argument: </span><code><span class="deltaxml-new" style="background:#90EE90">concat(("a", "b", "c"))</span></code><span class="deltaxml-new" style="background:#90EE90"> or as a series of separate arguments: </span><code><span class="deltaxml-new" style="background:#90EE90">concat("a", "b", "c")</span></code><span class="deltaxml-new" style="background:#90EE90">. It is also possible to mix the two approaches: the call </span><code><span class="deltaxml-new" style="background:#90EE90">concat("a", (), ("b", "c"))</span></code><span class="deltaxml-new" style="background:#90EE90"> has the same effect.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The argument sequence can also be supplied with a keyword (</span><code><span class="deltaxml-new" style="background:#90EE90">concat(values := ("a", "b", "c"))</span></code><span class="deltaxml-new" style="background:#90EE90">) but in that case it must be supplied as a single argument.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Type checking (using the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">) is applied to the argument value after it has been fully assembled. So, for example, if the declared type in the function definition is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string+</span></code><span class="deltaxml-new" style="background:#90EE90">, then any of the individual arguments may be an empty sequence, but the assembled result must be non-empty.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Function items may be constructed from a variadic function definition in two ways, as usual: either by using a named function reference, or by partial function application. The resulting function items are not themselves variadic: a function item always has a fixed arity and must be called with the correct number of arguments.</span></p><p><span class="deltaxml-new" style="background:#90EE90">So, for example, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#3</span></code><span class="deltaxml-new" style="background:#90EE90"> creates a function item with arity 3, which must always be called with three arguments. The required type for each of these arguments is the same as the required type declared on the final parameter in the function definition, which in this case is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType*</span></code><span class="deltaxml-new" style="background:#90EE90">. This means that a call such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#3(("a", "b"), (), ("c", "d"))</span></code><span class="deltaxml-new" style="background:#90EE90"> is permitted.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, the partial function application </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat("[", ?, "]")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a function item with arity one, with the required type of the single parameter being </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType*</span></code><span class="deltaxml-new" style="background:#90EE90">. This function is equivalent to the anonymous function </span><code><span class="deltaxml-new" style="background:#90EE90">fn($x){fn:concat("[", $x, "]")}</span></code><span class="deltaxml-new" style="background:#90EE90">. The semantics of partial function application are equivalent to first evaluating a named function reference with appropriate arity (in this case </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat#3</span></code><span class="deltaxml-new" style="background:#90EE90">) and then performing a dynamic partial application of the resulting function item.</span></p><div class="example"><div class="exampleHeader"><a id="example-variadic-function"></a><span class="deltaxml-new" style="background:#90EE90">Example: A Variadic Function</span></div><p><span class="deltaxml-new" style="background:#90EE90">The following function, declared in XQuery syntax, computes the product of a sequence of numbers (it might be useful in calculating compound interest).</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare %variadic function m:product as xs:double (
       $input as xs:double*) {
   if (empty($input)) then 1 else head($input) * m:product(tail($input))
};</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The function might be called supplying a single sequence-valued argument:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">m:product(for $year in 2000 to 2024 return $inflation?$year)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Alternatively it might be called with multiple arguments:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">m:product(1.05, 1.04, 1.02, 1.06)</span></pre></div></div></div></div><div class="div2"><h3><a id="id-path-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.6 Path Expressions</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PathExpr" id="doc-xpath40-PathExpr"></a><span class="deltaxml-new" style="background:#90EE90">[137]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("/" </span><a href="#doc-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">?)</span><br><span class="deltaxml-new" style="background:#90EE90">| ("//" </span><a href="#doc-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)</span><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-leading-lone-slash"><span class="deltaxml-new" style="background:#90EE90">xgc: leading-lone-slash</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e17524.doc-xpath40-RelativePathExpr" id="noid_d4e17524.doc-xpath40-RelativePathExpr"></a><span class="deltaxml-new" style="background:#90EE90">[138]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> (("/" | "//") </span><a href="#doc-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-path-expression" title="path expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A path expression consists of a series of one or more </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-new" style="background:#90EE90">steps</span></a><span class="deltaxml-new" style="background:#90EE90">, separated by </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90">, and optionally beginning with </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90">. A </span><b><span class="deltaxml-new" style="background:#90EE90">path expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is typically used to locate nodes within trees. ] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Absolute path expressions (those starting with an initial </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90">), start their selection from the root node of a tree; relative path expressions (those without a leading </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90">) start from the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A path expression consisting of a single step is evaluated as described in </span><a href="#id-steps"><b><span class="deltaxml-new" style="background:#90EE90">4.6.4 Steps</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div3"><h4><a id="id-absolute-path-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.6.1 Absolute Path Expressions</span></h4><p><span class="deltaxml-new" style="background:#90EE90">A path expression consisting of </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> on its own is treated as an abbreviation for </span><code><span class="deltaxml-new" style="background:#90EE90">/.</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An expression of the form </span><code><span class="deltaxml-new" style="background:#90EE90">/PP</span></code><span class="deltaxml-new" style="background:#90EE90"> (that is, a path expression with a leading </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90">) is treated as an abbreviation for the expression </span><code><span class="deltaxml-new" style="background:#90EE90">self::node()/(fn:root(.) treat as document-node())/PP</span></code><span class="deltaxml-new" style="background:#90EE90">. The effect of this expansion is that for every item </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> in the context value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs if </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is not a node [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0020</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The root node </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> of the tree containing </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is selected.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs if </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is not a document node [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0050</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression that follows the leading </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated with </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> as the context value.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The results of these multiple evaluations are then combined into a single sequence; if the result is a set of nodes, the nodes are delivered in document order with duplicates eliminated.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An expression of the form </span><code><span class="deltaxml-new" style="background:#90EE90">//PP</span></code><span class="deltaxml-new" style="background:#90EE90"> (that is, a path expression with a leading </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90">) is treated as an abbreviation for the expression </span><code><span class="deltaxml-new" style="background:#90EE90">self::node()/(fn:root(.) treat as document-node())/descendant-or-self:node()/PP</span></code><span class="deltaxml-new" style="background:#90EE90">. The effect of this expansion is that for every item </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> in the context value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs if </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is not a node [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0020</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The root node </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> of the tree containing </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90"> is selected.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs if </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> is not a document node [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0050</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The descendants of </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> are selected, along with </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> itself.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every node </span><var><span class="deltaxml-new" style="background:#90EE90">D</span></var><span class="deltaxml-new" style="background:#90EE90"> in this set of nodes, the expression that follows the leading </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated with </span><var><span class="deltaxml-new" style="background:#90EE90">D</span></var><span class="deltaxml-new" style="background:#90EE90"> as the context value.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The results of these multiple evaluations are then combined into a single sequence; if the result is a set of nodes, the nodes are delivered in document order with duplicates eliminated.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the context value is not a node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0020</span></a><span class="deltaxml-new" style="background:#90EE90">]. At evaluation time, if the root node of the context node is not a document node, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0050</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The descendants of a node do not include attribute nodes</span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90"> or namespace nodes</span></span></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90"> on its own is not allowed by the grammar.</span></p></div></div><div class="div3"><h4><a id="id-relative-path-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.6.2 Relative Path Expressions</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-RelativePathExpr" id="doc-xpath40-RelativePathExpr"></a><span class="deltaxml-new" style="background:#90EE90">[138]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> (("/" | "//") </span><a href="#doc-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> A relative path expression is a path expression that selects nodes within a tree by following a series of steps starting at the nodes in the context value (which may be any kind of node, not necessarily the root of the tree). </span></p><p><span class="deltaxml-new" style="background:#90EE90"> Each non-initial occurrence of </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90"> in a path expression is expanded as described in </span><a href="#abbrev"><b><span class="deltaxml-new" style="background:#90EE90">4.6.7 Abbreviated Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">, leaving a sequence of steps separated by </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90">. This sequence of steps is then evaluated from left to right. So a path such as </span><code><span class="deltaxml-new" style="background:#90EE90">E1/E2/E3/E4</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated as </span><code><span class="deltaxml-new" style="background:#90EE90">((E1/E2)/E3)/E4</span></code><span class="deltaxml-new" style="background:#90EE90">. The semantics of a path expression are thus defined by the semantics of the binary </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> operator, which is defined in </span><a href="#id-path-operator"><b><span class="deltaxml-new" style="background:#90EE90">4.6.3 Path operator (/)</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> Although the semantics describe the evaluation of a path with more than two steps as proceeding from left to right, the </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> operator is in most cases associative, so evaluation from right to left usually delivers the same result. The cases where </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> is not associative arise when the functions </span><code><span class="deltaxml-new" style="background:#90EE90">fn:position()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:last()</span></code><span class="deltaxml-new" style="background:#90EE90"> are used: </span><code><span class="deltaxml-new" style="background:#90EE90">A/B/position()</span></code><span class="deltaxml-new" style="background:#90EE90"> delivers a sequence of integers from 1 to the size of </span><code><span class="deltaxml-new" style="background:#90EE90">(A/B)</span></code><span class="deltaxml-new" style="background:#90EE90">, whereas </span><code><span class="deltaxml-new" style="background:#90EE90">A/(B/position())</span></code><span class="deltaxml-new" style="background:#90EE90"> restarts the counting at each </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90"> element. </span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the use of relative path expressions. In each case it is assumed that the context value is a single node, referred to as the context node.</span></p><div class="example"><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::div1/child::para</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the </span><code><span class="deltaxml-new" style="background:#90EE90">div1</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node; that is, the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element grandchildren of the context node that have </span><code><span class="deltaxml-new" style="background:#90EE90">div1</span></code><span class="deltaxml-new" style="background:#90EE90"> parents.</span></p></li></ul></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Since each step in a path provides context nodes for the following step, in effect, only the last step in a path is allowed to return a sequence of non-nodes.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p id="Chg-slash-note"><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> character can be used either as a complete path expression or as the beginning of a longer path expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">/*</span></code><span class="deltaxml-new" style="background:#90EE90">. Also, </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> is both the multiply operator and a wildcard in path expressions. This can cause parsing difficulties when </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> appears on the left-hand side of </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">. This is resolved using the </span><a href="#parse-note-leading-lone-slash"><span class="deltaxml-new" style="background:#90EE90">leading-lone-slash </span></a><span class="deltaxml-new" style="background:#90EE90"> constraint. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">/*</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">/ *</span></code><span class="deltaxml-new" style="background:#90EE90"> are valid path expressions containing wildcards, but </span><code><span class="deltaxml-new" style="background:#90EE90">/*5</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">/ * 5</span></code><span class="deltaxml-new" style="background:#90EE90"> raise syntax errors. Parentheses must be used when </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> is used on the left-hand side of an operator that could be confused with a node test, as in </span><code><span class="deltaxml-new" style="background:#90EE90">(/) * 5</span></code><span class="deltaxml-new" style="background:#90EE90">. Similarly, </span><code><span class="deltaxml-new" style="background:#90EE90">4 + / * 5</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a syntax error, but </span><code><span class="deltaxml-new" style="background:#90EE90">4 + (/) * 5</span></code><span class="deltaxml-new" style="background:#90EE90"> is a valid expression. The expression </span><code><span class="deltaxml-new" style="background:#90EE90">4 + /</span></code><span class="deltaxml-new" style="background:#90EE90"> is also valid, because </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> does not occur on the left-hand side of the operator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, in the expression </span><code><span class="deltaxml-new" style="background:#90EE90">/ union /*</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90"> is interpreted as an element name rather than an operator. For it to be parsed as an operator, the expression should be written </span><code><span class="deltaxml-new" style="background:#90EE90">(/) union /*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="id-path-operator"></a><span class="deltaxml-new" style="background:#90EE90">4.6.3 Path operator (</span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The path operator </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> is primarily used for locating nodes within trees. Its left-hand operand must return a sequence of nodes. The result of the operator is either a sequence of nodes (in document order, with no duplicates), or a sequence of non-nodes.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The operation </span><code><span class="deltaxml-new" style="background:#90EE90">E1/E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated as follows: Expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, and if the result is not a (possibly empty) sequence </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> of nodes, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0019" title="err:XPTY0019"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0019</span></a><span class="deltaxml-new" style="background:#90EE90">]. Each node in </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> then serves in turn to provide an inner focus (the node as the context value, its position in </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> as the context position, the length of </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> as the context size) for an evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#eval_context"><b><span class="deltaxml-new" style="background:#90EE90">2.2.2 Dynamic Context</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The sequences resulting from all the evaluations of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> are combined as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If every evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a (possibly empty) sequence of nodes, these sequences are combined, and duplicate nodes are eliminated based on node identity. The resulting node sequence is returned in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If every evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a (possibly empty) sequence of non-nodes, these sequences are concatenated</span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">, in order,</span></span></span><span class="deltaxml-new" style="background:#90EE90"> and returned. The returned sequence preserves the orderings within and among the subsequences generated by the evaluations of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the multiple evaluations of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> return at least one node and at least one non-node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0018" title="err:XPTY0018"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0018</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The semantics of the path operator can also be defined using the simple map operator (</span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90">) as follows (the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:distinct-ordered-nodes($R)</span></code><span class="deltaxml-new" style="background:#90EE90"> has the effect of eliminating duplicates and sorting nodes into document order):</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $R := E1 ! E2
return if (every $r in $R satisfies $r instance of node())
       then (fn:distinct-ordered-nodes($R))
       else if (every $r in $R satisfies not($r instance of node()))
       then $R
       else error()</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">For a table comparing the step operator to the map operator, see </span><a href="#id-map-operator"><b><span class="deltaxml-new" style="background:#90EE90">4.22 Simple map operator (!)</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="id-steps"></a><span class="deltaxml-new" style="background:#90EE90">4.6.4 Steps</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StepExpr" id="doc-xpath40-StepExpr"></a><span class="deltaxml-new" style="background:#90EE90">[139]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-AxisStep"><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e17959.doc-xpath40-AxisStep" id="noid_d4e17959.doc-xpath40-AxisStep"></a><span class="deltaxml-new" style="background:#90EE90">[140]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AxisStep"><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#doc-xpath40-ReverseStep"><span class="deltaxml-new" style="background:#90EE90">ReverseStep</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForwardStep"><span class="deltaxml-new" style="background:#90EE90">ForwardStep</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a><span class="deltaxml-new" style="background:#90EE90">*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForwardStep" id="doc-xpath40-ForwardStep"></a><span class="deltaxml-new" style="background:#90EE90">[141]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForwardStep"><span class="deltaxml-new" style="background:#90EE90">ForwardStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#doc-xpath40-ForwardAxis"><span class="deltaxml-new" style="background:#90EE90">ForwardAxis</span></a><a href="#doc-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">) | </span><a href="#doc-xpath40-AbbrevForwardStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevForwardStep</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ReverseStep" id="doc-xpath40-ReverseStep"></a><span class="deltaxml-new" style="background:#90EE90">[144]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ReverseStep"><span class="deltaxml-new" style="background:#90EE90">ReverseStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#doc-xpath40-ReverseAxis"><span class="deltaxml-new" style="background:#90EE90">ReverseAxis</span></a><a href="#doc-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">) | </span><a href="#doc-xpath40-AbbrevReverseStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevReverseStep</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e17962.doc-xpath40-Predicate" id="noid_d4e17962.doc-xpath40-Predicate"></a><span class="deltaxml-new" style="background:#90EE90">[160]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"[" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "]"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-step" title="step"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">step</span></b><span class="deltaxml-new" style="background:#90EE90"> is a part of a </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-new" style="background:#90EE90">path expression</span></a><span class="deltaxml-new" style="background:#90EE90"> that generates a sequence of items and then filters the sequence by zero or more </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new" style="background:#90EE90">predicates</span></a><span class="deltaxml-new" style="background:#90EE90">. The value of the step consists of those items that satisfy the predicates, working from left to right. A step may be either an </span><a title="axis step" class="termref" href="#dt-axis-step"><span class="deltaxml-new" style="background:#90EE90">axis step</span></a><span class="deltaxml-new" style="background:#90EE90"> or a postfix expression.] Postfix expressions are described in </span><a href="#id-postfix-expression"><b><span class="deltaxml-new" style="background:#90EE90">4.3 Postfix Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-axis-step" title="axis step"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">axis step</span></b><span class="deltaxml-new" style="background:#90EE90"> returns a sequence of nodes that are reachable from a starting node via a specified axis. Such a step has two parts: an </span><b><span class="deltaxml-new" style="background:#90EE90">axis</span></b><span class="deltaxml-new" style="background:#90EE90">, which defines the "direction of movement" for the step, and a </span><a title="node test" class="termref" href="#dt-node-test"><span class="deltaxml-new" style="background:#90EE90">node test</span></a><span class="deltaxml-new" style="background:#90EE90">, which selects nodes based on their kind, name, and/or </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> .] </span></p><p><span class="deltaxml-new" style="background:#90EE90">If the context value is a sequence of zero or more nodes, an axis step returns a sequence of zero or more nodes; otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0020" title="err:XPTY0020"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0020</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The step expression </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">./S</span></code><span class="deltaxml-new" style="background:#90EE90">. Thus, if the context value is a sequence containing multiple nodes, the semantics of a step expression are equivalent to a path expression in which the step is always applied to a single node. The following description therefore explains the semantics for the case where the context value is a single node, called the context node.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The equivalence of a step </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> to the path expression </span><code><span class="deltaxml-new" style="background:#90EE90">./S</span></code><span class="deltaxml-new" style="background:#90EE90"> means that the resulting node sequence is returned in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">An axis step may be either a </span><b><span class="deltaxml-new" style="background:#90EE90">forward step</span></b><span class="deltaxml-new" style="background:#90EE90"> or a </span><b><span class="deltaxml-new" style="background:#90EE90">reverse step</span></b><span class="deltaxml-new" style="background:#90EE90">, followed by zero or more </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new" style="background:#90EE90">predicates</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the </span><b><span class="deltaxml-new" style="background:#90EE90">abbreviated syntax</span></b><span class="deltaxml-new" style="background:#90EE90"> for a step, the axis can be omitted and other shorthand notations can be used as described in </span><a href="#abbrev"><b><span class="deltaxml-new" style="background:#90EE90">4.6.7 Abbreviated Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The unabbreviated syntax for an axis step consists of the axis name and node test separated by a double colon. The result of the step consists of the nodes reachable from the starting node via the specified axis that have the node kind, name, and/or </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> specified by the node test. For example, the step </span><code><span class="deltaxml-new" style="background:#90EE90">child::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node: </span><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><span class="deltaxml-new" style="background:#90EE90"> is the name of the axis, and </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> is the name of the element nodes to be selected on this axis. The available axes are described in </span><a href="#axes"><b><span class="deltaxml-new" style="background:#90EE90">4.6.4.1 Axes</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The available node tests are described in </span><a href="#node-tests"><b><span class="deltaxml-new" style="background:#90EE90">4.6.4.2 Node Tests</span></b></a><span class="deltaxml-new" style="background:#90EE90">. Examples of steps are provided in </span><a href="#unabbrev"><b><span class="deltaxml-new" style="background:#90EE90">4.6.6 Unabbreviated Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#abbrev"><b><span class="deltaxml-new" style="background:#90EE90">4.6.7 Abbreviated Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div4"><h5><a id="axes"></a><span class="deltaxml-new" style="background:#90EE90">4.6.4.1 Axes</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForwardAxis" id="doc-xpath40-ForwardAxis"></a><span class="deltaxml-new" style="background:#90EE90">[142]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForwardAxis"><span class="deltaxml-new" style="background:#90EE90">ForwardAxis</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("attribute"</span><br><span class="deltaxml-new" style="background:#90EE90">| "child"</span><br><span class="deltaxml-new" style="background:#90EE90">| "descendant"</span><br><span class="deltaxml-new" style="background:#90EE90">| "descendant-or-self"</span><br><span class="deltaxml-new" style="background:#90EE90">| "following"</span><br><span class="deltaxml-new" style="background:#90EE90">| "following-sibling"</span><br><span class="deltaxml-new" style="background:#90EE90">| "namespace"</span><br><span class="deltaxml-new" style="background:#90EE90">| "self") "::"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ReverseAxis" id="doc-xpath40-ReverseAxis"></a><span class="deltaxml-new" style="background:#90EE90">[145]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ReverseAxis"><span class="deltaxml-new" style="background:#90EE90">ReverseAxis</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("ancestor"</span><br><span class="deltaxml-new" style="background:#90EE90">| "ancestor-or-self"</span><br><span class="deltaxml-new" style="background:#90EE90">| "parent"</span><br><span class="deltaxml-new" style="background:#90EE90">| "preceding"</span><br><span class="deltaxml-new" style="background:#90EE90">| "preceding-sibling") "::"</span></code></td></tr></tbody></table><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath defines a full set of </span><b><span class="deltaxml-new" style="background:#90EE90">axes</span></b><span class="deltaxml-new" style="background:#90EE90"> for traversing documents, but a </span><b><span class="deltaxml-new" style="background:#90EE90">host language</span></b><span class="deltaxml-new" style="background:#90EE90"> may define a subset of these axes. The following axes are defined:</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery supports the following axes:</span></p></div><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the children of the context node, which are the nodes returned by the </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dm-children"><span class="deltaxml-new" style="background:#90EE90">Section 4.3 children Accessor</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Only document nodes and element nodes have children. If the context node is any other kind of node, or if the context node is an empty document or element node, then the child axis is an empty sequence. The children of a document node or element node may be element, processing instruction, comment, or text nodes. Attribute</span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">, namespace,</span></span></span><span class="deltaxml-new" style="background:#90EE90"> and document nodes can never appear as children.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">descendant</span></code><span class="deltaxml-new" style="background:#90EE90"> axis is defined as the transitive closure of the child axis; it contains the descendants of the context node (the children, the children of the children, and so on).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the sequence returned by the </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dm-parent"><span class="deltaxml-new" style="background:#90EE90">Section 4.11 parent Accessor</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, which returns the parent of the context node, or an empty sequence if the context node has no parent.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><span class="deltaxml-new" style="background:#90EE90"> axis is defined as the transitive closure of the parent axis; it contains the ancestors of the context node (the parent, the parent of the parent, and so on).</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The ancestor axis includes the root node of the tree in which the context node is found, unless the context node is the root node.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">the </span><code><span class="deltaxml-new" style="background:#90EE90">following-sibling</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the context node’s following siblings, those children of the context node’s parent that occur after the context node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">; if the context node is an attribute </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90"> or namespace </span></span></span><span class="deltaxml-new" style="background:#90EE90"> node, the </span><code><span class="deltaxml-new" style="background:#90EE90">following-sibling</span></code><span class="deltaxml-new" style="background:#90EE90"> axis is empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">the </span><code><span class="deltaxml-new" style="background:#90EE90">preceding-sibling</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the context node’s preceding siblings, those children of the context node’s parent that occur before the context node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">; if the context node is an attribute </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90"> or namespace </span></span></span><span class="deltaxml-new" style="background:#90EE90"> node, the </span><code><span class="deltaxml-new" style="background:#90EE90">preceding-sibling</span></code><span class="deltaxml-new" style="background:#90EE90"> axis is empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">following</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not descendants of the context node, and occur after the context node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">preceding</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains all nodes that are descendants of the root of the tree in which the context node is found, are not ancestors of the context node, and occur before the context node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the attributes of the context node, which are the nodes returned by the </span><span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dm-attributes"><span class="deltaxml-new" style="background:#90EE90">Section 4.1 attributes Accessor</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup></span><span class="deltaxml-new" style="background:#90EE90">; the axis will be empty unless the context node is an element.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">self</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains just the context node itself.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">descendant-or-self</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the context node and the descendants of the context node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor-or-self</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the context node and the ancestors of the context node; thus, the ancestor-or-self axis will always include the root node.</span></p></li><li class="xpath"><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> axis contains the namespace nodes of the context node, which are the nodes returned by the </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dm-namespace-nodes"><span class="deltaxml-new" style="background:#90EE90">Section 4.7 namespace-nodes Accessor</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">; this axis is empty unless the context node is an element node. The </span><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> axis is deprecated as of XPath 2.0. If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> axis must be supported. If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, then support for the </span><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> axis is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. An implementation that does not support the </span><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> axis when </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> must raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0010" title="err:XPST0010"><span class="deltaxml-new" style="background:#90EE90">err:XPST0010</span></a><span class="deltaxml-new" style="background:#90EE90">] if it is used. Applications needing information about the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of an element should use the functions </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-in-scope-prefixes"><span class="deltaxml-new" style="background:#90EE90">Section 10.2.7 fn:in-scope-prefixes</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, and </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-namespace-uri-for-prefix"><span class="deltaxml-new" style="background:#90EE90">Section 10.2.8 fn:namespace-uri-for-prefix</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Axes can be categorized as </span><b><span class="deltaxml-new" style="background:#90EE90">forward axes</span></b><span class="deltaxml-new" style="background:#90EE90"> and </span><b><span class="deltaxml-new" style="background:#90EE90">reverse axes</span></b><span class="deltaxml-new" style="background:#90EE90">. An axis that only ever contains the context node or nodes that are after the context node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90"> is a forward axis. An axis that only ever contains the context node or nodes that are before the context node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90"> is a reverse axis.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor-or-self</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">preceding</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">preceding-sibling</span></code><span class="deltaxml-new" style="background:#90EE90"> axes are reverse axes; all other axes are forward axes. The </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">descendant</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">following</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">preceding</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">self</span></code><span class="deltaxml-new" style="background:#90EE90"> axes partition a document (ignoring attribute </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">and namespace</span></span></span><span class="deltaxml-new" style="background:#90EE90"> nodes): they do not overlap and together they contain all the nodes in the document.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-principal-node-kind" title="principal node kind"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Every axis has a </span><b><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></b><span class="deltaxml-new" style="background:#90EE90">. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.] Thus:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">For the attribute axis, the principal node kind is attribute.</span></p></li><li class="xpath"><p><span class="deltaxml-new" style="background:#90EE90">For the namespace axis, the principal node kind is namespace.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For all other axes, the principal node kind is element.</span></p></li></ul></div><div class="div4"><h5><a id="node-tests"></a><span class="deltaxml-new" style="background:#90EE90">4.6.4.2 Node Tests</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#implausible-axis-steps"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-variadic-functions-overview"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> If the default namespace for elements and types has the special value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, then an unprefixed name in a </span><code><span class="deltaxml-new" style="background:#90EE90">NameTest</span></code><span class="deltaxml-new" style="background:#90EE90"> acts as a wildcard, matching names in any namespace or none. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/296"><span class="deltaxml-new" style="background:#90EE90">296</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1181"><span class="deltaxml-new" style="background:#90EE90">1181</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;30 April 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-node-test" title="node test"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">node test</span></b><span class="deltaxml-new" style="background:#90EE90"> is a condition on the name, kind (element, attribute, text, document, comment, or processing instruction), and/or </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of a node. A node test determines which nodes contained by an axis are selected by a </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-new" style="background:#90EE90">step</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NodeTest" id="doc-xpath40-NodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[147]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnionNodeTest"><span class="deltaxml-new" style="background:#90EE90">UnionNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-UnionNodeTest" id="doc-xpath40-UnionNodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[148]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnionNodeTest"><span class="deltaxml-new" style="background:#90EE90">UnionNodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SimpleNodeTest" id="doc-xpath40-SimpleNodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[149]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NameTest" id="doc-xpath40-NameTest"></a><span class="deltaxml-new" style="background:#90EE90">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Wildcard" id="doc-xpath40-Wildcard"></a><span class="deltaxml-new" style="background:#90EE90">[151]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"*"</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> ":*")</span><br><span class="deltaxml-new" style="background:#90EE90">| ("*:" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90">)</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> "*")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e18347.doc-xpath40-EQName" id="noid_d4e18347.doc-xpath40-EQName"></a><span class="deltaxml-new" style="background:#90EE90">[266]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e18348.doc-xpath40-KindTest" id="noid_d4e18348.doc-xpath40-KindTest"></a><span class="deltaxml-new" style="background:#90EE90">[233]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DocumentTest"><span class="deltaxml-new" style="background:#90EE90">DocumentTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-PITest"><span class="deltaxml-new" style="background:#90EE90">PITest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CommentTest"><span class="deltaxml-new" style="background:#90EE90">CommentTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-TextTest"><span class="deltaxml-new" style="background:#90EE90">TextTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-NamespaceNodeTest"><span class="deltaxml-new" style="background:#90EE90">NamespaceNodeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-AnyKindTest"><span class="deltaxml-new" style="background:#90EE90">AnyKindTest</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-UnionNodeTest"><span class="deltaxml-new" style="background:#90EE90">UnionNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> matches a node </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> if at least one of the constituent </span><a href="#doc-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">s matches </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, </span><code><span class="deltaxml-new" style="background:#90EE90">(div1|div2|div3)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a node named </span><code><span class="deltaxml-new" style="background:#90EE90">div1</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">div2</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">div3</span></code></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-name-test" title="name test"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A node test that consists only of an EQName or a Wildcard is called a </span><b><span class="deltaxml-new" style="background:#90EE90">name test</span></b><span class="deltaxml-new" style="background:#90EE90">.] A name test that consists of an EQName matches a node </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> if and only if the </span><b><span class="deltaxml-new" style="background:#90EE90">kind</span></b><span class="deltaxml-new" style="background:#90EE90"> of node </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is the </span><a title="principal node kind" class="termref" href="#dt-principal-node-kind"><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></a><span class="deltaxml-new" style="background:#90EE90"> for the step axis and the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> of the node is equal (as defined by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator) to the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> specified by the name test. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">child::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node; if the context node has no </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> children, it selects an empty set of nodes. </span><code><span class="deltaxml-new" style="background:#90EE90">attribute::abc:href</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the attribute of the context node with the QName </span><code><span class="deltaxml-new" style="background:#90EE90">abc:href</span></code><span class="deltaxml-new" style="background:#90EE90">; if the context node has no such attribute, it selects an empty set of nodes.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the EQName is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, it is resolved into an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> in the expression context. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">] if the QName has a prefix that does not correspond to any statically known namespace. An unprefixed QName, when used as a name test on an axis whose </span><a title="principal node kind" class="termref" href="#dt-principal-node-kind"><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><span class="deltaxml-new" style="background:#90EE90">, is interpreted as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is a namespace URI, then the name is interpreted as having that namespace URI.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is the special value </span><code><span class="deltaxml-new" style="background:#90EE90">"##any</span></code><span class="deltaxml-new" style="background:#90EE90">, then the name is interpreted as a wildcard that matches any element with the specified local name, in any namespace or none.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is absent, then the name is interpreted as being in no namespace.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">A name test is not satisfied by an element node whose name does not match the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> of the name test, even if it is in a </span><a title="substitution group" class="termref" href="#dt-substitution-group"><span class="deltaxml-new" style="background:#90EE90">substitution group</span></a><span class="deltaxml-new" style="background:#90EE90"> whose head is the named element.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A node test </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> is true for any node of the </span><a title="principal node kind" class="termref" href="#dt-principal-node-kind"><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></a><span class="deltaxml-new" style="background:#90EE90"> of the step axis. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">child::*</span></code><span class="deltaxml-new" style="background:#90EE90"> will select all element children of the context node, and </span><code><span class="deltaxml-new" style="background:#90EE90">attribute::*</span></code><span class="deltaxml-new" style="background:#90EE90"> will select all attributes of the context node.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A node test can have the form </span><code><span class="deltaxml-new" style="background:#90EE90">NCName:*</span></code><span class="deltaxml-new" style="background:#90EE90">. In this case, the prefix is expanded in the same way as with a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">. If the prefix is not found in the statically known namespaces, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">]. The node test is true for any node of the </span><a title="principal node kind" class="termref" href="#dt-principal-node-kind"><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></a><span class="deltaxml-new" style="background:#90EE90"> of the step axis whose </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> has the namespace URI to which the prefix is bound, regardless of the local part of the name.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A node test can contain a </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">, for example </span><code><span class="deltaxml-new" style="background:#90EE90">Q{http://example.com/msg}*</span></code><span class="deltaxml-new" style="background:#90EE90">. Such a node test is true for any node of the principal node kind of the step axis whose expanded QName has the namespace URI specified in the </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">, regardless of the local part of the name.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A node test can also have the form </span><code><span class="deltaxml-new" style="background:#90EE90">*:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">. In this case, the node test is true for any node of the </span><a title="principal node kind" class="termref" href="#dt-principal-node-kind"><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></a><span class="deltaxml-new" style="background:#90EE90"> of the step axis whose local name matches the given NCName, regardless of its namespace or lack of a namespace.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-kind-test" title="kind test"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An alternative form of a node test called a </span><b><span class="deltaxml-new" style="background:#90EE90">kind test</span></b><span class="deltaxml-new" style="background:#90EE90"> can select nodes based on their kind, name, and </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90">.] The syntax and semantics of a kind test are described in </span><a href="#id-sequencetype-syntax"><b><span class="deltaxml-new" style="background:#90EE90">3.1 Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-sequencetype-matching"><b><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></b></a><span class="deltaxml-new" style="background:#90EE90">. When a kind test is used in a </span><a title="node test" class="termref" href="#dt-node-test"><span class="deltaxml-new" style="background:#90EE90">node test</span></a><span class="deltaxml-new" style="background:#90EE90">, only those nodes on the designated axis that match the kind test are selected. Shown below are several examples of kind tests that might be used in path expressions:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">node()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">text()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any text node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">comment()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any comment node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">namespace-node()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any namespace node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">schema-element(person)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is in the </span><a title="substitution group" class="termref" href="#dt-substitution-group"><span class="deltaxml-new" style="background:#90EE90">substitution group</span></a><span class="deltaxml-new" style="background:#90EE90"> headed by </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90">), and whose type annotation is the same as (or is derived from) the declared type of the </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90"> element in the </span><a title="in-scope element declarations" class="termref" href="#dt-is-elems"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(person)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of its type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(doctor|nurse)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">doctor</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">nurse</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of its type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(person, surgeon)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any non-nilled element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90">, and whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90"> or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(doctor|nurse, medical-staff)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any non-nilled element node whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">doctor</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">nurse</span></code><span class="deltaxml-new" style="background:#90EE90">, and whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">medical-staff</span></code><span class="deltaxml-new" style="background:#90EE90"> or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">medical-staff</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">element(*, surgeon)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any non-nilled element node whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">surgeon</span></code><span class="deltaxml-new" style="background:#90EE90">), regardless of its name.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(price)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">price</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of its type annotation.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute(*, xs:decimal)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any attribute whose type annotation is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> (or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">), regardless of its name.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">document-node()</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any document node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">document-node(element(book))</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any document node whose content consists of a single element node that satisfies the </span><a title="kind test" class="termref" href="#dt-kind-test"><span class="deltaxml-new" style="background:#90EE90">kind test</span></a><code><span class="deltaxml-new" style="background:#90EE90">element(book)</span></code><span class="deltaxml-new" style="background:#90EE90">, interleaved with zero or more comments and processing instructions.</span></p></li></ul></div><div class="div4"><h5><a id="implausible-axis-steps"></a><span class="deltaxml-new" style="background:#90EE90">4.6.4.3 Implausible Axis Steps</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-arithmetic"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#node-tests"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as </span><code><span class="deltaxml-new" style="background:#90EE90">@price/@value</span></code><span class="deltaxml-new" style="background:#90EE90">, even though dynamic evaluation is defined to return an empty sequence rather than an error. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/602"><span class="deltaxml-new" style="background:#90EE90">602</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/603"><span class="deltaxml-new" style="background:#90EE90">603</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;25 July 2023]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">Certain axis steps, given an inferred type for the context value, are classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90">. During the static analysis phase, a processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> (subject to the rules in </span><a href="#id-implausible-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.6 Implausible Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">) report a static error when such axis steps are encountered: [</span><a href="#ERRXPTY0144" title="err:XPTY0144"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0144</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">More specifically, an axis step is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> if any of the following conditions applies:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The inferred item type of the context value is a node kind for which the specified axis is always empty: for example, the inferred item type of the context value is </span><code><span class="deltaxml-new" style="background:#90EE90">attribute()</span></code><span class="deltaxml-new" style="background:#90EE90"> and the axis is </span><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The node test exclusively selects node kinds that cannot appear on the specified axis: for example, the axis is </span><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><span class="deltaxml-new" style="background:#90EE90"> and the node test is </span><code><span class="deltaxml-new" style="background:#90EE90">document-node()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In a schema-aware environment, when using the </span><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">descendant</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">descendant-or-self</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><span class="deltaxml-new" style="background:#90EE90"> axes, the inferred item type of the context value has a content type that does not allow any node matching the node test to be present on the relevant axis. For example, if the inferred item type of the context value is </span><code><span class="deltaxml-new" style="background:#90EE90">schema-element(list)</span></code><span class="deltaxml-new" style="background:#90EE90"> and the relevant element declaration (taking into account substitution group membership and wildcards) only allows </span><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><span class="deltaxml-new" style="background:#90EE90"> children, the axis step </span><code><span class="deltaxml-new" style="background:#90EE90">child::li</span></code><span class="deltaxml-new" style="background:#90EE90"> will never select anything and is therefore classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Examples of implausible axis steps include the following:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">@code/text()</span></code><span class="deltaxml-new" style="background:#90EE90">: attributes cannot have text node children.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">/@code</span></code><span class="deltaxml-new" style="background:#90EE90">: document nodes cannot have attributes.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">ancestor::text()</span></code><span class="deltaxml-new" style="background:#90EE90">: the ancestor axis never returns text nodes.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Processors may choose not to classify the expression </span><code><span class="deltaxml-new" style="background:#90EE90">/..</span></code><span class="deltaxml-new" style="background:#90EE90"> as implausible, since XSLT 1.0 users were sometimes advised to use this construct as an explicit way of denoting the empty sequence.</span></p></div></div></div><div class="div3"><h4><a id="id-predicate"></a><span class="deltaxml-new" style="background:#90EE90">4.6.5 Predicates within Steps</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AxisStep" id="doc-xpath40-AxisStep"></a><span class="deltaxml-new" style="background:#90EE90">[140]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AxisStep"><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#doc-xpath40-ReverseStep"><span class="deltaxml-new" style="background:#90EE90">ReverseStep</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForwardStep"><span class="deltaxml-new" style="background:#90EE90">ForwardStep</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a><span class="deltaxml-new" style="background:#90EE90">*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e18808.doc-xpath40-Predicate" id="noid_d4e18808.doc-xpath40-Predicate"></a><span class="deltaxml-new" style="background:#90EE90">[160]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"[" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "]"</span></code></td></tr></tbody></table><p id="dt-predicate"><span class="deltaxml-new" style="background:#90EE90">A predicate within a Step has similar syntax and semantics to a predicate within a </span><a title="filter expression" class="termref" href="#dt-filter-expression"><span class="deltaxml-new" style="background:#90EE90">filter expression</span></a><span class="deltaxml-new" style="background:#90EE90">. The only difference is in the way the context position is set for evaluation of the predicate.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For the purpose of evaluating the context position within a predicate, the input sequence is considered to be sorted as follows: into document order if the predicate is in a forward-axis step, into reverse document order if the predicate is in a reverse-axis step, or in its original order if the predicate is not in a step.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of </span><a title="axis step" class="termref" href="#dt-axis-step"><span class="deltaxml-new" style="background:#90EE90">axis steps</span></a><span class="deltaxml-new" style="background:#90EE90"> that contain predicates:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example selects the second </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> element that is a child of the context node:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">child::chapter[2]</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example selects all the descendants of the context node that are elements named </span><code><span class="deltaxml-new" style="background:#90EE90">"toy"</span></code><span class="deltaxml-new" style="background:#90EE90"> and whose </span><code><span class="deltaxml-new" style="background:#90EE90">color</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute has the value </span><code><span class="deltaxml-new" style="background:#90EE90">"red"</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">descendant::toy[attribute::color = "red"]</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">employee</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have both a </span><code><span class="deltaxml-new" style="background:#90EE90">secretary</span></code><span class="deltaxml-new" style="background:#90EE90"> child element and an </span><code><span class="deltaxml-new" style="background:#90EE90">assistant</span></code><span class="deltaxml-new" style="background:#90EE90"> child element:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">child::employee[secretary][assistant]</span></pre></div></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">When using </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new" style="background:#90EE90">predicates</span></a><span class="deltaxml-new" style="background:#90EE90"> with a sequence of nodes selected using a </span><b><span class="deltaxml-new" style="background:#90EE90">reverse axis</span></b><span class="deltaxml-new" style="background:#90EE90">, the context positions for such a sequence are assigned in </span><a title="reverse document order" class="termref" href="#dt-reverse-document-order"><span class="deltaxml-new" style="background:#90EE90">reverse document order</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">preceding::foo[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the first qualifying </span><code><span class="deltaxml-new" style="background:#90EE90">foo</span></code><span class="deltaxml-new" style="background:#90EE90"> element in </span><a title="reverse document order" class="termref" href="#dt-reverse-document-order"><span class="deltaxml-new" style="background:#90EE90">reverse document order</span></a><span class="deltaxml-new" style="background:#90EE90">, because the predicate is part of an </span><a title="axis step" class="termref" href="#dt-axis-step"><span class="deltaxml-new" style="background:#90EE90">axis step</span></a><span class="deltaxml-new" style="background:#90EE90"> using a reverse axis. By contrast, </span><code><span class="deltaxml-new" style="background:#90EE90">(preceding::foo)[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the first qualifying </span><code><span class="deltaxml-new" style="background:#90EE90">foo</span></code><span class="deltaxml-new" style="background:#90EE90"> element in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">, because the parentheses cause </span><code><span class="deltaxml-new" style="background:#90EE90">(preceding::foo)</span></code><span class="deltaxml-new" style="background:#90EE90"> to be parsed as a </span><a title="primary expression" class="termref" href="#dt-primary-expression"><span class="deltaxml-new" style="background:#90EE90">primary expression</span></a><span class="deltaxml-new" style="background:#90EE90"> in which context positions are assigned in document order. Similarly, </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor::*[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the nearest ancestor element, because the </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><span class="deltaxml-new" style="background:#90EE90"> axis is a reverse axis, whereas </span><code><span class="deltaxml-new" style="background:#90EE90">(ancestor::*)[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the root element (first ancestor in document order).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The fact that a reverse-axis step assigns context positions in reverse document order for the purpose of evaluating predicates does not alter the fact that the final result of the step </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">(when in ordered mode) </span></span></span><span class="deltaxml-new" style="background:#90EE90"> is always in document order.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor::(div1|div2)[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> does not have the same meaning as </span><code><span class="deltaxml-new" style="background:#90EE90">(ancestor::div1|ancestor::div2)[1]</span></code><span class="deltaxml-new" style="background:#90EE90">. In the first expression, the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> is within a step that uses a reverse axis, so nodes are counted in reverse document order. In the second expression, the predicate applies to the result of a union expression, so nodes are counted in document order.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">When the context value for evaluation of a step includes multiple nodes, the step is evaluated separately for each of those nodes, and the results are combined. This means, for example, that if the context value contains three </span><code><span class="deltaxml-new" style="background:#90EE90">list</span></code><span class="deltaxml-new" style="background:#90EE90"> nodes, and each of those nodes has multiple </span><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><span class="deltaxml-new" style="background:#90EE90"> children, then the step </span><code><span class="deltaxml-new" style="background:#90EE90">item[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> will deliver a sequence of three </span><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><span class="deltaxml-new" style="background:#90EE90"> elements, namely the first </span><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><span class="deltaxml-new" style="background:#90EE90"> from each </span><code><span class="deltaxml-new" style="background:#90EE90">list</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div3"><h4><a id="unabbrev"></a><span class="deltaxml-new" style="background:#90EE90">4.6.6 Unabbreviated Syntax</span></h4><p><span class="deltaxml-new" style="background:#90EE90">This section provides a number of examples of path expressions in which the axis is explicitly specified in each </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-new" style="background:#90EE90">step</span></a><span class="deltaxml-new" style="background:#90EE90">. The syntax used in these examples is called the </span><b><span class="deltaxml-new" style="background:#90EE90">unabbreviated syntax</span></b><span class="deltaxml-new" style="background:#90EE90">. In many common cases, it is possible to write path expressions more concisely using an </span><b><span class="deltaxml-new" style="background:#90EE90">abbreviated syntax</span></b><span class="deltaxml-new" style="background:#90EE90">, as explained in </span><a href="#abbrev"><b><span class="deltaxml-new" style="background:#90EE90">4.6.7 Abbreviated Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">These examples assume that the context value is a single node, referred to as the context node.</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::(para|bullet)</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">bullet</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::*</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all element children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::text()</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all text node children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::(text()|comment())</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all text node and comment node children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::node()</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute::name</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">name</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attribute::*</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the attributes of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">parent::node()</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">descendant::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element descendants of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">ancestor::div</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90"> ancestors of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">ancestor-or-self::div</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90"> ancestors of the context node and, if the context node is a </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90"> element, the context node as well.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">descendant-or-self::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element descendants of the context node and, if the context node is a </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element, the context node as well.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">self::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the context node if it is a </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element, and otherwise returns an empty sequence.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">self::(chapter|appendix)</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the context node if it is a </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">appendix</span></code><span class="deltaxml-new" style="background:#90EE90"> element, and otherwise returns an empty sequence.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::chapter/descendant::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element descendants of the </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::*/child::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> grandchildren of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">/descendant::para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> elements in the same document as the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">/descendant::list/child::member</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90"> elements that have a </span><code><span class="deltaxml-new" style="background:#90EE90">list</span></code><span class="deltaxml-new" style="background:#90EE90"> parent and that are in the same document as the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para[position() = 1]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the first </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para[position() = last()]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the last </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para[position() = last()-1]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the last but one </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para[position() &gt; 1]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node other than the first </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">following-sibling::chapter[position() = 1]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the next </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> sibling of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">following-sibling::(chapter|appendix)[position() = 1]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the next sibling of the context node that is either a </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> or an </span><code><span class="deltaxml-new" style="background:#90EE90">appendix</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">preceding-sibling::chapter[position() = 1]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the previous </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> sibling of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">/descendant::figure[position() = 42]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the forty-second </span><code><span class="deltaxml-new" style="background:#90EE90">figure</span></code><span class="deltaxml-new" style="background:#90EE90"> element in the document containing the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">/child::book/child::chapter[position() = 5]/child::section[position() = 2]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the second </span><code><span class="deltaxml-new" style="background:#90EE90">section</span></code><span class="deltaxml-new" style="background:#90EE90"> of the fifth </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><span class="deltaxml-new" style="background:#90EE90">book</span></code><span class="deltaxml-new" style="background:#90EE90"> whose parent is the document node that contains the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para[attribute::type eq "warning"]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have a </span><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute with value </span><code><span class="deltaxml-new" style="background:#90EE90">warning</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para[attribute::type eq 'warning'][position() = 5]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the fifth </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node that has a </span><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute with value </span><code><span class="deltaxml-new" style="background:#90EE90">warning</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::para[position() = 5][attribute::type eq "warning"]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the fifth </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node if that child has a </span><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute with value </span><code><span class="deltaxml-new" style="background:#90EE90">warning</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::chapter[child::title = 'Introduction']</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have one or more </span><code><span class="deltaxml-new" style="background:#90EE90">title</span></code><span class="deltaxml-new" style="background:#90EE90"> children whose </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> is equal to the string </span><code><span class="deltaxml-new" style="background:#90EE90">Introduction</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::chapter[child::title]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have one or more </span><code><span class="deltaxml-new" style="background:#90EE90">title</span></code><span class="deltaxml-new" style="background:#90EE90"> children.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::*[self::chapter or self::appendix]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">appendix</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::*[self::(chapter|appendix)][position() = last()]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the last </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">appendix</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node.</span></p></li></ul></div><div class="div3"><h4><a id="abbrev"></a><span class="deltaxml-new" style="background:#90EE90">4.6.7 Abbreviated Syntax</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AbbrevForwardStep" id="doc-xpath40-AbbrevForwardStep"></a><span class="deltaxml-new" style="background:#90EE90">[143]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AbbrevForwardStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevForwardStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("@" </span><a href="#doc-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">) | </span><a href="#doc-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AbbrevReverseStep" id="doc-xpath40-AbbrevReverseStep"></a><span class="deltaxml-new" style="background:#90EE90">[146]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AbbrevReverseStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevReverseStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">".."</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The abbreviated syntax permits the following abbreviations:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The attribute axis </span><code><span class="deltaxml-new" style="background:#90EE90">attribute::</span></code><span class="deltaxml-new" style="background:#90EE90"> can be abbreviated by </span><code><span class="deltaxml-new" style="background:#90EE90">@</span></code><span class="deltaxml-new" style="background:#90EE90">. For example, a path expression </span><code><span class="deltaxml-new" style="background:#90EE90">para[@type = "warning"]</span></code><span class="deltaxml-new" style="background:#90EE90"> is short for </span><code><span class="deltaxml-new" style="background:#90EE90">child::para[attribute::type = "warning"]</span></code><span class="deltaxml-new" style="background:#90EE90"> and so selects </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> children with a </span><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute with value equal to </span><code><span class="deltaxml-new" style="background:#90EE90">warning</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the axis name is omitted from an </span><a title="axis step" class="termref" href="#dt-axis-step"><span class="deltaxml-new" style="background:#90EE90">axis step</span></a><span class="deltaxml-new" style="background:#90EE90">, the default axis is </span><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><span class="deltaxml-new" style="background:#90EE90">, with two exceptions: (1) if the </span><a href="#doc-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> in an axis step contains an </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> then the default axis is </span><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><span class="deltaxml-new" style="background:#90EE90">; (2) if the </span><a href="#doc-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> in an axis step is a </span><a href="#doc-xpath40-NamespaceNodeTest"><span class="deltaxml-new" style="background:#90EE90">NamespaceNodeTest</span></a><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">then a static error is raised [</span><a href="#ERRXQST0134" title="err:XQST0134"><span class="deltaxml-new" style="background:#90EE90">err:XQST0134</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">then the default axis is </span><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><span class="deltaxml-new" style="background:#90EE90">, but in an implementation that does not support the namespace axis, an error is raised [</span><a href="#ERRXQST0134" title="err:XQST0134"><span class="deltaxml-new" style="background:#90EE90">err:XQST0134</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></span></span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> The namespace axis is deprecated as of XPath 2.0, but is required in some languages that use XPath, including XSLT.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> For example, the path expression </span><code><span class="deltaxml-new" style="background:#90EE90">section/para</span></code><span class="deltaxml-new" style="background:#90EE90"> is an abbreviation for </span><code><span class="deltaxml-new" style="background:#90EE90">child::section/child::para</span></code><span class="deltaxml-new" style="background:#90EE90">, and the path expression </span><code><span class="deltaxml-new" style="background:#90EE90">section/@id</span></code><span class="deltaxml-new" style="background:#90EE90"> is an abbreviation for </span><code><span class="deltaxml-new" style="background:#90EE90">child::section/attribute::id</span></code><span class="deltaxml-new" style="background:#90EE90">. Similarly, </span><code><span class="deltaxml-new" style="background:#90EE90">section/attribute(id)</span></code><span class="deltaxml-new" style="background:#90EE90"> is an abbreviation for </span><code><span class="deltaxml-new" style="background:#90EE90">child::section/attribute::attribute(id)</span></code><span class="deltaxml-new" style="background:#90EE90">. Note that the latter expression contains both an axis specification and a </span><a title="node test" class="termref" href="#dt-node-test"><span class="deltaxml-new" style="background:#90EE90">node test</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An abbreviated axis step that omits the axis name must use a </span><a href="#doc-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> rather than a </span><a href="#doc-xpath40-UnionNodeTest"><span class="deltaxml-new" style="background:#90EE90">UnionNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">. This means that a construct such as </span><code><span class="deltaxml-new" style="background:#90EE90">(ul|ol)</span></code><span class="deltaxml-new" style="background:#90EE90"> is treated as an abbreviation for </span><code><span class="deltaxml-new" style="background:#90EE90">(child::ul|child::ol)</span></code><span class="deltaxml-new" style="background:#90EE90"> rather than </span><code><span class="deltaxml-new" style="background:#90EE90">child::(ul|ol)</span></code><span class="deltaxml-new" style="background:#90EE90">. Since the two constructs have exactly the same semantics, this is not actually a restriction.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Each non-initial occurrence of </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90"> is effectively replaced by </span><code><span class="deltaxml-new" style="background:#90EE90">/descendant-or-self::node()/</span></code><span class="deltaxml-new" style="background:#90EE90"> during processing of a path expression. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">div1//para</span></code><span class="deltaxml-new" style="background:#90EE90"> is short for </span><code><span class="deltaxml-new" style="background:#90EE90">child::div1/descendant-or-self::node()/child::para</span></code><span class="deltaxml-new" style="background:#90EE90"> and so will select all </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> descendants of </span><code><span class="deltaxml-new" style="background:#90EE90">div1</span></code><span class="deltaxml-new" style="background:#90EE90"> children.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The path expression </span><code><span class="deltaxml-new" style="background:#90EE90">//para[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> does </span><em><span class="deltaxml-new" style="background:#90EE90">not</span></em><span class="deltaxml-new" style="background:#90EE90"> mean the same as the path expression </span><code><span class="deltaxml-new" style="background:#90EE90">/descendant::para[1]</span></code><span class="deltaxml-new" style="background:#90EE90">. The latter selects the first descendant </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element; the former selects all descendant </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> elements that are the first </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> children of their respective parents.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A step consisting of </span><code><span class="deltaxml-new" style="background:#90EE90">..</span></code><span class="deltaxml-new" style="background:#90EE90"> is short for </span><code><span class="deltaxml-new" style="background:#90EE90">parent::node()</span></code><span class="deltaxml-new" style="background:#90EE90">. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">../title</span></code><span class="deltaxml-new" style="background:#90EE90"> is short for </span><code><span class="deltaxml-new" style="background:#90EE90">parent::node()/child::title</span></code><span class="deltaxml-new" style="background:#90EE90"> and so will select the </span><code><span class="deltaxml-new" style="background:#90EE90">title</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the parent of the context node.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90">, known as a </span><b><span class="deltaxml-new" style="background:#90EE90">context value reference</span></b><span class="deltaxml-new" style="background:#90EE90">, is a </span><a title="primary expression" class="termref" href="#dt-primary-expression"><span class="deltaxml-new" style="background:#90EE90">primary expression</span></a><span class="deltaxml-new" style="background:#90EE90">, and is described in </span><a href="#id-context-value-references"><b><span class="deltaxml-new" style="background:#90EE90">4.2.3 Context Value References</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of path expressions that use the abbreviated syntax. These examples assume that the context value is a single node, referred to as the context node:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all element children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">text()</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all text node children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">@name</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">name</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">@(id|name)</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">id</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">name</span></code><span class="deltaxml-new" style="background:#90EE90"> attributes of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">@*</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the attributes of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">para[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the first </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">para[last()]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the last </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">*/para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> grandchildren of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">/book/chapter[5]/section[2]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the second </span><code><span class="deltaxml-new" style="background:#90EE90">section</span></code><span class="deltaxml-new" style="background:#90EE90"> of the fifth </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><span class="deltaxml-new" style="background:#90EE90">book</span></code><span class="deltaxml-new" style="background:#90EE90"> whose parent is the document node that contains the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">chapter//para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element descendants of the </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">//para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> descendants of the root document node and thus selects all </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> elements in the same document as the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">//@version</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">version</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute nodes that are in the same document as the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">//list/member</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90"> elements in the same document as the context node that have a </span><code><span class="deltaxml-new" style="background:#90EE90">list</span></code><span class="deltaxml-new" style="background:#90EE90"> parent.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">.//para</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element descendants of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">..</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the parent of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">../@lang</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">lang</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute of the parent of the context node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">para[@type = "warning"]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have a </span><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute with value </span><code><span class="deltaxml-new" style="background:#90EE90">warning</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">para[@type = "warning"][5]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the fifth </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node that has a </span><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute with value </span><code><span class="deltaxml-new" style="background:#90EE90">warning</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">para[5][@type = "warning"]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the fifth </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> child of the context node if that child has a </span><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute with value </span><code><span class="deltaxml-new" style="background:#90EE90">warning</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">chapter[title = "Introduction"]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have one or more </span><code><span class="deltaxml-new" style="background:#90EE90">title</span></code><span class="deltaxml-new" style="background:#90EE90"> children whose </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> is equal to the string </span><code><span class="deltaxml-new" style="background:#90EE90">Introduction</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">chapter[title]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have one or more </span><code><span class="deltaxml-new" style="background:#90EE90">title</span></code><span class="deltaxml-new" style="background:#90EE90"> children.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">employee[@secretary and @assistant]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects all the </span><code><span class="deltaxml-new" style="background:#90EE90">employee</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node that have both a </span><code><span class="deltaxml-new" style="background:#90EE90">secretary</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute and an </span><code><span class="deltaxml-new" style="background:#90EE90">assistant</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">book/(chapter|appendix)/section</span></code><span class="deltaxml-new" style="background:#90EE90"> selects every </span><code><span class="deltaxml-new" style="background:#90EE90">section</span></code><span class="deltaxml-new" style="background:#90EE90"> element that has a parent that is either a </span><code><span class="deltaxml-new" style="background:#90EE90">chapter</span></code><span class="deltaxml-new" style="background:#90EE90"> or an </span><code><span class="deltaxml-new" style="background:#90EE90">appendix</span></code><span class="deltaxml-new" style="background:#90EE90"> element, that in turn is a child of a </span><code><span class="deltaxml-new" style="background:#90EE90">book</span></code><span class="deltaxml-new" style="background:#90EE90"> element that is a child of the context node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> is any expression that returns a sequence of nodes, then the expression </span><code><span class="deltaxml-new" style="background:#90EE90">E/.</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the same nodes in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">, with duplicates eliminated based on node identity.</span></p></li></ul></div></div><div class="div2"><h3><a id="id-sequence-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.7 Sequence Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 supports operators to construct, filter, and combine </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-new" style="background:#90EE90">sequences</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">. Sequences are never nested—for example, combining the values </span><code><span class="deltaxml-new" style="background:#90EE90">1</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">(2, 3)</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">( )</span></code><span class="deltaxml-new" style="background:#90EE90"> into a single sequence results in the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div3"><h4><a id="construct_seq"></a><span class="deltaxml-new" style="background:#90EE90">4.7.1 Sequence Concatenation</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e19833.doc-xpath40-Expr" id="noid_d4e19833.doc-xpath40-Expr"></a><span class="deltaxml-new" style="background:#90EE90">[45]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-comma-operator" title="comma operator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: One way to construct a sequence is by using the </span><b><span class="deltaxml-new" style="background:#90EE90">comma operator</span></b><span class="deltaxml-new" style="background:#90EE90">, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.] Empty parentheses can be used to denote an empty sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A sequence may contain duplicate </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">, but a sequence is never an item in another sequence. When a new sequence is created by concatenating two or more input sequences, the new sequence contains all the items of the input sequences and its length is the sum of the lengths of the input sequences.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-sequence-concatenation" title="sequence concatenation"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></b><span class="deltaxml-new" style="background:#90EE90"> of a number of sequences </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ... </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> is defined to be the sequence formed from the items of </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, followed by the items from </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, and so on, retaining order.] The comma operator returns the sequence concatenation of its two operands; repeated application (for example </span><code><span class="deltaxml-new" style="background:#90EE90">$s1, $s2, $s3, $s4</span></code><span class="deltaxml-new" style="background:#90EE90">) delivers the sequence concatenation of multiple sequences.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In places where the grammar calls for </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of expressions that construct sequences: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The result of this expression is a sequence of five integers:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(10, 1, 2, 3, 4)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">10, 1, 2, 3, 4</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(10, (1, 2), (), (3, 4))</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of this expression is a sequence containing all </span><code><span class="deltaxml-new" style="background:#90EE90">salary</span></code><span class="deltaxml-new" style="background:#90EE90"> children of the context node followed by all </span><code><span class="deltaxml-new" style="background:#90EE90">bonus</span></code><span class="deltaxml-new" style="background:#90EE90"> children.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(salary, bonus)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Assuming that </span><code><span class="deltaxml-new" style="background:#90EE90">$price</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the value </span><code><span class="deltaxml-new" style="background:#90EE90">10.50</span></code><span class="deltaxml-new" style="background:#90EE90">, the result of this expression is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">10.50, 10.50</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($price, $price)</span></pre></div></div></li></ul></div><div class="div3"><h4><a id="id-range-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.7.2 Range Expressions</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-RangeExpr" id="doc-xpath40-RangeExpr"></a><span class="deltaxml-new" style="background:#90EE90">[112]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-RangeExpr"><span class="deltaxml-new" style="background:#90EE90">RangeExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AdditiveExpr"><span class="deltaxml-new" style="background:#90EE90">AdditiveExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "to" </span><a href="#doc-xpath40-AdditiveExpr"><span class="deltaxml-new" style="background:#90EE90">AdditiveExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">RangeExpression</span></b><span class="deltaxml-new" style="background:#90EE90"> can be used to construct a sequence of integers. Each of the operands is converted as though it was an argument of a function with the expected parameter type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer?</span></code><span class="deltaxml-new" style="background:#90EE90">. If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate the semantics:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">1 to 4</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">1, 2, 3, 4</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">10 to 10</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the singleton sequence </span><code><span class="deltaxml-new" style="background:#90EE90">10</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">10 to 1</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the empty sequence</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">-13 to -10</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">-13, -12, -11, -10</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">More formally, a </span><b><span class="deltaxml-new" style="background:#90EE90">RangeExpression</span></b><span class="deltaxml-new" style="background:#90EE90"> is evaluated as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Each of the operands of the </span><code><span class="deltaxml-new" style="background:#90EE90">to</span></code><span class="deltaxml-new" style="background:#90EE90"> operator is converted as though it was an argument of a function with the expected parameter type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer?</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the two operands convert to the same integer, the result of the range expression is that integer.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate the use of </span><code><span class="deltaxml-new" style="background:#90EE90">RangeExpressions</span></code><span class="deltaxml-new" style="background:#90EE90"> .</span></p><div class="example"><p><span class="deltaxml-new" style="background:#90EE90">This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">10, 1, 2, 3, 4</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(10, 1 to 4)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This example selects the first four items from an input sequence:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$input[position() = 1 to 4]</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This example returns the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(0, 0.1, 0.2, 0.3, 0.5)</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$x = (1 to 5)!.*0.1</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This example constructs a sequence of length one containing the single integer 10.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">10 to 10</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this example is a sequence of length zero.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">15 to 10</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This example uses the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:reverse</span></code><span class="deltaxml-new" style="background:#90EE90"> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence 15, 14, 13, 12, 11, 10.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">reverse(10 to 15)</span></pre></div></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">To construct a sequence of integers based on steps other than 1, use the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:slice</span></code><span class="deltaxml-new" style="background:#90EE90"> function, as defined in </span><a href="https://www.w3.org/TR/xpath-functions-31/#general-seq-funcs"><span class="deltaxml-new" style="background:#90EE90">Section 14.1 General functions and operators on sequences </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO31</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="combining_seq"></a><span class="deltaxml-new" style="background:#90EE90">4.7.3 Combining Node Sequences</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-UnionExpr" id="doc-xpath40-UnionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[115]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnionExpr"><span class="deltaxml-new" style="background:#90EE90">UnionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-IntersectExceptExpr"><span class="deltaxml-new" style="background:#90EE90">IntersectExceptExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("union" | "|") </span><a href="#doc-xpath40-IntersectExceptExpr"><span class="deltaxml-new" style="background:#90EE90">IntersectExceptExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-IntersectExceptExpr" id="doc-xpath40-IntersectExceptExpr"></a><span class="deltaxml-new" style="background:#90EE90">[116]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-IntersectExceptExpr"><span class="deltaxml-new" style="background:#90EE90">IntersectExceptExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-InstanceofExpr"><span class="deltaxml-new" style="background:#90EE90">InstanceofExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("intersect" | "except") </span><a href="#doc-xpath40-InstanceofExpr"><span class="deltaxml-new" style="background:#90EE90">InstanceofExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 provides the following operators for combining sequences of nodes:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">|</span></code><span class="deltaxml-new" style="background:#90EE90"> operators are equivalent. They take two node sequences as operands and return a sequence containing all the nodes that occur in either of the operands.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">intersect</span></code><span class="deltaxml-new" style="background:#90EE90"> operator takes two node sequences as operands and returns a sequence containing all the nodes that occur in both operands.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">except</span></code><span class="deltaxml-new" style="background:#90EE90"> operator takes two node sequences as operands and returns a sequence containing all the nodes that occur in the first operand but not in the second operand.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">All these operators eliminate duplicate nodes from their result sequences based on node identity. The resulting sequence is returned in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">If an operand of </span><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">intersect</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">except</span></code><span class="deltaxml-new" style="background:#90EE90"> contains an item that is not a node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90"> If an </span><code><span class="deltaxml-new" style="background:#90EE90">IntersectExceptExpr</span></code><span class="deltaxml-new" style="background:#90EE90"> contains more than two </span><code><span class="deltaxml-new" style="background:#90EE90">InstanceofExprs, they are grouped from left to right.</span></code><span class="deltaxml-new" style="background:#90EE90"> With a </span><code><span class="deltaxml-new" style="background:#90EE90">UnionExpr</span></code><span class="deltaxml-new" style="background:#90EE90">, it makes no difference how operands are grouped, the results are the same. </span></p><div class="example"><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of expressions that combine sequences. Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C. Assume that the variables </span><code><span class="deltaxml-new" style="background:#90EE90">$seq1</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$seq2</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$seq3</span></code><span class="deltaxml-new" style="background:#90EE90"> are bound to the following sequences of these nodes:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq1</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to (A, B)</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq2</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to (A, B)</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq3</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to (B, C)</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Then: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq1 union $seq2</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence (A, B). </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq2 union $seq3</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence (A, B, C). </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq1 intersect $seq2</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence (A, B). </span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq2 intersect $seq3</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence containing B only.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq1 except $seq2</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the empty sequence.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$seq2 except $seq3</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence containing A only.</span></p></li></ul></div><p><span class="deltaxml-new" style="background:#90EE90">In addition to the sequence operators described here, see </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#sequence-functions"><span class="deltaxml-new" style="background:#90EE90">Section 13 Functions and operators on sequences</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> for functions defined on sequences. </span></p></div></div><div class="div2"><h3><a id="id-arithmetic"></a><span class="deltaxml-new" style="background:#90EE90">4.8 Arithmetic Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-string-templates"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#implausible-axis-steps"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The symbols </span><code><span class="deltaxml-new" style="background:#90EE90">×</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">÷</span></code><span class="deltaxml-new" style="background:#90EE90"> can be used for multiplication and division. </span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 provides arithmetic operators for addition, subtraction, multiplication, division, and modulus, in their usual binary and unary forms.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AdditiveExpr" id="doc-xpath40-AdditiveExpr"></a><span class="deltaxml-new" style="background:#90EE90">[113]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AdditiveExpr"><span class="deltaxml-new" style="background:#90EE90">AdditiveExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MultiplicativeExpr"><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("+" | "-") </span><a href="#doc-xpath40-MultiplicativeExpr"><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MultiplicativeExpr" id="doc-xpath40-MultiplicativeExpr"></a><span class="deltaxml-new" style="background:#90EE90">[114]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MultiplicativeExpr"><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnionExpr"><span class="deltaxml-new" style="background:#90EE90">UnionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("*" | "×" | "div" | "÷" | "idiv" | "mod") </span><a href="#doc-xpath40-UnionExpr"><span class="deltaxml-new" style="background:#90EE90">UnionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-UnaryExpr" id="doc-xpath40-UnaryExpr"></a><span class="deltaxml-new" style="background:#90EE90">[122]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("-" | "+")* </span><a href="#doc-xpath40-ValueExpr"><span class="deltaxml-new" style="background:#90EE90">ValueExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ValueExpr" id="doc-xpath40-ValueExpr"></a><span class="deltaxml-new" style="background:#90EE90">[123]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ValueExpr"><span class="deltaxml-new" style="background:#90EE90">ValueExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ValidateExpr"><span class="deltaxml-new" style="background:#90EE90">ValidateExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ExtensionExpr"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-SimpleMapExpr"><span class="deltaxml-new" style="background:#90EE90">SimpleMapExpr</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A subtraction operator must be preceded by whitespace if it could otherwise be interpreted as part of the previous token. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">a-b</span></code><span class="deltaxml-new" style="background:#90EE90"> will be interpreted as a name, but </span><code><span class="deltaxml-new" style="background:#90EE90">a - b</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">a -b</span></code><span class="deltaxml-new" style="background:#90EE90"> will be interpreted as arithmetic expressions. (See </span><a href="#whitespace-rules"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5 Whitespace Rules</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for further details on whitespace handling.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">The arithmetic operator symbols </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">×</span></code><span class="deltaxml-new" style="background:#90EE90"> (xD7) are interchangeable, and denote multiplication.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The arithmetic operator symbols </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">÷</span></code><span class="deltaxml-new" style="background:#90EE90"> (xF7) are interchangeable, and denote division.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> If an </span><code><span class="deltaxml-new" style="background:#90EE90">AdditiveExpr</span></code><span class="deltaxml-new" style="background:#90EE90"> contains more than two </span><code><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExprs</span></code><span class="deltaxml-new" style="background:#90EE90">, they are grouped from left to right. So, for instance, </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">A - B + C - D</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">((A - B) + C) - D</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> Similarly, the operands of a </span><code><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExpr</span></code><span class="deltaxml-new" style="background:#90EE90"> are grouped from left to right. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The first step in evaluating an arithmetic expression is to evaluate its operands. The order in which the operands are evaluated is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, each operand is evaluated by applying the following steps, in order:</span></p></div><div class="xpath"><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the operand. The result of this operation is called the </span><b><span class="deltaxml-new" style="background:#90EE90">atomized operand</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized operand is an empty sequence, the result of the arithmetic expression is the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90">, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized operand is a sequence of length greater than one, any items after the first item in the sequence are discarded.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized operand is now an instance of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> (including </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">), </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, then it is converted to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> by applying the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:number</span></code><span class="deltaxml-new" style="background:#90EE90"> function. (Note that </span><code><span class="deltaxml-new" style="background:#90EE90">fn:number</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the value </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> if its operand cannot be converted to a number.)</span></p></li></ol></div><p><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, each</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Each</span></span></span><span class="deltaxml-new" style="background:#90EE90"> operand is evaluated by applying the following steps, in order:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the operand. The result of this operation is called the </span><b><span class="deltaxml-new" style="background:#90EE90">atomized operand</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized operand is an empty sequence, the result of the arithmetic expression is an empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the atomized operand is a sequence of length greater than one, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized operand is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, it is cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">. If the cast fails, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised. [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001" title="err:FORG0001"><span class="deltaxml-new" style="background:#90EE90">err:FORG0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">After evaluation of the operands, if the types of the operands are a valid combination for the given arithmetic operator, the operator is applied to the operands, resulting in an atomic item or a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> (for example, an error might result from dividing by zero). The combinations of atomic types that are accepted by the various arithmetic operators, and their respective result types, are listed in </span><a href="#mapping"><b><span class="deltaxml-new" style="background:#90EE90">B.2 Operator Mapping</span></b></a><span class="deltaxml-new" style="background:#90EE90"> together with the </span><a title="operator function" class="termref" href="#dt-operator-function"><span class="deltaxml-new" style="background:#90EE90">operator functions</span></a><span class="deltaxml-new" style="background:#90EE90"> that define the semantics of the operator for each type combination, including the dynamic errors that can be raised by the operator. The definitions of the operator functions are found in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in </span><a href="#mapping"><b><span class="deltaxml-new" style="background:#90EE90">B.2 Operator Mapping</span></b></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 provides three division operators:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">÷</span></code><span class="deltaxml-new" style="background:#90EE90"> operators are synonyms, and implement numeric division as well as division of duration values; the semantics are defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-numeric-divide"><span class="deltaxml-new" style="background:#90EE90">Section 4.2.4 op:numeric-divide</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">idiv</span></code><span class="deltaxml-new" style="background:#90EE90"> operator implements integer division; the semantics are defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-numeric-integer-divide"><span class="deltaxml-new" style="background:#90EE90">Section 4.2.5 op:numeric-integer-divide</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of arithmetic expressions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The first expression below returns the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">-1.5</span></code><span class="deltaxml-new" style="background:#90EE90">, and the second expression returns the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">-1</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">-3 div 2
-3 idiv 2</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Subtraction of two date values results in a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$emp/hiredate - $emp/birthdate</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates the difference between a subtraction operator and a hyphen:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$unit-price - $unit-discount</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Unary operators have higher precedence than binary operators (other than </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code><span class="deltaxml-new" style="background:#90EE90">), subject of course to the use of parentheses. Therefore, the following two examples have different meanings:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</span></pre></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p id="note-consecutive-unary-ops"><span class="deltaxml-new" style="background:#90EE90">Multiple consecutive unary arithmetic operators are permitted.</span></p></div></div><div class="div2"><h3><a id="id-string-expr"></a><span class="deltaxml-new" style="background:#90EE90">4.9 String Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">This section describes several ways of constructing strings.</span></p><div class="div3"><h4><a id="id-string-concat-expr"></a><span class="deltaxml-new" style="background:#90EE90">4.9.1 String Concatenation Expressions</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringConcatExpr" id="doc-xpath40-StringConcatExpr"></a><span class="deltaxml-new" style="background:#90EE90">[111]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringConcatExpr"><span class="deltaxml-new" style="background:#90EE90">StringConcatExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-RangeExpr"><span class="deltaxml-new" style="background:#90EE90">RangeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "||" </span><a href="#doc-xpath40-RangeExpr"><span class="deltaxml-new" style="background:#90EE90">RangeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">String concatenation expressions allow the string representations of values to be concatenated. In XQuery 4.0 and XPath 4.0, </span><code><span class="deltaxml-new" style="background:#90EE90">$a || $b</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">fn:concat($a, $b)</span></code><span class="deltaxml-new" style="background:#90EE90">. The following expression evaluates to the string </span><code><span class="deltaxml-new" style="background:#90EE90">concatenate</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">() || "con" || ("cat", "enate")</span></pre></div></div><div class="div3"><h4><a id="id-string-templates"></a><span class="deltaxml-new" style="background:#90EE90">4.9.2 String Templates</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-value-comparisons"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-arithmetic"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> String templates provide a new way of constructing strings: for example </span><code><span class="deltaxml-new" style="background:#90EE90">`{$greeting}, {$planet}!`</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">$greeting || ', ' || $planet || '!'</span></code><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/58"><span class="deltaxml-new" style="background:#90EE90">58</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/324"><span class="deltaxml-new" style="background:#90EE90">324</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;29 January 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringTemplate" id="doc-xpath40-StringTemplate"></a><span class="deltaxml-new" style="background:#90EE90">[220]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"`" (</span><a href="#doc-xpath40-StringTemplateFixedPart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateFixedPart</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-StringTemplateVariablePart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateVariablePart</span></a><span class="deltaxml-new" style="background:#90EE90">)* "`"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringTemplateFixedPart" id="doc-xpath40-StringTemplateFixedPart"></a><span class="deltaxml-new" style="background:#90EE90">[221]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringTemplateFixedPart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateFixedPart</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - ('{' | '}' | '`')) | "{{" | "}}" | "``")*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringTemplateVariablePart" id="doc-xpath40-StringTemplateVariablePart"></a><span class="deltaxml-new" style="background:#90EE90">[222]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringTemplateVariablePart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateVariablePart</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e20472.doc-xpath40-EnclosedExpr" id="noid_d4e20472.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">String templates provide an alternative way of constructing strings. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">`Pi is {round(math:pi(), 4)}`</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the string </span><code><span class="deltaxml-new" style="background:#90EE90">"Pi is 3.1416"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A string template starts and ends with a grave accent (x60), popularly known as a back-tick. Between the back-ticks is a string consisting of an sequence of fixed parts and variable parts:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A variable part consists of an optional XPath expression enclosed in curly brackets (</span><code><span class="deltaxml-new" style="background:#90EE90">{}</span></code><span class="deltaxml-new" style="background:#90EE90">): more specifically, a string conforming to the XPath production </span><code><span class="deltaxml-new" style="background:#90EE90">Expr?</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An expression within a variable part may contain an unescaped curly bracket within a </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> or within a comment.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Currently no XPath expression starts with an opening curly bracket, so the use of </span><code><span class="deltaxml-new" style="background:#90EE90">{{</span></code><span class="deltaxml-new" style="background:#90EE90"> creates no ambiguity. If an enclosed expression ends with a closing curly bracket, no whitespace is required between this and the closing delimiter.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The fact that the expression is optional means that the string contained between the curly brackets may be zero-length, may comprise whitespace only, or may contain XPath comments. The effective value in this case is a zero-length string, which is equivalent to omitting the variable part entirely, together with its curly-bracket delimiters. </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A fixed part may contain any characters, except that:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">a left curly bracket </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90"> be written as </span><code><span class="deltaxml-new" style="background:#90EE90">{{</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">a right curly bracket </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90"> be written as </span><code><span class="deltaxml-new" style="background:#90EE90">}}</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">a back-tick </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90"> be written as </span><code><span class="deltaxml-new" style="background:#90EE90">``</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> The result of evaluating a string template is the string obtained by concatenating the expansions of the fixed and variable parts:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The expansion of a fixed part is obtained by replacing any double curly brackets (</span><code><span class="deltaxml-new" style="background:#90EE90">{{</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">}}</span></code><span class="deltaxml-new" style="background:#90EE90">) by the corresponding single curly bracket, and replacing doubled back-ticks (</span><code><span class="deltaxml-new" style="background:#90EE90">``</span></code><span class="deltaxml-new" style="background:#90EE90">) by a single back-tick.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expansion of a variable part containing an expression is as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the value of the enclosed expression, converting it to a sequence of atomic items.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is an empty sequence, the result is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expansion of an empty variable part (one that contains no expression) is a zero-length string.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">For example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $greeting := "Hello",
    $planet := "Mars"
return `{ $greeting }, { $planet }!`</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">returns </span><code><span class="deltaxml-new" style="background:#90EE90">"Hello, Mars!"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The expression:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $longMonths := (1, 3, 5, 7, 8, 10, 12)
return `The months with 31 days are: { $longMonths }.`</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">returns </span><code><span class="deltaxml-new" style="background:#90EE90">"The months with 31 days are: 1 3 5 7 8 10 12."</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The rules for processing an enclosed expression are identical to the rules for attributes in XQuery direct element constructors. These rules differ slightly from the rules in XSLT attribute value templates, where adjacent text nodes are concatenated with no separator, prior to atomization.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A string template containing no variable parts is effectively just another way of writing a string literal: </span><code><span class="deltaxml-new" style="background:#90EE90">"Goethe"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">'Goethe'</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">`Goethe`</span></code><span class="deltaxml-new" style="background:#90EE90"> are interchangeable. This means that back-ticks can sometimes be a useful way of delimiting a string that contains both single and double quotes: </span><code><span class="deltaxml-new" style="background:#90EE90">`He said: "I didn't."`</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is sometimes useful to use string templates in conjunction with the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:char</span></code><span class="deltaxml-new" style="background:#90EE90"> function to build strings containing special characters, for example </span><code><span class="deltaxml-new" style="background:#90EE90">`Chapter{ fn:char("nbsp") }{ $chapNr }`</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">String literals containing an ampersand behave differently between XPath and XQuery: in XPath (unless first expanded by an XML parser) the string literal </span><code><span class="deltaxml-new" style="background:#90EE90">"Bacon &amp; Eggs"</span></code><span class="deltaxml-new" style="background:#90EE90"> represents a string containing an ampersand, while in XQuery it is an error, because an ampersand is taken as introducing a character reference. This difference does not arise for string templates, since neither XPath nor XQuery recognizes entity or character references in a string template. This means that back-tick delimited strings (such as </span><code><span class="deltaxml-new" style="background:#90EE90">`Bacon &amp; Eggs`</span></code><span class="deltaxml-new" style="background:#90EE90">) may be useful in contexts where an XPath expression is required to have the same effect whether it is evaluated using an XPath or an XQuery processor.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">In XQuery, the token </span><code><span class="deltaxml-new" style="background:#90EE90">``[</span></code><span class="deltaxml-new" style="background:#90EE90"> is recognized as the start of a </span><a class="xquery termref" title="string constructor" href="#dt-string-constructor"><span class="deltaxml-new" style="background:#90EE90">string constructor</span></a><code class="xpath"><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></code><span class="deltaxml-new" style="background:#90EE90">, under the “longest token” rule (see </span><a href="#lexical-structure"><b><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></b></a><span class="deltaxml-new" style="background:#90EE90">). This means that the construct </span><code><span class="deltaxml-new" style="background:#90EE90">``[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> is not recognized as a </span><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by a predicate. </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">Although the token </span><code><span class="deltaxml-new" style="background:#90EE90">``[</span></code><span class="deltaxml-new" style="background:#90EE90"> is not used in XPath, it is reserved for compatibility reasons, and </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90"> be rejected as syntactically invalid.</span></span></span><span class="deltaxml-new" style="background:#90EE90"> In the unlikely event that an empty </span><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by a predicate is wanted, whitespace or parentheses can be used to avoid the tokenization problem.</span></p></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-string-constructors"></a><span class="deltaxml-new" style="background:#90EE90">4.9.3 String Constructors</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-string-constructor" title="string constructor"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">String Constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> creates a string from literal text and interpolated expressions. ] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The syntax of a string constructor is convenient for generating JSON, JavaScript, CSS, SPARQL, XQuery, XPath, or other languages that use curly brackets, quotation marks, or other strings that are delimiters in XQuery 4.0 and XPath 4.0.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringConstructor" id="doc-xpath40-StringConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[223]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"``[" </span><a href="#doc-xpath40-StringConstructorContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringConstructorContent</span></a><span class="deltaxml-new" style="background:#90EE90"> "]``"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringConstructorContent" id="doc-xpath40-StringConstructorContent"></a><span class="deltaxml-new" style="background:#90EE90">[224]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringConstructorContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringConstructorContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringConstructorChars" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringConstructorChars</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#doc-xpath40-StringInterpolation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringInterpolation</span></a><a href="#doc-xpath40-StringConstructorChars" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringConstructorChars</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringConstructorChars" id="doc-xpath40-StringConstructorChars"></a><span class="deltaxml-new" style="background:#90EE90">[225]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringConstructorChars" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringConstructorChars</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* ('`{' | ']``') Char*))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-StringInterpolation" id="doc-xpath40-StringInterpolation"></a><span class="deltaxml-new" style="background:#90EE90">[226]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringInterpolation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringInterpolation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"`{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}`"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody></table><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">String templates (see </span><a href="#id-string-templates"><b><span class="deltaxml-new" style="background:#90EE90">4.9.2 String Templates</span></b></a><span class="deltaxml-new" style="background:#90EE90">) and string constructors have overlapping functionality. String constructors were introduced in XQuery 3.1, and are not available in XPath; string templates are new in XQuery 4.0 and XPath 4.0. String constructors were designed specifically for convenience when generating code in languages that use curly braces, but with experience, they have been found to be somewhat unwieldy for simpler applications; this motivated the introduction of a simpler syntax in 4.0.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">In a </span><a href="#doc-xpath40-StringConstructor"><span class="deltaxml-new" style="background:#90EE90">string constructor</span></a><span class="deltaxml-new" style="background:#90EE90">, adjacent </span><a href="#doc-xpath40-StringConstructorChars"><span class="deltaxml-new" style="background:#90EE90">string constructor characters</span></a><span class="deltaxml-new" style="background:#90EE90"> are treated as literal text. Line endings are processed as elsewhere in XQuery; no other processing is performed on this text. To evaluate a string constructor, each sequence of adjacent string constructor characters is converted to a string containing the same characters, and each </span><a href="#doc-xpath40-StringInterpolation"><span class="deltaxml-new" style="background:#90EE90">string constructor interpolation</span></a><code><span class="deltaxml-new" style="background:#90EE90">$i</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, then converted to a string using the expression </span><code><span class="deltaxml-new" style="background:#90EE90">string-join($i, ' ')</span></code><span class="deltaxml-new" style="background:#90EE90">. A string constructor interpolation that does not contain an expression (</span><code><span class="deltaxml-new" style="background:#90EE90">`{ }`</span></code><span class="deltaxml-new" style="background:#90EE90">) is ignored. The strings created from string constructor characters and the strings created from string constructor interpolations are then concatenated, in order.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For instance, the following expression:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $s in ("one", "two", "red", "blue")
return ``[`{ $s }` fish]``</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">evaluates to the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">("one fish", "two fish", "red fish", "blue fish")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Character entities are not expanded in string constructor content. Thus, </span><code><span class="deltaxml-new" style="background:#90EE90">``[&amp;lt;]``</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the string </span><code><span class="deltaxml-new" style="background:#90EE90">"&amp;lt;"</span></code><span class="deltaxml-new" style="background:#90EE90">, not the string </span><code><span class="deltaxml-new" style="background:#90EE90">"&lt;"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Interpolations can contain string constructors. For instance, consider the following expression:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">``[`{ $i, ``[literal text]``, $j, ``[more literal text]`` }`]``</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Assuming the values </span><code><span class="deltaxml-new" style="background:#90EE90">$i := 1</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$j := 2</span></code><span class="deltaxml-new" style="background:#90EE90">, this evaluates to the string </span><code><span class="deltaxml-new" style="background:#90EE90">"1 literal text 2 more literal text"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples are based on an example taken from the documentation of </span><a href="#Moustache"><span class="deltaxml-new" style="background:#90EE90">[Moustache]</span></a><span class="deltaxml-new" style="background:#90EE90">, a JavaScript template library. Each function takes a map, containing values like these:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{
  "name": "Chris",
  "value": 10000,
  "taxed_value": 10000 - (10000 * 0.4),
  "in_ca": true
}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">This function creates a simple string.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:prize-message($a) as xs:string {
  ``[Hello `{ $a?name }`
You have just won `{ $a?value }` dollars!
`{ 
   if ($a?in_ca) 
   then ``[Well, `{ $a?taxed_value }` dollars, after taxes.]``
   else ""
}`]``
};</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">This is the output of the above function :</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">Hello Chris
You have just won 10000 dollars!
Well, 6000 dollars, after taxes.</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">This function creates a similar string in HTML syntax.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:prize-message($a) as xs:string {
  ``[&lt;div&gt;
  &lt;h1&gt;Hello `{ $a?name }`&lt;/h1&gt;
  &lt;p&gt;You have just won `{ $a?value }` dollars!&lt;/p&gt;
    `{ 
      if ($a?in_ca) 
      then ``[  &lt;p&gt;Well, `{ $a?taxed_value }` dollars, after taxes.&lt;/p&gt; ]``
      else ""
    }`
&lt;/div&gt;]``
};</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">This is the output of the above function :</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;div&gt;
  &lt;h1&gt;Hello Chris&lt;/h1&gt;
  &lt;p&gt;You have just won 10000 dollars!&lt;/p&gt;
  &lt;p&gt;Well, 6000 dollars, after taxes.&lt;/p&gt; 
&lt;/div&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">This function creates a similar string in JSON syntax.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:prize-message($a) as xs:string {
  ``[{ 
  "name" : `{ $a?name }`
  "value" : `{ $a?value }`
  `{
  if ($a?in_ca) 
  then 
  ``[, 
  "taxed_value" : `{ $a?taxed_value }`]``  
  else ""
  }`
}]`` 
};</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">This is the output of the above function :</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{ 
  "name" : "Chris",
  "value" : 10000,
  "taxed_value" : 6000
}</span></pre></div></div></div></div><div class="div2"><h3><a id="id-comparisons"></a><span class="deltaxml-new" style="background:#90EE90">4.10 Comparison Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">Comparison expressions allow two values to be compared. XQuery 4.0 and XPath 4.0 provides three kinds of comparison expressions, called value comparisons, general comparisons, and node comparisons.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ComparisonExpr" id="doc-xpath40-ComparisonExpr"></a><span class="deltaxml-new" style="background:#90EE90">[109]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ComparisonExpr"><span class="deltaxml-new" style="background:#90EE90">ComparisonExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">OtherwiseExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( (</span><a href="#doc-xpath40-ValueComp"><span class="deltaxml-new" style="background:#90EE90">ValueComp</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-GeneralComp"><span class="deltaxml-new" style="background:#90EE90">GeneralComp</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-NodeComp"><span class="deltaxml-new" style="background:#90EE90">NodeComp</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">OtherwiseExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ValueComp" id="doc-xpath40-ValueComp"></a><span class="deltaxml-new" style="background:#90EE90">[129]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ValueComp"><span class="deltaxml-new" style="background:#90EE90">ValueComp</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"eq" | "ne" | "lt" | "le" | "gt" | "ge"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-GeneralComp" id="doc-xpath40-GeneralComp"></a><span class="deltaxml-new" style="background:#90EE90">[128]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GeneralComp"><span class="deltaxml-new" style="background:#90EE90">GeneralComp</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NodeComp" id="doc-xpath40-NodeComp"></a><span class="deltaxml-new" style="background:#90EE90">[130]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NodeComp"><span class="deltaxml-new" style="background:#90EE90">NodeComp</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"is" | "&lt;&lt;" | "&gt;&gt;"</span></code></td></tr></tbody></table><div class="xpath note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">When an XPath expression is written within an XML document, the XML escaping rules for special characters must be followed; thus </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> must be written as </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;lt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><p><span class="deltaxml-new" style="background:#90EE90">For a summary of the differences between different ways of comparing atomic items in XQuery 4.0 and XPath 4.0, see </span><a href="#id-atomic-comparisons"><b><span class="deltaxml-new" style="background:#90EE90">J Atomic Comparisons: An Overview</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div3"><h4><a id="id-value-comparisons"></a><span class="deltaxml-new" style="background:#90EE90">4.10.1 Value Comparisons</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-general-comparisons"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-string-templates"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close. </span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">The value comparison operators are </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><span class="deltaxml-new" style="background:#90EE90">. Value comparisons are used for comparing single values.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">. Each operand is evaluated by applying the following steps, in order:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to each operand. The result of this operation is called the </span><b><span class="deltaxml-new" style="background:#90EE90">atomized operand</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If an atomized operand is an empty sequence, the result of the value comparison is an empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If an atomized operand is a sequence of length greater than one, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If an atomized operand is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, it is cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The purpose of this rule is to make value comparisons transitive. Users should be aware that the general comparison operators have a different rule for casting of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> operands. Users should also be aware that transitivity of value comparisons may be compromised by loss of precision during type conversion (for example, two </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> values that differ slightly may both be considered equal to the same </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90"> value because </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90"> has less precision than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the two operands are instances of different primitive types (meaning the 19 primitive types defined in </span><a href="https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes"><span class="deltaxml-new" style="background:#90EE90">Section 3.2 Primitive datatypes</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS2</span></small></sup><span class="deltaxml-new" style="background:#90EE90">), then: </span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If each operand is an instance of one of the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">, then both operands are cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If each operand is an instance of one of the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, then both operands are cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If each operand is an instance of one of the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">, then both operands are cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The primitive type of an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> value for this purpose is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">Finally, if the types of the operands are a valid combination for the given operator, the operator is applied to the operands.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The combinations of atomic types that are accepted by the various value comparison operators, and their respective result types, are listed in </span><a href="#mapping"><b><span class="deltaxml-new" style="background:#90EE90">B.2 Operator Mapping</span></b></a><span class="deltaxml-new" style="background:#90EE90"> together with the </span><a title="operator function" class="termref" href="#dt-operator-function"><span class="deltaxml-new" style="background:#90EE90">operator functions</span></a><span class="deltaxml-new" style="background:#90EE90"> that define the semantics of the operator for each type combination. The definitions of the operator functions are found in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Informally, if both atomized operands consist of exactly one atomic item, then the result of the comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the value of the first operand is (equal, not equal, less than, less than or equal, greater than, greater than or equal) to the value of the second operand; otherwise the result of the comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in </span><a href="#mapping"><b><span class="deltaxml-new" style="background:#90EE90">B.2 Operator Mapping</span></b></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of value comparisons:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison atomizes the node(s) that are returned by the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$book/author</span></code><span class="deltaxml-new" style="background:#90EE90">. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$book1/author eq "Kennedy"</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> because atomization converts an array to its member sequence:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[ "Kennedy" ] eq "Kennedy"</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-new" style="background:#90EE90">path expression</span></a><span class="deltaxml-new" style="background:#90EE90"> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a </span><code><span class="deltaxml-new" style="background:#90EE90">weight</span></code><span class="deltaxml-new" style="background:#90EE90"> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that </span><code><span class="deltaxml-new" style="background:#90EE90">weight</span></code><span class="deltaxml-new" style="background:#90EE90"> is a validated element with a numeric type.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">//product[weight gt 100]</span></pre></div></div></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The following comparisons are true because, in each case, the two constructed nodes have the same value after atomization, even though they have different identities and/or names:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;</span></pre></div></div><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is true if </span><code><span class="deltaxml-new" style="background:#90EE90">my:hatsize</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">my:shoesize</span></code><span class="deltaxml-new" style="background:#90EE90"> are both user-defined types that are derived by restriction from a primitive </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a><span class="deltaxml-new" style="background:#90EE90"> type:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">my:hatsize(5) eq my:shoesize(5)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is true. The </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">QName("http://example.com/ns1", "this:color") eq QName("http://example.com/ns1", "that:color")</span></pre></div></div></li></ul></div><div class="div3"><h4><a id="id-general-comparisons"></a><span class="deltaxml-new" style="background:#90EE90">4.10.2 General Comparisons</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-xquery-for-clause"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-value-comparisons"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Operators such as </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> can use the full-width forms </span><code><span class="deltaxml-new" style="background:#90EE90">＜</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">＞</span></code><span class="deltaxml-new" style="background:#90EE90"> to avoid the need for XML escaping. </span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">The general comparison operators are </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">!=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><span class="deltaxml-new" style="background:#90EE90">. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is always </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, a general comparison is evaluated by applying the following rules, in order:</span></p></div><div class="xpath"><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If either operand is a single atomic item that is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, then the other operand is converted to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> by taking its </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to each operand. After atomization, each operand is a sequence of atomic items.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the comparison operator is </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, then each item in both of the operand sequences is converted to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> by applying the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:number</span></code><span class="deltaxml-new" style="background:#90EE90"> function. (Note that </span><code><span class="deltaxml-new" style="background:#90EE90">fn:number</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the value </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> if its operand cannot be converted to a number.)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if and only if there is a pair of atomic items, one in the first operand sequence and the other in the second operand sequence, that have the required </span><b><span class="deltaxml-new" style="background:#90EE90">magnitude relationship</span></b><span class="deltaxml-new" style="background:#90EE90">. Otherwise the result of the comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or an error. The </span><b><span class="deltaxml-new" style="background:#90EE90">magnitude relationship</span></b><span class="deltaxml-new" style="background:#90EE90"> between two atomic items is determined by applying the following rules. If a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> operation called for by these rules is not successful, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised. [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001" title="err:FORG0001"><span class="deltaxml-new" style="background:#90EE90">err:FORG0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If at least one of the two atomic items is an instance of a </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a><span class="deltaxml-new" style="background:#90EE90"> type, then both atomic items are converted to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> by applying the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:number</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If at least one of the two atomic items is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, or if both atomic items are instances of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, then both atomic items are cast to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If one of the atomic items is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> and the other is not an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, or any </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a><span class="deltaxml-new" style="background:#90EE90"> type, then the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> item is cast to the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the other value.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">After performing the conversions described above, the atomic items are compared using one of the value comparison operators </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><span class="deltaxml-new" style="background:#90EE90">, depending on whether the general comparison operator was </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">!=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><span class="deltaxml-new" style="background:#90EE90">. The values have the required </span><b><span class="deltaxml-new" style="background:#90EE90">magnitude relationship</span></b><span class="deltaxml-new" style="background:#90EE90"> if and only if the result of this value comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li></ol></div><p><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, a</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">A</span></span></span><span class="deltaxml-new" style="background:#90EE90"> general comparison is evaluated by applying the following rules, in order:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to each operand. After atomization, each operand is a sequence of atomic items.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if and only if there is a pair of atomic items, one in the first operand sequence and the other in the second operand sequence, that have the required </span><b><span class="deltaxml-new" style="background:#90EE90">magnitude relationship</span></b><span class="deltaxml-new" style="background:#90EE90">. Otherwise the result of the comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or an error. The </span><b><span class="deltaxml-new" style="background:#90EE90">magnitude relationship</span></b><span class="deltaxml-new" style="background:#90EE90"> between two atomic items is determined by applying the following rules. If a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> operation called for by these rules is not successful, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised. [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001" title="err:FORG0001"><span class="deltaxml-new" style="background:#90EE90">err:FORG0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></p><div class="xquery note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The purpose of these rules is to preserve compatibility with XPath 1.0, in which (for example) </span><code><span class="deltaxml-new" style="background:#90EE90">x &lt; 17</span></code><span class="deltaxml-new" style="background:#90EE90"> is a numeric comparison if </span><code><span class="deltaxml-new" style="background:#90EE90">x</span></code><span class="deltaxml-new" style="background:#90EE90"> is an untyped value. Users should be aware that the value comparison operators have different rules for casting of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> operands.</span></p></div><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If both atomic items are instances of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, then the values are cast to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If exactly one of the atomic items is an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, it is cast to a type depending on the other value’s dynamic type T according to the following rules, in which V denotes the value to be cast: </span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">If T is a numeric type or is derived from a numeric type, then V is cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If T is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90">, then V is cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If T is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> or is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90">, then V is cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In all other cases, V is cast to the primitive base type of T.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> The special treatment of the duration types is required to avoid errors that may arise when comparing the primitive type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></code><span class="deltaxml-new" style="background:#90EE90"> with any duration type. </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">After performing the conversions described above, the atomic items are compared using one of the value comparison operators </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><span class="deltaxml-new" style="background:#90EE90">, depending on whether the general comparison operator was </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">!=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><span class="deltaxml-new" style="background:#90EE90">. The values have the required </span><b><span class="deltaxml-new" style="background:#90EE90">magnitude relationship</span></b><span class="deltaxml-new" style="background:#90EE90"> if and only if the result of this value comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li></ol><p><span class="deltaxml-new" style="background:#90EE90">When evaluating a general comparison in which either operand is a sequence of items, an implementation may return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> as soon as it finds an item in the first operand and an item in the second operand that have the required </span><b><span class="deltaxml-new" style="background:#90EE90">magnitude relationship</span></b><span class="deltaxml-new" style="background:#90EE90">. Similarly, a general comparison may raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a result of these rules, the result of a general comparison is not deterministic in the presence of errors.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of general comparisons:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is true if the </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> of any </span><code><span class="deltaxml-new" style="background:#90EE90">author</span></code><span class="deltaxml-new" style="background:#90EE90"> subelement of </span><code><span class="deltaxml-new" style="background:#90EE90">$book1</span></code><span class="deltaxml-new" style="background:#90EE90"> is "Kennedy" as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$book1/author = "Kennedy"</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> because atomization converts an array to its member sequence:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[ "Obama", "Nixon", "Kennedy" ] = "Kennedy"</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example contains three general comparisons. The value of the first two comparisons is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, and the value of the third comparison is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. This example illustrates the fact that general comparisons are not transitive.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example contains two general comparisons, both of which are </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">. This example illustrates the fact that the </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">!=</span></code><span class="deltaxml-new" style="background:#90EE90"> operators are not inverses of each other.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(1, 2) = (2, 3)
(1, 2) != (2, 3)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Suppose that </span><code><span class="deltaxml-new" style="background:#90EE90">$a</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$b</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">$c</span></code><span class="deltaxml-new" style="background:#90EE90"> are bound to element nodes with type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, with </span><a title="string value" class="termref" href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string values</span></a><code><span class="deltaxml-new" style="background:#90EE90">"1"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"2"</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">"2.0"</span></code><span class="deltaxml-new" style="background:#90EE90"> respectively. Then </span><code><span class="deltaxml-new" style="background:#90EE90">($a, $b) = ($c, 3.0)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, because </span><code><span class="deltaxml-new" style="background:#90EE90">$b</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$c</span></code><span class="deltaxml-new" style="background:#90EE90"> are compared as strings. However, </span><code><span class="deltaxml-new" style="background:#90EE90">($a, $b) = ($c, 2.0)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, because </span><code><span class="deltaxml-new" style="background:#90EE90">$b</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">2.0</span></code><span class="deltaxml-new" style="background:#90EE90"> are compared as numbers.</span></p></li></ul></div><div class="div3"><h4><a id="id-node-comparisons"></a><span class="deltaxml-new" style="background:#90EE90">4.10.3 Node Comparisons</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Node comparisons are used to compare two nodes, by their identity or by their </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">. The result of a node comparison is defined by the following rules:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The operands of a node comparison are evaluated in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> order.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If either operand is an empty sequence, the result of the comparison is an empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Each operand must be either a single node or an empty sequence; otherwise a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A comparison with the </span><code><span class="deltaxml-new" style="background:#90EE90">is</span></code><span class="deltaxml-new" style="background:#90EE90"> operator is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the two operand nodes are the same node; otherwise it is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. See </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> for the definition of node identity.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A comparison with the </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> operator returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the left operand node precedes the right operand node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A comparison with the </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> operator returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the left operand node follows the right operand node in </span><a title="document order" class="termref" href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a><span class="deltaxml-new" style="background:#90EE90">; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of node comparisons:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is true only if the left and right sides each evaluate to exactly the same single node:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">/books/book[isbn = "1558604820"] is /books/book[call = "QA76.9 C3845"]</span></pre></div></div></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is false because each constructed node has its own identity:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following comparison is true only if the node identified by the left side occurs before the node identified by the right side in document order:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">/transactions/purchase[parcel = "28-451"] &lt;&lt; /transactions/sale[parcel = "33-870"]</span></pre></div></div></li></ul></div></div><div class="div2"><h3><a id="id-logical-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.11 Logical Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">logical expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is either an </span><b><span class="deltaxml-new" style="background:#90EE90">and-expression</span></b><span class="deltaxml-new" style="background:#90EE90"> or an </span><b><span class="deltaxml-new" style="background:#90EE90">or-expression</span></b><span class="deltaxml-new" style="background:#90EE90">. If a logical expression does not raise an error, its value is always one of the boolean values </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OrExpr" id="doc-xpath40-OrExpr"></a><span class="deltaxml-new" style="background:#90EE90">[107]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrExpr"><span class="deltaxml-new" style="background:#90EE90">OrExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">AndExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "or" </span><a href="#doc-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">AndExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AndExpr" id="doc-xpath40-AndExpr"></a><span class="deltaxml-new" style="background:#90EE90">[108]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">AndExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ComparisonExpr"><span class="deltaxml-new" style="background:#90EE90">ComparisonExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "and" </span><a href="#doc-xpath40-ComparisonExpr"><span class="deltaxml-new" style="background:#90EE90">ComparisonExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The first step in evaluating a logical expression is to find the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of each of its operands (see </span><a href="#id-ebv"><b><span class="deltaxml-new" style="background:#90EE90">2.5.4 Effective Boolean Value</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The value of an and-expression is determined by the effective boolean values (EBVs) of its operands, as shown in the following table:</span></p><div class="medium"><table style="width:80%" class="medium"><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">AND:</span></th><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></th><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></th><th><span class="deltaxml-new" style="background:#90EE90">error in EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></th></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></th><td><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">error</span></td></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></th><td><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></td><td><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">either </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or error</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">if </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise either </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or error.</span></span></span></td></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">error in EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></th><td><span class="deltaxml-new" style="background:#90EE90">error</span></td><td><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">either </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or error</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">if </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, then error; otherwise either </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or error.</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">error</span></td></tr></tbody></table></div><p><span class="deltaxml-new" style="background:#90EE90">The value of an or-expression is determined by the effective boolean values (EBVs) of its operands, as shown in the following table:</span></p><div class="medium"><table style="width:80%" class="medium"><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">OR:</span></th><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></th><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></th><th><span class="deltaxml-new" style="background:#90EE90">error in EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></th></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></th><td><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></td><td><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">either </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or error</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">if </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise either </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or error.</span></span></span></td></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub><span class="deltaxml-new" style="background:#90EE90"> = </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></th><td><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">error</span></td></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">error in EBV</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></th><td><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">either </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or error</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">if </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, then error; otherwise either </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or error.</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">error</span></td><td><span class="deltaxml-new" style="background:#90EE90">error</span></td></tr></tbody></table></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, the order in which the operands of a logical expression are evaluated is effectively prescribed. Specifically, it is defined that when there is no need to evaluate the second operand in order to determine the result, then no error can occur as a result of evaluating the second operand.</span></p></div><p><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">If </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, the order in which the operands of a logical expression are evaluated is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">. In this case,</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">The order in which the operands of a logical expression are evaluated is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">. The tables above are defined in such a way that</span></span></span><span class="deltaxml-new" style="background:#90EE90"> an or-expression can return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the first expression evaluated is true, and it can raise an error if evaluation of the first expression raises an error. Similarly, an and-expression can return </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> if the first expression evaluated is false, and it can raise an error if evaluation of the first expression raises an error. As a result of these rules, a logical expression is not deterministic in the presence of errors, as illustrated in the examples below.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of logical expressions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The following expressions return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">1 eq 1 and 2 eq 2</span></pre></div></div><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">1 eq 1 or 2 eq 3</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following expression may return either </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90"> (in </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90">, the result must be </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></span></span><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">1 eq 2 and 3 idiv 0 = 1</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following expression may return either </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90"> (in </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90">, the result must be </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></span></span><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">1 eq 1 or 3 idiv 0 = 1</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following expression must raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">1 eq 1 and 3 idiv 0 = 1</span></pre></div></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In addition to and- and or-expressions, XQuery 4.0 and XPath 4.0 provides a function named </span><code><span class="deltaxml-new" style="background:#90EE90">fn:not</span></code><span class="deltaxml-new" style="background:#90EE90"> that takes a general sequence as parameter and returns a boolean value. The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:not</span></code><span class="deltaxml-new" style="background:#90EE90"> function is defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:not</span></code><span class="deltaxml-new" style="background:#90EE90"> function reduces its parameter to an </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90">. It then returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the effective boolean value of its parameter is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> if the effective boolean value of its parameter is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">. If an error is encountered in finding the effective boolean value of its operand, </span><code><span class="deltaxml-new" style="background:#90EE90">fn:not</span></code><span class="deltaxml-new" style="background:#90EE90"> raises the same error.</span></p></div><div class="xquery"><div class="div2 xquery"><div class="xquery"><h3><a id="id-constructors"></a><span class="deltaxml-new" style="background:#90EE90">4.12 Node Constructors</span></h3></div><p><span class="deltaxml-new" style="background:#90EE90">XQuery provides node constructors that can create XML nodes within a query.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NodeConstructor" id="doc-xpath40-NodeConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[182]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NodeConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NodeConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirectConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-ComputedConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ComputedConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirectConstructor" id="doc-xpath40-DirectConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[183]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirectConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirElemConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-DirCommentConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirCommentConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-DirPIConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirPIConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirElemConstructor" id="doc-xpath40-DirElemConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[184]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirElemConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;" </span><a href="#doc-xpath40-QName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#doc-xpath40-DirAttributeList" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirAttributeList</span></a><span class="deltaxml-new" style="background:#90EE90"> ("/&gt;" | ("&gt;" </span><a href="#doc-xpath40-DirElemContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirElemContent</span></a><span class="deltaxml-new" style="background:#90EE90">* "&lt;/" </span><a href="#doc-xpath40-QName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-S" class="xquery"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? "&gt;"))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirElemContent" id="doc-xpath40-DirElemContent"></a><span class="deltaxml-new" style="background:#90EE90">[189]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirElemContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirElemContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirectConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CDataSection" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CommonContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-ElementContentChar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ElementContentChar</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ElementContentChar" id="doc-xpath40-ElementContentChar"></a><span class="deltaxml-new" style="background:#90EE90">[280]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ElementContentChar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ElementContentChar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - [{}&lt;&amp;])</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CommonContent" id="doc-xpath40-CommonContent"></a><span class="deltaxml-new" style="background:#90EE90">[190]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CommonContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PredefinedEntityRef" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-CharRef" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | "{{" | "}}" | </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CDataSection" id="doc-xpath40-CDataSection"></a><span class="deltaxml-new" style="background:#90EE90">[195]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CDataSection" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;![CDATA[" </span><a href="#doc-xpath40-CDataSectionContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CDataSectionContents</span></a><span class="deltaxml-new" style="background:#90EE90"> "]]&gt;"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CDataSectionContents" id="doc-xpath40-CDataSectionContents"></a><span class="deltaxml-new" style="background:#90EE90">[196]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CDataSectionContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CDataSectionContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* ']]&gt;' Char*))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirAttributeList" id="doc-xpath40-DirAttributeList"></a><span class="deltaxml-new" style="background:#90EE90">[185]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirAttributeList" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirAttributeList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-S" class="xquery"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#doc-xpath40-QName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-S" class="xquery"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? "=" </span><a href="#prod-xpath40-S" class="xquery"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-DirAttributeValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirAttributeValue</span></a><span class="deltaxml-new" style="background:#90EE90">)?)*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirAttributeValue" id="doc-xpath40-DirAttributeValue"></a><span class="deltaxml-new" style="background:#90EE90">[186]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirAttributeValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirAttributeValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">('"' (</span><a href="#doc-xpath40-EscapeQuot" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-QuotAttrValueContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QuotAttrValueContent</span></a><span class="deltaxml-new" style="background:#90EE90">)* '"')</span><br><span class="deltaxml-new" style="background:#90EE90">| ("'" (</span><a href="#doc-xpath40-EscapeApos" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-AposAttrValueContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AposAttrValueContent</span></a><span class="deltaxml-new" style="background:#90EE90">)* "'")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-QuotAttrValueContent" id="doc-xpath40-QuotAttrValueContent"></a><span class="deltaxml-new" style="background:#90EE90">[187]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QuotAttrValueContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QuotAttrValueContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QuotAttrContentChar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QuotAttrContentChar</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CommonContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AposAttrValueContent" id="doc-xpath40-AposAttrValueContent"></a><span class="deltaxml-new" style="background:#90EE90">[188]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AposAttrValueContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AposAttrValueContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AposAttrContentChar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AposAttrContentChar</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CommonContent" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-QuotAttrContentChar" id="doc-xpath40-QuotAttrContentChar"></a><span class="deltaxml-new" style="background:#90EE90">[281]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QuotAttrContentChar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QuotAttrContentChar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - ["{}&lt;&amp;])</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AposAttrContentChar" id="doc-xpath40-AposAttrContentChar"></a><span class="deltaxml-new" style="background:#90EE90">[282]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AposAttrContentChar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AposAttrContentChar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - ['{}&lt;&amp;])</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e21977.doc-xpath40-EscapeQuot" id="noid_d4e21977.doc-xpath40-EscapeQuot"></a><span class="deltaxml-new" style="background:#90EE90">[278]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EscapeQuot" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">'""'</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e21978.doc-xpath40-EscapeApos" id="noid_d4e21978.doc-xpath40-EscapeApos"></a><span class="deltaxml-new" style="background:#90EE90">[279]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EscapeApos" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"''"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e21979.doc-xpath40-EnclosedExpr" id="noid_d4e21979.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Constructors are provided for element, attribute, document, text, comment, and processing instruction nodes. Two kinds of constructors are provided: </span><b><span class="deltaxml-new" style="background:#90EE90">direct constructors</span></b><span class="deltaxml-new" style="background:#90EE90">, which use an XML-like notation that can incorporate enclosed expressions, and </span><b><span class="deltaxml-new" style="background:#90EE90">computed constructors</span></b><span class="deltaxml-new" style="background:#90EE90">, which use a notation based on enclosed expressions. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The rest of this section contains a conceptual description of the semantics of various kinds of constructor expressions. An XQuery implementation is free to use any implementation technique that produces the same result as the processing steps described here.</span></p><div class="div3"><h4><a id="id-element-constructor"></a><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></h4><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">element constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> creates an element node. [</span><a id="dt-direct-elem-const" title="direct element constructor"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> is a form of element constructor in which the name of the constructed element is a constant.] Direct element constructors are based on standard XML notation. For example, the following expression is a direct element constructor that creates a </span><code><span class="deltaxml-new" style="background:#90EE90">book</span></code><span class="deltaxml-new" style="background:#90EE90"> element containing an attribute and some nested elements:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;book isbn="isbn-0060229357"&gt;
  &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
  &lt;author&gt;
    &lt;first&gt;Crockett&lt;/first&gt;
    &lt;last&gt;Johnson&lt;/last&gt;
  &lt;/author&gt;
&lt;/book&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If the element name in a direct element constructor has a namespace prefix, the namespace prefix is resolved to a namespace URI using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">. If the element name has no namespace prefix, </span><span><span class="deltaxml-new" style="background:#90EE90">the namespace binding for the zero-length prefix in the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> is used; if there is no such binding, the element name will be in no namespace</span></span><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The statically known namespaces may be affected by </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attributes</span></a><span class="deltaxml-new" style="background:#90EE90"> found inside the element constructor.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The namespace prefix of the element name is retained after expansion of the </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. The resulting </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> becomes the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed element node.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In a direct element constructor, the name used in the end tag must exactly match the name used in the corresponding start tag, including its prefix or absence of a prefix [</span><a href="#ERRXQST0118" title="err:XQST0118"><span class="deltaxml-new" style="background:#90EE90">err:XQST0118</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">In a direct element constructor, curly braces { } delimit </span><a title="enclosed expression" class="termref" href="#dt-enclosed-expression"><span class="deltaxml-new" style="background:#90EE90">enclosed expressions</span></a><span class="deltaxml-new" style="background:#90EE90">, distinguishing them from literal text. Enclosed expressions are evaluated and replaced by their value, as illustrated by the following example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The above query might generate the following result (whitespace has been added for readability to this result and other result examples in this document):</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Since XQuery uses curly braces to denote enclosed expressions, some convention is needed to denote a curly brace used as an ordinary character. For this purpose, a pair of identical curly brace characters within the content of an element or attribute are interpreted by XQuery as a single curly brace character (that is, the pair </span><code><span class="deltaxml-new" style="background:#90EE90">"{{"</span></code><span class="deltaxml-new" style="background:#90EE90"> represents the character </span><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><span class="deltaxml-new" style="background:#90EE90"> and the pair </span><code><span class="deltaxml-new" style="background:#90EE90">"}}"</span></code><span class="deltaxml-new" style="background:#90EE90"> represents the character </span><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><span class="deltaxml-new" style="background:#90EE90">.) Alternatively, the </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character references</span></a><code><span class="deltaxml-new" style="background:#90EE90">&amp;#x7b;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#x7d;</span></code><span class="deltaxml-new" style="background:#90EE90"> can be used to denote curly brace characters. A single left curly brace (</span><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><span class="deltaxml-new" style="background:#90EE90">) is interpreted as the beginning delimiter for an enclosed expression. A single right curly brace (</span><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><span class="deltaxml-new" style="background:#90EE90">) without a matching left curly brace is treated as a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0003" title="err:XPST0003"><span class="deltaxml-new" style="background:#90EE90">err:XPST0003</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The result of an element constructor is a new element node, with its own node identity. All the attribute and descendant nodes of the new element node are also new nodes with their own identities, even if they are copies of existing nodes.</span></p><div class="div4"><h5><a id="id-attributes"></a><span class="deltaxml-new" style="background:#90EE90">4.12.1.1 Attributes</span></h5><p><span class="deltaxml-new" style="background:#90EE90">The start tag of a direct element constructor may contain one or more attributes. As in XML, each attribute is specified by a name and a value. In a direct element constructor, the name of each attribute is specified by a constant </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, and the value of the attribute is specified by a string of characters enclosed in single or double quotes. As in the main content of the element constructor, an attribute value may contain </span><a title="enclosed expression" class="termref" href="#dt-enclosed-expression"><span class="deltaxml-new" style="background:#90EE90">enclosed expressions</span></a><span class="deltaxml-new" style="background:#90EE90">, which are evaluated and replaced by their value during processing of the element constructor.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Each attribute in a direct element constructor creates a new attribute node, with its own node identity, whose parent is the constructed element node. However, note that </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attributes</span></a><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-namespaces"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.2 Namespace Declaration Attributes</span></b></a><span class="deltaxml-new" style="background:#90EE90">) do not create attribute nodes.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If an attribute name has a namespace prefix, the prefix is resolved to a namespace URI using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">. If the attribute name has no namespace prefix, the attribute is in no namespace. Note that the statically known namespaces used in resolving an attribute name may be affected by </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attributes</span></a><span class="deltaxml-new" style="background:#90EE90"> that are found inside the same element constructor. The namespace prefix of the attribute name is retained after expansion of the </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. The resulting </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> becomes the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed attribute node.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the attributes in a direct element constructor do not have distinct </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> as their respective </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> properties, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0040" title="err:XQST0040"><span class="deltaxml-new" style="background:#90EE90">err:XQST0040</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">Conceptually, an attribute (other than a namespace declaration attribute) in a direct element constructor is processed by the following steps:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Each consecutive sequence of literal characters in the attribute content is processed as a string literal containing those characters, with the following exceptions:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">Each occurrence of two consecutive </span><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><span class="deltaxml-new" style="background:#90EE90"> characters is replaced by a single </span><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><span class="deltaxml-new" style="background:#90EE90"> character. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each occurrence of two consecutive </span><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><span class="deltaxml-new" style="background:#90EE90"> characters is replaced by a single </span><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><span class="deltaxml-new" style="background:#90EE90"> character. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each occurrence of </span><a href="#doc-xpath40-EscapeQuot"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a><span class="deltaxml-new" style="background:#90EE90"> is replaced by a single </span><code><span class="deltaxml-new" style="background:#90EE90">"</span></code><span class="deltaxml-new" style="background:#90EE90"> character. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each occurrence of </span><a href="#doc-xpath40-EscapeApos"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a><span class="deltaxml-new" style="background:#90EE90"> is replaced by a single </span><code><span class="deltaxml-new" style="background:#90EE90">'</span></code><span class="deltaxml-new" style="background:#90EE90"> character. </span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Attribute value normalization is then applied to normalize whitespace and expand </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character references</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference"><span class="deltaxml-new" style="background:#90EE90">predefined entity references</span></a><span class="deltaxml-new" style="background:#90EE90">. The rules for attribute value normalization are the rules from Section 3.3.3 of [XML 1.0] or Section 3.3.3 of [XML 1.1] (it is implementation-defined which version is used). The rules are applied as though the type of the attribute were CDATA (leading and trailing whitespace characters are not stripped.) </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each enclosed expression is converted to a string as follows:</span></p><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the value of the enclosed expression, converting it to a sequence of atomic items.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is an empty sequence, the result is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">Adjacent strings resulting from the above steps are concatenated with no intervening blanks. The resulting string becomes the </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the attribute node. The attribute node is given a </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> (this type annotation may change if the parent element is validated). The </span><code><span class="deltaxml-new" style="background:#90EE90">typed-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the attribute node is the same as its </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90">, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the attribute node is set to the element node constructed by the direct element constructor that contains this attribute.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the attribute name is </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90"> processing is performed as defined in </span><a href="#XMLID"><span class="deltaxml-new" style="background:#90EE90">[XML ID]</span></a><span class="deltaxml-new" style="background:#90EE90">. This ensures that the attribute has the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:ID</span></code><span class="deltaxml-new" style="background:#90EE90"> and that its value is properly normalized. If an error is encountered during </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90"> processing, an implementation may raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQDY0091" title="err:XQDY0091"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0091</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the attribute name is </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the resulting attribute node is set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise the </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">is-idrefs</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the attribute node is unconditionally set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;shoe size="7"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The string value of the </span><code><span class="deltaxml-new" style="background:#90EE90">size</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is </span><code><span class="deltaxml-new" style="background:#90EE90">"7"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;shoe size="{7}"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The string value of the </span><code><span class="deltaxml-new" style="background:#90EE90">size</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is </span><code><span class="deltaxml-new" style="background:#90EE90">"7"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;shoe size="{()}"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The string value of the </span><code><span class="deltaxml-new" style="background:#90EE90">size</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is the zero-length string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The string value of the </span><code><span class="deltaxml-new" style="background:#90EE90">ref</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is </span><code><span class="deltaxml-new" style="background:#90EE90">"[1 5 6 7 9]"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;shoe size="As big as { $hat/@size }"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The string value of the </span><code><span class="deltaxml-new" style="background:#90EE90">size</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is the string </span><code><span class="deltaxml-new" style="background:#90EE90">"As big as "</span></code><span class="deltaxml-new" style="background:#90EE90">, concatenated with the string value of the node denoted by the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$hat/@size</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div><div class="div4"><h5><a id="id-namespaces"></a><span class="deltaxml-new" style="background:#90EE90">4.12.1.2 Namespace Declaration Attributes</span></h5><p><span class="deltaxml-new" style="background:#90EE90">The names of a constructed element and its attributes may be </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> that include </span><b><span class="deltaxml-new" style="background:#90EE90">namespace prefixes</span></b><span class="deltaxml-new" style="background:#90EE90">. Namespace prefixes can be bound to namespaces in the </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> or by </span><b><span class="deltaxml-new" style="background:#90EE90">namespace declaration attributes</span></b><span class="deltaxml-new" style="background:#90EE90">. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> to use a namespace prefix that has not been bound to a namespace [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-namespace-decl-attr" title="namespace declaration attribute"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></b><span class="deltaxml-new" style="background:#90EE90"> is used inside a direct element constructor. Its purpose is to bind a namespace prefix </span><span><span class="deltaxml-new" style="background:#90EE90">(including the zero-length prefix)</span></span><span class="deltaxml-new" style="background:#90EE90"> for the constructed element node, including its attributes.] Syntactically, a namespace declaration attribute has the form of an attribute with namespace prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">, or with name </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> and no namespace prefix. All the namespace declaration attributes of a given element must have distinct names [</span><a href="#ERRXQST0071" title="err:XQST0071"><span class="deltaxml-new" style="background:#90EE90">err:XQST0071</span></a><span class="deltaxml-new" style="background:#90EE90">]. Each namespace declaration attribute is processed as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The value of the namespace declaration attribute (a </span><a href="#doc-xpath40-DirAttributeValue"><span class="deltaxml-new" style="background:#90EE90">DirAttributeValue</span></a><span class="deltaxml-new" style="background:#90EE90">) is processed as follows. If the </span><a href="#doc-xpath40-DirAttributeValue"><span class="deltaxml-new" style="background:#90EE90">DirAttributeValue</span></a><span class="deltaxml-new" style="background:#90EE90"> contains an </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, a static error is raised [</span><a href="#ERRXQST0022" title="err:XQST0022"><span class="deltaxml-new" style="background:#90EE90">err:XQST0022</span></a><span class="deltaxml-new" style="background:#90EE90">]. Otherwise, it is processed as described in rule 1 of </span><a href="#id-attributes"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.1 Attributes</span></b></a><span class="deltaxml-new" style="background:#90EE90">. An implementation may raise a static error[</span><a href="#ERRXQST0046" title="err:XQST0046"><span class="deltaxml-new" style="background:#90EE90">err:XQST0046</span></a><span class="deltaxml-new" style="background:#90EE90">] if the resulting value is of nonzero length and is neither an absolute URI nor a relative URI. The resulting value is used as the namespace URI in the following rules. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the prefix of the attribute name is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">, then the local part of the attribute name is interpreted as a namespace prefix. This prefix and the namespace URI are added to the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructor expression (overriding any existing binding of the given prefix), and are also added as a namespace binding to the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructed element. If the namespace URI is a zero-length string and the implementation supports </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">, any existing namespace binding for the given prefix is removed from the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructed element and from the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructor expression. If the namespace URI is a zero-length string and the implementation does not support </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">, a static error is raised [</span><a href="#ERRXQST0085" title="err:XQST0085"><span class="deltaxml-new" style="background:#90EE90">err:XQST0085</span></a><span class="deltaxml-new" style="background:#90EE90">]. It is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> whether an implementation supports </span><a href="#XMLNAMES"><span class="deltaxml-new" style="background:#90EE90">[XML Names]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the name of the namespace declaration attribute is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> with no prefix, then:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the namespace URI is a zero-length string, then:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Any no-prefix namespace binding is removed from the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructed element and from the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructor expression.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Unless the query prolog contains a default namespace declaration or import schema declaration defining the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> as being </span><code><span class="deltaxml-new" style="background:#90EE90">fixed</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context of the element constructor is set to </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise (when the namespace URI is not a zero-length string): </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The namespace URI is added (with no prefix) to the </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructed element (overriding any existing binding of the zero-length prefix), and to the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the constructor expression.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Unless the query prolog contains a default namespace declaration or import schema declaration defining the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> as being </span><code><span class="deltaxml-new" style="background:#90EE90">fixed</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> in the static context of the constructor expression is set to the specified namespace URI.</span></p></li></ul></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">] if a namespace declaration attribute attempts to do any of the following: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Bind the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> to some namespace URI other than </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind a prefix other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> to any namespace URI. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind a prefix to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> A namespace declaration attribute does not cause an attribute node to be created. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate namespace declaration attributes:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">In this element constructor, a namespace declaration attribute is used to set the default namespace to </span><code><span class="deltaxml-new" style="background:#90EE90">http://example.org/animals</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;cat xmlns="http://example.org/animals"&gt;
  &lt;breed&gt;{variety/@name}&lt;/breed&gt;
&lt;/cat&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">More specifically:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The expanded name of the constructed element will be </span><code><span class="deltaxml-new" style="background:#90EE90">Q{http://example.org/animals}cat</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The constructed element will have a namespace binding that associates the empty prefix with the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://example.org/animals</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The static context for evaluation of any expressions within the element constructor will include a binding of the empty prefix to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://example.org/animals</span></code><span class="deltaxml-new" style="background:#90EE90">. This ensures that the nested </span><code><span class="deltaxml-new" style="background:#90EE90">breed</span></code><span class="deltaxml-new" style="background:#90EE90"> element will also be in the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://example.org/animals</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> within the element constructor will be </span><code><span class="deltaxml-new" style="background:#90EE90">http://example.org/animals</span></code><span class="deltaxml-new" style="background:#90EE90">, which means that the element name </span><code><span class="deltaxml-new" style="background:#90EE90">variety</span></code><span class="deltaxml-new" style="background:#90EE90"> is also interpreted as being in this namespace. This effect may be unwanted, since the document containing the context node may well use a different default namespace. In XQuery 4.0 this effect can be prevented by declaring, in the query prolog, that the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">fixed</span></code><span class="deltaxml-new" style="background:#90EE90">. Alternatively the path expression can be written </span><code><span class="deltaxml-new" style="background:#90EE90">Q{}variety/@name</span></code><span class="deltaxml-new" style="background:#90EE90"> to make it explicit that </span><code><span class="deltaxml-new" style="background:#90EE90">variety</span></code><span class="deltaxml-new" style="background:#90EE90"> refers to a no-namespace element.</span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">In this element constructor, namespace declaration attributes are used to bind the namespace prefixes </span><code><span class="deltaxml-new" style="background:#90EE90">metric</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">english</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;box xmlns:metric="http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units"&gt;
  &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt;
  &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt;
  &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt;
&lt;/box&gt;</span></pre></div></div></li></ul></div><div class="div4"><h5><a id="id-content"></a><span class="deltaxml-new" style="background:#90EE90">4.12.1.3 Content</span></h5><p><span class="deltaxml-new" style="background:#90EE90">The part of a direct element constructor between the start tag and the end tag is called the </span><b><span class="deltaxml-new" style="background:#90EE90">content</span></b><span class="deltaxml-new" style="background:#90EE90"> of the element constructor. This content may consist of text characters (parsed as </span><a href="#doc-xpath40-ElementContentChar"><span class="deltaxml-new" style="background:#90EE90">ElementContentChar</span></a><span class="deltaxml-new" style="background:#90EE90">), nested direct constructors, </span><a href="#doc-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSections</span></a><span class="deltaxml-new" style="background:#90EE90">, character and </span><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference"><span class="deltaxml-new" style="background:#90EE90">predefined entity references</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="enclosed expression" class="termref" href="#dt-enclosed-expression"><span class="deltaxml-new" style="background:#90EE90">enclosed expressions</span></a><span class="deltaxml-new" style="background:#90EE90">. In general, the value of an enclosed expression may be any sequence of nodes and/or atomic items. Enclosed expressions can be used in the content of an element constructor to compute both the content and the attributes of the constructed node.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Conceptually, the content of an element constructor is processed as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The content is evaluated to produce a sequence of nodes called the </span><b><span class="deltaxml-new" style="background:#90EE90">content sequence</span></b><span class="deltaxml-new" style="background:#90EE90">, as follows:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy"><span class="deltaxml-new" style="background:#90EE90">boundary-space policy</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace"><span class="deltaxml-new" style="background:#90EE90">boundary whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> is identified and deleted (see </span><a href="#id-whitespace"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.4 Boundary Whitespace</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for the definition of boundary whitespace.)</span></p></li><li><p><a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference"><span class="deltaxml-new" style="background:#90EE90">Predefined entity references</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character references</span></a><span class="deltaxml-new" style="background:#90EE90"> are expanded into their referenced strings, as described in </span><a href="#id-literals"><b><span class="deltaxml-new" style="background:#90EE90">4.2.1 Literals</span></b></a><span class="deltaxml-new" style="background:#90EE90">. Characters inside a </span><a href="#doc-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a><span class="deltaxml-new" style="background:#90EE90">, including special characters such as </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;</span></code><span class="deltaxml-new" style="background:#90EE90">, are treated as literal characters rather than as markup characters (except for the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">]]&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, which terminates the CDataSection).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each consecutive sequence of literal characters evaluates to a single text node containing the characters.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Each nested direct constructor is evaluated according to the rules in </span><a href="#id-element-constructor"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#id-otherConstructors"><b><span class="deltaxml-new" style="background:#90EE90">4.12.2 Other Direct Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">, resulting in a new element, comment, or processing instruction node. Then:</span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the resulting node is then set to the newly constructed element node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the resulting node, and of each of its descendants, is set to be the same as that of its new parent, unless it (the child node) has an </span><code><span class="deltaxml-new" style="background:#90EE90">xml:base</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute, in which case its </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to the value of that attribute, </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved (if it is relative)</span></a><span class="deltaxml-new" style="background:#90EE90"> against the </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property of its new parent node.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">Enclosed expressions are evaluated as follows: </span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">Each array returned by the enclosed expression is flattened by calling the function </span><code><span class="deltaxml-new" style="background:#90EE90">array:flatten()</span></code><span class="deltaxml-new" style="background:#90EE90"> before the steps that follow.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If an enclosed expression returns a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, a type error is raised [</span><a href="#ERRXQTY0105" title="err:XQTY0105"><span class="deltaxml-new" style="background:#90EE90">err:XQTY0105</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For each adjacent sequence of one or more atomic items returned by an enclosed expression, a new text node is constructed, containing the result of casting each atomic item to a string, with a single space character inserted between adjacent values.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The insertion of blank characters between adjacent values applies even if one or both of the values is a zero-length string.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">For each node returned by an enclosed expression, a new copy is made of the given node and all nodes that have the given node as an ancestor, collectively referred to as </span><b><span class="deltaxml-new" style="background:#90EE90">copied nodes</span></b><span class="deltaxml-new" style="background:#90EE90">. The properties of the copied nodes are as follows:</span></p><ol class="enumua"><li><p><span class="deltaxml-new" style="background:#90EE90">Each copied node receives a new node identity.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">children</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">attributes</span></code><span class="deltaxml-new" style="background:#90EE90"> properties of the copied nodes are set so as to preserve their inter-node relationships. For the topmost node (the node directly returned by the enclosed expression), the </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to the node constructed by this constructor.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumur"><li><p><span class="deltaxml-new" style="background:#90EE90">If the copied node is an element node, its </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> is set to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">. Its </span><code><span class="deltaxml-new" style="background:#90EE90">nilled</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">is-idrefs</span></code><span class="deltaxml-new" style="background:#90EE90"> properties are set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the copied node is an attribute node, its </span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. Its </span><code><span class="deltaxml-new" style="background:#90EE90">is-idrefs</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. Its </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the qualified name of the attribute node is </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise it is set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> of each copied element and attribute node remains unchanged, and its </span><code><span class="deltaxml-new" style="background:#90EE90">typed-value</span></code><span class="deltaxml-new" style="background:#90EE90"> becomes equal to its </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> Implementations that store only the </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> of a node are required at this point to convert the typed value to a string form.</span></p></div></li></ol><p><span class="deltaxml-new" style="background:#90EE90">On the other hand, if </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">nilled</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">typed-value</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">is-idrefs</span></code><span class="deltaxml-new" style="background:#90EE90"> properties of the copied nodes are preserved.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">in-scope-namespaces</span></code><span class="deltaxml-new" style="background:#90EE90"> property of a copied element node is determined by the following rules. In applying these rules, the default namespace or absence of a default namespace is treated like any other namespace binding:</span></p><ol class="enumur"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> specifies </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, all in-scope-namespaces of the original element are retained in the new copy. If </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> specifies </span><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, the new copy retains only those in-scope namespaces of the original element that are used in the names of the element and its attributes.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> specifies </span><code><span class="deltaxml-new" style="background:#90EE90">inherit</span></code><span class="deltaxml-new" style="background:#90EE90">, the copied node inherits all the in-scope namespaces of the constructed node, augmented and overridden by the in-scope namespaces of the original element that were preserved by the preceding rule. If </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> specifies </span><code><span class="deltaxml-new" style="background:#90EE90">no-inherit</span></code><span class="deltaxml-new" style="background:#90EE90">, the copied node does not inherit any in-scope namespaces from the constructed node.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">An enclosed expression in the content of an element constructor may cause one or more existing nodes to be copied. Type error [</span><a href="#ERRXQTY0086" title="err:XQTY0086"><span class="deltaxml-new" style="background:#90EE90">err:XQTY0086</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised in the following cases:</span></p><ol class="enumur"><li><p><span class="deltaxml-new" style="background:#90EE90"> An element node is copied, and the </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the element node or one of its attributes is </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> An attribute node is copied but its parent element node is not copied, and the </span><a title="typed value" class="termref" href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the copied attribute node is </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> The rationale for error [</span><a href="#ERRXQTY0086" title="err:XQTY0086"><span class="deltaxml-new" style="background:#90EE90">err:XQTY0086</span></a><span class="deltaxml-new" style="background:#90EE90">] is as follows: It is not possible to preserve the type of a QName without also preserving the namespace binding that defines the prefix of the QName.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">When an element or processing instruction node is copied, its </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to be the same as that of its new parent, with the following exception: if a copied element node has an </span><code><span class="deltaxml-new" style="background:#90EE90">xml:base</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute, its </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to the value of that attribute, </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved (if it is relative)</span></a><span class="deltaxml-new" style="background:#90EE90"> against the </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the new parent node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">All other properties of the copied nodes are preserved.</span></p></li></ol></li></ol></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the content sequence contains an attribute node or a namespace node following a node that is not an attribute node or a namespace node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQTY0024" title="err:XQTY0024"><span class="deltaxml-new" style="background:#90EE90">err:XQTY0024</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The properties of the newly constructed element node are determined as follows:</span></p><ol class="enumla"><li><p><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> resulting from resolving the element name in the start tag, including its original namespace prefix (if any), as described in </span><a href="#id-element-constructor"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> is set to empty.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attributes</span></code><span class="deltaxml-new" style="background:#90EE90"> consist of all the attributes specified in the start tag as described in </span><a href="#id-attributes"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.1 Attributes</span></b></a><span class="deltaxml-new" style="background:#90EE90">, together with all the attribute nodes in the content sequence, in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> order. Note that the </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0025" title="err:XQDY0025"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0025</span></a><span class="deltaxml-new" style="background:#90EE90">]. If an attribute named </span><code><span class="deltaxml-new" style="background:#90EE90">xml:space</span></code><span class="deltaxml-new" style="background:#90EE90"> has a value other than </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> may be raised [</span><a href="#ERRXQDY0092" title="err:XQDY0092"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0092</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">children</span></code><span class="deltaxml-new" style="background:#90EE90"> consist of all the element, text, comment, and processing instruction nodes in the content sequence. Note that the </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of each of these nodes has been set to the newly constructed element node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> is set to the following value:</span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">If the constructed node has an attribute named </span><code><span class="deltaxml-new" style="background:#90EE90">xml:base</span></code><span class="deltaxml-new" style="background:#90EE90">, then the value of this attribute, </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved (if it is relative)</span></a><span class="deltaxml-new" style="background:#90EE90"> against the </span><span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a></span><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#id-resolve-relative-uri"><b><span class="deltaxml-new" style="background:#90EE90">2.5.6 Resolving a Relative URI Reference</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the </span><span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">in-scope-namespaces</span></code><span class="deltaxml-new" style="background:#90EE90"> consist of all the namespace bindings resulting from namespace declaration attributes as described in </span><a href="#id-namespaces"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.2 Namespace Declaration Attributes</span></b></a><span class="deltaxml-new" style="background:#90EE90">, and possibly additional namespace bindings as described in </span><a href="#id-ns-nodes-on-elements"><b><span class="deltaxml-new" style="background:#90EE90">4.12.4 In-scope Namespaces of a Constructed Element</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">nilled</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property is equal to the concatenated contents of the text-node descendants in document order. If there are no text-node descendants, the </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property is a zero-length string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">typed-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property is equal to the </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">. On the other hand, if construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">is-idrefs</span></code><span class="deltaxml-new" style="background:#90EE90"> properties are set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li></ol><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;{ 1 }&lt;/a&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element node has one child, a text node containing the value </span><code><span class="deltaxml-new" style="background:#90EE90">"1"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;{ 1, 2, 3 }&lt;/a&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element node has one child, a text node containing the value </span><code><span class="deltaxml-new" style="background:#90EE90">"1 2 3"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;c&gt;{ 1 }{ 2 }{ 3 }&lt;/c&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element node has one child, a text node containing the value </span><code><span class="deltaxml-new" style="background:#90EE90">"123"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;b&gt;{ 1, "2", "3" }&lt;/b&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element node has one child, a text node containing the value </span><code><span class="deltaxml-new" style="background:#90EE90">"1 2 3"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element node has one child, a text node containing the value </span><code><span class="deltaxml-new" style="background:#90EE90">"I saw 8 cats."</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element node has one child, a text node containing the value </span><code><span class="deltaxml-new" style="background:#90EE90">"I saw 8 cats."</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;fact&gt;I saw &lt;howmany&gt;{ 5 + 3 }&lt;/howmany&gt; cats.&lt;/fact&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element node has three children: a text node containing </span><code><span class="deltaxml-new" style="background:#90EE90">"I saw </span></code><span class="deltaxml-new" style="background:#90EE90"> ", a child element node named </span><code><span class="deltaxml-new" style="background:#90EE90">howmany</span></code><span class="deltaxml-new" style="background:#90EE90">, and a text node containing </span><code><span class="deltaxml-new" style="background:#90EE90">" cats."</span></code><span class="deltaxml-new" style="background:#90EE90">. The child element node in turn has a single text node child containing the value </span><code><span class="deltaxml-new" style="background:#90EE90">"8"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div><div class="div4"><h5><a id="id-whitespace"></a><span class="deltaxml-new" style="background:#90EE90">4.12.1.4 Boundary Whitespace</span></h5><p><span class="deltaxml-new" style="background:#90EE90">In a direct element constructor, whitespace characters may appear in the content of the constructed element. In some cases, enclosed expressions and/or nested elements may be separated only by whitespace characters. For example, in the expression below, the end-tag </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;/title&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and the start-tag </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;author&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> are separated by a newline character and four space characters:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;book isbn="isbn-0060229357"&gt;
  &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
  &lt;author&gt;
    &lt;first&gt;Crockett&lt;/first&gt;
    &lt;last&gt;Johnson&lt;/last&gt;
  &lt;/author&gt;
&lt;/book&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-boundary-whitespace" title="boundary whitespace"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Boundary whitespace</span></b><span class="deltaxml-new" style="background:#90EE90"> is a sequence of consecutive whitespace characters within the content of a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></a><span class="deltaxml-new" style="background:#90EE90">, that is delimited at each end either by the start or end of the content, or by a </span><a href="#doc-xpath40-DirectConstructor"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">, or by an </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90">. For this purpose, characters generated by </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character references</span></a><span class="deltaxml-new" style="background:#90EE90"> such as </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#x20;</span></code><span class="deltaxml-new" style="background:#90EE90"> or by </span><a href="#doc-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSections</span></a><span class="deltaxml-new" style="background:#90EE90"> are not considered to be whitespace characters.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy"><span class="deltaxml-new" style="background:#90EE90">boundary-space policy</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> controls whether boundary whitespace is preserved by element constructors. If boundary-space policy is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, boundary whitespace is not considered significant and is discarded. On the other hand, if boundary-space policy is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, boundary whitespace is considered significant and is preserved.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;cat&gt;
  &lt;breed&gt;{ $b }&lt;/breed&gt;
  &lt;color&gt;{ $c }&lt;/color&gt;
&lt;/cat&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed </span><code><span class="deltaxml-new" style="background:#90EE90">cat</span></code><span class="deltaxml-new" style="background:#90EE90"> element node has two child element nodes named </span><code><span class="deltaxml-new" style="background:#90EE90">breed</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">color</span></code><span class="deltaxml-new" style="background:#90EE90">. Whitespace surrounding the child elements will be stripped away by the element constructor if boundary-space policy is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt; { "abc" } &lt;/a&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If boundary-space policy is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, this example is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;abc&lt;/a&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">. However, if boundary-space policy is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, this example is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;&nbsp;&nbsp;abc&nbsp;&nbsp;&lt;/a&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt; z { "abc" }&lt;/a&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Since the whitespace surrounding the </span><code><span class="deltaxml-new" style="background:#90EE90">z</span></code><span class="deltaxml-new" style="background:#90EE90"> is not boundary whitespace, it is always preserved. This example is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;&nbsp;z&nbsp;abc&lt;/a&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;&amp;#x20;{ "abc" }&lt;/a&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This example is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;&nbsp;abc&lt;/a&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless of the boundary-space policy, because the space generated by the </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character reference</span></a><span class="deltaxml-new" style="background:#90EE90"> is not treated as a whitespace character.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;{ "  " }&lt;/a&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This example constructs an element containing two space characters, regardless of the boundary-space policy, because whitespace inside an enclosed expression is never considered to be boundary whitespace.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;{ [ "one", "little", "fish" ] }&lt;/a&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This example constructs an element containing the text </span><code><span class="deltaxml-new" style="background:#90EE90">one little fish</span></code><span class="deltaxml-new" style="background:#90EE90">, because the array is flattened, and the resulting sequence of atomic items is converted to a text node with a single blank between values.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Element constructors treat attributes named </span><code><span class="deltaxml-new" style="background:#90EE90">xml:space</span></code><span class="deltaxml-new" style="background:#90EE90"> as ordinary attributes. An </span><code><span class="deltaxml-new" style="background:#90EE90">xml:space</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute does not affect the handling of whitespace by an element constructor.</span></p></div></div></div><div class="div3"><h4><a id="id-otherConstructors"></a><span class="deltaxml-new" style="background:#90EE90">4.12.2 Other Direct Constructors</span></h4><p><span class="deltaxml-new" style="background:#90EE90">XQuery allows an expression to generate a processing instruction node or a comment node. This can be accomplished by using a </span><b><span class="deltaxml-new" style="background:#90EE90">direct processing instruction constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> or a </span><b><span class="deltaxml-new" style="background:#90EE90">direct comment constructor</span></b><span class="deltaxml-new" style="background:#90EE90">. In each case, the syntax of the constructor expression is based on the syntax of a similar construct in XML.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirPIConstructor" id="doc-xpath40-DirPIConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[193]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirPIConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirPIConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;?" </span><a href="#prod-xpath40-PITarget" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PITarget</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#prod-xpath40-S" class="xquery"><span class="deltaxml-new" style="background:#90EE90">S</span></a><a href="#doc-xpath40-DirPIContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirPIContents</span></a><span class="deltaxml-new" style="background:#90EE90">)? "?&gt;"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirPIContents" id="doc-xpath40-DirPIContents"></a><span class="deltaxml-new" style="background:#90EE90">[194]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirPIContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirPIContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* '?&gt;' Char*))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirCommentConstructor" id="doc-xpath40-DirCommentConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[191]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirCommentConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirCommentConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;!--" </span><a href="#doc-xpath40-DirCommentContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirCommentContents</span></a><span class="deltaxml-new" style="background:#90EE90"> "--&gt;"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DirCommentContents" id="doc-xpath40-DirCommentContents"></a><span class="deltaxml-new" style="background:#90EE90">[192]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirCommentContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DirCommentContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - '-') | ('-' (</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - '-')))*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A direct processing instruction constructor creates a processing instruction node whose </span><code><span class="deltaxml-new" style="background:#90EE90">target</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><a href="#prod-xpath40-PITarget"><span class="deltaxml-new" style="background:#90EE90">PITarget</span></a><span class="deltaxml-new" style="background:#90EE90"> and whose </span><code><span class="deltaxml-new" style="background:#90EE90">content</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><a href="#doc-xpath40-DirPIContents"><span class="deltaxml-new" style="background:#90EE90">DirPIContents</span></a><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the node is empty. The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the node is empty.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#prod-xpath40-PITarget"><span class="deltaxml-new" style="background:#90EE90">PITarget</span></a><span class="deltaxml-new" style="background:#90EE90"> of a processing instruction must not consist of the characters </span><code><span class="deltaxml-new" style="background:#90EE90">XML</span></code><span class="deltaxml-new" style="background:#90EE90"> in any combination of upper and lower case, </span><span><span class="deltaxml-new" style="background:#90EE90">and must not contain a colon</span></span><span class="deltaxml-new" style="background:#90EE90">. The </span><a href="#doc-xpath40-DirPIContents"><span class="deltaxml-new" style="background:#90EE90">DirPIContents</span></a><span class="deltaxml-new" style="background:#90EE90"> of a processing instruction must not contain the string </span><code><span class="deltaxml-new" style="background:#90EE90">"?&gt;"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a direct processing instruction constructor:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;?format role="output" ?&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">A direct comment constructor creates a comment node whose </span><code><span class="deltaxml-new" style="background:#90EE90">content</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><a href="#doc-xpath40-DirCommentContents"><span class="deltaxml-new" style="background:#90EE90">DirCommentContents</span></a><span class="deltaxml-new" style="background:#90EE90">. Its </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property is empty.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#doc-xpath40-DirCommentContents"><span class="deltaxml-new" style="background:#90EE90">DirCommentContents</span></a><span class="deltaxml-new" style="background:#90EE90"> of a comment must not contain two consecutive hyphens or end with a hyphen. These rules are syntactically enforced by the grammar shown above.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a direct comment constructor:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;!-- Tags are ignored in the following section --&gt;</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A direct comment constructor is different from a </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">comment</span></a><span class="deltaxml-new" style="background:#90EE90">, since a direct comment constructor actually constructs a comment node, whereas a </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">comment</span></a><span class="deltaxml-new" style="background:#90EE90"> is simply used in documenting a query and is not evaluated.</span></p></div></div><div class="div3"><h4><a id="id-computedConstructors"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3 Computed Constructors</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ComputedConstructor" id="doc-xpath40-ComputedConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[197]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ComputedConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ComputedConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompDocConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompDocConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CompElemConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompElemConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CompAttrConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompAttrConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CompNamespaceConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompNamespaceConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CompTextConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompTextConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CompCommentConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompCommentConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#doc-xpath40-CompPIConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompPIConstructor</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">An alternative way to create nodes is by using a </span><b><span class="deltaxml-new" style="background:#90EE90">computed constructor</span></b><span class="deltaxml-new" style="background:#90EE90">. A computed constructor begins with a keyword that identifies the type of node to be created: </span><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">document</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">text</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">comment</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For those kinds of nodes that have names (element, attribute, and processing instruction nodes), the keyword that specifies the node kind is followed by the name of the node to be created. This name may be specified either as an EQName or as an expression enclosed in braces. [</span><a id="dt-name-expression" title="name expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: When an expression is used to specify the name of a constructed node, that expression is called the </span><b><span class="deltaxml-new" style="background:#90EE90">name expression</span></b><span class="deltaxml-new" style="background:#90EE90"> of the constructor.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the use of computed element and attribute constructors in a simple case where the names of the constructed nodes are constants. This example generates exactly the same result as the first example in </span><a href="#id-element-constructor"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">element book {
  attribute isbn { "isbn-0060229357" },
  element title { "Harold and the Purple Crayon" },
  element author {
    element first { "Crockett" },
    element last { "Johnson" }
  }
}</span></pre></div></div><div class="div4"><h5><a id="id-computedElements"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3.1 Computed Element Constructors</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CompElemConstructor" id="doc-xpath40-CompElemConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[199]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompElemConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompElemConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"element" (</span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}")) </span><a href="#doc-xpath40-EnclosedContentExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedContentExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e23487.doc-xpath40-EQName" id="noid_d4e23487.doc-xpath40-EQName"></a><span class="deltaxml-new" style="background:#90EE90">[266]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-URIQualifiedName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EnclosedContentExpr" id="doc-xpath40-EnclosedContentExpr"></a><span class="deltaxml-new" style="background:#90EE90">[200]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedContentExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedContentExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e23489.doc-xpath40-EnclosedExpr" id="noid_d4e23489.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-computed-elem-const" title="computed element constructor"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">computed element constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> creates an element node, allowing both the name and the content of the node to be computed.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><span class="deltaxml-new" style="background:#90EE90"> is followed by an EQName, it is expanded to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> as follows: if the EQName has a BracedURILiteral it is expanded using the specified URI; if the EQName is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> with a namespace prefix it is expanded using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">; if the EQName is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> without a prefix it is implicitly qualified by the </span><span><span class="deltaxml-new" style="background:#90EE90">namespace URI that is bound to the zero-length prefix in the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">; if there is no such binding, the expanded name will be in no namespace. </span></span><span class="deltaxml-new" style="background:#90EE90">. The resulting </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is used as the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed element node. If expansion of the QName is not successful, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><span class="deltaxml-new" style="background:#90EE90"> is followed by a </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90">, the name expression is processed as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the value of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90">. If the result of atomization is not a single atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized value of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">, that </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is used as the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed element, retaining the prefix part of the QName.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized value of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, that value is converted to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span><span class="deltaxml-new" style="background:#90EE90">as follows:</span></span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">Leading and trailing whitespace is removed.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is an unprefixed </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, it is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is a lexical QName with a prefix, that prefix is </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved to a namespace URI</span></a><span class="deltaxml-new" style="background:#90EE90"> using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is a URI-qualified name (</span><code><span class="deltaxml-new" style="background:#90EE90">Q{uri}local</span></code><span class="deltaxml-new" style="background:#90EE90">), it is converted to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> with the supplied namespace URI and local name, and with no prefix.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This was under-specified in XQuery 3.1.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The resulting </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is used as the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed element, retaining the prefix part of the QName </span><span><span class="deltaxml-new" style="background:#90EE90">(or its absence)</span></span><span class="deltaxml-new" style="background:#90EE90">. If conversion of the atomized </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90"> to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is not successful, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0074" title="err:XQDY0074"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0074</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0096" title="err:XQDY0096"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0096</span></a><span class="deltaxml-new" style="background:#90EE90">] if the node-name of the constructed element node has any of the following properties: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is not </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in Step 1e of </span><a href="#id-content"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.3 Content</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The result of processing the content expression is a sequence of nodes called the </span><b><span class="deltaxml-new" style="background:#90EE90">content sequence</span></b><span class="deltaxml-new" style="background:#90EE90">. If the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is absent, the content sequence is an empty sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Processing of the computed element constructor proceeds as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the content sequence contains an attribute node or a namespace node following a node that is not an attribute node or a namespace node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQTY0024" title="err:XQTY0024"><span class="deltaxml-new" style="background:#90EE90">err:XQTY0024</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The properties of the newly constructed element node are determined as follows:</span></p><ol class="enumla"><li><p><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> resulting from processing the specified </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90">, as described above.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">attributes</span></code><span class="deltaxml-new" style="background:#90EE90"> consist of all the attribute nodes in the content sequence, in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> order. Note that the </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0025" title="err:XQDY0025"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0025</span></a><span class="deltaxml-new" style="background:#90EE90">]. If an attribute named </span><code><span class="deltaxml-new" style="background:#90EE90">xml:space</span></code><span class="deltaxml-new" style="background:#90EE90"> has a value other than </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> may be raised [</span><a href="#ERRXQDY0092" title="err:XQDY0092"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0092</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">children</span></code><span class="deltaxml-new" style="background:#90EE90"> consist of all the element, text, comment, and processing instruction nodes in the content sequence. Note that the </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of each of these nodes has been set to the newly constructed element node.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> is set to the following value: </span></p><ol class="enumlr"><li><p><span class="deltaxml-new" style="background:#90EE90">If the constructed node has an attribute named </span><code><span class="deltaxml-new" style="background:#90EE90">xml:base</span></code><span class="deltaxml-new" style="background:#90EE90">, then the value of this attribute, </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved (if it is relative)</span></a><span class="deltaxml-new" style="background:#90EE90"> against the </span><span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a></span><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#id-resolve-relative-uri"><b><span class="deltaxml-new" style="background:#90EE90">2.5.6 Resolving a Relative URI Reference</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the </span><span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">in-scope-namespaces</span></code><span class="deltaxml-new" style="background:#90EE90"> are computed as described in </span><a href="#id-ns-nodes-on-elements"><b><span class="deltaxml-new" style="background:#90EE90">4.12.4 In-scope Namespaces of a Constructed Element</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">nilled</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property is equal to the concatenated contents of the text-node descendants in document order.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">typed-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property is equal to the </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">. On the other hand, if construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">is-idrefs</span></code><span class="deltaxml-new" style="background:#90EE90"> properties are set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li></ol><p><span class="deltaxml-new" style="background:#90EE90">A computed element constructor might be used to make a modified copy of an existing element. For example, if the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to an element with </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a><span class="deltaxml-new" style="background:#90EE90"> content, the following constructor might be used to create a new element with the same name and attributes as </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> and with numeric content equal to twice the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">element { node-name($e) } { $e/@*, 2 * data($e) }</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">In this example, if </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound by the expression </span><code><span class="deltaxml-new" style="background:#90EE90">let $e := &lt;length units="inches"&gt;{5}&lt;/length&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, then the result of the example expression is the element </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;length units="inches"&gt;10&lt;/length&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">fn:node-name($e)</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName?</span></code><span class="deltaxml-new" style="background:#90EE90">, denoting zero or one QName. The example can be successfully evaluated as written provided that </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to exactly one element node with numeric content.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">One important purpose of computed constructors is to allow the name of a node to be computed. We will illustrate this feature by an expression that translates the name of an element from one language to another. Suppose that the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$dict</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a </span><code><span class="deltaxml-new" style="background:#90EE90">dictionary</span></code><span class="deltaxml-new" style="background:#90EE90"> element containing a sequence of </span><code><span class="deltaxml-new" style="background:#90EE90">entry</span></code><span class="deltaxml-new" style="background:#90EE90"> elements, each of which encodes translations for a specific word. Here is an example entry that encodes the German and Italian variants of the word “address”:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;entry word="address"&gt;
   &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
   &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Suppose further that the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the following element:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Then the following expression generates a new element in which the name of </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> has been translated into Italian and the content of </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> (including its attributes, if any) has been preserved. The first enclosed expression after the </span><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword generates the name of the element, and the second enclosed expression generates the content and attributes:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">element {
  $dict/entry[@word = name($e)]/variant[@xml:lang = "it"]
} {
  $e/@*, $e/node()
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this expression is as follows:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;</span></pre></div></div></div><div class="div4"><h5><a id="id-computedAttributes"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3.2 Computed Attribute Constructors</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CompAttrConstructor" id="doc-xpath40-CompAttrConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[201]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompAttrConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompAttrConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"attribute" (</span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}")) </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e23980.doc-xpath40-EQName" id="noid_d4e23980.doc-xpath40-EQName"></a><span class="deltaxml-new" style="background:#90EE90">[266]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-URIQualifiedName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e23981.doc-xpath40-EnclosedExpr" id="noid_d4e23981.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A computed attribute constructor creates a new attribute node, with its own node identity.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Attributes have no default namespace. The rules that expand attribute names create an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> prefix if an attribute name has a namespace URI but no prefix is provided.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><span class="deltaxml-new" style="background:#90EE90"> is followed by an EQName, it is expanded to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the EQName has a BracedURILiteral it is expanded using the specified URI to create an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">; the name of the attribute is constructed using the namespace URI and local name of the expanded QName and an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> prefix.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the EQName is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> with a namespace prefix it is expanded using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the EQName is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> without a prefix, the expanded QName is in no namespace.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The resulting </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (including its prefix) is used as the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed attribute node. If expansion of the QName is not successful, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><span class="deltaxml-new" style="background:#90EE90"> is followed by a </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90">, the name expression is processed as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the result of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90">. If the result of </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is not a single atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized value of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> returned by the atomized name expression has a namespace URI but has no prefix, it is given an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> prefix.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The resulting </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (including its prefix) is used as the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed attribute node.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized value of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, that value is converted to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span><span class="deltaxml-new" style="background:#90EE90">as follows:</span></span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">Leading and trailing whitespace is removed.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is an unprefixed </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, it is treated as a local name in no namespace.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is a lexical QName with a prefix, that prefix is </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved to a namespace URI</span></a><span class="deltaxml-new" style="background:#90EE90"> using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the value is a URI-qualified name (</span><code><span class="deltaxml-new" style="background:#90EE90">Q{uri}local</span></code><span class="deltaxml-new" style="background:#90EE90">), it is converted to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> with the supplied namespace URI and local name, and with an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> prefix.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This was under-specified in XQuery 3.1.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The resulting </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (including its prefix) is used as the </span><code><span class="deltaxml-new" style="background:#90EE90">node-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed attribute. If conversion of the atomized </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90"> to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is not successful, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0074" title="err:XQDY0074"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0074</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0044" title="err:XQDY0044"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0044</span></a><span class="deltaxml-new" style="background:#90EE90">] if the node-name of the constructed attribute node has any of the following properties: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It has no namespace prefix and its local name is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is not </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a computed attribute constructor is processed as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the result of the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90">, converting it to a sequence of atomic items. (If the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is absent, the result of this step is an empty sequence.)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is an empty sequence, the value of the attribute is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the new attribute node. The </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><code><span class="deltaxml-new" style="background:#90EE90">type-name</span></code><span class="deltaxml-new" style="background:#90EE90"> property) of the new attribute node is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">typed-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the attribute node is the same as its </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90">, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the attribute node is set to empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the attribute name is </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90"> processing is performed as defined in </span><a href="#XMLID"><span class="deltaxml-new" style="background:#90EE90">[XML ID]</span></a><span class="deltaxml-new" style="background:#90EE90">. This ensures that the attribute node has the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:ID</span></code><span class="deltaxml-new" style="background:#90EE90"> and that its value is properly normalized. If an error is encountered during </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90"> processing, an implementation may raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQDY0091" title="err:XQDY0091"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0091</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the attribute name is </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the resulting attribute node is set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise the </span><code><span class="deltaxml-new" style="background:#90EE90">is-id</span></code><span class="deltaxml-new" style="background:#90EE90"> property is set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">is-idrefs</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the attribute node is unconditionally set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the attribute name is </span><code><span class="deltaxml-new" style="background:#90EE90">xml:space</span></code><span class="deltaxml-new" style="background:#90EE90"> and the attribute value is other than </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> may be raised [</span><a href="#ERRXQDY0092" title="err:XQDY0092"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0092</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">attribute size {4 + 3}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="string value" class="termref" href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><span class="deltaxml-new" style="background:#90EE90">size</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is </span><code><span class="deltaxml-new" style="background:#90EE90">"7"</span></code><span class="deltaxml-new" style="background:#90EE90"> and its type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">attribute {
  if ($sex = "M") then "husband" else "wife"
} {
  &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt;
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The name of the constructed attribute is either </span><code><span class="deltaxml-new" style="background:#90EE90">husband</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">wife</span></code><span class="deltaxml-new" style="background:#90EE90">. Its </span><a title="string value" class="termref" href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string value</span></a><span class="deltaxml-new" style="background:#90EE90"> is "</span><code><span class="deltaxml-new" style="background:#90EE90">Hello 1 2 3 Goodbye</span></code><span class="deltaxml-new" style="background:#90EE90">".</span></p></li></ul></div><div class="div4"><h5><a id="id-documentConstructors"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3.3 Document Node Constructors</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CompDocConstructor" id="doc-xpath40-CompDocConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[198]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompDocConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompDocConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"document" </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e24371.doc-xpath40-EnclosedExpr" id="noid_d4e24371.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">All document node constructors are computed constructors. The result of a document node constructor is a new document node, with its own node identity.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A document node constructor is useful when the result of a query is to be a document in its own right. The following example illustrates a query that returns an XML document containing a root element named </span><code><span class="deltaxml-new" style="background:#90EE90">author-list</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">document {
  &lt;author-list&gt;{
    doc("bib.xml")/bib/book/author
  }&lt;/author-list&gt;
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a document node constructor is processed in exactly the same way as an enclosed expression in the content of a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in Step 1e of </span><a href="#id-content"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.3 Content</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The result of processing the content expression is a sequence of nodes called the </span><b><span class="deltaxml-new" style="background:#90EE90">content sequence</span></b><span class="deltaxml-new" style="background:#90EE90">. Processing of the document node constructor then proceeds as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the content sequence contains an attribute node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the content sequence contains a namespace node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The properties of the newly constructed document node are determined as follows:</span></p><ol class="enumla"><li><p><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> is set to the </span><span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">children</span></code><span class="deltaxml-new" style="background:#90EE90"> consist of all the element, text, comment, and processing instruction nodes in the content sequence. Note that the </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of each of these nodes has been set to the newly constructed document node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">unparsed-entities</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">document-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> properties are empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property is equal to the concatenated contents of the text-node descendants in document order.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">typed-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property is equal to the </span><code><span class="deltaxml-new" style="background:#90EE90">string-value</span></code><span class="deltaxml-new" style="background:#90EE90"> property, as an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li></ol><p><span class="deltaxml-new" style="background:#90EE90">No validation is performed on the constructed document node. The </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> rules that govern the structure of an XML document (for example, the document node must have exactly one child that is an element node) are not enforced by the XQuery document node constructor.</span></p></div><div class="div4"><h5><a id="id-textConstructors"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3.4 Text Node Constructors</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CompTextConstructor" id="doc-xpath40-CompTextConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[206]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompTextConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompTextConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"text" </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e24472.doc-xpath40-EnclosedExpr" id="noid_d4e24472.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">All text node constructors are computed constructors. The result of a text node constructor is a new text node, with its own node identity.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a text node constructor is processed as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the value of the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90">, converting it to a sequence of atomic items.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is an empty sequence, no text node is constructed. Otherwise, each atomic item in the atomized sequence is cast into a string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the </span><code><span class="deltaxml-new" style="background:#90EE90">content</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed text node.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed text node is set to empty.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">It is possible for a text node constructor to construct a text node containing a zero-length string. However, if used in the content of a constructed element or document node, such a text node will be deleted or merged with another text node.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a text node constructor:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">text { "Hello" }</span></pre></div></div></div><div class="div4"><h5><a id="id-computed-pis"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3.5 Computed Processing Instruction Constructors</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CompPIConstructor" id="doc-xpath40-CompPIConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[208]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompPIConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompPIConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"processing-instruction" (</span><a href="#prod-xpath40-NCName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}")) </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e24512.doc-xpath40-EnclosedExpr" id="noid_d4e24512.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A computed processing instruction constructor (</span><a href="#doc-xpath40-CompPIConstructor"><span class="deltaxml-new" style="background:#90EE90">CompPIConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">) constructs a new processing instruction node with its own node identity. </span></p><p><span class="deltaxml-new" style="background:#90EE90">If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction</span></code><span class="deltaxml-new" style="background:#90EE90"> is followed by an NCName, that NCName is used as the </span><code><span class="deltaxml-new" style="background:#90EE90">target</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed node. If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction</span></code><span class="deltaxml-new" style="background:#90EE90"> is followed by a </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90">, the name expression is processed as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the value of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90">. If the result of </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is not a single atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the atomized value of the </span><a title="name expression" class="termref" href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, that value is cast to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">. If the value cannot be cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0041" title="err:XQDY0041"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0041</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The resulting NCName is then used as the </span><code><span class="deltaxml-new" style="background:#90EE90">target</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the newly constructed processing instruction node. However, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if the NCName is equal to </span><code><span class="deltaxml-new" style="background:#90EE90">"XML"</span></code><span class="deltaxml-new" style="background:#90EE90"> (in any combination of upper and lower case) [</span><a href="#ERRXQDY0064" title="err:XQDY0064"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0064</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a computed processing instruction constructor is processed as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the value of the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90">, converting it to a sequence of atomic items. (If the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is absent, the result of this step is an empty sequence.)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string. If any of the resulting strings contains the string </span><code><span class="deltaxml-new" style="background:#90EE90">"?&gt;"</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQDY0026" title="err:XQDY0026"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0026</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. Leading whitespace is removed from the resulting string. The resulting string then becomes the </span><code><span class="deltaxml-new" style="background:#90EE90">content</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed processing instruction node.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The remaining properties of the new processing instruction node are determined as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property is empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property is empty.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a computed processing instruction constructor:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $target := "audio-output",
return processing-instruction { $target } { "beep" }</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The processing instruction node constructed by this example might be serialized as follows:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;?audio-output beep?&gt;</span></pre></div></div><div class="div4"><h5><a id="id-computed-comments"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3.6 Computed Comment Constructors</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CompCommentConstructor" id="doc-xpath40-CompCommentConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[207]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompCommentConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompCommentConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"comment" </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e24660.doc-xpath40-EnclosedExpr" id="noid_d4e24660.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A computed comment constructor (</span><a href="#doc-xpath40-CompCommentConstructor"><span class="deltaxml-new" style="background:#90EE90">CompCommentConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">) constructs a new comment node with its own node identity. The </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a computed comment constructor is processed as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the value of the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90">, converting it to a sequence of atomic items.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the </span><code><span class="deltaxml-new" style="background:#90EE90">content</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed comment node.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQDY0072" title="err:XQDY0072"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0072</span></a><span class="deltaxml-new" style="background:#90EE90">] if the result of the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the constructed comment node is set to empty.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a computed comment constructor:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $homebase := "Houston"
return comment { concat($homebase, ", we have a problem.") }</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The comment node constructed by this example might be serialized as follows:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;!--Houston, we have a problem.--&gt;</span></pre></div></div><div class="div4"><h5><a id="id-computed-namespaces"></a><span class="deltaxml-new" style="background:#90EE90">4.12.3.7 Computed Namespace Constructors</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CompNamespaceConstructor" id="doc-xpath40-CompNamespaceConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[202]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompNamespaceConstructor" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CompNamespaceConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"namespace" (</span><a href="#doc-xpath40-Prefix" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Prefix</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EnclosedPrefixExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedPrefixExpr</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-EnclosedURIExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedURIExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Prefix" id="doc-xpath40-Prefix"></a><span class="deltaxml-new" style="background:#90EE90">[203]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Prefix" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Prefix</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EnclosedPrefixExpr" id="doc-xpath40-EnclosedPrefixExpr"></a><span class="deltaxml-new" style="background:#90EE90">[204]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedPrefixExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedPrefixExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EnclosedURIExpr" id="doc-xpath40-EnclosedURIExpr"></a><span class="deltaxml-new" style="background:#90EE90">[205]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedURIExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedURIExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e24717.doc-xpath40-EnclosedExpr" id="noid_d4e24717.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A computed namespace constructor creates a new namespace node, with its own node identity. The parent of the newly created namespace node is empty.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the constructor specifies a </span><code><span class="deltaxml-new" style="background:#90EE90">Prefix</span></code><span class="deltaxml-new" style="background:#90EE90">, it is used as the prefix for the namespace node.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the constructor specifies a </span><code><span class="deltaxml-new" style="background:#90EE90">PrefixExpr</span></code><span class="deltaxml-new" style="background:#90EE90">, the prefix expression is evaluated as follows:</span></p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">PrefixExpr</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the result of </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is an empty sequence or a single atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, then the following rules are applied in order:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If the result is castable to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, then it is used as the local name of the newly constructed namespace node. (The local name of a namespace node represents the prefix part of the namespace binding.)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result is the empty sequence or a zero-length </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> item, the new namespace node has no name (such a namespace node represents a binding for the default namespace).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0074" title="err:XQDY0074"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0074</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is not an empty sequence or a single atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> is evaluated, and the result is cast to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> to create the </span><code><span class="deltaxml-new" style="background:#90EE90">URI</span></code><span class="deltaxml-new" style="background:#90EE90"> property for the newly created node. An implementation may raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQDY0074" title="err:XQDY0074"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0074</span></a><span class="deltaxml-new" style="background:#90EE90">] if the </span><code><span class="deltaxml-new" style="background:#90EE90">URIExpr</span></code><span class="deltaxml-new" style="background:#90EE90"> of a computed namespace constructor is not a valid instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An error [</span><a href="#ERRXQDY0101" title="err:XQDY0101"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0101</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised if a computed namespace constructor attempts to do any of the following:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Bind the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> to some namespace URI other than </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind a prefix other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> to any namespace URI. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind a prefix to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind any prefix (including the empty prefix) to a zero-length namespace URI.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">By itself, a computed namespace constructor has no effect on in-scope namespaces, but if an element constructor’s content sequence contains a namespace node, the namespace binding it represents is added to the element’s </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A computed namespace constructor has no effect on the statically known namespaces.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The newly created namespace node has all properties defined for a namespace node in the data model. As defined in the data model, the name of the node is the prefix, the string value of the node is the URI, the relative order of nodes that share no common ancestor is implementation dependent, and the relative order of namespace nodes that share a parent is also implementation dependent.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A computed namespace constructor with a prefix:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">namespace a { "http://a.example.com" }</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A computed namespace constructor with a prefix expression:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">namespace { "a" } { "http://a.example.com" }</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A computed namespace constructor with an empty prefix:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">namespace { "" } { "http://a.example.com" }</span></pre></div></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Computed namespace constructors are generally used to add to the in-scope namespaces of elements created with element constructors:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;age xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; {
  namespace xs { "http://www.w3.org/2001/XMLSchema" },
  attribute xsi:type { "xs:integer" },
  23
}&lt;/age&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">In the above example, note that the </span><code><span class="deltaxml-new" style="background:#90EE90">xsi</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace binding is created for the element because it is used in an attribute name. The attribute’s content is simply character data, and has no effect on namespace bindings. The computed namespace constructor ensures that the </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90"> binding is created.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Computed namespace constructors have no effect on the statically known namespaces. If the prefix a is not already defined in the statically known namespaces, the following expression results in a static error [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;a:form&gt;{
  namespace a { "http://a.example.com" }
}&lt;/a:form&gt;</span></pre></div></div></div></div><div class="div3"><h4><a id="id-ns-nodes-on-elements"></a><span class="deltaxml-new" style="background:#90EE90">4.12.4 In-scope Namespaces of a Constructed Element</span></h4><p><span class="deltaxml-new" style="background:#90EE90">An element node constructed by a direct or computed element constructor has an </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> property that consists of a set of </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">namespace bindings</span></a><span class="deltaxml-new" style="background:#90EE90">. The in-scope namespaces of an element node may affect the way the node is serialized (see </span><a href="#id-serialization"><b><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></b></a><span class="deltaxml-new" style="background:#90EE90">), and may also affect the behavior of certain functions that operate on nodes, such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name</span></code><span class="deltaxml-new" style="background:#90EE90">. Note the difference between </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, which is a dynamic property of an element node, and </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, which is a static property of an expression. Also note that one of the namespace bindings in the in-scope namespaces may have no prefix (denoting the default namespace for the given element). The in-scope namespaces of a constructed element node consist of the following namespace bindings:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A namespace binding is created for each namespace declared in the current element constructor by a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A namespace binding is created for each namespace node in the content sequence of the current element constructor.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A namespace binding is created for each namespace that is declared in a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></a><span class="deltaxml-new" style="background:#90EE90"> of an enclosing </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></a><span class="deltaxml-new" style="background:#90EE90"> and not overridden by the current element constructor or an intermediate constructor.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A namespace binding is always created to bind the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For each prefix used in the name of the constructed element or in the names of its attributes, a namespace binding must exist. If a namespace binding does not already exist for one of these prefixes, a new namespace binding is created for it. If this would result in a conflict, because it would require two different bindings of the same prefix, then the prefix used in the node name is changed to an arbitrary </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> prefix that does not cause such a conflict, and a namespace binding is created for this new prefix. If there is an in-scope default namespace, then a binding is created between the empty prefix and that URI.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">Copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> does not affect the namespace bindings of a newly constructed element node. It applies only to existing nodes that are copied by a constructor expression.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">In an element constructor, if two or more namespace bindings in the in-scope bindings would have the same prefix, then an error is raised if they have different URIs [</span><a href="#ERRXQDY0102" title="err:XQDY0102"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0102</span></a><span class="deltaxml-new" style="background:#90EE90">]; if they would have the same prefix and URI, duplicate bindings are ignored. If the name of an element in an element constructor is in no namespace, creating a default namespace for that element using a computed namespace constructor is an error [</span><a href="#ERRXQDY0102" title="err:XQDY0102"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0102</span></a><span class="deltaxml-new" style="background:#90EE90">]. For instance, the following computed constructor raises an error because the element’s name is not in a namespace, but a default namespace is defined.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">element e { namespace { '' } { 'u' } }</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following query illustrates the in-scope namespaces of a constructed element:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace p="http://example.com/ns/p";
declare namespace q="http://example.com/ns/q";
declare namespace f="http://example.com/ns/f";

&lt;p:a q:b="{ f:func(2) }" xmlns:r="http://example.com/ns/r"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> of the resulting </span><code><span class="deltaxml-new" style="background:#90EE90">p:a</span></code><span class="deltaxml-new" style="background:#90EE90"> element consists of the following namespace bindings:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">p = "http://example.com/ns/p"</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">q = "http://example.com/ns/q"</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">r = "http://example.com/ns/r"</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xml = "http://www.w3.org/XML/1998/namespace"</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The namespace bindings for </span><code><span class="deltaxml-new" style="background:#90EE90">p</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">q</span></code><span class="deltaxml-new" style="background:#90EE90"> are added to the result element because their respective namespaces are used in the names of the element and its attributes. The namespace binding </span><code><span class="deltaxml-new" style="background:#90EE90">r="http://example.com/ns/r"</span></code><span class="deltaxml-new" style="background:#90EE90"> is added to the in-scope namespaces of the constructed element because it is defined by a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></a><span class="deltaxml-new" style="background:#90EE90">, even though it is not used in a name.</span></p><p><span class="deltaxml-new" style="background:#90EE90">No namespace binding corresponding to </span><code><span class="deltaxml-new" style="background:#90EE90">f="http://example.com/ns/f"</span></code><span class="deltaxml-new" style="background:#90EE90"> is created, because the namespace prefix </span><code><span class="deltaxml-new" style="background:#90EE90">f</span></code><span class="deltaxml-new" style="background:#90EE90"> appears only in the query prolog and is not used in an element or attribute name of the constructed node. This namespace binding does not appear in the query result, even though it is present in the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> and is available for use during processing of the query.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Note that the following constructed element, if nested within a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, cannot be validated: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The constructed element will have namespace bindings for the prefixes </span><code><span class="deltaxml-new" style="background:#90EE90">xsi</span></code><span class="deltaxml-new" style="background:#90EE90"> (because it is used in a name) and </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> (because it is defined for every constructed element node). During validation of the constructed element, the validator will be unable to interpret the namespace prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90"> because it is has no namespace binding. Validation of this constructed element could be made possible by providing a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></a><span class="deltaxml-new" style="background:#90EE90">, as in the following example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xsi:type="xs:integer"&gt;3&lt;/p&gt;</span></pre></div></div></div></div></div><div class="div2"><h3><a id="id-flwor-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.13 </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">FLWOR Expressions</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">For and Let Expressions</span></span></span></h3><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery provides a versatile expression called a FLWOR expression that may contain multiple clauses. The FLWOR expression can be used for many purposes, including iterating over sequences, joining multiple documents, and performing grouping and aggregation. The name FLWOR, pronounced "flower", is suggested by the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90">, which introduce some of the clauses used in FLWOR expressions (but this is not a complete list of such clauses.)</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The complete syntax of a FLWOR expression is shown here, and relevant parts of the syntax are repeated in subsequent sections of this document.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath provides two closely-related expressions, called For and Let expressions, that can be used to bind variables to values. The complete syntax is shown here, and relevant parts of the syntax are repeated in subsequent sections of this document.</span></p></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForExpr" id="doc-xpath40-ForExpr"></a><span class="deltaxml-new" style="background:#90EE90">[48]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a><a href="#doc-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-LetExpr" id="doc-xpath40-LetExpr"></a><span class="deltaxml-new" style="background:#90EE90">[50]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LetClause"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a><a href="#doc-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FLWORExpr" id="doc-xpath40-FLWORExpr"></a><span class="deltaxml-new" style="background:#90EE90">[51]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FLWORExpr"><span class="deltaxml-new" style="background:#90EE90">FLWORExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-InitialClause"><span class="deltaxml-new" style="background:#90EE90">InitialClause</span></a><a href="#doc-xpath40-IntermediateClause"><span class="deltaxml-new" style="background:#90EE90">IntermediateClause</span></a><span class="deltaxml-new" style="background:#90EE90">* </span><a href="#doc-xpath40-ReturnClause"><span class="deltaxml-new" style="background:#90EE90">ReturnClause</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-InitialClause" id="doc-xpath40-InitialClause"></a><span class="deltaxml-new" style="background:#90EE90">[52]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InitialClause"><span class="deltaxml-new" style="background:#90EE90">InitialClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-LetClause"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-WindowClause"><span class="deltaxml-new" style="background:#90EE90">WindowClause</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-IntermediateClause" id="doc-xpath40-IntermediateClause"></a><span class="deltaxml-new" style="background:#90EE90">[53]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-IntermediateClause"><span class="deltaxml-new" style="background:#90EE90">IntermediateClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-InitialClause"><span class="deltaxml-new" style="background:#90EE90">InitialClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-WhereClause"><span class="deltaxml-new" style="background:#90EE90">WhereClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-WhileClause"><span class="deltaxml-new" style="background:#90EE90">WhileClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-GroupByClause"><span class="deltaxml-new" style="background:#90EE90">GroupByClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-OrderByClause"><span class="deltaxml-new" style="background:#90EE90">OrderByClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-CountClause"><span class="deltaxml-new" style="background:#90EE90">CountClause</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForClause" id="doc-xpath40-ForClause"></a><span class="deltaxml-new" style="background:#90EE90">[54]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"for" </span><a href="#doc-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForBinding" id="doc-xpath40-ForBinding"></a><span class="deltaxml-new" style="background:#90EE90">[55]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForMemberBinding"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForEntryBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForItemBinding" id="doc-xpath40-ForItemBinding"></a><span class="deltaxml-new" style="background:#90EE90">[56]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-AllowingEmpty"><span class="deltaxml-new" style="background:#90EE90">AllowingEmpty</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForMemberBinding" id="doc-xpath40-ForMemberBinding"></a><span class="deltaxml-new" style="background:#90EE90">[57]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForMemberBinding"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"member" "$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForEntryBinding" id="doc-xpath40-ForEntryBinding"></a><span class="deltaxml-new" style="background:#90EE90">[59]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForEntryBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#doc-xpath40-ForEntryKeyBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryKeyBinding</span></a><a href="#doc-xpath40-ForEntryValueBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">?) | </span><a href="#doc-xpath40-ForEntryValueBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForEntryKeyBinding" id="doc-xpath40-ForEntryKeyBinding"></a><span class="deltaxml-new" style="background:#90EE90">[60]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForEntryKeyBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryKeyBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"key" "$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForEntryValueBinding" id="doc-xpath40-ForEntryValueBinding"></a><span class="deltaxml-new" style="background:#90EE90">[61]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForEntryValueBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"value" "$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-LetClause" id="doc-xpath40-LetClause"></a><span class="deltaxml-new" style="background:#90EE90">[63]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetClause"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"let" </span><a href="#doc-xpath40-LetBinding"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-LetBinding"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-LetBinding" id="doc-xpath40-LetBinding"></a><span class="deltaxml-new" style="background:#90EE90">[64]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetBinding"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ":=" </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25087.doc-xpath40-TypeDeclaration" id="noid_d4e25087.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AllowingEmpty" id="doc-xpath40-AllowingEmpty"></a><span class="deltaxml-new" style="background:#90EE90">[58]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AllowingEmpty"><span class="deltaxml-new" style="background:#90EE90">AllowingEmpty</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"allowing" "empty"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PositionalVar" id="doc-xpath40-PositionalVar"></a><span class="deltaxml-new" style="background:#90EE90">[62]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"at" "$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-WindowClause" id="doc-xpath40-WindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[65]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowClause"><span class="deltaxml-new" style="background:#90EE90">WindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"for" (</span><a href="#doc-xpath40-TumblingWindowClause"><span class="deltaxml-new" style="background:#90EE90">TumblingWindowClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-SlidingWindowClause"><span class="deltaxml-new" style="background:#90EE90">SlidingWindowClause</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TumblingWindowClause" id="doc-xpath40-TumblingWindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[66]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TumblingWindowClause"><span class="deltaxml-new" style="background:#90EE90">TumblingWindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"tumbling" "window" "$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SlidingWindowClause" id="doc-xpath40-SlidingWindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[67]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SlidingWindowClause"><span class="deltaxml-new" style="background:#90EE90">SlidingWindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"sliding" "window" "$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-WindowStartCondition" id="doc-xpath40-WindowStartCondition"></a><span class="deltaxml-new" style="background:#90EE90">[68]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"start" </span><a href="#doc-xpath40-WindowVars"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a><span class="deltaxml-new" style="background:#90EE90"> ("when" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-WindowEndCondition" id="doc-xpath40-WindowEndCondition"></a><span class="deltaxml-new" style="background:#90EE90">[69]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"only"? "end" </span><a href="#doc-xpath40-WindowVars"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a><span class="deltaxml-new" style="background:#90EE90"> ("when" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-WindowVars" id="doc-xpath40-WindowVars"></a><span class="deltaxml-new" style="background:#90EE90">[70]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowVars"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("$" </span><a href="#doc-xpath40-CurrentItem"><span class="deltaxml-new" style="background:#90EE90">CurrentItem</span></a><span class="deltaxml-new" style="background:#90EE90">)? </span><a href="#doc-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? ("previous" "$" </span><a href="#doc-xpath40-PreviousItem"><span class="deltaxml-new" style="background:#90EE90">PreviousItem</span></a><span class="deltaxml-new" style="background:#90EE90">)? ("next" "$" </span><a href="#doc-xpath40-NextItem"><span class="deltaxml-new" style="background:#90EE90">NextItem</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CurrentItem" id="doc-xpath40-CurrentItem"></a><span class="deltaxml-new" style="background:#90EE90">[71]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CurrentItem"><span class="deltaxml-new" style="background:#90EE90">CurrentItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PreviousItem" id="doc-xpath40-PreviousItem"></a><span class="deltaxml-new" style="background:#90EE90">[72]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PreviousItem"><span class="deltaxml-new" style="background:#90EE90">PreviousItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NextItem" id="doc-xpath40-NextItem"></a><span class="deltaxml-new" style="background:#90EE90">[73]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NextItem"><span class="deltaxml-new" style="background:#90EE90">NextItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25100.doc-xpath40-CountClause" id="noid_d4e25100.doc-xpath40-CountClause"></a><span class="deltaxml-new" style="background:#90EE90">[74]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CountClause"><span class="deltaxml-new" style="background:#90EE90">CountClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"count" "$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25101.doc-xpath40-WhereClause" id="noid_d4e25101.doc-xpath40-WhereClause"></a><span class="deltaxml-new" style="background:#90EE90">[75]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WhereClause"><span class="deltaxml-new" style="background:#90EE90">WhereClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"where" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25102.doc-xpath40-WhileClause" id="noid_d4e25102.doc-xpath40-WhileClause"></a><span class="deltaxml-new" style="background:#90EE90">[76]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WhileClause"><span class="deltaxml-new" style="background:#90EE90">WhileClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"while" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-GroupByClause" id="doc-xpath40-GroupByClause"></a><span class="deltaxml-new" style="background:#90EE90">[77]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GroupByClause"><span class="deltaxml-new" style="background:#90EE90">GroupByClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"group" "by" </span><a href="#doc-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-GroupingSpec" id="doc-xpath40-GroupingSpec"></a><span class="deltaxml-new" style="background:#90EE90">[78]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-GroupingVariable"><span class="deltaxml-new" style="background:#90EE90">GroupingVariable</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ":=" </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)? ("collation" </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-GroupingVariable" id="doc-xpath40-GroupingVariable"></a><span class="deltaxml-new" style="background:#90EE90">[79]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GroupingVariable"><span class="deltaxml-new" style="background:#90EE90">GroupingVariable</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25107.doc-xpath40-OrderByClause" id="noid_d4e25107.doc-xpath40-OrderByClause"></a><span class="deltaxml-new" style="background:#90EE90">[80]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderByClause"><span class="deltaxml-new" style="background:#90EE90">OrderByClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"stable"? "order" "by" </span><a href="#doc-xpath40-OrderSpec"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-OrderSpec"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OrderSpec" id="doc-xpath40-OrderSpec"></a><span class="deltaxml-new" style="background:#90EE90">[81]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderSpec"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#doc-xpath40-OrderModifier"><span class="deltaxml-new" style="background:#90EE90">OrderModifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OrderModifier" id="doc-xpath40-OrderModifier"></a><span class="deltaxml-new" style="background:#90EE90">[82]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderModifier"><span class="deltaxml-new" style="background:#90EE90">OrderModifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ReturnClause" id="doc-xpath40-ReturnClause"></a><span class="deltaxml-new" style="background:#90EE90">[83]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ReturnClause"><span class="deltaxml-new" style="background:#90EE90">ReturnClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"return" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ForLetReturn" id="doc-xpath40-ForLetReturn"></a><span class="deltaxml-new" style="background:#90EE90">[49]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("return" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody></table><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The semantics of FLWOR expressions are based on a concept called a </span><b><span class="deltaxml-new" style="background:#90EE90">tuple stream</span></b><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="id-tuple-stream-foobar" title="tuple stream"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">tuple stream</span></b><span class="deltaxml-new" style="background:#90EE90"> is an ordered sequence of zero or more </span><b><span class="deltaxml-new" style="background:#90EE90">tuples</span></b><span class="deltaxml-new" style="background:#90EE90">.] [</span><a id="id-tuple-foobar" title="tuple"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">tuple</span></b><span class="deltaxml-new" style="background:#90EE90"> is a set of zero or more named variables, each of which is bound to a value that is an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90">.] Each tuple stream is homogeneous in the sense that all its tuples contain variables with the same names and the same </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static types</span></a><span class="deltaxml-new" style="background:#90EE90">. The following example illustrates a tuple stream consisting of four tuples, each containing three variables named </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$y</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">$z</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p></div><div class="xquery"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1003, $y = "Fred", $z = &lt;age&gt;21&lt;/age&gt;)
($x = 1017, $y = "Mary", $z = &lt;age&gt;35&lt;/age&gt;)
($x = 1020, $y = "Bill", $z = &lt;age&gt;18&lt;/age&gt;)
($x = 1024, $y = "John", $z = &lt;age&gt;29&lt;/age&gt;)</span></pre></div></div><div class="xquery note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In this section, tuple streams are represented as shown in the above example. Each tuple is on a separate line and is enclosed in parentheses, and the variable bindings inside each tuple are separated by commas. This notation does not represent XQuery syntax, but is simply a representation of a tuple stream for the purpose of defining the semantics of FLWOR expressions.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Tuples and tuple streams are not part of the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90">. They exist only as conceptual intermediate results during the processing of a FLWOR expression.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Conceptually, the first clause generates a tuple stream. Each clause between the first clause and the return clause takes the tuple stream generated by the previous clause as input and generates a (possibly different) tuple stream as output. The return clause takes a tuple stream as input and, for each tuple in this tuple stream, generates an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90">; the final result of the FLWOR expression is the ordered concatenation of these </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instances</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The initial clause in a FLWOR expression may be a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. Intermediate clauses may be </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses. These intermediate clauses may be repeated as many times as desired, in any order. The final clause of the FLWOR expression must be a </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. The semantics of the various clauses are described in the following sections.</span></p></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-binding-rules"></a><span class="deltaxml-new" style="background:#90EE90">4.13.1 Variable Bindings</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The following clauses in FLWOR expressions bind values to variables: </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90">. The binding of variables for </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90"> is governed by the following rules (the binding of variables in </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> is discussed in </span><a href="#id-group-by"><b><span class="deltaxml-new" style="background:#90EE90">4.13.8 Group By Clause</span></b></a><span class="deltaxml-new" style="background:#90EE90">, the binding of variables in </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses is discussed in </span><a href="#id-windows"><b><span class="deltaxml-new" style="background:#90EE90">4.13.4 Window Clause</span></b></a><span class="deltaxml-new" style="background:#90EE90">):</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The scope of a bound variable includes all subexpressions of the containing FLWOR that appear after the variable binding. The scope does not include the expression to which the variable is bound. The following code fragment, containing two </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses, illustrates how variable bindings may reference variables that were bound in earlier clauses, or in earlier bindings in the same clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := 47, $y := f($x)
let $z := g($x, $y)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">A given variable name may be bound more than once in a FLWOR expression, or even within one clause of a FLWOR expression. In such a case, each new binding occludes the previous one, which becomes inaccessible in the remainder of the FLWOR expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, it is valid to write:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := 0, $x := $x*2, $x := $x + 1</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">This binds three separate variables, each of which happens to have the same name. It should not be construed as binding a series of different values to the same variable.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-type-declaration" title="type declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A variable binding may be accompanied by a </span><b><span class="deltaxml-new" style="background:#90EE90">type declaration</span></b><span class="deltaxml-new" style="background:#90EE90">, which consists of the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the static type of the variable, declared using the syntax in </span><a href="#id-sequencetype-syntax"><b><span class="deltaxml-new" style="background:#90EE90">3.1 Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.] The type declaration defines a required type for the value. At run-time, the supplied value for the variable is converted to the required type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. If conversion is not possible, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">]. For example, the following </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> because the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$salary</span></code><span class="deltaxml-new" style="background:#90EE90"> has a type declaration that is not satisfied by the value that is bound to it:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $salary as xs:decimal :=  "cat"</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The following </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, however, succeeds, because the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90"> allow an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> to be supplied where an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> is required:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $temperature as xs:double := 32.5</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">In applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> does not apply.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-binding-collection" title="binding collection"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, when an expression is preceded by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90">, the value of that expression is called a </span><b><span class="deltaxml-new" style="background:#90EE90">binding collection</span></b><span class="deltaxml-new" style="background:#90EE90">.] The collection may be either a sequence, an array, or a map. The </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause iterates over its binding collection, producing multiple bindings for one or more variables. Details on how binding collections are used in </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses are described in the following sections.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-binding-sequence" title="binding sequence"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, when an expression is preceded by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90">, the value of that expression is called a </span><b><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></b><span class="deltaxml-new" style="background:#90EE90">.] The </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause iterates over its binding sequence, producing multiple bindings for one or more variables. Details on how binding sequences are used in </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses are described in the following sections.</span></p></li></ol></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-xquery-for-clause"></a><span class="deltaxml-new" style="background:#90EE90">4.13.2 For Clause</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-xquery-let-clause"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-general-comparisons"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for member</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is added to FLWOR expressions to allow iteration over an array. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/49"><span class="deltaxml-new" style="background:#90EE90">49</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/344"><span class="deltaxml-new" style="background:#90EE90">344</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;10 February 2023]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for key/value</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is added to FLWOR expressions to allow iteration over a map. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/31"><span class="deltaxml-new" style="background:#90EE90">31</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1249"><span class="deltaxml-new" style="background:#90EE90">1249</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;1 June 2024]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The value bound to a variable in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is now converted to the declared type by applying the coercion rules. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/189"><span class="deltaxml-new" style="background:#90EE90">189</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/820"><span class="deltaxml-new" style="background:#90EE90">820</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;8 November 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25369.doc-xpath40-ForClause" id="noid_d4e25369.doc-xpath40-ForClause"></a><span class="deltaxml-new" style="background:#90EE90">[54]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"for" </span><a href="#doc-xpath40-ForBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-ForBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25370.doc-xpath40-ForBinding" id="noid_d4e25370.doc-xpath40-ForBinding"></a><span class="deltaxml-new" style="background:#90EE90">[55]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForItemBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForMemberBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForEntryBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25371.doc-xpath40-ForItemBinding" id="noid_d4e25371.doc-xpath40-ForItemBinding"></a><span class="deltaxml-new" style="background:#90EE90">[56]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForItemBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-AllowingEmpty" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AllowingEmpty</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-PositionalVar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25372.doc-xpath40-ForMemberBinding" id="noid_d4e25372.doc-xpath40-ForMemberBinding"></a><span class="deltaxml-new" style="background:#90EE90">[57]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForMemberBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"member" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-PositionalVar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25373.doc-xpath40-ForEntryBinding" id="noid_d4e25373.doc-xpath40-ForEntryBinding"></a><span class="deltaxml-new" style="background:#90EE90">[59]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForEntryBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#doc-xpath40-ForEntryKeyBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForEntryKeyBinding</span></a><a href="#doc-xpath40-ForEntryValueBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">?) | </span><a href="#doc-xpath40-ForEntryValueBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-PositionalVar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25374.doc-xpath40-ForEntryKeyBinding" id="noid_d4e25374.doc-xpath40-ForEntryKeyBinding"></a><span class="deltaxml-new" style="background:#90EE90">[60]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForEntryKeyBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForEntryKeyBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"key" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25375.doc-xpath40-ForEntryValueBinding" id="noid_d4e25375.doc-xpath40-ForEntryValueBinding"></a><span class="deltaxml-new" style="background:#90EE90">[61]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForEntryValueBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"value" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25376.doc-xpath40-TypeDeclaration" id="noid_d4e25376.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25377.doc-xpath40-AllowingEmpty" id="noid_d4e25377.doc-xpath40-AllowingEmpty"></a><span class="deltaxml-new" style="background:#90EE90">[58]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AllowingEmpty" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AllowingEmpty</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"allowing" "empty"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25378.doc-xpath40-PositionalVar" id="noid_d4e25378.doc-xpath40-PositionalVar"></a><span class="deltaxml-new" style="background:#90EE90">[62]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalVar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"at" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is used for iteration. Each variable in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause iterates over a sequence, an array, or a map.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The expression following the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated; we refer to the resulting sequence, array, or map generically as the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, and to its items, members, or entries as the </span><code><span class="deltaxml-new" style="background:#90EE90">components</span></code><span class="deltaxml-new" style="background:#90EE90"> of the collection.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">When a </span><a href="#doc-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> is used (that is, when none of the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> is used), the range variable is bound in turn to each item in the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, which is treated as a sequence of items.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When a </span><a href="#doc-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> is used (that is, when the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90"> is used), the range variable is bound in turn to each member of the array.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In this case the corresponding </span><code><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></code><span class="deltaxml-new" style="background:#90EE90"> must evaluate to a single array, otherwise a type error is raised [</span><a href="#ERRXPTY0141" title="err:XPTY0141"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0141</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When a </span><a href="#doc-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> is used (that is, when either or both of the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> are used), the </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> range variable (if present) is bound in turn to each key in the map (in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> order), and the </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> range variable (if present) is bound to the corresponding value.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In this case the corresponding </span><code><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></code><span class="deltaxml-new" style="background:#90EE90"> must evaluate to a single map, otherwise a type error is raised [</span><a href="#ERRXPTY0141" title="err:XPTY0141"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0141</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">If both the </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> variables are declared, their </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> must be distinct [</span><a href="#ERRXQST0089" title="err:XQST0089"><span class="deltaxml-new" style="background:#90EE90">err:XQST0089</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">If a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause contains multiple bindings separated by commas it is semantically equivalent to multiple </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses, each containing one of the bindings in the original </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The clause</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x in $expr1, $y in $expr2</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">is semantically equivalent to:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x in $expr1
for $y in $expr2</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The clause</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for member $x in $expr1, member $y in $expr2</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">is semantically equivalent to:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for member $x in $expr1
for member $y in $expr2</span></pre></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In the remainder of this section, we define the semantics of a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause containing a single variable and an associated expression (following the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90">) whose value is the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> for that variable.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is the initial clause in a FLWOR expression, it iterates over its </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, binding the variable(s) to each component in turn. The resulting sequence of variable bindings becomes the initial tuple stream that serves as input to the next clause of the FLWOR expression. The order of tuples in the tuple stream preserves the order of the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> is empty, the output tuple stream depends on whether </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified. If </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, the output tuple stream consists of one tuple in which the variable is bound to an empty sequence. This option is not available when the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> are used. If </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is not specified, the output tuple stream consists of zero tuples.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrates tuple streams that are generated by initial </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x in (100, 200, 300)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">or (equivalently):</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x allowing empty in (100, 200, 300)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 100)
($x = 200)
($x = 300)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x in ()</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream contains no tuples.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x allowing empty in ()</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = ())</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for member $x in [ 1, 2, (5 to 10) ]</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = (1))
($x = (2))
($x = (5, 6, 7, 8, 9, 10)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for member $x in []</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream contains no tuples.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for key $k value $v in map{'x':1, 'y':2}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($k = 'x', $v = 1)
($k = 'y', $v = 2)</span></pre></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-positional-variable" title="positional variable"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">positional variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is a variable that is preceded by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><span class="deltaxml-new" style="background:#90EE90">.] A positional variable may be associated with the range variable(s) that are bound in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. In this case, as the main range variable(s) iterate over the components of its </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, the positional variable iterates over the integers that represent the ordinal numbers of these component in the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, starting with one. Each tuple in the output tuple stream contains bindings for both the main variable and the positional variable. If the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> is empty and </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, the positional variable in the output tuple is bound to the integer zero. Positional variables have the implied type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> of a positional variable must be distinct from the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> of the main variable with which it is associated [</span><a href="#ERRXQST0089" title="err:XQST0089"><span class="deltaxml-new" style="background:#90EE90">err:XQST0089</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate how a positional variable would have affected the results of the previous examples that generated tuples:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x at $i in (100, 200, 300)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 100, $i = 1)
($x = 200, $i = 2)
($x = 300, $i = 3)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x at $i in [1 to 3, 11 to 13, 21 to 23</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = (1, 2, 3), $i = 1)
($x = (11, 12, 13), $i = 2)
($x = (21, 22, 23), $i = 3)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Initial clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x allowing empty at $i in ()</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = (), $i = 0)</span></pre></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">If a single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is an intermediate clause in a FLWOR expression, its </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> is evaluated for each input tuple, given the bindings in that input tuple. Each input tuple generates zero or more tuples in the output tuple stream. Each of these output tuples consists of the original variable bindings of the input tuple plus a binding of the new variable to one of the items in its </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collecction</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Although the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> is conceptually evaluated independently for each input tuple, an optimized implementation may sometimes be able to avoid re-evaluating the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> if it can show that the variables that the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> depends on have the same values as in a previous evaluation.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">For a given input tuple, if the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> for the new variable in the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause </span><span><span class="deltaxml-new" style="background:#90EE90">is empty (that is, it is an empty sequence or an empty array depending on whether </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified)</span></span><span class="deltaxml-new" style="background:#90EE90">, and if </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> option is available only when processing sequences, not when processing arrays or maps. The effect is that if the binding collection is an empty sequence, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to an empty sequence.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If a type declaration is present and </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, the type declaration should include an occurrence indicator of </span><code><span class="deltaxml-new" style="background:#90EE90">"?"</span></code><span class="deltaxml-new" style="background:#90EE90"> to indicate that the variable may be bound to an empty sequence.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">If the new variable introduced by a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause has an associated </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90">, the output tuples generated by the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause also contain bindings for the </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90">. In this case, as the new variable is bound to each item in its </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90"> is bound to the ordinal position of that item within the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, starting with one. Note that, since the </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90"> represents a position within a </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, the output tuples corresponding to each input tuple are independently numbered, starting with one. For a given input tuple, if the </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> is empty and </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, the </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90"> in the output tuple is bound to the integer zero.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The tuples in the output tuple stream are ordered primarily by the order of the input tuples from which they are derived, and secondarily by the order of the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> for the new variable; otherwise the order of the output tuple stream is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrates the effects of intermediate </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Input tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1)
($x = 2)
($x = 3)
($x = 4)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Intermediate </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $y in ($x to 3)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In this example, there is no output tuple that corresponds to the input tuple </span><code><span class="deltaxml-new" style="background:#90EE90">($x = 4)</span></code><span class="deltaxml-new" style="background:#90EE90"> because, when the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is evaluated with the bindings in this input tuple, the resulting </span><a title="binding collection" class="termref" href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> for </span><code><span class="deltaxml-new" style="background:#90EE90">$y</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example shows how the previous example would have been affected by a </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90"> (assuming the same input tuple stream):</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $y at $j in ($x to 3)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example shows how the previous example would have been affected by </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90">. Note that </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> causes the input tuple </span><code><span class="deltaxml-new" style="background:#90EE90">($x = 4)</span></code><span class="deltaxml-new" style="background:#90EE90"> to be represented in the output tuple stream, even though the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> for </span><code><span class="deltaxml-new" style="background:#90EE90">$y</span></code><span class="deltaxml-new" style="background:#90EE90"> contains no items for this input tuple. This example illustrates that </span><code><span class="deltaxml-new" style="background:#90EE90">allowing empty</span></code><span class="deltaxml-new" style="background:#90EE90"> in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause serves a purpose similar to that of an “outer join” in a relational database query. (Assume the same input tuple stream as in the previous example.)</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $y allowing empty at $j in ($x to 3)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
($x = 4, $y = (), $j = 0)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates processing of arrays:</span></p><p><span class="deltaxml-new" style="background:#90EE90">Input tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1)
($x = 2)
($x = 3)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Intermediate </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for member $y in [[$x+1, $x+2], [[$x+3, $x+4]]</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1, $y = [ 2, 3 ])
($x = 1, $y = [ 4, 5 ])
($x = 2, $y = [ 3, 4 ])
($x = 2, $y = [ 5, 6 ])
($x = 3, $y = [ 4, 5 ])
($x = 3, $y = [ 6, 7 ])</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example shows how a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause that binds two variables is semantically equivalent to two </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses that bind one variable each. We assume that this </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause occurs at the beginning of a FLWOR expression. It is equivalent to an initial single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause that provides an input tuple stream to an intermediate single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x in (1, 2, 3, 4), $y in ($x to 3)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)</span></pre></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause may contain one or more </span><a title="type declaration" class="termref" href="#dt-type-declaration"><span class="deltaxml-new" style="background:#90EE90">type declarations</span></a><span class="deltaxml-new" style="background:#90EE90">, identified by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><span class="deltaxml-new" style="background:#90EE90">. The semantics of </span><a title="type declaration" class="termref" href="#dt-type-declaration"><span class="deltaxml-new" style="background:#90EE90">type declarations</span></a><span class="deltaxml-new" style="background:#90EE90"> are defined in </span><a href="#id-binding-rules"><b><span class="deltaxml-new" style="background:#90EE90">4.13.1 Variable Bindings</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-xquery-let-clause"></a><span class="deltaxml-new" style="background:#90EE90">4.13.3 Let Clause</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-windows"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-xquery-for-clause"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The value bound to a variable in a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is now converted to the declared type by applying the coercion rules. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/189"><span class="deltaxml-new" style="background:#90EE90">189</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/254"><span class="deltaxml-new" style="background:#90EE90">254</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;29 November 2022]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25898.doc-xpath40-LetClause" id="noid_d4e25898.doc-xpath40-LetClause"></a><span class="deltaxml-new" style="background:#90EE90">[63]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"let" </span><a href="#doc-xpath40-LetBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-LetBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25899.doc-xpath40-LetBinding" id="noid_d4e25899.doc-xpath40-LetBinding"></a><span class="deltaxml-new" style="background:#90EE90">[64]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetBinding" class="xquery"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ":=" </span><a href="#doc-xpath40-StandaloneExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e25900.doc-xpath40-TypeDeclaration" id="noid_d4e25900.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The purpose of a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is to bind values to one or more variables. Each variable is bound to the result of evaluating an expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause contains multiple variables, it is semantically equivalent to multiple </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses, each containing a single variable. For example, the clause</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := $expr1, $y := $expr2</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">is semantically equivalent to the following sequence of clauses:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := $expr1
let $y := $expr2</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">In the remainder of this section, we define the semantics of a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause containing a single variable </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> and an associated expression </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is the initial clause in a FLWOR expression, it simply binds the variable </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> to the result of the expression </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90">. The result of the </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is a tuple stream consisting of one tuple with a single binding that binds </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> to the result of </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90">. This tuple stream serves as input to the next clause in the FLWOR expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is an intermediate clause in a FLWOR expression, it adds a new binding for variable </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> to each tuple in the input tuple stream. For each input tuple, the value bound to </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> is the result of evaluating expression </span><em><span class="deltaxml-new" style="background:#90EE90">E</span></em><span class="deltaxml-new" style="background:#90EE90">, given the bindings that are already present in that input tuple. The resulting tuples become the output tuple stream of the </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The number of tuples in the output tuple stream of an intermediate </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is the same as the number of tuples in the input tuple stream. The number of bindings in the output tuples is one more than the number of bindings in the input tuples, unless the input tuples already contain bindings for </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90">; in this case, the new binding for </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> occludes (replaces) the earlier binding for </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90">, and the number of bindings is unchanged.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause may contain one or more </span><a title="type declaration" class="termref" href="#dt-type-declaration"><span class="deltaxml-new" style="background:#90EE90">type declarations</span></a><span class="deltaxml-new" style="background:#90EE90">, identified by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><span class="deltaxml-new" style="background:#90EE90">. The semantics of type declarations are defined in </span><a href="#id-binding-rules"><b><span class="deltaxml-new" style="background:#90EE90">4.13.1 Variable Bindings</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following code fragment illustrates how a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause and a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause can be used together. The </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause produces an initial tuple stream containing a binding for variable </span><code><span class="deltaxml-new" style="background:#90EE90">$d</span></code><span class="deltaxml-new" style="background:#90EE90"> to each department number found in a given input document. The </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause adds an additional binding to each tuple, binding variable </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> to a sequence of employees whose department number matches the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$d</span></code><span class="deltaxml-new" style="background:#90EE90"> in that tuple.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $d in doc("depts.xml")/depts/deptno
let $e := doc("emps.xml")/emps/emp[deptno eq $d]</span></pre></div></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-windows"></a><span class="deltaxml-new" style="background:#90EE90">4.13.4 Window Clause</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-while"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-xquery-let-clause"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in window expressions has become optional, as well as the </span><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword and its associated expression. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/452"><span class="deltaxml-new" style="background:#90EE90">452</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/483"><span class="deltaxml-new" style="background:#90EE90">483</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;18 May 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26023.doc-xpath40-WindowClause" id="noid_d4e26023.doc-xpath40-WindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[65]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"for" (</span><a href="#doc-xpath40-TumblingWindowClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TumblingWindowClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-SlidingWindowClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SlidingWindowClause</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26024.doc-xpath40-TumblingWindowClause" id="noid_d4e26024.doc-xpath40-TumblingWindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[66]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TumblingWindowClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TumblingWindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"tumbling" "window" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#doc-xpath40-WindowStartCondition" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-WindowEndCondition" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26025.doc-xpath40-SlidingWindowClause" id="noid_d4e26025.doc-xpath40-SlidingWindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[67]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SlidingWindowClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SlidingWindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"sliding" "window" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#doc-xpath40-WindowStartCondition" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-WindowEndCondition" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26026.doc-xpath40-WindowStartCondition" id="noid_d4e26026.doc-xpath40-WindowStartCondition"></a><span class="deltaxml-new" style="background:#90EE90">[68]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowStartCondition" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"start" </span><a href="#doc-xpath40-WindowVars" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a><span class="deltaxml-new" style="background:#90EE90"> ("when" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26027.doc-xpath40-WindowEndCondition" id="noid_d4e26027.doc-xpath40-WindowEndCondition"></a><span class="deltaxml-new" style="background:#90EE90">[69]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowEndCondition" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"only"? "end" </span><a href="#doc-xpath40-WindowVars" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a><span class="deltaxml-new" style="background:#90EE90"> ("when" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26028.doc-xpath40-WindowVars" id="noid_d4e26028.doc-xpath40-WindowVars"></a><span class="deltaxml-new" style="background:#90EE90">[70]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WindowVars" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("$" </span><a href="#doc-xpath40-CurrentItem" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CurrentItem</span></a><span class="deltaxml-new" style="background:#90EE90">)? </span><a href="#doc-xpath40-PositionalVar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? ("previous" "$" </span><a href="#doc-xpath40-PreviousItem" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PreviousItem</span></a><span class="deltaxml-new" style="background:#90EE90">)? ("next" "$" </span><a href="#doc-xpath40-NextItem" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NextItem</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26029.doc-xpath40-CurrentItem" id="noid_d4e26029.doc-xpath40-CurrentItem"></a><span class="deltaxml-new" style="background:#90EE90">[71]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CurrentItem" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CurrentItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26030.doc-xpath40-PositionalVar" id="noid_d4e26030.doc-xpath40-PositionalVar"></a><span class="deltaxml-new" style="background:#90EE90">[62]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalVar" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"at" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26031.doc-xpath40-PreviousItem" id="noid_d4e26031.doc-xpath40-PreviousItem"></a><span class="deltaxml-new" style="background:#90EE90">[72]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PreviousItem" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PreviousItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26032.doc-xpath40-NextItem" id="noid_d4e26032.doc-xpath40-NextItem"></a><span class="deltaxml-new" style="background:#90EE90">[73]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NextItem" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NextItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Like a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause iterates over its </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> and generates a sequence of tuples. In the case of a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, each tuple represents a window. [</span><a id="dt-window" title="window"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">window</span></b><span class="deltaxml-new" style="background:#90EE90"> is a sequence of consecutive items drawn from the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">.] Each window is represented by at least one and at most nine bound variables. The variables have user-specified names, but their roles are as follows:</span></p><ul><li><p><em><span class="deltaxml-new" style="background:#90EE90">Window-variable:</span></em><span class="deltaxml-new" style="background:#90EE90"> Bound to the sequence of items from the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that comprise the window.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Start-item:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the first item in the window.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Start-item-position:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the ordinal position of the first window item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><em><span class="deltaxml-new" style="background:#90EE90">Start-item-position</span></em><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90">; hence, its type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Start-previous-item:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that precedes the first item in the window (empty sequence if none).</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Start-next-item:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that follows the first item in the window (empty sequence if none).</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">End-item:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the last item in the window.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">End-item-position:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the ordinal position of the last window item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><em><span class="deltaxml-new" style="background:#90EE90">End-item-position</span></em><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90">; hence, its type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">End-previous-item:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that precedes the last item in the window (empty sequence if none).</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">End-next-item:</span></em><span class="deltaxml-new" style="background:#90EE90"> (Optional) Bound to the item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that follows the last item in the window (empty sequence if none).</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">All variables in a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause must have distinct names; otherwise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0103" title="err:XQST0103"><span class="deltaxml-new" style="background:#90EE90">err:XQST0103</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following is an example of a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause that binds nine variables to the roles listed above. In this example, the variables are named </span><code><span class="deltaxml-new" style="background:#90EE90">$w</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$s</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$spos</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$sprev</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$snext</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$epos</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$eprev</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">$enext</span></code><span class="deltaxml-new" style="background:#90EE90"> respectively. A </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause always binds the window variable, but typically binds only a subset of the other variables.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10)
  start $s at $spos previous $sprev next $snext when true() 
  end   $e at $epos previous $eprev next $enext when true()</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Windows are created by iterating over the items in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">, in order, identifying the start item and the end item of each window by evaluating the </span><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> and the </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90">. Each of these conditions is satisfied if the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the expression following the </span><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">. The start item of the window is an item that satisfies the </span><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-tumbling-windows"><b><span class="deltaxml-new" style="background:#90EE90">4.13.4.1 Tumbling Windows</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-sliding-windows"><b><span class="deltaxml-new" style="background:#90EE90">4.13.4.2 Sliding Windows</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for a more complete explanation.) The end item of the window is the first item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">, beginning with the start item, that satisfies the </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> (again, see </span><a href="#id-tumbling-windows"><b><span class="deltaxml-new" style="background:#90EE90">4.13.4.1 Tumbling Windows</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-sliding-windows"><b><span class="deltaxml-new" style="background:#90EE90">4.13.4.2 Sliding Windows</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for more details.) Each window contains its start item, its end item, and all items that occur between them in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">. If the end item is the start item, then the window contains only one item. If a start item is identified, but no following item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> satisfies the </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90">, then the </span><code><span class="deltaxml-new" style="background:#90EE90">only</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword determines whether a window is generated: if </span><code><span class="deltaxml-new" style="background:#90EE90">only end</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, then no window is generated; otherwise, the end item is set to the last item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> and a window is generated.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the above example, the </span><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> are both </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, which causes each item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> to be in a separate window. Typically, the </span><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> are expressed in terms of bound variables. For example, the following </span><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> might be used to start a new window for every item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that is larger than both the previous item and the following item:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">start $s previous $sprev next $snext
 when $s &gt; $sprev and $s &gt; $snext</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The scoping rules for the variables bound by a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause are as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">In the </span><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><span class="deltaxml-new" style="background:#90EE90">-expression of the </span><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90">, the following variables (identified here by their roles) are in scope (if bound): </span><em><span class="deltaxml-new" style="background:#90EE90">start-item, start-item-position, start-previous-item, start-next-item.</span></em></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In the </span><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><span class="deltaxml-new" style="background:#90EE90">-expression of the </span><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90">, the following variables (identified here by their roles) are in scope (if bound): </span><em><span class="deltaxml-new" style="background:#90EE90">start-item, start-item-position, start-previous-item, start-next-item, end-item, end-item-position, end-previous-item, end-next-item.</span></em></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In the clauses of the FLWOR expression that follow the </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, all nine of the variables bound by the </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause (including </span><em><span class="deltaxml-new" style="background:#90EE90">window-variable</span></em><span class="deltaxml-new" style="background:#90EE90">) are in scope (if bound).</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword of a condition and the associated expression is optional. If omitted, the expression defaults to </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. If the complete </span><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is omitted, no variables are bound and the expression also defaults to </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><span class="deltaxml-new" style="background:#90EE90"> clause can be omitted only within a </span><a href="#doc-xpath40-TumblingWindowClause"><span class="deltaxml-new" style="background:#90EE90">TumblingWindowClause</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">tumbling</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">sliding</span></code><span class="deltaxml-new" style="background:#90EE90"> determines the way in which the starting item of each window is identified, as explained in the following sections.</span></p><div class="div4"><h5><a id="id-tumbling-windows"></a><span class="deltaxml-new" style="background:#90EE90">4.13.4.1 Tumbling Windows</span></h5><p><span class="deltaxml-new" style="background:#90EE90">If the window type is </span><code><span class="deltaxml-new" style="background:#90EE90">tumbling</span></code><span class="deltaxml-new" style="background:#90EE90">, then windows never overlap. The search for the start of the first window begins at the beginning of the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">. After each window is generated, the search for the start of the next window begins with the item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that occurs after the ending item of the last generated window. Thus, no item that occurs in one window can occur in another window drawn from the same </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> (unless the sequence contains the same item more than once). In a tumbling window clause, the </span><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is optional; if it is omitted, the </span><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is applied to identify all potential starting items in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">, and a window is constructed for each starting item, including all items from that starting item up to the item before the next window’s starting item, or the end of the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">, whichever comes first.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate the use of tumbling windows.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Show non-overlapping windows of three items.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show averages of non-overlapping three-item windows.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return avg($w)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">4 10</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show first and last items in each window of three items.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start $first at $s
  only end $last at $e when $e - $s eq 2
return &lt;window&gt;{ $first, $last }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 6&lt;/window&gt;
&lt;window&gt;8 12&lt;/window&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show non-overlapping windows of up to three items (illustrates </span><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><span class="deltaxml-new" style="background:#90EE90"> clause without the </span><code><span class="deltaxml-new" style="background:#90EE90">only</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword).</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show non-overlapping windows of up to three items (illustrates use of </span><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><span class="deltaxml-new" style="background:#90EE90"> without explicit </span><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s when $s mod 3 = 1
return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show non-overlapping sequences starting with a number divisible by 3.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start $first when $first mod 3 = 2
return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show non-overlapping sequences ending with a number divisible by 3.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  end $last when $last mod 3 = 0
return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result (identical to the result of the previous query):</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</span></pre></div></li></ul></div><div class="div4"><h5><a id="id-sliding-windows"></a><span class="deltaxml-new" style="background:#90EE90">4.13.4.2 Sliding Windows</span></h5><p><span class="deltaxml-new" style="background:#90EE90">If the window type is </span><code><span class="deltaxml-new" style="background:#90EE90">sliding window</span></code><span class="deltaxml-new" style="background:#90EE90">, then windows may overlap. Every item in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> that satisfies the </span><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90"> is the starting item of a new window. Thus, a given item may be found in multiple windows drawn from the same </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate the use of sliding windows.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Show windows of three items.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;4 6 8&lt;/window&gt;
&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;10 12 14&lt;/window&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show moving averages of three items.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return avg($w)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">4 6 8 10 12</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Show overlapping windows of up to three items (illustrates </span><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><span class="deltaxml-new" style="background:#90EE90"> clause without the </span><code><span class="deltaxml-new" style="background:#90EE90">only</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword).</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  end at $e when $e - $s eq 2
return &lt;window&gt;{ $w }&lt;/window&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;window&gt;2 4 6&lt;/window&gt;
&lt;window&gt;4 6 8&lt;/window&gt;
&lt;window&gt;6 8 10&lt;/window&gt;
&lt;window&gt;8 10 12&lt;/window&gt;
&lt;window&gt;10 12 14&lt;/window&gt;
&lt;window&gt;12 14&lt;/window&gt;
&lt;window&gt;14&lt;/window&gt;</span></pre></div></li></ul></div><div class="div4"><h5><a id="id-effects-of-window-clauses"></a><span class="deltaxml-new" style="background:#90EE90">4.13.4.3 Effects of Window Clauses on the Tuple Stream</span></h5><p><span class="deltaxml-new" style="background:#90EE90">The effects of a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause on the tuple stream are similar to the effects of a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. As described in </span><a href="#id-windows"><b><span class="deltaxml-new" style="background:#90EE90">4.13.4 Window Clause</span></b></a><span class="deltaxml-new" style="background:#90EE90">, a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause generates zero or more windows, each of which is represented by at least one and at most nine bound variables.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is the initial clause in a FLWOR expression, the bound variables that describe each window become an output tuple. These tuples form the initial tuple stream that serves as input to the next clause of the FLWOR expression. The order of tuples in the tuple stream is the order in which their start items appear in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">. The cardinality of the tuple stream is equal to the number of windows.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is an intermediate clause in a FLWOR expression, each input tuple generates zero or more output tuples, each consisting of the original bound variables of the input tuple plus the new bound variables that represent one of the generated windows. For each tuple </span><em><span class="deltaxml-new" style="background:#90EE90">T</span></em><span class="deltaxml-new" style="background:#90EE90"> in the input tuple stream, the output tuple stream will contain </span><em><span class="deltaxml-new" style="background:#90EE90">N</span><sub><span class="deltaxml-new" style="background:#90EE90">T</span></sub></em><span class="deltaxml-new" style="background:#90EE90"> tuples, where </span><em><span class="deltaxml-new" style="background:#90EE90">N</span><sub><span class="deltaxml-new" style="background:#90EE90">T</span></sub></em><span class="deltaxml-new" style="background:#90EE90"> is the number of windows generated by the </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, given the bindings in the input tuple </span><em><span class="deltaxml-new" style="background:#90EE90">T</span></em><span class="deltaxml-new" style="background:#90EE90">. Input tuples for which no windows are generated are not represented in the output tuple stream. The order of tuples in the output stream is determined primarily by the order of the input tuples from which they were derived, and secondarily by the order in which their start items appear in the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause that is the initial clause in a FLWOR expression. The example is based on input data that consists of a sequence of closing stock prices for a specific company. For this example we assume the following input data (assume that the </span><code><span class="deltaxml-new" style="background:#90EE90">price</span></code><span class="deltaxml-new" style="background:#90EE90"> elements have a validated type of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">):</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;stock&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing&gt;
&lt;/stock&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">A user wishes to find “run-ups,” which are defined as sequences of dates that begin with a “low” and end with a “high” price (that is, the stock price begins to rise on the first day of the run-up, and continues to rise or remain even through the last day of the run-up.) The following query uses a tumbling window to find run-ups in the input data:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for tumbling window $w in //closing
   start $first next $second when $first/price &lt; $second/price
   end $last next $beyond when $last/price &gt; $beyond/price
return
  &lt;run-up&gt;
    &lt;start-date&gt;{ data($first/date) }&lt;/start-date&gt;
    &lt;start-price&gt;{ data($first/price) }&lt;/start-price&gt;
    &lt;end-date&gt;{ data($last/date) }&lt;/end-date&gt;
    &lt;end-price&gt;{ data($last/price) }&lt;/end-price&gt;
  &lt;/run-up&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">For our sample input data, this </span><code><span class="deltaxml-new" style="background:#90EE90">tumbling window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause generates a tuple stream consisting of two tuples, each representing a window and containing five bound variables named </span><code><span class="deltaxml-new" style="background:#90EE90">$w</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$first</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$second</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$last</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">$beyond</span></code><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is evaluated for each of these tuples, generating the following query result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;run-up&gt;
  &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
  &lt;start-price&gt;101&lt;/start-price&gt;
  &lt;end-date&gt;2008-01-04&lt;/end-date&gt;
  &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up&gt;
  &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
  &lt;start-price&gt;102&lt;/start-price&gt;
  &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
  &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause that is an intermediate clause in a FLWOR expression. In this example, the input data contains closing stock prices for several different companies, each identified by a three-letter symbol. We assume the following input data (again assuming that the type of the </span><code><span class="deltaxml-new" style="background:#90EE90">price</span></code><span class="deltaxml-new" style="background:#90EE90"> element is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">):</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;stocks&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;105&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-01&lt;/date&gt; &lt;price&gt;057&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-02&lt;/date&gt; &lt;price&gt;054&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;102&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-03&lt;/date&gt; &lt;price&gt;056&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;103&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-04&lt;/date&gt; &lt;price&gt;052&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;101&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-05&lt;/date&gt; &lt;price&gt;055&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;ABC&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;104&lt;/price&gt; &lt;/closing&gt;
  &lt;closing&gt; &lt;symbol&gt;DEF&lt;/symbol&gt; &lt;date&gt;2008-01-06&lt;/date&gt; &lt;price&gt;059&lt;/price&gt; &lt;/closing&gt;
&lt;/stocks&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">As in the previous example, we want to find "run-ups," which are defined as sequences of dates that begin with a "low" and end with a "high" price for a specific company. In this example, however, the input data consists of stock prices for multiple companies. Therefore it is necessary to isolate the stock prices of each company before forming windows. This can be accomplished by an initial </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, followed by a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, as follows:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $symbol in distinct-values(//symbol)
let $closings := //closing[symbol = $symbol]
for tumbling window $w in $closings
  start $first next $second when $first/price &lt; $second/price
  end $last next $beyond when $last/price &gt; $beyond/price
return
  &lt;run-up symbol="{ $symbol }"&gt;
    &lt;start-date&gt;{ data($first/date) }&lt;/start-date&gt;
    &lt;start-price&gt;{ data($first/price) }&lt;/start-price&gt;
    &lt;end-date&gt;{ data($last/date) }&lt;/end-date&gt;
    &lt;end-price&gt;{ data($last/price) }&lt;/end-price&gt;
  &lt;/run-up&gt;</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In the above example, the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses could be rewritten as follows:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $closings in //closing
let $symbol := $closings/symbol
group by $symbol</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is described in </span><a href="#id-group-by"><b><span class="deltaxml-new" style="background:#90EE90">4.13.8 Group By Clause</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses in this query generate an initial tuple stream consisting of two tuples. In the first tuple, </span><code><span class="deltaxml-new" style="background:#90EE90">$symbol</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to "ABC" and </span><code><span class="deltaxml-new" style="background:#90EE90">$closings</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the sequence of </span><code><span class="deltaxml-new" style="background:#90EE90">closing</span></code><span class="deltaxml-new" style="background:#90EE90"> elements for company ABC. In the second tuple, </span><code><span class="deltaxml-new" style="background:#90EE90">$symbol</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to "DEF" and </span><code><span class="deltaxml-new" style="background:#90EE90">$closings</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the sequence of </span><code><span class="deltaxml-new" style="background:#90EE90">closing</span></code><span class="deltaxml-new" style="background:#90EE90"> elements for company DEF.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause operates on this initial tuple stream, generating two windows for the first tuple and two windows for the second tuple. The result is a tuple stream consisting of four tuples, each with the following bound variables: </span><code><span class="deltaxml-new" style="background:#90EE90">$symbol</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$closings</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$w</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$first</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$second</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$last</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">$beyond</span></code><span class="deltaxml-new" style="background:#90EE90">. The </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is then evaluated for each of these tuples, generating the following query result:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-04&lt;/end-date&gt;
   &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
   &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;054&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-03&lt;/end-date&gt;
   &lt;end-price&gt;056&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-04&lt;/start-date&gt;
   &lt;start-price&gt;052&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
   &lt;end-price&gt;059&lt;/end-price&gt;
&lt;/run-up&gt;</span></pre></div></div></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-where"></a><span class="deltaxml-new" style="background:#90EE90">4.13.5 Where Clause</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-WhereClause" id="doc-xpath40-WhereClause"></a><span class="deltaxml-new" style="background:#90EE90">[75]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WhereClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WhereClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"where" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause serves as a filter for the tuples in its input tuple stream. The expression in the </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, called the </span><b><span class="deltaxml-new" style="background:#90EE90">where-expression</span></b><span class="deltaxml-new" style="background:#90EE90">, is evaluated once for each of these tuples. If the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the where-expression is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, the tuple is retained in the output tuple stream; otherwise the tuple is discarded.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates the effect of a </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause on a tuple stream:</span></p><p><span class="deltaxml-new" style="background:#90EE90">Input tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($a = 5, $b = 11)
($a = 91, $b = 42)
($a = 17, $b = 30)
($a = 85, $b = 63)</span></pre></div><p><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">where $a &gt; $b</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($a = 91, $b = 42)
($a = 85, $b = 63)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following query illustrates how a </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause might be used with a </span><a title="positional variable" class="termref" href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a><span class="deltaxml-new" style="background:#90EE90"> to perform sampling on an input sequence. The query returns one value out of each one hundred input values.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">                     </span><span class="parse-test"><span class="parse-test"><span class="deltaxml-new" style="background:#90EE90">for $x at $i in $input
where $i mod 100 = 0
return $x</span></span></span></pre></div></div></li></ul></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-while"></a><span class="deltaxml-new" style="background:#90EE90">4.13.6 While Clause</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-for-expressions"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-windows"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> A FLWOR expression may now include a </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, which causes early exit from the iteration when a condition is encountered. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/187"><span class="deltaxml-new" style="background:#90EE90">187</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/943"><span class="deltaxml-new" style="background:#90EE90">943</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;6 February 2024]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-WhileClause" id="doc-xpath40-WhileClause"></a><span class="deltaxml-new" style="background:#90EE90">[76]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-WhileClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">WhileClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"while" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> clause serves as a filter for the tuples in its input tuple stream. The expression in the while clause, called the </span><code><span class="deltaxml-new" style="background:#90EE90">while-expression</span></code><span class="deltaxml-new" style="background:#90EE90">, is evaluated once for each of these tuples. If the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><span class="deltaxml-new" style="background:#90EE90">while-expression</span></code><span class="deltaxml-new" style="background:#90EE90"> is true, the tuple is retained in the output tuple stream; otherwise the tuple and all subsequent tuples in the stream are discarded.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates the effect of a </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> clause on a tuple stream.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Input tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($a = 13, $b = 11)
($a = 91, $b = 42)
($a = 17, $b = 30)
($a = 85, $b = 63)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">while clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">while $a &gt; $b</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90"> Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($a = 13, $b = 11)
($a = 91, $b = 42)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following query illustrates how a </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> clause might be used to extract all items in an input sequence before the first one that fails to satisfy some condition. In this case it selects the leading </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> elements in the input sequence, stopping before the first element that is not a </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element. </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x in $section/*
while $x[self::para]
return $x</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following query illustrates how a </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> clause might be used to limit the number of items returned in the query result. </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $x in $section/para
where contains($x, 'the')
count $total
while $total le 10
return $x</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">In this example a </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause would have exactly the same effect, but might require a smarter optimizer to deliver the same performance.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Although the semantics are described in terms of discarding all the tuples following the first one that fails to match the condition, a practical implementation is likely to avoid evaluating those tuples, thus giving an "early exit" from the iteration performed by the FLWOR expression. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">for $i in $input while $i le 3</span></code><span class="deltaxml-new" style="background:#90EE90"> differs from the expression </span><code><span class="deltaxml-new" style="background:#90EE90">subsequence-where($input, to := fn {. gt 3 })</span></code><span class="deltaxml-new" style="background:#90EE90"> in that the </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> expression drops the first item that is greater than 3, while the </span><code><span class="deltaxml-new" style="background:#90EE90">subsequence-where</span></code><span class="deltaxml-new" style="background:#90EE90"> expression retains it.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The effect of the </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is unpredictable in cases where the ordering of the tuple stream is unpredictable. This can happen, for example, when iterating over the entries in a map.</span></p></div></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-count"></a><span class="deltaxml-new" style="background:#90EE90">4.13.7 Count Clause</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CountClause" id="doc-xpath40-CountClause"></a><span class="deltaxml-new" style="background:#90EE90">[74]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CountClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CountClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"count" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The purpose of a </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is to enhance the tuple stream with a new variable that is bound, in each tuple, to the ordinal position of that tuple in the tuple stream. The name of the new variable is specified in the </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. Its type is implicitly </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The output tuple stream of a </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is the same as its input tuple stream, with each tuple enhanced by one additional variable that is bound to the ordinal position of that tuple in the tuple stream. However, if the name of the new variable is the same as the name of an existing variable in the input tuple stream, the new variable occludes (replaces) the existing variable of the same name, and the number of bound variables in each tuple is unchanged.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate uses of the </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates the effect of a </span><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90"> clause on an input tuple stream:</span></p><p><span class="deltaxml-new" style="background:#90EE90">Input tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($name = "Bob", $age = 21)
($name = "Carol", $age = 19)
($name = "Ted", $age = 20)
($name = "Alice", $age = 22)</span></pre></div><p><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">count $counter</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($name = "Bob", $age = 21, $counter = 1)
($name = "Carol", $age = 19, $counter = 2)
($name = "Ted", $age = 20, $counter = 3)
($name = "Alice", $age = 22, $counter = 4)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates how a counter might be used to filter the result of a query. The query ranks products in order by decreasing sales, and returns the three products with the highest sales. Assume that the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$products</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a sequence of </span><code><span class="deltaxml-new" style="background:#90EE90">product</span></code><span class="deltaxml-new" style="background:#90EE90"> elements, each of which has </span><code><span class="deltaxml-new" style="background:#90EE90">name</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">sales</span></code><span class="deltaxml-new" style="background:#90EE90"> child-elements.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $p in $products
order by $p/sales descending
count $rank
while $rank &lt;= 3
return &lt;product rank="{ $rank }"&gt;{ $p/name, $p/sales }&lt;/product&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this query has the following structure:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;product rank="1"&gt;
  &lt;name&gt;Toaster&lt;/name&gt;
  &lt;sales&gt;968&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="2"&gt;
  &lt;name&gt;Blender&lt;/name&gt;
  &lt;sales&gt;520&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="3"&gt;
  &lt;name&gt;Can Opener&lt;/name&gt;
  &lt;sales&gt;475&lt;/sales&gt;
&lt;/product&gt;</span></pre></div></li></ul></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-group-by"></a><span class="deltaxml-new" style="background:#90EE90">4.13.8 Group By Clause</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26898.doc-xpath40-GroupByClause" id="noid_d4e26898.doc-xpath40-GroupByClause"></a><span class="deltaxml-new" style="background:#90EE90">[77]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GroupByClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">GroupByClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"group" "by" </span><a href="#doc-xpath40-GroupingSpec" class="xquery"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-GroupingSpec" class="xquery"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26899.doc-xpath40-GroupingSpec" id="noid_d4e26899.doc-xpath40-GroupingSpec"></a><span class="deltaxml-new" style="background:#90EE90">[78]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GroupingSpec" class="xquery"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-GroupingVariable" class="xquery"><span class="deltaxml-new" style="background:#90EE90">GroupingVariable</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ":=" </span><a href="#doc-xpath40-StandaloneExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)? ("collation" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e26900.doc-xpath40-GroupingVariable" id="noid_d4e26900.doc-xpath40-GroupingVariable"></a><span class="deltaxml-new" style="background:#90EE90">[79]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GroupingVariable" class="xquery"><span class="deltaxml-new" style="background:#90EE90">GroupingVariable</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause generates an output tuple stream in which each tuple represents a group of tuples from the input tuple stream that have equivalent grouping keys. We will refer to the tuples in the input tuple stream as </span><b><span class="deltaxml-new" style="background:#90EE90">pre-grouping tuples</span></b><span class="deltaxml-new" style="background:#90EE90">, and the tuples in the output tuple stream as </span><b><span class="deltaxml-new" style="background:#90EE90">post-grouping tuples</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause assigns each pre-grouping tuple to a group, and generates one post-grouping tuple for each group. In the post-grouping tuple for a group, each grouping key is represented by a variable that was specified in a </span><a href="#doc-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90">, and every variable that appears in the pre-grouping tuples that were assigned to that group is represented by a variable of the same name, bound to a sequence of all values bound to the variable in any of these pre-grouping tuples. Subsequent clauses in the FLWOR expression see only the variable bindings in the post-grouping tuples; they no longer have access to the variable bindings in the pre-grouping tuples. The number of post-grouping tuples is less than or equal to the number of pre-grouping tuples.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause contains one or more </span><a href="#doc-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">grouping specifications</span></a><span class="deltaxml-new" style="background:#90EE90">, as shown in the grammar. [</span><a id="dt-grouping-variable" title="grouping variable"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Each grouping specification specifies one </span><a href="#doc-xpath40-GroupingVariable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90">, which refers to variable bindings in the pre-grouping tuples. The values of the grouping variables are used to assign pre-grouping tuples to groups.] Each grouping specification may optionally provide an expression to which its grouping variable is bound. If no expression is provided, the grouping variable name must be equal (by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator on </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90">) to the name of a variable in the input tuple stream, and it refers to that variable; otherwise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0094" title="err:XQST0094"><span class="deltaxml-new" style="background:#90EE90">err:XQST0094</span></a><span class="deltaxml-new" style="background:#90EE90">]. For each grouping specification that contains a binding expression, a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> binding is created in the pre-grouping tuples, and the grouping variable refers to that </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> binding. For example, the clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">group by $g1, $g2 := $expr1, $g3 := $expr2 collation "Spanish"</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">is semantically equivalent to the following sequence of clauses:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $g2 := $expr1
let $g3 := $expr2
group by $g1, $g2, $g3 collation "Spanish"</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The process of group formation proceeds as follows: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-grouping-key" title="grouping key"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The atomized value of a </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90"> is called a </span><b><span class="deltaxml-new" style="background:#90EE90">grouping key</span></b><span class="deltaxml-new" style="background:#90EE90">.] For each pre-grouping tuple, the </span><a title="grouping key" class="termref" href="#dt-grouping-key"><span class="deltaxml-new" style="background:#90EE90">grouping keys</span></a><span class="deltaxml-new" style="background:#90EE90"> are created by </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomizing</span></a><span class="deltaxml-new" style="background:#90EE90"> the values of the </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variables</span></a><span class="deltaxml-new" style="background:#90EE90"> (in the post-grouping tuples, each grouping variable is set to the value of the corresponding grouping key, as discussed below). If the value of any </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90"> consists of more than one item, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">]. If a type declaration is present and the resulting atomized value is not an instance of the specified type, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The input tuple stream is partitioned into groups of tuples whose grouping keys are </span><a title="equivalent grouping keys" class="termref" href="#dt-equivalent-grouping-keys"><span class="deltaxml-new" style="background:#90EE90">equivalent</span></a><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-equivalent-grouping-keys" title="equivalent grouping keys"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Two tuples </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> have </span><b><span class="deltaxml-new" style="background:#90EE90">equivalent grouping keys</span></b><span class="deltaxml-new" style="background:#90EE90"> if and only if, for each grouping variable </span><var><span class="deltaxml-new" style="background:#90EE90">GV</span></var><span class="deltaxml-new" style="background:#90EE90">, the atomized value of </span><var><span class="deltaxml-new" style="background:#90EE90">GV</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> is deep-equal to the atomized value of </span><var><span class="deltaxml-new" style="background:#90EE90">GV</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, as defined by applying the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> using the appropriate collation.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> has been changed in XQuery 4.0 and XPath 4.0 so that it is now transitive; the problem that existed in earlier versions when comparing numeric values of different types has thereby been resolved.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The atomized grouping key will always be either an empty sequence or a single atomic item. Defining equivalence by reference to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> function ensures that the empty sequence is equivalent only to the empty sequence, that </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90">, that untypedAtomic items are compared as strings, and that values for which the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator is not defined are considered non-equivalent.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The appropriate collation for comparing two grouping keys is the collation specified in the pertinent </span><a href="#doc-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90"> if present, or the default collation from the </span><span><span class="deltaxml-new" style="background:#90EE90">dynamic</span></span><span class="deltaxml-new" style="background:#90EE90"> context otherwise. If the collation is specified by a relative URI, that relative URI is </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved to an absolute URI</span></a><span class="deltaxml-new" style="background:#90EE90"> using the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">. If the specified collation is not found in statically known collations, a static error is raised [</span><a href="#ERRXQST0076" title="err:XQST0076"><span class="deltaxml-new" style="background:#90EE90">err:XQST0076</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Each group of tuples produced by the above process results in one post-grouping tuple. The pre-grouping tuples from which the group is derived have </span><em><span class="deltaxml-new" style="background:#90EE90">equivalent</span></em><a title="grouping key" class="termref" href="#dt-grouping-key"><span class="deltaxml-new" style="background:#90EE90">grouping keys</span></a><span class="deltaxml-new" style="background:#90EE90">, but these keys are not necessarily identical (for example, the strings </span><code><span class="deltaxml-new" style="background:#90EE90">"Frog"</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">"frog"</span></code><span class="deltaxml-new" style="background:#90EE90"> might be </span><em><span class="deltaxml-new" style="background:#90EE90">equivalent</span></em><span class="deltaxml-new" style="background:#90EE90"> according to the collation in use.) In the post-grouping tuple, each </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90"> is bound to the value of the corresponding grouping key. </span></p><p><span class="deltaxml-new" style="background:#90EE90">In the post-grouping tuple generated for a given group, each non-grouping variable is bound to a sequence containing the concatenated values of that variable in all the pre-grouping tuples that were assigned to that group. The values derived from individual tuples are concatenated in a way that preserves the order of the pre-grouping tuple stream.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This behavior may be surprising to SQL programmers, since SQL reduces the equivalent of a non-grouping variable to one representative value. Consider the following query:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := 64000
for $c in //customer
where $c/salary &gt; $x
group by $d := $c/department
return &lt;department name="{ $d }"&gt;
  Number of employees earning more than ${ $x } is { count($c) }
&lt;/department&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If there are three qualifying customers in the sales department this evaluates to:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;department name="sales"&gt;
  Number of employees earning more than $64000 64000 64000 is 3
&lt;/department&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">In XQuery, each group is a sequence of items that match the group by criteria—in a tree-structured language like XQuery, this is convenient, because further structures can be built based on the items in this sequence. Because there are three items in the group, </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to a sequence of three items. To reduce this to one item, use </span><code><span class="deltaxml-new" style="background:#90EE90">fn:distinct-values()</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := 64000
for $c in //customer
let $d := $c/department
where $c/salary &gt; $x
group by $d
return &lt;department name="{ $d }"&gt;
  Number of employees earning more than ${ distinct-values($x) } is { count($c) }
&lt;/department&gt;</span></pre></div></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In general, the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of a variable in a post-grouping tuple is different from the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the variable with the same name in the pre-grouping tuples.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The order in which tuples appear in the post-grouping tuple stream is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause can be used to impose a value-based ordering on the post-grouping tuple stream. Similarly, if it is desired to impose a value-based ordering within a group (i.e., on the sequence of items bound to a non-grouping variable), this can be accomplished by a nested FLWOR expression that iterates over these items and applies an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. In some cases, a value-based ordering within groups can be accomplished by applying an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause on a non-grouping variable before applying the </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause rebinds all the variables in the input tuple stream. The scopes of these variables are not affected by the </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, but in post-grouping tuples the values of the variables represent group properties rather than properties of individual pre-grouping tuples.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates the effect of a </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause on a tuple stream.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Input tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P78395&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P94738&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P41653&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P70421&lt;/itemno&gt;)</span></pre></div><p><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">group by $storeno</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($storeno = S101, $itemno = (&lt;itemno&gt;P78395&lt;/itemno&gt;, &lt;itemno&gt;P41653&lt;/itemno&gt;))
($storeno = S102, $itemno = (&lt;itemno&gt;P94738&lt;/itemno&gt;, &lt;itemno&gt;P70421&lt;/itemno&gt;))</span></pre></div></li></ul><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example and the ones that follow are based on two separate sequences of elements, named </span><code><span class="deltaxml-new" style="background:#90EE90">$sales</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$products</span></code><span class="deltaxml-new" style="background:#90EE90">. We assume that the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$sales</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a sequence of elements with the following structure:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;sales&gt;
  &lt;storeno&gt;S101&lt;/storeno&gt;
  &lt;itemno&gt;P78395&lt;/itemno&gt;
  &lt;qty&gt;125&lt;/qty&gt;
&lt;/sales&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">We also assume that the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$products</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a sequence of elements with the following structure:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;product&gt;
  &lt;itemno&gt;P78395&lt;/itemno&gt;
  &lt;price&gt;25.00&lt;/price&gt;
  &lt;category&gt;Men's Wear&lt;/category&gt;
&lt;/product&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The simplest kind of grouping query has a single </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90">. The query in this example finds the total quantity of items sold by each store:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $s in $sales
let $storeno := $s/storeno
group by $storeno
return &lt;store number="{ $storeno }" total-qty="{ sum($s/qty) }"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this query is a sequence of elements with the following structure:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;store number="S101" total-qty="1550" /&gt;
&lt;store number="S102" total-qty="2125" /&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">In a more realistic example, a user might be interested in the total revenue generated by each store for each product category. Revenue depends on both the quantity sold of various items and the price of each item. The following query joins the two input sequences and groups the resulting tuples by two </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variables</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $s in $sales
for $p in $products[itemno = $s/itemno]
let $revenue := $s/qty * $p/price
group by $storeno := $s/storeno, 
         $category := $p/category
return &lt;summary storeno="{ $storeno }"
                category="{ $category }"
                revenue="{ sum($revenue) }"/&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this query is a sequence of elements with the following structure:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;summary storeno="S101" category="Men's Wear" revenue="10185"/&gt;
&lt;summary storeno="S101" category="Stationery" revenue="4520"/&gt;
&lt;summary storeno="S102" category="Men's Wear" revenue="9750"/&gt;
&lt;summary storeno="S102" category="Appliances" revenue="22650"/&gt;
&lt;summary storeno="S102" category="Jewelry" revenue="30750"/&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the previous example was a “flat” list of elements. A user might prefer the query result to be presented in the form of a hierarchical report, grouped primarily by store (in order by store number) and secondarily by product category. Within each store, the user might want to see only those product categories whose total revenue exceeds $10,000, presented in descending order by their total revenue. This report is generated by the following query:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $s1 in $sales
let $storeno := $s1/storeno
group by $storeno
order by $storeno
return &lt;store storeno="{ $storeno }"&gt;{
  for $s2 in $s1
  for $p in $products[itemno = $s2/itemno]
  let $category := $p/category
  let $revenue := $s2/qty * $p/price
  group by $category
  let $group-revenue := sum($revenue)
  where $group-revenue &gt; 10000
  order by $group-revenue descending
  return &lt;category name="{ $category }" revenue="{ $group-revenue }"/&gt;
}&lt;/store&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this example query has the following structure:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;store storeno="S101"&gt;
  &lt;category name="Men's Wear" revenue="10185"/&gt;
&lt;/store&gt;
&lt;store storeno="S102"&gt;
  &lt;category name="Jewelry" revenue="30750"/&gt;
  &lt;category name="Appliances" revenue="22650"/&gt;
&lt;/store&gt;</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates how to avoid a possible pitfall in writing grouping queries.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In each post-grouping tuple, all variables except for the grouping variable are bound to sequences of items derived from all the pre-grouping tuples from which the group was formed. For instance, in the following query, </span><code><span class="deltaxml-new" style="background:#90EE90">$high-price</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a sequence of items in the post-grouping tuple.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $high-price := 1000
for $p in $products[price &gt; $high-price]
let $category := $p/category
group by $category
return &lt;category name="{ $category }"&gt;{
  count($p) || ' products have price greater than ' || $high-price || '.'
}&lt;/category&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If three products in the “Men’s Wear” category have prices greater than 1000, the result of this query might look (in part) like this:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;category name="Men’s Wear"&gt;
  3 products have price greater than 1000 1000 1000.
&lt;/category&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The repetition of "1000" in this query result is due to the fact that </span><code><span class="deltaxml-new" style="background:#90EE90">$high-price</span></code><span class="deltaxml-new" style="background:#90EE90"> is not a </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90">. One way to avoid this repetition is to move the binding of </span><code><span class="deltaxml-new" style="background:#90EE90">$high-price</span></code><span class="deltaxml-new" style="background:#90EE90"> to an outer-level FLWOR expression, as follows:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $high-price := 1000
return (
  for $p in $products[price &gt; $high-price]
  let $category := $p/category
  group by $category
  return &lt;category name="{ $category }"&gt;{
    count($p) || ' products have price greater than ' || $high-price || '.'
  }&lt;/category&gt;  
)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of the revised query might contain the following element:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;category name="Men's Wear"&gt;
  3 products have price greater than 1000.
&lt;/category&gt;</span></pre></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If a collation name is specified, it must be supplied as a literal string; it cannot be computed dynamically. A workaround in such cases is to use the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collation-key</span></code><span class="deltaxml-new" style="background:#90EE90"> function. For example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $p in $products
group by collation-key($p/description, $collation)
return $product/@code</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Note however that the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collation-key</span></code><span class="deltaxml-new" style="background:#90EE90"> function might not work for all collations.</span></p></div></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-order-by-clause"></a><span class="deltaxml-new" style="background:#90EE90">4.13.9 Order By Clause</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OrderByClause" id="doc-xpath40-OrderByClause"></a><span class="deltaxml-new" style="background:#90EE90">[80]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderByClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderByClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"stable"? "order" "by" </span><a href="#doc-xpath40-OrderSpec" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-OrderSpec" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27249.doc-xpath40-OrderSpec" id="noid_d4e27249.doc-xpath40-OrderSpec"></a><span class="deltaxml-new" style="background:#90EE90">[81]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderSpec" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#doc-xpath40-OrderModifier" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderModifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27250.doc-xpath40-OrderModifier" id="noid_d4e27250.doc-xpath40-OrderModifier"></a><span class="deltaxml-new" style="background:#90EE90">[82]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderModifier" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderModifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The purpose of an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is to impose a value-based ordering on the tuples in the tuple stream. The output tuple stream of the </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause contains the same tuples as its input tuple stream, but the tuples may be in a different order.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause contains one or more ordering specifications, called </span><a href="#doc-xpath40-OrderSpec"><span class="deltaxml-new" style="background:#90EE90">orderspecs</span></a><span class="deltaxml-new" style="background:#90EE90">, as shown in the grammar. For each tuple in the input tuple stream, the orderspecs are evaluated, using the variable bindings in that tuple. The relative order of two tuples is determined by comparing the values of their orderspecs, working from left to right until a pair of unequal values is encountered. If an orderspec specifies a </span><a title="collation" class="termref" href="#dt-collation"><span class="deltaxml-new" style="background:#90EE90">collation</span></a><span class="deltaxml-new" style="background:#90EE90">, that collation is used in comparing values of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">, or types derived from them (otherwise, the </span><a title="default collation" class="termref" href="#dt-def-collation"><span class="deltaxml-new" style="background:#90EE90">default collation</span></a><span class="deltaxml-new" style="background:#90EE90"> is used in comparing values of these types). If an orderspec specifies a collation by a relative URI, that relative URI is </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved to an absolute URI</span></a><span class="deltaxml-new" style="background:#90EE90"> using the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">. If an orderspec specifies a collation that is not found in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically known collations</span></a><span class="deltaxml-new" style="background:#90EE90">, an error is raised [</span><a href="#ERRXQST0076" title="err:XQST0076"><span class="deltaxml-new" style="background:#90EE90">err:XQST0076</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The process of evaluating and comparing the orderspecs is based on the following rules:</span></p><ul><li><p><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90"> is applied to the result of the expression in each orderspec. If the result of atomization is neither a single atomic item nor an empty sequence, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">For the purpose of determining their relative position in the ordering sequence, the </span><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><span class="deltaxml-new" style="background:#90EE90"> relationship between two orderspec values </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is defined as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">When the orderspec specifies </span><code><span class="deltaxml-new" style="background:#90EE90">empty least</span></code><span class="deltaxml-new" style="background:#90EE90">, the following rules are applied in order: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is an empty sequence and </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> is not an empty sequence, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V </span></var><span class="deltaxml-new" style="background:#90EE90"> is true.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> is neither </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> nor an empty sequence, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is true.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> are both instances of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, they are compared using the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W, C)</span></code><span class="deltaxml-new" style="background:#90EE90"> where </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> is the requested collation, defaulting to the default collation from the static context.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W, C)</span></code><span class="deltaxml-new" style="background:#90EE90"> is less than zero, then </span><em><span class="deltaxml-new" style="background:#90EE90">W</span></em><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> is true; otherwise </span><em><span class="deltaxml-new" style="background:#90EE90">W</span></em><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> is false.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> are both instances of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90">, they are compared using the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W)</span></code><span class="deltaxml-new" style="background:#90EE90"> is less than zero, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is true; otherwise </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is false.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If none of the above rules apply, then:</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">W gt V</span></code><span class="deltaxml-new" style="background:#90EE90"> is true, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is true; otherwise </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is false.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">When the orderspec specifies </span><code><span class="deltaxml-new" style="background:#90EE90">empty greatest</span></code><span class="deltaxml-new" style="background:#90EE90">, the following rules are applied in order: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> is an empty sequence and </span><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> is not an empty sequence, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is true.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is neither </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> nor an empty sequence, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is true.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> are both instances of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, they are compared using the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W, C)</span></code><span class="deltaxml-new" style="background:#90EE90"> where </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> is the requested collation, defaulting to the default collation from the static context.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W, C)</span></code><span class="deltaxml-new" style="background:#90EE90"> is less than zero, then </span><em><span class="deltaxml-new" style="background:#90EE90">W</span></em><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> is true; otherwise </span><em><span class="deltaxml-new" style="background:#90EE90">W</span></em><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><em><span class="deltaxml-new" style="background:#90EE90">V</span></em><span class="deltaxml-new" style="background:#90EE90"> is false.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><span class="deltaxml-new" style="background:#90EE90"> are both instances of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90">, they are compared using the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare(V, W)</span></code><span class="deltaxml-new" style="background:#90EE90"> is less than zero, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is true; otherwise </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is false.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If none of the above rules apply, then:</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">W gt V</span></code><span class="deltaxml-new" style="background:#90EE90"> is true, then </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is true; otherwise </span><var><span class="deltaxml-new" style="background:#90EE90">W</span></var><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is false.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">When the orderspec specifies neither </span><code><span class="deltaxml-new" style="background:#90EE90">empty least</span></code><span class="deltaxml-new" style="background:#90EE90"> nor </span><code><span class="deltaxml-new" style="background:#90EE90">empty greatest</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="default order for empty sequences" class="termref" href="#dt-default-empty-order"><span class="deltaxml-new" style="background:#90EE90">default order for empty sequences</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> determines whether the rules for </span><code><span class="deltaxml-new" style="background:#90EE90">empty least</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">empty greatest</span></code><span class="deltaxml-new" style="background:#90EE90"> are used. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">If </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90"> are two tuples in the input tuple stream, and </span><em><span class="deltaxml-new" style="background:#90EE90">V1</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">V2</span></em><span class="deltaxml-new" style="background:#90EE90"> are the first pair of values encountered when evaluating their orderspecs from left to right for which one value is </span><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><span class="deltaxml-new" style="background:#90EE90"> the other (as defined above), then:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><em><span class="deltaxml-new" style="background:#90EE90">V1</span></em><span class="deltaxml-new" style="background:#90EE90"> is </span><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><em><span class="deltaxml-new" style="background:#90EE90">V2:</span></em><span class="deltaxml-new" style="background:#90EE90"> If the orderspec specifies </span><code><span class="deltaxml-new" style="background:#90EE90">descending</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> precedes </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90"> in the output tuple stream; otherwise, </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90"> precedes </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> in the output tuple stream.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><em><span class="deltaxml-new" style="background:#90EE90">V2</span></em><span class="deltaxml-new" style="background:#90EE90"> is </span><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><em><span class="deltaxml-new" style="background:#90EE90">V1</span></em><span class="deltaxml-new" style="background:#90EE90">: If the orderspec specifies </span><code><span class="deltaxml-new" style="background:#90EE90">descending</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90"> precedes </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> in the output tuple stream; otherwise, </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> precedes </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90"> in the output tuple stream.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">If neither </span><em><span class="deltaxml-new" style="background:#90EE90">V1</span></em><span class="deltaxml-new" style="background:#90EE90"> nor </span><em><span class="deltaxml-new" style="background:#90EE90">V2</span></em><span class="deltaxml-new" style="background:#90EE90"> is </span><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><span class="deltaxml-new" style="background:#90EE90"> the other for any pair of orderspecs for tuples </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90">, the following rules apply.</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">stable</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, the original order of </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90"> is preserved in the output tuple stream.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">stable</span></code><span class="deltaxml-new" style="background:#90EE90"> is not specified, the order of </span><em><span class="deltaxml-new" style="background:#90EE90">T1</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">T2</span></em><span class="deltaxml-new" style="background:#90EE90"> in the output tuple stream is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If two orderspecs return the special floating-point values positive and negative zero, neither of these values is </span><em><span class="deltaxml-new" style="background:#90EE90">greater-than</span></em><span class="deltaxml-new" style="background:#90EE90"> the other, since </span><code><span class="deltaxml-new" style="background:#90EE90">+0.0 gt -0.0</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">-0.0 gt +0.0</span></code><span class="deltaxml-new" style="background:#90EE90"> are both </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example illustrates the effect of an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause on a tuple stream. The keyword </span><code><span class="deltaxml-new" style="background:#90EE90">stable</span></code><span class="deltaxml-new" style="background:#90EE90"> indicates that, when two tuples have equal sort keys, their order in the input tuple stream is preserved.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Input tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "KLM030", $make = "Dodge", $value = () )</span></pre></div><p><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">stable order by $make,
  $value descending empty least</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Output tuple stream:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "KLM030", $make = "Dodge", $value = () )
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)</span></pre></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example shows how an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause can be used to sort the result of a query, even if the sort key is not included in the query result. This query returns employee names in descending order by salary, without returning the actual salaries:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $e in $employees
order by $e/salary descending
return $e/name</span></pre></div></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If a collation name is specified, it must be supplied as a literal string; it cannot be computed dynamically. Two possible workarounds are to use the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:sort</span></code><span class="deltaxml-new" style="background:#90EE90"> function or the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collation-key</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Using </span><code><span class="deltaxml-new" style="background:#90EE90">fn:sort</span></code><span class="deltaxml-new" style="background:#90EE90"> the expression</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $b in $books/book[price &lt; 100]
order by $b/title
return $b</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">can be replaced with the following, which uses a dynamically-chosen collation:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">sort(
  $books/book[price &lt; 100],
  $collation,
  function($book) { $book/title }
)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Alternatively, it is possible to compute collation keys using a dynamically-chosen collation, and sort on the values of the collation keys:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $b in $books/book[price &lt; 100]
order by collation-key($b/title, $collation)
return $b</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Note however that the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collation-key</span></code><span class="deltaxml-new" style="background:#90EE90"> function might not work for all collations.</span></p></div></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-return-clause"></a><span class="deltaxml-new" style="background:#90EE90">4.13.10 Return Clause</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27769.doc-xpath40-ReturnClause" id="noid_d4e27769.doc-xpath40-ReturnClause"></a><span class="deltaxml-new" style="background:#90EE90">[83]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ReturnClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ReturnClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"return" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is the final clause of a FLWOR expression. The </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is evaluated once for each tuple in its input tuple stream, using the variable bindings in the respective tuples, in the order in which these tuples appear in the input tuple stream. The results of these evaluations are concatenated, as if by the </span><a title="comma operator" class="termref" href="#dt-comma-operator"><span class="deltaxml-new" style="background:#90EE90">comma operator</span></a><span class="deltaxml-new" style="background:#90EE90">, to form the result of the FLWOR expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a FLWOR expression containing several clauses. The </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause iterates over all the departments in an input document named </span><code><span class="deltaxml-new" style="background:#90EE90">depts.xml</span></code><span class="deltaxml-new" style="background:#90EE90">, binding the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$d</span></code><span class="deltaxml-new" style="background:#90EE90"> to each department in turn. For each binding of </span><code><span class="deltaxml-new" style="background:#90EE90">$d</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause binds variable </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> to all the employees in the given department, selected from another input document named </span><code><span class="deltaxml-new" style="background:#90EE90">emps.xml</span></code><span class="deltaxml-new" style="background:#90EE90"> (the relationship between employees and departments is represented by matching their </span><code><span class="deltaxml-new" style="background:#90EE90">deptno</span></code><span class="deltaxml-new" style="background:#90EE90"> values). Each tuple in the resulting tuple stream contains a pair of bindings for </span><code><span class="deltaxml-new" style="background:#90EE90">$d</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> (</span><code><span class="deltaxml-new" style="background:#90EE90">$d</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a department and </span><code><span class="deltaxml-new" style="background:#90EE90">$e</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to a set of employees in that department). The </span><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><span class="deltaxml-new" style="background:#90EE90"> clause filters the tuple stream, retaining only those tuples that represent departments having at least ten employees. The </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause orders the surviving tuples in descending order by the average salary of the employees in the department. The </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause constructs a new </span><code><span class="deltaxml-new" style="background:#90EE90">big-dept</span></code><span class="deltaxml-new" style="background:#90EE90"> element for each surviving tuple, containing the department number, headcount, and average salary.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $d in doc("depts.xml")//dept
let $e := doc("emps.xml")//emp[deptno eq $d/deptno]
where count($e) &gt;= 10
order by avg($e/salary) descending
return &lt;big-dept&gt;{
  $d/deptno,
  &lt;headcount&gt;{count($e)}&lt;/headcount&gt;,
  &lt;avgsal&gt;{avg($e/salary)}&lt;/avgsal&gt;
}&lt;/big-dept&gt;</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Notes:</span></b></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The order in which items appear in the result of a FLWOR expression depends on the ordering of the input tuple stream to the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, which in turn is influenced by </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses. For example, consider the following query, which is based on the same two input documents as the previous example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $d in doc("depts.xml")//dept
order by $d/deptno
for $e in doc("emps.xml")//emp[deptno eq $d/deptno]
return &lt;assignment&gt;{
  $d/deptno, $e/name
}&lt;/assignment&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of this query is a sequence of </span><code><span class="deltaxml-new" style="background:#90EE90">assignment</span></code><span class="deltaxml-new" style="background:#90EE90"> elements, each containing a </span><code><span class="deltaxml-new" style="background:#90EE90">deptno</span></code><span class="deltaxml-new" style="background:#90EE90"> element and a </span><code><span class="deltaxml-new" style="background:#90EE90">name</span></code><span class="deltaxml-new" style="background:#90EE90"> element. The sequence will be ordered primarily by the </span><code><span class="deltaxml-new" style="background:#90EE90">deptno</span></code><span class="deltaxml-new" style="background:#90EE90"> values because of the </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. Subsequences of </span><code><span class="deltaxml-new" style="background:#90EE90">assignment</span></code><span class="deltaxml-new" style="background:#90EE90"> elements with equal </span><code><span class="deltaxml-new" style="background:#90EE90">deptno</span></code><span class="deltaxml-new" style="background:#90EE90"> values will be ordered by the document order of their </span><code><span class="deltaxml-new" style="background:#90EE90">name</span></code><span class="deltaxml-new" style="background:#90EE90"> elements within the </span><code><span class="deltaxml-new" style="background:#90EE90">emps.xml</span></code><span class="deltaxml-new" style="background:#90EE90"> document.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Parentheses are helpful in </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses that contain comma operators, since FLWOR expressions have a higher precedence than the comma operator. For example, the following query raises an error because after the comma, </span><code><span class="deltaxml-new" style="background:#90EE90">$j</span></code><span class="deltaxml-new" style="background:#90EE90"> is no longer within the FLWOR expression, and is an undefined variable:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $i := 5
let $j := 20 * $i
return $i, $j</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Parentheses can be used to bring </span><code><span class="deltaxml-new" style="background:#90EE90">$j</span></code><span class="deltaxml-new" style="background:#90EE90"> into the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause of the FLWOR expression, as the programmer probably intended:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $i := 5
let $j := 20 * $i
return ($i, $j)</span></pre></div></div></li></ul></div></div></div><div class="xpath"><div class="div3 xpath"><h4><a id="id-for-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.13.11 For Expressions</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-let-expressions"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-while"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for member</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is added to FLWOR expressions to allow iteration over an array.</span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/49"><span class="deltaxml-new" style="background:#90EE90">49</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/344"><span class="deltaxml-new" style="background:#90EE90">344</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;10 February 2023]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Multiple </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses can be combined in an expression without an intervening </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/22"><span class="deltaxml-new" style="background:#90EE90">22</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/28"><span class="deltaxml-new" style="background:#90EE90">28</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;18 December 2020]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> A </span><code><span class="deltaxml-new" style="background:#90EE90">for key/value</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is added to FLWOR expressions to allow iteration over maps.</span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/31"><span class="deltaxml-new" style="background:#90EE90">31</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1249"><span class="deltaxml-new" style="background:#90EE90">1249</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;1 June 2024]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> A positional variable can be defined in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/231"><span class="deltaxml-new" style="background:#90EE90">231</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1131"><span class="deltaxml-new" style="background:#90EE90">1131</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;1 April 2024]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The type of a variable used in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression can be declared. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/796"><span class="deltaxml-new" style="background:#90EE90">796</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1131"><span class="deltaxml-new" style="background:#90EE90">1131</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;1 April 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">XPath provides an iteration facility called a </span><b><span class="deltaxml-new" style="background:#90EE90">for expression</span></b><span class="deltaxml-new" style="background:#90EE90">. It can be used to iterate over the items of a sequence, the members of an array, or the entries in a map.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27939.doc-xpath40-ForExpr" id="noid_d4e27939.doc-xpath40-ForExpr"></a><span class="deltaxml-new" style="background:#90EE90">[48]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForExpr" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForClause" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a><a href="#doc-xpath40-ForLetReturn" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27940.doc-xpath40-ForClause" id="noid_d4e27940.doc-xpath40-ForClause"></a><span class="deltaxml-new" style="background:#90EE90">[54]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForClause" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"for" </span><a href="#doc-xpath40-ForBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-ForBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27941.doc-xpath40-ForBinding" id="noid_d4e27941.doc-xpath40-ForBinding"></a><span class="deltaxml-new" style="background:#90EE90">[55]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForItemBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForMemberBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ForEntryBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27942.doc-xpath40-ForItemBinding" id="noid_d4e27942.doc-xpath40-ForItemBinding"></a><span class="deltaxml-new" style="background:#90EE90">[56]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForItemBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName" class="xpath"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xpath"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-AllowingEmpty" class="xpath"><span class="deltaxml-new" style="background:#90EE90">AllowingEmpty</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-PositionalVar" class="xpath"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27943.doc-xpath40-ForMemberBinding" id="noid_d4e27943.doc-xpath40-ForMemberBinding"></a><span class="deltaxml-new" style="background:#90EE90">[57]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForMemberBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"member" "$" </span><a href="#doc-xpath40-VarName" class="xpath"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xpath"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-PositionalVar" class="xpath"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27944.doc-xpath40-ForEntryBinding" id="noid_d4e27944.doc-xpath40-ForEntryBinding"></a><span class="deltaxml-new" style="background:#90EE90">[59]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForEntryBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#doc-xpath40-ForEntryKeyBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForEntryKeyBinding</span></a><a href="#doc-xpath40-ForEntryValueBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">?) | </span><a href="#doc-xpath40-ForEntryValueBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-PositionalVar" class="xpath"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27945.doc-xpath40-ForLetReturn" id="noid_d4e27945.doc-xpath40-ForLetReturn"></a><span class="deltaxml-new" style="background:#90EE90">[49]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForLetReturn" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForExpr" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LetExpr" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("return" </span><a href="#doc-xpath40-ExprSingle" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27946.doc-xpath40-TypeDeclaration" id="noid_d4e27946.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration" class="xpath"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType" class="xpath"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e27947.doc-xpath40-PositionalVar" id="noid_d4e27947.doc-xpath40-PositionalVar"></a><span class="deltaxml-new" style="background:#90EE90">[62]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalVar" class="xpath"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"at" "$" </span><a href="#doc-xpath40-VarName" class="xpath"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is evaluated as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a href="#doc-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a><span class="deltaxml-new" style="background:#90EE90"> includes multiple </span><a href="#doc-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90">s with a comma separator, the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">expression is first expanded to a set of nested </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expressions, each of which contains a single </span><a href="#doc-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90">. More specifically, every separating comma is replaced by </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">for $x in X, $y in Y return $x + $y</span></code><span class="deltaxml-new" style="background:#90EE90"> is expanded to </span><code><span class="deltaxml-new" style="background:#90EE90">for $x in X for $y in Y return $x + $y</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Having performed this expansion, variables bound in the </span><a href="#doc-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a><span class="deltaxml-new" style="background:#90EE90"> are called the </span><b><span class="deltaxml-new" style="background:#90EE90">range variables</span></b><span class="deltaxml-new" style="background:#90EE90">, the variable named in the </span><a href="#doc-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90"> (if present) is called the </span><b><span class="deltaxml-new" style="background:#90EE90">position variable</span></b><span class="deltaxml-new" style="background:#90EE90">, the expression that follows the </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is called the </span><b><span class="deltaxml-new" style="background:#90EE90">binding expression</span></b><span class="deltaxml-new" style="background:#90EE90">, and the expression in the </span><a href="#doc-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a><span class="deltaxml-new" style="background:#90EE90"> part (that is, the following </span><a href="#doc-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, or the </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> that follows the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword) is called the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-binding-collection-xp" title="binding collection"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The result of evaluating the </span><b><span class="deltaxml-new" style="background:#90EE90">binding expression</span></b><span class="deltaxml-new" style="background:#90EE90"> in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is called the </span><b><span class="deltaxml-new" style="background:#90EE90">binding collection</span></b><span class="deltaxml-new" style="background:#90EE90"> ].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a </span><b><span class="deltaxml-new" style="background:#90EE90">position variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is declared, its type is implicitly </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. Its name (as a QName) must be different from the name of a </span><b><span class="deltaxml-new" style="background:#90EE90">range variable</span></b><span class="deltaxml-new" style="background:#90EE90"> declared in the same </span><a href="#doc-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90">. [</span><a href="#ERRXQST0089" title="err:XQST0089"><span class="deltaxml-new" style="background:#90EE90">err:XQST0089</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When a </span><a href="#doc-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> is used (that is, when none of the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> is used), the expression iterates over the items in a sequence: </span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If a </span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90"> is present then each item in the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> is converted to the specified type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is evaluated once for each item in the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, with a dynamic context in which the </span><b><span class="deltaxml-new" style="background:#90EE90">range variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is bound to that item, and the </span><b><span class="deltaxml-new" style="background:#90EE90">position variable</span></b><span class="deltaxml-new" style="background:#90EE90"> (if present) is bound to the one-based position of that item in the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">, as an instance of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the </span><a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the results of the successive evaluations of the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">When the </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is present: </span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">The value of the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> must be a single array. Otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised: [</span><a href="#ERRXPTY0141" title="err:XPTY0141"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0141</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a </span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90"> is present then each member of the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> array is converted to the specified type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. (Recall that this can be any sequence, not necessarily a single item). </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">for member</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is obtained by evaluating the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90"> once for each member of that array, with the range variable bound to that member </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is evaluated once for each member of the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> array, with a dynamic context in which the </span><b><span class="deltaxml-new" style="background:#90EE90">range variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is bound to that member, and the </span><b><span class="deltaxml-new" style="background:#90EE90">position variable</span></b><span class="deltaxml-new" style="background:#90EE90"> (if present) is bound to the one-based position of that member in the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the </span><a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the results of the successive evaluations of the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Note that the result is a sequence, not an array.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">When the </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> and/or </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> keywords are present: </span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">The value of the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> must be a single map. Otherwise, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised: [</span><a href="#ERRXPTY0141" title="err:XPTY0141"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0141</span></a><span class="deltaxml-new" style="background:#90EE90">]. The map is treated as a sequence of key/value pairs, in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> order. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is present, then the corresponding variable is bound to the key part of the key/value pair.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is present, then the corresponding variable is bound to the value part of the key/value pair.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If both the </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> keywords are present, then the corresponding variables must have distinct names. [</span><a href="#ERRXQST0089" title="err:XQST0089"><span class="deltaxml-new" style="background:#90EE90">err:XQST0089</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a </span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90"> is present for the key, then each key is converted to the specified type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a </span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90"> is present for the value, then each value is converted to the specified type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the single-variable </span><code><span class="deltaxml-new" style="background:#90EE90">for key/value</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is obtained by evaluating the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90"> once for each entry in the map, with the range variables bound to that entry as described.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is evaluated once for each entry of the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90"> map, with a dynamic context in which the </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><b><span class="deltaxml-new" style="background:#90EE90">range variable</span></b><span class="deltaxml-new" style="background:#90EE90"> (if present) is bound to the key part of that entry, the </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><b><span class="deltaxml-new" style="background:#90EE90">range variable</span></b><span class="deltaxml-new" style="background:#90EE90"> (if present) is bound to the value part of that entry, and the </span><b><span class="deltaxml-new" style="background:#90EE90">position variable</span></b><span class="deltaxml-new" style="background:#90EE90"> (if present) is bound to the one-based position of that entry in the </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> ordering of the </span><a title="binding collection" class="termref" href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the </span><a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the results of the successive evaluations of the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Note that the result is a sequence, not a map.</span></p></li></ol></li></ol><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the use of a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression in restructuring an input document. The example is based on the following input:</span></p></div><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The following example transforms the input document into a list in which each author’s name appears only once, followed by a list of titles of books written by that author. This example assumes that the context value is the </span><code><span class="deltaxml-new" style="background:#90EE90">bib</span></code><span class="deltaxml-new" style="background:#90EE90"> element in the input document.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="parse-test"><span class="parse-test"><span class="deltaxml-new" style="background:#90EE90">for $a in distinct-values(book/author)
return ((book/author[. = $a])[1], book[author = $a]/title)</span></span></span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of the above expression consists of the following sequence of elements. The titles of books written by a given author are listed after the name of the author. The ordering of </span><code><span class="deltaxml-new" style="background:#90EE90">author</span></code><span class="deltaxml-new" style="background:#90EE90"> elements in the result is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> due to the semantics of the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:distinct-values</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;author&gt;Stevens&lt;/author&gt;
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression containing more than one variable:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="parse-test"><span class="parse-test"><span class="deltaxml-new" style="background:#90EE90">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></span></span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The result of the above expression, expressed as a sequence of numbers, is as follows: </span><code><span class="deltaxml-new" style="background:#90EE90">11, 12, 21, 22</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">The scope of a variable bound in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90">. The scope does not include the expression to which the variable is bound. The following example illustrates how a variable binding may reference another variable bound earlier in the same </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="parse-test"><span class="parse-test"><span class="deltaxml-new" style="background:#90EE90">for $x in $z, $y in f($x)
return g($x, $y)</span></span></span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates processing of an array.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for member $map in parse-json('[{ "x": 1, "y": 2 }, { "x": 10, "y": 20 }]') 
return $map ! (?x + ?y)</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The result is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(3, 30)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates processing of a map.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for key $key value $value in map{ "x": 1, "y": 2, "z: 3 }
return `{$key}={$value}`</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The result is the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">("x=1", "y=2", "z=3")</span></code><span class="deltaxml-new" style="background:#90EE90"> (but not necessarily in that order).</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The focus for evaluation of the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> clause of a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the same as the focus for evaluation of the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression itself. The following example, which attempts to find the total value of a set of order-items, is therefore incorrect: </span></p><div class="error"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">sum(for $i in order-item return @price * @qty)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> Instead, the expression must be written to use the variable bound in the </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">sum(for $i in order-item return $i!(@price * @qty))</span></pre></div></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">XPath 4.0 allows the format:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">for $order in //orders
for $line in $order/order-line
return $line/value</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">primarily because it is familiar to XQuery users, some of whom may regard it as more readable than the XPath 3.1 alternative which uses a comma in place of the second </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div></div><div class="xpath"><div class="div3 xpath"><h4><a id="id-let-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.13.12 Let Expressions</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-map-constructors"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-for-expressions"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Multiple </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses can be combined in an expression without an intervening </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/22"><span class="deltaxml-new" style="background:#90EE90">22</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/28"><span class="deltaxml-new" style="background:#90EE90">28</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;18 December 2020]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The type of a variable used in a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> expression can be declared. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/796"><span class="deltaxml-new" style="background:#90EE90">796</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1131"><span class="deltaxml-new" style="background:#90EE90">1131</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;1 April 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">XPath allows a variable to be declared and bound to a value using a </span><b><span class="deltaxml-new" style="background:#90EE90">let expression</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e28398.doc-xpath40-LetExpr" id="noid_d4e28398.doc-xpath40-LetExpr"></a><span class="deltaxml-new" style="background:#90EE90">[50]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetExpr" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LetClause" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a><a href="#doc-xpath40-ForLetReturn" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e28399.doc-xpath40-LetClause" id="noid_d4e28399.doc-xpath40-LetClause"></a><span class="deltaxml-new" style="background:#90EE90">[63]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetClause" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"let" </span><a href="#doc-xpath40-LetBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-LetBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e28400.doc-xpath40-LetBinding" id="noid_d4e28400.doc-xpath40-LetBinding"></a><span class="deltaxml-new" style="background:#90EE90">[64]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetBinding" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName" class="xpath"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xpath"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ":=" </span><a href="#doc-xpath40-StandaloneExpr" class="xpath"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e28401.doc-xpath40-ForLetReturn" id="noid_d4e28401.doc-xpath40-ForLetReturn"></a><span class="deltaxml-new" style="background:#90EE90">[49]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForLetReturn" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForExpr" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LetExpr" class="xpath"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("return" </span><a href="#doc-xpath40-ExprSingle" class="xpath"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e28402.doc-xpath40-TypeDeclaration" id="noid_d4e28402.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration" class="xpath"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType" class="xpath"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A let expression is evaluated as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the let expression uses multiple variables, it is first expanded to a set of nested let expressions, each of which uses only one variable. Specifically, any separating comma is replaced by </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">let $x := 4, $y := 3 return $x + $y</span></code><span class="deltaxml-new" style="background:#90EE90"> is expanded to </span><code><span class="deltaxml-new" style="background:#90EE90">let $x := 4 let $y := 3 return $x + $y</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In a single-variable let expression, the variable is called the range variable. The expression that follows the </span><code><span class="deltaxml-new" style="background:#90EE90">:=</span></code><span class="deltaxml-new" style="background:#90EE90"> symbol is evaluated, and if a </span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90"> is present, its value is converted to the specified type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. The resulting value is called the binding sequence. The expression in the </span><a href="#doc-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a><span class="deltaxml-new" style="background:#90EE90"> part (that is, the following </span><a href="#doc-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, or the </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> that follows the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword) is called the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90">. The result of the let expression is obtained by evaluating the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90"> with a dynamic context in which the range variable is bound to the binding sequence. </span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The scope of a variable bound in a let expression is the </span><b><span class="deltaxml-new" style="background:#90EE90">return expression</span></b><span class="deltaxml-new" style="background:#90EE90">. The scope does not include the expression to which the variable is bound. The following example illustrates how a variable binding may reference another variable bound earlier in the same let expression:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := doc('a.xml')/*, $y := $x//*
return $y[@value gt $x/@min]</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">It is not required that the variables should have distinct names. It is permitted, for example, to write:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $x := "[A fine romance]"
let $x := substring-after($x, "[")
let $x := substring-before($x, "]")
return upper-case($x)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">which returns the result </span><code><span class="deltaxml-new" style="background:#90EE90">"A FINE ROMANCE"</span></code><span class="deltaxml-new" style="background:#90EE90">. Note that this expression declares three separate variables which happen to have the same name; it should not be read as declaring a single variable and binding it successively to different values.</span></p></div></div></div></div><div class="div2"><h3><a id="id-maps-and-arrays"></a><span class="deltaxml-new" style="background:#90EE90">4.14 Maps and Arrays</span></h3><p><span class="deltaxml-new" style="background:#90EE90">Most modern programming languages have support for collections of key/value pairs, which may be called maps, dictionaries, associative arrays, hash tables, keyed lists, or objects (these are not the same thing as objects in object-oriented systems). In XQuery 4.0 and XPath 4.0, we call these maps. Most modern programming languages also support ordered lists of values, which may be called arrays, vectors, or sequences. In XQuery 4.0 and XPath 4.0, we have both sequences and arrays. Unlike sequences, an array is an item, and can appear as an item in a sequence.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The XQuery 4.0 and XPath 4.0 specification focuses on syntax provided for maps and arrays, especially constructors and lookup.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Some of the functionality typically needed for maps and arrays is provided by functions defined in </span><span class="markup-error"><span class="deltaxml-new" style="background:#90EE90">[TITLE OF FO40 SPEC, TITLE OF maps-and-arrays SECTION]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></span><span class="deltaxml-new" style="background:#90EE90">, including functions used to read JSON to create maps and arrays, serialize maps and arrays to JSON, combine maps to create a new map, remove map entries to create a new map, iterate over the keys of a map, convert an array to create a sequence, combine arrays to form a new array, and iterate over arrays in various ways.</span></p></div><div class="div3"><h4><a id="id-maps"></a><span class="deltaxml-new" style="background:#90EE90">4.14.1 Maps</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-map" title="map"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">map</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function that associates a set of keys with values, resulting in a collection of key / value pairs.] [</span><a id="dt-entry" title="entry"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Each key / value pair in a map is called an </span><b><span class="deltaxml-new" style="background:#90EE90">entry</span></b><span class="deltaxml-new" style="background:#90EE90">.] [</span><a id="dt-associated-value" title="associated value"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The value associated with a given key is called the </span><b><span class="deltaxml-new" style="background:#90EE90">associated value</span></b><span class="deltaxml-new" style="background:#90EE90"> of the key.] </span></p><div class="div4"><h5><a id="id-map-constructors"></a><span class="deltaxml-new" style="background:#90EE90">4.14.1.1 Map Constructors</span></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-lookup"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-let-expressions"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> In map constructors, the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> is now optional, so </span><code><span class="deltaxml-new" style="background:#90EE90">map { 0: false(), 1: true() }</span></code><span class="deltaxml-new" style="background:#90EE90"> can now be written </span><code><span class="deltaxml-new" style="background:#90EE90">{ 0: false(), 1: true() }</span></code><span class="deltaxml-new" style="background:#90EE90">, provided it is used in a context where this creates no ambiguity. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1070"><span class="deltaxml-new" style="background:#90EE90">1070</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1071"><span class="deltaxml-new" style="background:#90EE90">1071</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;26 March 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">A Map is created using a </span><a href="#doc-xpath40-MapConstructor"><span class="deltaxml-new" style="background:#90EE90">MapConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MapConstructor" id="doc-xpath40-MapConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[212]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MapConstructor"><span class="deltaxml-new" style="background:#90EE90">MapConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"map" </span><a href="#doc-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BareMapConstructor" id="doc-xpath40-BareMapConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[213]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" (</span><a href="#doc-xpath40-MapConstructorEntry"><span class="deltaxml-new" style="background:#90EE90">MapConstructorEntry</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-MapConstructorEntry"><span class="deltaxml-new" style="background:#90EE90">MapConstructorEntry</span></a><span class="deltaxml-new" style="background:#90EE90">)*)? "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MapConstructorEntry" id="doc-xpath40-MapConstructorEntry"></a><span class="deltaxml-new" style="background:#90EE90">[214]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MapConstructorEntry"><span class="deltaxml-new" style="background:#90EE90">MapConstructorEntry</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MapKeyExpr"><span class="deltaxml-new" style="background:#90EE90">MapKeyExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ":" </span><a href="#doc-xpath40-MapValueExpr"><span class="deltaxml-new" style="background:#90EE90">MapValueExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MapKeyExpr" id="doc-xpath40-MapKeyExpr"></a><span class="deltaxml-new" style="background:#90EE90">[215]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MapKeyExpr"><span class="deltaxml-new" style="background:#90EE90">MapKeyExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MapValueExpr" id="doc-xpath40-MapValueExpr"></a><span class="deltaxml-new" style="background:#90EE90">[216]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MapValueExpr"><span class="deltaxml-new" style="background:#90EE90">MapValueExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody></table><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The keyword </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> was required in earlier versions of the language; in XQuery 4.0 and XPath 4.0 it becomes optional, provided the expression is used in a context where this creates no ambiguity.</span></p><p><span class="deltaxml-new" style="background:#90EE90">As a rule of thumb, the </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword can be omitted when the map constructor is an expression that follows one of the tokens </span><code><span class="deltaxml-new" style="background:#90EE90">(</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">[</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">,</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">:</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">:=</span></code><span class="deltaxml-new" style="background:#90EE90">. It cannot be omitted when the map constructor follows a keyword such as </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">then</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><span class="deltaxml-new" style="background:#90EE90">. In such cases the map constructor must either be introduced with the </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword, or must appear in parentheses.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Although the grammar allows a </span><a href="#doc-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> to appear within an </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> (that is, between curly braces), this may be confusing to readers, and using the </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword in such cases may improve clarity. In any event, if the </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> appears in a context such as a </span><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><span class="deltaxml-new" style="background:#90EE90">, the two adjacent left opening braces must at least be separated by whitespace.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> In some circumstances, it is necessary to include whitespace before or after the colon of a </span><a href="#doc-xpath40-MapConstructorEntry"><span class="deltaxml-new" style="background:#90EE90">MapConstructorEntry</span></a><span class="deltaxml-new" style="background:#90EE90"> to ensure that it is parsed as intended. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> For instance, consider the expression </span><code><span class="deltaxml-new" style="background:#90EE90">{a:b}</span></code><span class="deltaxml-new" style="background:#90EE90">. Although it matches the EBNF for MapConstructor (with </span><code><span class="deltaxml-new" style="background:#90EE90">a</span></code><span class="deltaxml-new" style="background:#90EE90"> matching MapKeyExpr and </span><code><span class="deltaxml-new" style="background:#90EE90">b</span></code><span class="deltaxml-new" style="background:#90EE90"> matching MapValueExpr), the "longest possible match" rule requires that </span><code><span class="deltaxml-new" style="background:#90EE90">a:b</span></code><span class="deltaxml-new" style="background:#90EE90"> be parsed as a QName, which results in a syntax error. Changing the expression to </span><code><span class="deltaxml-new" style="background:#90EE90">{a :b}</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">{a: b}</span></code><span class="deltaxml-new" style="background:#90EE90"> will prevent this, resulting in the intended parse. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, consider these three expressions:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">    {a:b:c}
    {a:*:c}
    {*:b:c}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90"> In each case, the expression matches the EBNF in two different ways, but the “longest possible match” rule forces the parse in which the MapKeyExpr is </span><code><span class="deltaxml-new" style="background:#90EE90">a:b</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">a:*</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">*:b</span></code><span class="deltaxml-new" style="background:#90EE90"> (respectively) and the MapValueExpr is </span><code><span class="deltaxml-new" style="background:#90EE90">c</span></code><span class="deltaxml-new" style="background:#90EE90">. To achieve the alternative parse (in which the MapKeyExpr is merely </span><code><span class="deltaxml-new" style="background:#90EE90">a</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">), insert whitespace before and/or after the first colon. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#lexical-structure"><b><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The value of the expression (whether or not the </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is present) is a map whose entries correspond to the key-value pairs obtained by evaluating the successive </span><a href="#doc-xpath40-MapKeyExpr"><span class="deltaxml-new" style="background:#90EE90">MapKeyExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-MapValueExpr"><span class="deltaxml-new" style="background:#90EE90">MapValueExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> expressions.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Each </span><a href="#doc-xpath40-MapKeyExpr"><span class="deltaxml-new" style="background:#90EE90">MapKeyExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> expression is evaluated and atomized; a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] occurs if the result is not a single atomic item. The associated value is the result of evaluating the corresponding </span><a href="#doc-xpath40-MapValueExpr"><span class="deltaxml-new" style="background:#90EE90">MapValueExpr</span></a><span class="deltaxml-new" style="background:#90EE90">. If the </span><a href="#doc-xpath40-MapValueExpr"><span class="deltaxml-new" style="background:#90EE90">MapValueExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> evaluates to a node, the associated value is the node itself, not a new node with the same values. [</span><a id="dt-same-key" title="same key"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Two atomic items </span><code><span class="deltaxml-new" style="background:#90EE90">K1</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">K2</span></code><span class="deltaxml-new" style="background:#90EE90"> have the </span><b><span class="deltaxml-new" style="background:#90EE90">same key value</span></b><span class="deltaxml-new" style="background:#90EE90"> if </span><code><span class="deltaxml-new" style="background:#90EE90">fn:atomic-equal(K1, K2)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal"><span class="deltaxml-new" style="background:#90EE90">Section 13.2.1 fn:atomic-equal</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> ] If two or more entries have the </span><a title="same key" class="termref" href="#dt-same-key"><span class="deltaxml-new" style="background:#90EE90">same key value</span></a><span class="deltaxml-new" style="background:#90EE90"> then a dynamic error is raised [</span><a href="#ERRXQDY0137" title="err:XQDY0137"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0137</span></a><span class="deltaxml-new" style="background:#90EE90">]. The error </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be raised statically if two or more entries can be determined statically to have the </span><a title="same key" class="termref" href="#dt-same-key"><span class="deltaxml-new" style="background:#90EE90">same key value</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following expression constructs a map with seven entries:</span></p><div class="exampleInner"><a id="map-weekdays"></a><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Maps can nest, and can contain any XDM value. Here is an example of a nested map with values that can be string values, numeric values, or arrays:</span></p><div class="exampleInner"><a id="map-book"></a><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">
{
  "book": {
    "title": "Data on the Web",
    "year": 2000,
    "author": [
      {
        "last": "Abiteboul",
        "first": "Serge"
      },
      {
        "last": "Buneman",
        "first": "Peter"
      },
      {
        "last": "Suciu",
        "first": "Dan"
      }
    ],
    "publisher": "Morgan Kaufmann Publishers",
    "price": 39.95
  }
}</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The syntax deliberately mimics JSON, but there are a few differences. JSON constructs that are not accepted in XQuery 4.0 and XPath 4.0 map constructors include the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">null</span></code><span class="deltaxml-new" style="background:#90EE90">, and backslash-escaped characters such as </span><code><span class="deltaxml-new" style="background:#90EE90">"\n"</span></code><span class="deltaxml-new" style="background:#90EE90"> in string literals. In an XQuery 4.0 and XPath 4.0 map constructor, of course, any literal value can be replaced with an expression.</span></p></div></div><div class="div4"><h5><a id="id-map-lookup"></a><span class="deltaxml-new" style="background:#90EE90">4.14.1.2 Map Lookup using Function Call Syntax</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Maps are </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function items</span></a><span class="deltaxml-new" style="background:#90EE90">, and a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-call"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a><span class="deltaxml-new" style="background:#90EE90"> can be used to look up the value associated with a key in a map. If </span><code><span class="deltaxml-new" style="background:#90EE90">$map</span></code><span class="deltaxml-new" style="background:#90EE90"> is a map and </span><code><span class="deltaxml-new" style="background:#90EE90">$key</span></code><span class="deltaxml-new" style="background:#90EE90"> is a key, then </span><code><span class="deltaxml-new" style="background:#90EE90">$map($key)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">map:get($map, $key)</span></code><span class="deltaxml-new" style="background:#90EE90">. The semantics of such a function call are formally defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-map-get"><span class="deltaxml-new" style="background:#90EE90">Section 17.3.9 map:get</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$weekdays("Su")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the </span><a title="associated value" class="termref" href="#dt-associated-value"><span class="deltaxml-new" style="background:#90EE90">associated value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the key </span><code><span class="deltaxml-new" style="background:#90EE90">Su</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$books("Green Eggs and Ham")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><a title="associated value" class="termref" href="#dt-associated-value"><span class="deltaxml-new" style="background:#90EE90">associated value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the key </span><code><span class="deltaxml-new" style="background:#90EE90">Green Eggs and Ham</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 also provides an alternate syntax for map and array lookup that is more terse, supports wildcards, and allows lookup to iterate over a sequence of maps or arrays. See </span><a href="#id-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3 Lookup Expressions for Maps and Arrays</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for details.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Map lookups can be chained.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples: (These examples assume that </span><code><span class="deltaxml-new" style="background:#90EE90">$b</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the books map from the previous section)</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$b("book")("title")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the string </span><code><span class="deltaxml-new" style="background:#90EE90">Data on the Web</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$b("book")("author")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the array of authors.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$b("book")("author")(1)("last")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the string </span><code><span class="deltaxml-new" style="background:#90EE90">Abiteboul</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">(This example combines </span><a href="#id-array-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.2.2 Array Lookup using Function Call Syntax</span></b></a><span class="deltaxml-new" style="background:#90EE90"> with map lookups.)</span></p></li></ul></div></div><div class="div3"><h4><a id="id-arrays"></a><span class="deltaxml-new" style="background:#90EE90">4.14.2 Arrays</span></h4><div class="div4"><h5><a id="id-array-constructors"></a><span class="deltaxml-new" style="background:#90EE90">4.14.2.1 Array Constructors</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-array" title="array"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">array</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> that associates a set of positions, represented as positive integer keys, with values.] The first position in an array is associated with the integer 1. [</span><a id="dt-member" title="member"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The values of an array are called its </span><b><span class="deltaxml-new" style="background:#90EE90">members</span></b><span class="deltaxml-new" style="background:#90EE90">.] In the type hierarchy, array has a distinct type, which is derived from function. Atomization converts arrays to sequences (see </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">Atomization</span></a><span class="deltaxml-new" style="background:#90EE90">). </span></p><p><span class="deltaxml-new" style="background:#90EE90">An array is created using an </span><a href="#doc-xpath40-ArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">ArrayConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArrayConstructor" id="doc-xpath40-ArrayConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[217]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">ArrayConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SquareArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">SquareArrayConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-CurlyArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">CurlyArrayConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SquareArrayConstructor" id="doc-xpath40-SquareArrayConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[218]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SquareArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">SquareArrayConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"[" (</span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*)? "]"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CurlyArrayConstructor" id="doc-xpath40-CurlyArrayConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[219]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CurlyArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">CurlyArrayConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"array" </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> If a member of an array is a node, its node identity is preserved. In both forms of an </span><a href="#doc-xpath40-ArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">ArrayConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">, if a member expression evaluates to a node, the associated value is the node itself, not a new node with the same values. If the member expression evaluates to a map or array, the associated value is a new map or array with the same values. </span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-SquareArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">SquareArrayConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> consists of a comma-delimited set of argument expressions. It returns an array in which each member contains the value of the corresponding argument expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ 1, 2, 5, 7 ]</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with four members: </span><code><span class="deltaxml-new" style="background:#90EE90">1</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">2</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">5</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">7</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ (), (27, 17, 0) ]</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with two members: </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90"> and the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(27, 17, 0)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; ]</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with three members: the value of $x, the result of evaluating the function call, and a tautology element.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-CurlyArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">CurlyArrayConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> can use any expression to create its members. It evaluates its operand expression to obtain a sequence of items and creates an array with these items as members. Unlike a SquareArrayConstructor, a comma in a CurlyArrayConstructor is the </span><a title="comma operator" class="termref" href="#dt-comma-operator"><span class="deltaxml-new" style="background:#90EE90">comma operator</span></a><span class="deltaxml-new" style="background:#90EE90">, not a delimiter. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { $x }</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with one member for each item in the sequence to which $x is bound.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { local:items() }</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with one member for each item in the sequence to which </span><code><span class="deltaxml-new" style="background:#90EE90">local:items()</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { 1, 2, 5, 7 }</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with four members: </span><code><span class="deltaxml-new" style="background:#90EE90">1</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">2</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">5</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">7</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { (), (27, 17, 0) }</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with three members: </span><code><span class="deltaxml-new" style="background:#90EE90">27</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">17</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; }</span></code><span class="deltaxml-new" style="background:#90EE90"> creates an array with the following members: the items to which </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound, followed by the items to which </span><code><span class="deltaxml-new" style="background:#90EE90">local:items()</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates, followed by a tautology element.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 does not provide explicit support for sparse arrays. Use integer-valued maps to represent sparse arrays, for example: </span><code><span class="deltaxml-new" style="background:#90EE90">{ 27 : -1, 153 : 17 }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div4"><h5><a id="id-array-lookup"></a><span class="deltaxml-new" style="background:#90EE90">4.14.2.2 Array Lookup using Function Call Syntax</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Arrays are </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function items</span></a><span class="deltaxml-new" style="background:#90EE90">, and a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-call"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a><span class="deltaxml-new" style="background:#90EE90"> can be used to look up the value associated with position in an array. If </span><code><span class="deltaxml-new" style="background:#90EE90">$array</span></code><span class="deltaxml-new" style="background:#90EE90"> is an array and </span><code><span class="deltaxml-new" style="background:#90EE90">$index</span></code><span class="deltaxml-new" style="background:#90EE90"> is an integer corresponding to a position in the array, then </span><code><span class="deltaxml-new" style="background:#90EE90">$array($key)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">array:get($array, $key)</span></code><span class="deltaxml-new" style="background:#90EE90">. The semantics of such a function call are formally defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-array-get"><span class="deltaxml-new" style="background:#90EE90">Section 18.2.11 array:get</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ 1, 2, 5, 7 ](4)</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">7</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ [ 1, 2, 3 ], [ 4, 5, 6 ] ](2)</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">[ 4, 5, 6 ]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ [ 1, 2, 3 ], [ 4, 5, 6 ] ](2)(2)</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">5</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ 'a', 123, &lt;name&gt;Robert Johnson&lt;/name&gt; ](3)</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;name&gt;Robert Johnson&lt;/name&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { (), (27, 17, 0) }(1)</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">27</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { (), (27, 17, 0) }(2)</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">17</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array { "licorice", "ginger" }(20)</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a dynamic error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001"><span class="deltaxml-new" style="background:#90EE90">err:FOAY0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 also provides an alternate syntax for map and array lookup that is more terse, supports wildcards, and allows lookup to iterate over a sequence of maps or arrays. See </span><a href="#id-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3 Lookup Expressions for Maps and Arrays</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for details.</span></p></div></div></div><div class="div3"><h4><a id="id-lookup"></a><span class="deltaxml-new" style="background:#90EE90">4.14.3 Lookup Expressions for Maps and Arrays</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-filter-maps-and-arrays"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-map-constructors"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The lookup operator </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> can now be followed by a string literal, for cases where map keys are strings other than NCNames. It can also be followed by a variable reference. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> A deep lookup operator </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90"> is provided for searching trees of maps and arrays. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/297"><span class="deltaxml-new" style="background:#90EE90">297</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/837"><span class="deltaxml-new" style="background:#90EE90">837</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;23 November 2023]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Lookup expressions can now take a modifier (such as </span><code><span class="deltaxml-new" style="background:#90EE90">keys</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">values</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">pairs</span></code><span class="deltaxml-new" style="background:#90EE90">) enabling them to return structured results rather than a flattened sequence. In addition they can be qualified with a type to select only the results that match that type. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issues </span><a href="https://github.com/qt4cg/qtspecs/issues/960"><span class="deltaxml-new" style="background:#90EE90">960</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="https://github.com/qt4cg/qtspecs/issues/1094"><span class="deltaxml-new" style="background:#90EE90">1094</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1125"><span class="deltaxml-new" style="background:#90EE90">1125</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;23 April 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 provides two lookup operators </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90"> for maps and arrays. These provide a terse syntax for accessing the entries in a map or the members of an array.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The operator "?", known as the shallow lookup operator, returns values found immediately in the operand map or array. The operator "??", known as the deep lookup operator, also searches nested maps and arrays. The effect of the deep lookup operator "??" is explained in </span><a href="#id-deep-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3.3 Deep Lookup</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="div4"><h5><a id="id-postfix-lookup"></a><span class="deltaxml-new" style="background:#90EE90">4.14.3.1 Postfix Lookup Expressions</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-LookupExpr" id="doc-xpath40-LookupExpr"></a><span class="deltaxml-new" style="background:#90EE90">[161]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LookupExpr"><span class="deltaxml-new" style="background:#90EE90">LookupExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#doc-xpath40-Lookup"><span class="deltaxml-new" style="background:#90EE90">Lookup</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Lookup" id="doc-xpath40-Lookup"></a><span class="deltaxml-new" style="background:#90EE90">[163]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Lookup"><span class="deltaxml-new" style="background:#90EE90">Lookup</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("?" | "??") (</span><a href="#doc-xpath40-Modifier"><span class="deltaxml-new" style="background:#90EE90">Modifier</span></a><span class="deltaxml-new" style="background:#90EE90"> "::")? </span><a href="#doc-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Modifier" id="doc-xpath40-Modifier"></a><span class="deltaxml-new" style="background:#90EE90">[164]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Modifier"><span class="deltaxml-new" style="background:#90EE90">Modifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"pairs" | "keys" | "values" | "items"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-KeySpecifier" id="doc-xpath40-KeySpecifier"></a><span class="deltaxml-new" style="background:#90EE90">[165]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-LookupWildcard"><span class="deltaxml-new" style="background:#90EE90">LookupWildcard</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypeQualifier"><span class="deltaxml-new" style="background:#90EE90">TypeQualifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-LookupWildcard" id="doc-xpath40-LookupWildcard"></a><span class="deltaxml-new" style="background:#90EE90">[166]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LookupWildcard"><span class="deltaxml-new" style="background:#90EE90">LookupWildcard</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"*"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypeQualifier" id="doc-xpath40-TypeQualifier"></a><span class="deltaxml-new" style="background:#90EE90">[167]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeQualifier"><span class="deltaxml-new" style="background:#90EE90">TypeQualifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"type" "(" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">Lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> has two parts: the </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90"> determines which entries (in a map) or members (in an array) are selected, and the </span><code><span class="deltaxml-new" style="background:#90EE90">Modifier</span></code><span class="deltaxml-new" style="background:#90EE90"> determines how they are delivered in the result. The default modifier is </span><code><span class="deltaxml-new" style="background:#90EE90">items</span></code><span class="deltaxml-new" style="background:#90EE90">, which delivers the result as a flattened sequence of items.</span></p><p><span class="deltaxml-new" style="background:#90EE90">To take a simple example, given </span><code><span class="deltaxml-new" style="background:#90EE90">$A</span></code><span class="deltaxml-new" style="background:#90EE90"> as an array </span><code><span class="deltaxml-new" style="background:#90EE90">[ ("a", "b"), ("c", "d"), ("e", "f") ]</span></code><span class="deltaxml-new" style="background:#90EE90">, some example Lookup expressions are:</span></p><table style="width:100%"><caption><span class="deltaxml-new" style="background:#90EE90">Example Lookup Expressions on an Array</span></caption><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?*</span></code><span class="deltaxml-new" style="background:#90EE90"> (or </span><code><span class="deltaxml-new" style="background:#90EE90">$A?items::*)</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("a", "b", "c", "d", "e", "f")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?pairs::*</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">({ "key": 1, "value": ("a", "b") }, { "key": 2, "value": ("c", "d") }, { "key": 3, "value": ("e", "f") })</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?values::*</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">([ "a", "b" ], [ "c", "d" ], [ "e", "f" ])</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?keys::*</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3)</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?2</span></code><span class="deltaxml-new" style="background:#90EE90"> (or </span><code><span class="deltaxml-new" style="background:#90EE90">$A?items::2)</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("c", "d")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?pairs::2</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">({ "key": 2, "value":("c", "d") })</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?values::2</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">([ "c", "d" ])</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?keys::2</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">(2)</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?(3, 1)</span></code><span class="deltaxml-new" style="background:#90EE90"> (or </span><code><span class="deltaxml-new" style="background:#90EE90">$A?items::(3, 1))</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("e", "f", "a", "b")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?pairs::(3, 1)</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">({ "key": 3, "value": ("e", "f") }, { "key": 1, "value": ("a", "b") })</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?values::(3, 1)</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">([ "e", "f" ][ "a", "b" ])</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$A?keys::(3, 1)</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">(3, 1)</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Similarly, given </span><code><span class="deltaxml-new" style="background:#90EE90">$M</span></code><span class="deltaxml-new" style="background:#90EE90"> as a map </span><code><span class="deltaxml-new" style="background:#90EE90">{ "X": ("a", "b"), "Y": ("c", "d"), "Z": ("e", "f") }</span></code><span class="deltaxml-new" style="background:#90EE90">, some example lookup expressions are as follows. Note that because maps are unordered, the results are not necessarily in the order shown.</span></p><table style="width:100%"><caption><span class="deltaxml-new" style="background:#90EE90">Example Lookup Expressions on a Map</span></caption><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?*</span></code><span class="deltaxml-new" style="background:#90EE90"> (or </span><code><span class="deltaxml-new" style="background:#90EE90">$M?items::*)</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("a", "b", "c", "d", "e", "f")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?pairs::*</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">({ "key": "X", "value": ("a", "b") }, { "key": "Y", "value": ("c", "d") }, { "key": "Z", "value": ("e", "f") })</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?values::*</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">([ "a", "b" ], [ "c", "d" ], [ "e", "f" ])</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?keys::*</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("X", "Y", "Z")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?Y</span></code><span class="deltaxml-new" style="background:#90EE90"> (or </span><code><span class="deltaxml-new" style="background:#90EE90">$M?items::Y)</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("c", "d")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?pairs::Y</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">({ "key": "Y", "value":("c", "d") })</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?values::Y</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">([ "c", "d" ])</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?keys::Y</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("Y")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?("Z", "X")</span></code><span class="deltaxml-new" style="background:#90EE90"> (or </span><code><span class="deltaxml-new" style="background:#90EE90">$A?items::("Z", "X"))</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("e", "f", "a", "b")</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?pairs::("Z", "X")</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">({ "key": "Z", "value": ("e", "f") }, { "key": "X", "value": ("a", "b") })</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?values::("Z", "X")</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">([ "e", "f" ][ "a", "b" ])</span></code></td></tr><tr><td><code><span class="deltaxml-new" style="background:#90EE90">$M?keys::("Z", "X")</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">("Z", "X")</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The semantics of a postfix lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">E?pairs::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> are defined as follows. The results with other modifiers can be derived from this result, as explained below.</span></p><ol class="enumar"><li><p><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is evaluated to produce a value </span><code><span class="deltaxml-new" style="background:#90EE90">$V</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$V</span></code><span class="deltaxml-new" style="background:#90EE90"> is not a singleton (that is if </span><code><span class="deltaxml-new" style="background:#90EE90">count($V) ne 1</span></code><span class="deltaxml-new" style="background:#90EE90">), then the result (by recursive application of these rules) is the value of </span><code><span class="deltaxml-new" style="background:#90EE90">for $v in $V return $v?pairs::KS</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$V</span></code><span class="deltaxml-new" style="background:#90EE90"> is a singleton array (that is, if </span><code><span class="deltaxml-new" style="background:#90EE90">$V instance of array(*)</span></code><span class="deltaxml-new" style="background:#90EE90">) then:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><code><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></code><span class="deltaxml-new" style="background:#90EE90">, then it is evaluated to produce a value </span><code><span class="deltaxml-new" style="background:#90EE90">$K</span></code><span class="deltaxml-new" style="background:#90EE90"> and the result is:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">data($K) ! map{ "key": ., "value": array:get($V, .)}</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The focus for evaluating the key specifier expression is the same as the focus for the </span><code><span class="deltaxml-new" style="background:#90EE90">Lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> expression itself.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a href="#doc-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a><span class="deltaxml-new" style="background:#90EE90"> is an </span><a href="#doc-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> with value </span><code><span class="deltaxml-new" style="background:#90EE90">$i</span></code><span class="deltaxml-new" style="background:#90EE90">, the result is the same as </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::($i)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a href="#doc-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span><span class="deltaxml-new" style="background:#90EE90">or </span><code><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></code></span><span class="deltaxml-new" style="background:#90EE90">, the expression raises a type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is a wildcard (</span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">), the result is the same as </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::(1 to array:size($V))</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Note that array items are returned in order.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><code><span class="deltaxml-new" style="background:#90EE90">TypeSpecifier</span></code><code><span class="deltaxml-new" style="background:#90EE90">type(T)</span></code><span class="deltaxml-new" style="background:#90EE90">, the result is the same as </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::*[?value instance of T]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">$V</span></var><span class="deltaxml-new" style="background:#90EE90"> is a singleton map (that is, if </span><code><span class="deltaxml-new" style="background:#90EE90">$V instance of map(*)</span></code><span class="deltaxml-new" style="background:#90EE90">) then:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><code><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></code><span class="deltaxml-new" style="background:#90EE90">, then it is evaluated to produce a value </span><code><span class="deltaxml-new" style="background:#90EE90">$K</span></code><span class="deltaxml-new" style="background:#90EE90"> and the result is:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">data($K) ! map{ "key": ., "value": map:get($V, .)</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The focus for evaluating the key specifier expression is the same as the focus for the </span><code><span class="deltaxml-new" style="background:#90EE90">Lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> expression itself.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span class="deltaxml-new" style="background:#90EE90"> or a </span><code><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></code><span class="deltaxml-new" style="background:#90EE90">, with value </span><code><span class="deltaxml-new" style="background:#90EE90">$S</span></code><span class="deltaxml-new" style="background:#90EE90">, the result is the same as </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::($S)</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></code><span class="deltaxml-new" style="background:#90EE90"> with value </span><code><span class="deltaxml-new" style="background:#90EE90">$N</span></code><span class="deltaxml-new" style="background:#90EE90">, the result is the same as </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::($N)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is a wildcard (</span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">), the result is the same as </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::(map:keys($V))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The order of entries in the result sequence in this case is implementation-dependent.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is a </span><code><span class="deltaxml-new" style="background:#90EE90">TypeSpecifier</span></code><code><span class="deltaxml-new" style="background:#90EE90">type(T)</span></code><span class="deltaxml-new" style="background:#90EE90">, the result is the same as </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::*[?value instance of T]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise (that is, if </span><code><span class="deltaxml-new" style="background:#90EE90">$V</span></code><span class="deltaxml-new" style="background:#90EE90"> is neither a map nor an array) a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">If the modifier is </span><code><span class="deltaxml-new" style="background:#90EE90">items</span></code><span class="deltaxml-new" style="background:#90EE90"> (explicitly or by default), the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V?items::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::KS ! map:get(., "value")</span></code><span class="deltaxml-new" style="background:#90EE90">; that is, it is the </span><a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the value parts.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the modifier is </span><code><span class="deltaxml-new" style="background:#90EE90">values</span></code><span class="deltaxml-new" style="background:#90EE90">, the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V?values::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::KS ! array{ map:get(., "value") }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the modifier is </span><code><span class="deltaxml-new" style="background:#90EE90">keys</span></code><span class="deltaxml-new" style="background:#90EE90">, the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V?keys::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V?pairs::KS ! map:get(., "key")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">map{ "first" : "Jenna", "last" : "Scott" }?first</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">"Jenna"</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">map{ "first name" : "Jenna", "last name" : "Scott" }?"first name"</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">"Jenna"</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ 4, 5, 6 ]?2</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">5</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">({ "first": "Tom" }, { "first": "Dick" }, { "first": "Harry" })?first</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">("Tom", "Dick", "Harry")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">([ 1, 2, 3 ], [ 4, 5, 6 ])?2</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">(2, 5)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">([ 1, [ "a", "b" ], [ 4, 5, [ "c", "d"] ])?type(array(xs:string))</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">([ "a", "b" ], [ "c", "d" ])</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ "a", "b" ]?3</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a dynamic error [</span><a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001"><span class="deltaxml-new" style="background:#90EE90">err:FOAY0001</span></a><span class="deltaxml-new" style="background:#90EE90">]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></p></li></ul></div><div class="div4"><h5><a id="id-unary-lookup"></a><span class="deltaxml-new" style="background:#90EE90">4.14.3.2 Unary Lookup</span></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-UnaryLookup" id="doc-xpath40-UnaryLookup"></a><span class="deltaxml-new" style="background:#90EE90">[227]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnaryLookup"><span class="deltaxml-new" style="background:#90EE90">UnaryLookup</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("?" | "??") (</span><a href="#doc-xpath40-Modifier"><span class="deltaxml-new" style="background:#90EE90">Modifier</span></a><span class="deltaxml-new" style="background:#90EE90"> "::")? </span><a href="#doc-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e29762.doc-xpath40-Modifier" id="noid_d4e29762.doc-xpath40-Modifier"></a><span class="deltaxml-new" style="background:#90EE90">[164]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Modifier"><span class="deltaxml-new" style="background:#90EE90">Modifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"pairs" | "keys" | "values" | "items"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e29763.doc-xpath40-KeySpecifier" id="noid_d4e29763.doc-xpath40-KeySpecifier"></a><span class="deltaxml-new" style="background:#90EE90">[165]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-LookupWildcard"><span class="deltaxml-new" style="background:#90EE90">LookupWildcard</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-TypeQualifier"><span class="deltaxml-new" style="background:#90EE90">TypeQualifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e29764.doc-xpath40-LookupWildcard" id="noid_d4e29764.doc-xpath40-LookupWildcard"></a><span class="deltaxml-new" style="background:#90EE90">[166]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LookupWildcard"><span class="deltaxml-new" style="background:#90EE90">LookupWildcard</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"*"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e29765.doc-xpath40-TypeQualifier" id="noid_d4e29765.doc-xpath40-TypeQualifier"></a><span class="deltaxml-new" style="background:#90EE90">[167]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeQualifier"><span class="deltaxml-new" style="background:#90EE90">TypeQualifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"type" "(" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Unary lookup is most commonly used in predicates (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">$map[?name = 'Mike']</span></code><span class="deltaxml-new" style="background:#90EE90">) or with the simple map operator (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">avg($maps ! (?price - ?discount))</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The unary lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">?modifier::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is defined to be equivalent to the postfix lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">.?modifier::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> which has the context value (</span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90">) as the implicit first operand. See </span><a href="#id-postfix-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3.1 Postfix Lookup Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for the postfix lookup operator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">?name</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">.("name")</span></code><span class="deltaxml-new" style="background:#90EE90">, an appropriate lookup for a map.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">?2</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">.(2)</span></code><span class="deltaxml-new" style="background:#90EE90">, an appropriate lookup for an array or an integer-valued map.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the context item is the result of parsing the JSON input:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{

  "name": "John Smith",
  "address": { "street": "18 Acacia Avenue", "postcode": "MK12 2EX" },
  "previous-address": { "street": "12 Seaview Road", "postcode": "EX8 9AA" }
}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">then </span><code><span class="deltaxml-new" style="background:#90EE90">?*[. instance of record(street, postcode)]?postcode</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">("MK12 2EX", "EX8 9AA")</span></code><span class="deltaxml-new" style="background:#90EE90"> (or some permutation thereof).</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Writing </span><code><span class="deltaxml-new" style="background:#90EE90">?*?postcode</span></code><span class="deltaxml-new" style="background:#90EE90"> would raise a type error, because the result of the initial step </span><code><span class="deltaxml-new" style="background:#90EE90">?*</span></code><span class="deltaxml-new" style="background:#90EE90"> includes an item (the string </span><code><span class="deltaxml-new" style="background:#90EE90">"John Smith"</span></code><span class="deltaxml-new" style="background:#90EE90">) that is neither a map nor an array.</span></p></div></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">?"first name"</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">.("first name")</span></code></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">?("$funky / &lt;looking @string")</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">.("$funky / &lt;looking @string")</span></code><span class="deltaxml-new" style="background:#90EE90">, an appropriate lookup for a map with rather odd conventions for keys.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">?($a)</span></code><span><span class="deltaxml-new" style="background:#90EE90">and </span><code><span class="deltaxml-new" style="background:#90EE90">?$a</span></code><span class="deltaxml-new" style="background:#90EE90"> are</span></span><span class="deltaxml-new" style="background:#90EE90"> equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">for $k in $a return .($k)</span></code><span class="deltaxml-new" style="background:#90EE90">, allowing keys for an array or map to be passed using a variable.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">?(2 to 4)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">for $k in (2,3,4) return .($k)</span></code><span class="deltaxml-new" style="background:#90EE90">, a convenient way to return a range of values from an array.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">?(3.5)</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a type error if the context value is an array because the parameter must be an integer.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">If the context value is an array, </span><code><span class="deltaxml-new" style="background:#90EE90">let $x:= &lt;node i="3"/&gt; return ?($x/@i)</span></code><span class="deltaxml-new" style="background:#90EE90"> does not raise a type error because the attribute is untyped.</span></p><p><span class="deltaxml-new" style="background:#90EE90">But </span><code><span class="deltaxml-new" style="background:#90EE90">let $x:= &lt;node i="3"/&gt; return ?($x/@i+1)</span></code><span class="deltaxml-new" style="background:#90EE90"> does raise a type error because the </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> operator with an untyped operand returns a double.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">([ 1, 2, 3 ], [ 1, 2, 5 ], [ 1, 2 ])[?3 = 5]</span></code><span class="deltaxml-new" style="background:#90EE90"> raises an error because </span><code><span class="deltaxml-new" style="background:#90EE90">?3</span></code><span class="deltaxml-new" style="background:#90EE90"> on one of the items in the sequence fails.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$m</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the weekdays map described in </span><a href="#id-maps"><b><span class="deltaxml-new" style="background:#90EE90">4.14.1 Maps</span></b></a><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">$m?*</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the values </span><code><span class="deltaxml-new" style="background:#90EE90">("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")</span></code><span class="deltaxml-new" style="background:#90EE90">, in </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> order.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ 1, 2, 5, 7 ]?*</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">(1, 2, 5, 7)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]?*</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">([ 1, 2, 3 ], [ 4, 5, 6 ])</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ [1, 2, 3], 4, 5 ]?type(array(xs:integer))</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">([1, 2, 3])</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ [ 1, 2, 3 ], [ 4, 5, 6 ], 7 ]?type(array(*))?2</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">(2, 5)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">[ [ 1, 2, 3 ], 4, 5 ]?type(xs:integer)</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">(4, 5)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul></div><div class="div4"><h5><a id="id-deep-lookup"></a><span class="deltaxml-new" style="background:#90EE90">4.14.3.3 Deep Lookup</span></h5><p><span class="deltaxml-new" style="background:#90EE90">The deep lookup operator </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90"> has both unary and postfix forms. The unary form </span><code><span class="deltaxml-new" style="background:#90EE90">??modifier::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> (where </span><var><span class="deltaxml-new" style="background:#90EE90">KS</span></var><span class="deltaxml-new" style="background:#90EE90"> is any </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90">) has the same effect as the binary form </span><code><span class="deltaxml-new" style="background:#90EE90">.??modifier::KS</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The semantics are defined as follows.</span></p><p><span class="deltaxml-new" style="background:#90EE90">First we define the </span><b><span class="deltaxml-new" style="background:#90EE90">recursive content</span></b><span class="deltaxml-new" style="background:#90EE90"> of an item as follows:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function immediate-content($item as item()) as record(key, value)* {
  if ($item instance of map(*)) {
    map:pairs($item)
  } else if ($item instance of array(*)) {
    for member $m at $p in $item
    return map { "key": $p, "value": $m }
  }
};    
declare function recursive-content($item as item()) as record(key, value)* {
  immediate-content($item) ! (., ?items::value =!&gt; recursive-content())
};</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Explanation: the immediate content of a map is obtained by splitting it into a sequence of key-value pairs, each representing one entry. The immediate content of an array is obtained by constructing a sequence of key-value pairs, one for each array member, where the key is the array index and the value is the corresponding member. Each key-value pair is of type </span><code><span class="deltaxml-new" style="background:#90EE90">record(key as xs:anyAtomicType, value as item()*)</span></code><span class="deltaxml-new" style="background:#90EE90">. The recursive content of an item contains the key-value pairs in its immediate content, each followed by the recursive content obtained by expanding any maps or arrays in the immediate content. </span></p></div><p><span class="deltaxml-new" style="background:#90EE90">It is then useful to represent the recursive content as a sequence of singleton maps: so each pair </span><code><span class="deltaxml-new" style="background:#90EE90">{ "key": $K, "value": $V }</span></code><span class="deltaxml-new" style="background:#90EE90"> is converted to the form </span><code><span class="deltaxml-new" style="background:#90EE90">{ $K: $V }</span></code><span class="deltaxml-new" style="background:#90EE90">. This can be achieved using the expression </span><code><span class="deltaxml-new" style="background:#90EE90">recursive-content($V) ! { ?key: ?value }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In addition we define the function </span><code><span class="deltaxml-new" style="background:#90EE90">array-or-map</span></code><span class="deltaxml-new" style="background:#90EE90"> as follows:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function array-or-map($item as item()) {
  typeswitch ($item) {
    case array(*) | map(*) return $item
    default return error(xs:QName("err:XPTY0004"))
  }
}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">E??pairs::KS</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> is any expression and </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is any </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90">, is then:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">((</span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> =!&gt; array-or-map() =&gt; recursive-content()) 
                  ! { ?key: ?value })
                  ? pairs::</span><var><span class="deltaxml-new" style="background:#90EE90">KS</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This is best explained by considering examples.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Consider the expression </span><code><span class="deltaxml-new" style="background:#90EE90">let $V := [ { "first": "John", "last": "Smith" }, { "first": "Mary", "last": "Evans" } ]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The recursive content of this array is the sequence of six maps:</span></p><ol class="enumar"><li><p><code><span class="deltaxml-new" style="background:#90EE90">{ "key": 1, "value": { "first": "John", "last": "Smith" } }</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">{ "key": 2, "value": { "first": "Mary", "last": "Evans" } }</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">{ "key": "first", "value": "John" }</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">{ "key": "last", "value": "Smith" }</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">{ "key": "first", "value": "Mary" }</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">{ "key": "last", "value": "Evans" }</span></code></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$V??pairs::*</span></code><span class="deltaxml-new" style="background:#90EE90"> returns this sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">With some other </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$V??pairs::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> returns selected items from this sequence that match </span><code><span class="deltaxml-new" style="background:#90EE90">KS</span></code><span class="deltaxml-new" style="background:#90EE90">. Formally this is achieved by converting the key-value pairs to singleton maps, applying the </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90"> to the sequence of singleton maps, and then converting the result back into a sequence of key-value pairs.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, given the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$V??pairs::first</span></code><span class="deltaxml-new" style="background:#90EE90">, the selection from the converted sequence will include the two singleton maps </span><code><span class="deltaxml-new" style="background:#90EE90">{ "first" : "John" }</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">{ "first" : "Mary" }</span></code><span class="deltaxml-new" style="background:#90EE90">, which will be delivered in key-value pair form as </span><code><span class="deltaxml-new" style="background:#90EE90">{ "key": "first", "value": "John" }, { "key": "first", "value": "Mary" }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The effect of using modifiers other than </span><code><span class="deltaxml-new" style="background:#90EE90">pairs</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as with shallow lookup expressions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the modifier is </span><code><span class="deltaxml-new" style="background:#90EE90">items</span></code><span class="deltaxml-new" style="background:#90EE90"> (explicitly or by default), the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V??items::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V??pairs::KS ! map:get(., "value")</span></code><span class="deltaxml-new" style="background:#90EE90">; that is, it is the </span><a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a><span class="deltaxml-new" style="background:#90EE90"> of the value parts.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the modifier is </span><code><span class="deltaxml-new" style="background:#90EE90">values</span></code><span class="deltaxml-new" style="background:#90EE90">, the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V??values::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V??pairs::KS ! array{ map:get(., "value") }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the modifier is </span><code><span class="deltaxml-new" style="background:#90EE90">keys</span></code><span class="deltaxml-new" style="background:#90EE90">, the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V??keys::KS</span></code><span class="deltaxml-new" style="background:#90EE90"> is the same as the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$V??pairs::KS ! map:get(., "key")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This means that with the example given earlier:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$V ?? first</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">"John", "Mary"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$V ?? last</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">"Smith", "Evans"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$V ?? 1</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">{ "first": "John", "last": "Smith" }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$V ?? type(record(first, last)) ! `{?first} {?last}`</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">"John Smith", "Mary Evans"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The effect of evaluating all shallow lookups on maps rather than arrays is that no error arises if an array subscript is out of bounds. In the above example, </span><code><span class="deltaxml-new" style="background:#90EE90">$value??3</span></code><span class="deltaxml-new" style="background:#90EE90"> would return an empty sequence, it would not raise an error.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This also affects the way an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> key value is handled. Given the shallow lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">$A?$x</span></code><span class="deltaxml-new" style="background:#90EE90">, if </span><code><span class="deltaxml-new" style="background:#90EE90">$A</span></code><span class="deltaxml-new" style="background:#90EE90"> is an array and </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> (after atomization) is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> then the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> is converted to an integer (by virtue of the coercion rules applying to a call on </span><code><span class="deltaxml-new" style="background:#90EE90">array:get</span></code><span class="deltaxml-new" style="background:#90EE90">). With a deep lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">$A??$x</span></code><span class="deltaxml-new" style="background:#90EE90">, by contrast, the semantics are defined in terms of a map lookup, in which </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> items are always treated as strings. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The definition of the </span><code><span class="deltaxml-new" style="background:#90EE90">recursive-content</span></code><span class="deltaxml-new" style="background:#90EE90"> function is such that items in the top-level value that are not maps or arrays are ignored, whereas items that are not themselves maps or arrays, but which appear in the content of a map or array at the top level, are included. This means that </span><code><span class="deltaxml-new" style="background:#90EE90">E??X</span></code><span class="deltaxml-new" style="background:#90EE90"> mirrors the behavior of </span><code><span class="deltaxml-new" style="background:#90EE90">E//X</span></code><span class="deltaxml-new" style="background:#90EE90">, in that it includes all items that are one-or-more levels deep in the tree.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The result of the deep lookup operator retains order when processing sequences and arrays, but not when processing maps.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An expression involving multiple deep lookup operators may return duplicates. For example, the result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">[ [ [ "a" ], [ "b" ] ], [ [ "c" ], [ "d" ] ] ] ?? 1 ?? 1</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">([ "a" ], "a", "b", "a", "c")</span></code><span class="deltaxml-new" style="background:#90EE90">. This is because the first </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90"> operator selects members in position 1 at all three levels, that is it selects the arrays </span><code><span class="deltaxml-new" style="background:#90EE90">[ [ "a" ], [ "b" ] ]</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">[ "a" ]</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">[ "c" ]</span></code><span class="deltaxml-new" style="background:#90EE90"> as well as each of the four string values. The second </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90"> operator selects members in position 1 within each of these values, which results in the string </span><code><span class="deltaxml-new" style="background:#90EE90">"a"</span></code><span class="deltaxml-new" style="background:#90EE90"> being selected twice.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A type error is raised if the value of the left-hand expression includes an item that is neither a map nor an array.</span></p></div><div class="example"><div class="exampleHeader"><a id="ex-deep-lookup"></a><span class="deltaxml-new" style="background:#90EE90">Example: Examples of Deep Lookup Expressions</span></div><p><span class="deltaxml-new" style="background:#90EE90">Consider the tree </span><code><span class="deltaxml-new" style="background:#90EE90">$tree</span></code><span class="deltaxml-new" style="background:#90EE90"> of maps and arrays that results from applying the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:parse-json</span></code><span class="deltaxml-new" style="background:#90EE90"> function to the following input:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{
  "desc"    : "Distances between several cities, in kilometers.",
  "updated" : "2014-02-04T18:50:45",
  "uptodate": true,
  "author"  : null,
  "cities"  : {
    "Brussels": [
      { "to": "London",    "distance": 322 },
      { "to": "Paris",     "distance": 265 },
      { "to": "Amsterdam", "distance": 173 }
    ],
    "London": [
      { "to": "Brussels",  "distance": 322 },
      { "to": "Paris",     "distance": 344 },
      { "to": "Amsterdam", "distance": 358 }
    ],
    "Paris": [
      { "to": "Brussels",  "distance": 265 },
      { "to": "London",    "distance": 344 },
      { "to": "Amsterdam", "distance": 431 }
     ],
    "Amsterdam": [
      { "to": "Brussels",  "distance": 173 },
      { "to": "London",    "distance": 358 },
      { "to": "Paris",     "distance": 431 }
    ]
  }
}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">Given two variables </span><code><span class="deltaxml-new" style="background:#90EE90">$from</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$to</span></code><span class="deltaxml-new" style="background:#90EE90"> containing the names of two cities that are present in this table, the distance between the two cities can be obtained with the expression:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$tree ??$from ??type(record(to, distance))[?to=$to] ?distance</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The names of all pairs of cities whose distance is represented in the data can be obtained with the expression:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$tree ??$cities =&gt; 
     map:for-each( fn($key, $val) { $val ??to ! ($key || "-" || .) } )</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></p><div class="example"><div class="exampleHeader"><a id="d5e33661"></a><span class="deltaxml-new" style="background:#90EE90">Example: Comparison with JSONPath</span></div><p><span class="deltaxml-new" style="background:#90EE90">This example provides XPath equivalents to some examples given in the JSONPath specification. [TODO: add a reference].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The examples query the result of parsing the following JSON value, representing a store whose stock consists of four books and a bicycle:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{
  "store": {
    "book": [
      {
        "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      {
        "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      {
        "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      {
        "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 399
    }
  }
}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The following table illustrates some queries on this data, expressed both in JSONPath and in XQuery 4.0 and XPath 4.0.</span></p><div class="small"><table style="width:100%" class="small"><caption><span class="deltaxml-new" style="background:#90EE90">JSONPath vs XQuery 4.0 and XPath 4.0 Comparison</span></caption><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Query</span></th><th><span class="deltaxml-new" style="background:#90EE90">JSONPath</span></th><th><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0</span></th></tr></thead><tbody><tr><td><span class="deltaxml-new" style="background:#90EE90">The authors of all books in the store</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$.store.book[*].author</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m?store?book??author</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">All authors</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..author</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??author</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">All things in store (four books and a red bicycle)</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$.store.* </span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m?store?*</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">The prices of everything in the store</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$.store..price</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m?store??price</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">The third book</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..book[2] </span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??book?3</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">The third book's author</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..book[2].author</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??book?3?author</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">The third book's publisher (empty result)</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..book[2].publisher</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??book?3?publisher</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">The last book (in order)</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..book[-1]</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??book =&gt; array:foot()</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">The first two books</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..book[0,1]</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??book?(1,2)</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">All books with an ISBN</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..book[?@.isbn]</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??book[?isbn]</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">All books cheaper than 10</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..book[?@.price&lt;10]</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??book[?price lt 10]</span></code></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">All member values and array elements contained in the input value</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">$..*</span></code></td><td><code><span class="deltaxml-new" style="background:#90EE90">$m??*</span></code></td></tr></tbody></table></div></div></div><div class="div4"><h5><a id="id-implausible-lookup-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.14.3.4 Implausible Lookup Expressions</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Under certain conditions a lookup expression that will never select anything is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90">. During the static analysis phase, a processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> (subject to the rules in </span><a href="#id-implausible-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.6 Implausible Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">) report a static error when such lookup expressions are encountered: [</span><a href="#ERRXPTY0145" title="err:XPTY0145"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0145</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">More specifically, a shallow unary or postfix lookup is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> if any of the following conditions applies:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is a record test (see </span><a href="#id-record-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.3 Record Test</span></b></a><span class="deltaxml-new" style="background:#90EE90">), and the </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is a record test (see </span><a href="#id-record-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.3 Record Test</span></b></a><span class="deltaxml-new" style="background:#90EE90">), and the </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></code><span class="deltaxml-new" style="background:#90EE90"> that cannot validly appear as a field name in the record. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is a map type, and the inferred type of the </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90">, after coercion, is a type that is disjoint with the key type of the map. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The inferred type of the left-hand operand (or the context value, in the case of a unary expression) is an array type, and the </span><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90"> is the </span><code><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></code><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90"> (zero). </span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Other errors, such as using an </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><code><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></code><span class="deltaxml-new" style="background:#90EE90"> for an array lookup, are handled under the general provisions for type errors.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Examples of implausible lookup expressions include the following:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">parse-uri($uri)?3</span></code><span class="deltaxml-new" style="background:#90EE90">: the declared result type of </span><code><span class="deltaxml-new" style="background:#90EE90">parse-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> is a record test, so the selector </span><code><span class="deltaxml-new" style="background:#90EE90">3</span></code><span class="deltaxml-new" style="background:#90EE90"> will never select anything.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">in-scope-namespaces($node)(current-date())</span></code><span class="deltaxml-new" style="background:#90EE90">: the result type of </span><code><span class="deltaxml-new" style="background:#90EE90">in-scope-namespaces</span></code><span class="deltaxml-new" style="background:#90EE90"> is a map with </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> keys, so the selector </span><code><span class="deltaxml-new" style="background:#90EE90">current-date()</span></code><span class="deltaxml-new" style="background:#90EE90"> will never select anything.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array:subarray($a, 2, 5)?0</span></code><span class="deltaxml-new" style="background:#90EE90">: the integer zero cannot select any member of an array, because numbering starts at 1.</span></p></li></ul></div></div><div class="div3"><h4><a id="id-filter-maps-and-arrays"></a><span class="deltaxml-new" style="background:#90EE90">4.14.4 Filter Expressions for Maps and Arrays</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-unordered-expressions"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-lookup"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Filter expressions for maps and arrays are introduced. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1159"><span class="deltaxml-new" style="background:#90EE90">1159</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1163"><span class="deltaxml-new" style="background:#90EE90">1163</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;20 April 2024]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Predicates in filter expressions for maps and arrays can now be numeric. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1207"><span class="deltaxml-new" style="background:#90EE90">1207</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/tba"><span class="deltaxml-new" style="background:#90EE90">tba</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;15 May 2024]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FilterExprAM" id="doc-xpath40-FilterExprAM"></a><span class="deltaxml-new" style="background:#90EE90">[162]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FilterExprAM"><span class="deltaxml-new" style="background:#90EE90">FilterExprAM</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> "?[" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "]"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Maps and arrays can be filtered using the construct </span><code><var><span class="deltaxml-new" style="background:#90EE90">INPUT</span></var><span class="deltaxml-new" style="background:#90EE90">?[</span><var><span class="deltaxml-new" style="background:#90EE90">FILTER</span></var><span class="deltaxml-new" style="background:#90EE90">]</span></code><span class="deltaxml-new" style="background:#90EE90">. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">$array?[count(.)=1]</span></code><span class="deltaxml-new" style="background:#90EE90"> filters an array to retain only those members that are single items.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The character-pair </span><code><span class="deltaxml-new" style="background:#90EE90">?[</span></code><span class="deltaxml-new" style="background:#90EE90"> forms a single token; no intervening whitespace or comment is allowed.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The required type of the left-hand operand </span><code><var><span class="deltaxml-new" style="background:#90EE90">INPUT</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">(map(*)|array(*))?</span></code><span class="deltaxml-new" style="background:#90EE90">: that is, it must be either an empty sequence, a single map, or a single array [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">]. If it is an empty sequence, the result of the expression is an empty sequence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the value of </span><code><var><span class="deltaxml-new" style="background:#90EE90">INPUT</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is an array, then the </span><code><var><span class="deltaxml-new" style="background:#90EE90">FILTER</span></var></code><span class="deltaxml-new" style="background:#90EE90"> expression is evaluated for each member of the array, with that member as the context value, with its position in the array as the context position, and with the size of the array as the context size. The result of the expression is an array containing those members of the input array for which the </span><a title="predicate truth value" class="termref" href="#dt-predicate-truth-value"><span class="deltaxml-new" style="background:#90EE90">predicate truth value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><var><span class="deltaxml-new" style="background:#90EE90">FILTER</span></var></code><span class="deltaxml-new" style="background:#90EE90"> expression is true. The order of retained members is preserved.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the following expression:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $array := [(), (1), (2,3), (4,5,6)] return $array?[count(.) ge 2]</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">returns:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[(2,3), (4,5,6)]</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Numeric predicates are handled in the same way as with filter expressions for sequences. However, the result is always an array, even if only one member is selected. For example, given the </span><code><span class="deltaxml-new" style="background:#90EE90">$array</span></code><span class="deltaxml-new" style="background:#90EE90"> shown above, the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$array?[3]</span></code><span class="deltaxml-new" style="background:#90EE90"> is the singleton array </span><code><span class="deltaxml-new" style="background:#90EE90">[(2, 3)]</span></code><span class="deltaxml-new" style="background:#90EE90">. Contrast this with </span><code><span class="deltaxml-new" style="background:#90EE90">$array?3</span></code><span class="deltaxml-new" style="background:#90EE90"> which delivers the sequence </span><code><span class="deltaxml-new" style="background:#90EE90">2, 3</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">If the value of </span><code><var><span class="deltaxml-new" style="background:#90EE90">INPUT</span></var></code><span class="deltaxml-new" style="background:#90EE90"> is a map, then the </span><code><var><span class="deltaxml-new" style="background:#90EE90">FILTER</span></var></code><span class="deltaxml-new" style="background:#90EE90"> expression is evaluated for each entry in the map, with the context value set to an item of type </span><code><span class="deltaxml-new" style="background:#90EE90">record(key as xs:anyAtomicType, value as item()*)</span></code><span class="deltaxml-new" style="background:#90EE90">, in which the </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> fields represent the key and value of the map entry. The context position is the position of the entry in the map (in an arbitrary ordering), and the context size is the number of entries in the map. The result of the expression is a map containing those entries of the input map for which the </span><a title="predicate truth value" class="termref" href="#dt-predicate-truth-value"><span class="deltaxml-new" style="background:#90EE90">predicate truth value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><var><span class="deltaxml-new" style="background:#90EE90">FILTER</span></var></code><span class="deltaxml-new" style="background:#90EE90"> expression is true.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the following expression:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let map := { 1: "alpha", 2: "beta", 3: "gamma" } return $map?[?key ge 2]</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">returns:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{ 2: "beta", 3: "gamma" }</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Filtering of maps based on numeric positions is not generally useful, because the order of entries in a map is unpredictable; but it is available in the interests of orthogonality. </span></p></div></div><div class="div3"><h4><a id="id-pinned-maps-and-arrays"></a><span class="deltaxml-new" style="background:#90EE90">4.14.5 Pinned Maps and Arrays</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Unlike navigation within node trees derived from XML, navigation within a tree of maps and arrays derived from JSON is normally “downwards only”: there is no equivalent of the parent or ancestor axis. This means, for example, that having selected leav nodes in the tree with an expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">??name</span></code><span class="deltaxml-new" style="background:#90EE90">, there is no way of navigating from the items in the result to any related items. Pinned maps and arrays provide a solution to this problem; if a map or array is pinned (by calling the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:pin</span></code><span class="deltaxml-new" style="background:#90EE90"> function), then values found by navigating within the map or array are </span><b><span class="deltaxml-new" style="background:#90EE90">labeled</span></b><span class="deltaxml-new" style="background:#90EE90">, which provides supplementary information about their location within the containing tree structure.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For further information about pinned and labeled values see </span><span class="markup-error"><span class="deltaxml-new" style="background:#90EE90">[TITLE OF DM40 SPEC, TITLE OF id-labeled-items SECTION]</span><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup></span><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">More specifically, if a map </span><code><span class="deltaxml-new" style="background:#90EE90">$M</span></code><span class="deltaxml-new" style="background:#90EE90"> or an array </span><code><span class="deltaxml-new" style="background:#90EE90">$A</span></code><span class="deltaxml-new" style="background:#90EE90"> is pinned, then any value returned by </span><code><span class="deltaxml-new" style="background:#90EE90">map:get($M, $key)</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">array:get($A, $index)</span></code><span class="deltaxml-new" style="background:#90EE90"> will be a sequence of labeled items. The label can be obtained by calling the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:label</span></code><span class="deltaxml-new" style="background:#90EE90">, and the result will be a map having the following properties:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">pinned</span></code><span class="deltaxml-new" style="background:#90EE90">: set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">. This means that any further selections from this value (if it is itself a map or array) will also deliver labeled items.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90">: the containing map (</span><code><span class="deltaxml-new" style="background:#90EE90">$M</span></code><span class="deltaxml-new" style="background:#90EE90">) or array (</span><code><span class="deltaxml-new" style="background:#90EE90">$A</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90">: the key (</span><code><span class="deltaxml-new" style="background:#90EE90">$key</span></code><span class="deltaxml-new" style="background:#90EE90">) or index (</span><code><span class="deltaxml-new" style="background:#90EE90">$index</span></code><span class="deltaxml-new" style="background:#90EE90">) that was used to select the item.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">position</span></code><span class="deltaxml-new" style="background:#90EE90">: in the general case the value returned by </span><code><span class="deltaxml-new" style="background:#90EE90">map:get</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">array:get</span></code><span class="deltaxml-new" style="background:#90EE90"> is a sequence, and each item in the sequence is labeled with its 1-based position in that sequence.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">ancestors</span></code><span class="deltaxml-new" style="background:#90EE90">: a zero-arity function that delivers the item's parent (its containing map or array), that item's parent, and so on, recursively, up to the map or array that was the root of the selection. The sequence is in upwards navigation order (the immediate parent comes first).</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">path</span></code><span class="deltaxml-new" style="background:#90EE90">: a zero-arity function that delivers the sequence of keys (in the case of maps) or integer indexes (in the case of arrays) by which the item was reached. The sequence is in downwards navigation order (the immediate key or index of the item comes last).</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The formal model for the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:pin</span></code><span class="deltaxml-new" style="background:#90EE90"> is that it returns a deep copy of the supplied map or array in which all items in the recursive content have been labeled. This is a useful model because it avoids the need to specify the effect of each individual function and operator on the structure. For example, the rule has the consequence that the result of </span><code><span class="deltaxml-new" style="background:#90EE90">pin([ 11, 12, 13, 14 ]) =&gt; array:remove(3) =&gt; array:for-each(fn { label(.)?key })</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">[ 1, 2, 4 ]</span></code><span class="deltaxml-new" style="background:#90EE90">. In a practical implementation, however, it is likely that labels will be attached to items lazily, at the time they are retrieved. Such an implementation will need to recognize pinned maps and arrays and treat them specially when operations such as </span><code><span class="deltaxml-new" style="background:#90EE90">array:get</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">array:remove</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">array:for-each</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">array:subarray</span></code><span class="deltaxml-new" style="background:#90EE90">, and their map counterparts, are evaluated.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Because maps and arrays selected from a pinned map or array are themselves pinned, deep lookup operations (whether conducted using the deep lookup operator </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90">, or the </span><code><span class="deltaxml-new" style="background:#90EE90">map:find</span></code><span class="deltaxml-new" style="background:#90EE90"> function, or by user-written recursive code) will deliver a labeled value whose </span><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><span class="deltaxml-new" style="background:#90EE90"> properties can be used to navigate back up through the tree.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, given the example map shown in </span><a href="#id-map-constructors"><b><span class="deltaxml-new" style="background:#90EE90">4.14.1.1 Map Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">$map??last[. = "Suciu"]</span></code><span class="deltaxml-new" style="background:#90EE90"> selects the map entry with key </span><code><span class="deltaxml-new" style="background:#90EE90">"last"</span></code><span class="deltaxml-new" style="background:#90EE90"> and value </span><code><span class="deltaxml-new" style="background:#90EE90">"Suciu"</span></code><span class="deltaxml-new" style="background:#90EE90">, but by itself gives no information about where this entry was found. By first pinning the map, this extra information can be made available through the label on the result. For example you can select all co-authors of "Suciu" by writing:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">pin($map)??last[. = "Suciu"] =&gt; label()?ancestors()?author??last</span></pre></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">When an entry in a map, or a member of an array, has the empty sequence as its value, the value contains no items and is therefore unchanged in the pinned version of the containing structure. In addition, the lookup operators </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90"> flatten their result to a single sequence, so any empty values are effectively discarded from the result. For this reason, pinned arrays and maps work best when all values in arrays and maps are singleton items. An option is therefore provided on the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:parse-json</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:json-doc</span></code><span class="deltaxml-new" style="background:#90EE90"> functions to change the representation of JSON </span><code><span class="deltaxml-new" style="background:#90EE90">null</span></code><span class="deltaxml-new" style="background:#90EE90"> values (whose default is an empty sequence, </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90">) to a user-supplied value.</span></p></div><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b><span class="deltaxml-new" style="background:#90EE90">Editorial note</span></b></td><td style="text-align: right; vertical-align:top; width: 50%;"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span></td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2"><span class="deltaxml-new" style="background:#90EE90">That note is anticipating a proposal in a separate PR.</span></td></tr></tbody></table></div></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-unordered-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.15 Ordered and Unordered Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-conditionals"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-filter-maps-and-arrays"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">ordered{E}</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">unordered{E}</span></code><span class="deltaxml-new" style="background:#90EE90"> expressions are retained for backwards compatibility reasons, but in XQuery 4.0 they are deprecated and have no useful effect. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1339"><span class="deltaxml-new" style="background:#90EE90">1339</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OrderedExpr" id="doc-xpath40-OrderedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[177]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"ordered" </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-UnorderedExpr" id="doc-xpath40-UnorderedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[178]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnorderedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">UnorderedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"unordered" </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e30887.doc-xpath40-EnclosedExpr" id="noid_d4e30887.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">This syntax is retained from earlier versions of XQuery; in XQuery 4.0 it is deprecated and has no effect.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The constructs </span><code><span class="deltaxml-new" style="background:#90EE90">ordered{E}</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">unordered{E}</span></code><span class="deltaxml-new" style="background:#90EE90"> both return the result of evaluating the expression </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In addition to </span><code><span class="deltaxml-new" style="background:#90EE90">ordered</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">unordered</span></code><span class="deltaxml-new" style="background:#90EE90"> expressions, XQuery provides a function named </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unordered</span></code><span class="deltaxml-new" style="background:#90EE90"> that operates on any sequence of items and returns the same sequence in an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> order. A call to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unordered</span></code><span class="deltaxml-new" style="background:#90EE90"> function may be thought of as giving permission for the argument expression to be materialized in whatever order the system finds most efficient. The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unordered</span></code><span class="deltaxml-new" style="background:#90EE90"> function relaxes ordering only for the sequence that is its immediate operand, whereas the </span><code><span class="deltaxml-new" style="background:#90EE90">unordered</span></code><span class="deltaxml-new" style="background:#90EE90"> expression in earlier XQuery versions sets the ordering mode for its operand expression and all nested expressions.</span></p></div></div></div><div class="div2"><h3><a id="id-conditionals"></a><span class="deltaxml-new" style="background:#90EE90">4.16 Conditional Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-otherwise"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-unordered-expressions"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Alternative syntax for conditional expressions is available: </span><code><span class="deltaxml-new" style="background:#90EE90">if (condition) {X} else {Y}</span></code><span class="deltaxml-new" style="background:#90EE90">, with the </span><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><span class="deltaxml-new" style="background:#90EE90"> part being optional. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/234"><span class="deltaxml-new" style="background:#90EE90">234</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/284"><span class="deltaxml-new" style="background:#90EE90">284</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;23 January 2023]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 allows conditional expressions to be written in several different ways.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-IfExpr" id="doc-xpath40-IfExpr"></a><span class="deltaxml-new" style="background:#90EE90">[97]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">IfExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"if" "(" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")" (</span><a href="#doc-xpath40-UnbracedActions"><span class="deltaxml-new" style="background:#90EE90">UnbracedActions</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-BracedActions"><span class="deltaxml-new" style="background:#90EE90">BracedActions</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-UnbracedActions" id="doc-xpath40-UnbracedActions"></a><span class="deltaxml-new" style="background:#90EE90">[98]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnbracedActions"><span class="deltaxml-new" style="background:#90EE90">UnbracedActions</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"then" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> "else" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BracedActions" id="doc-xpath40-BracedActions"></a><span class="deltaxml-new" style="background:#90EE90">[99]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BracedActions"><span class="deltaxml-new" style="background:#90EE90">BracedActions</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ThenAction"><span class="deltaxml-new" style="background:#90EE90">ThenAction</span></a><a href="#doc-xpath40-ElseIfAction"><span class="deltaxml-new" style="background:#90EE90">ElseIfAction</span></a><span class="deltaxml-new" style="background:#90EE90">* </span><a href="#doc-xpath40-ElseAction"><span class="deltaxml-new" style="background:#90EE90">ElseAction</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ThenAction" id="doc-xpath40-ThenAction"></a><span class="deltaxml-new" style="background:#90EE90">[100]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ThenAction"><span class="deltaxml-new" style="background:#90EE90">ThenAction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ElseIfAction" id="doc-xpath40-ElseIfAction"></a><span class="deltaxml-new" style="background:#90EE90">[101]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ElseIfAction"><span class="deltaxml-new" style="background:#90EE90">ElseIfAction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"else" "if" "(" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")" </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ElseAction" id="doc-xpath40-ElseAction"></a><span class="deltaxml-new" style="background:#90EE90">[102]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ElseAction"><span class="deltaxml-new" style="background:#90EE90">ElseAction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"else" </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e30946.doc-xpath40-EnclosedExpr" id="noid_d4e30946.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">There are two formats with essentially the same semantics.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The unbraced expression </span><code><span class="deltaxml-new" style="background:#90EE90">if (C) then T else E</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to the braced expression </span><code><span class="deltaxml-new" style="background:#90EE90">if (C) {T} else {E}</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> of a conditional expression using the braced format is obtained by applying the following rules in order, finishing as soon as </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> has a value:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Let </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> be the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the test expression, as defined in </span><a href="#id-ebv"><b><span class="deltaxml-new" style="background:#90EE90">2.5.4 Effective Boolean Value</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> is true, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is the value of the </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-ThenAction"><span class="deltaxml-new" style="background:#90EE90">ThenAction</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#doc-xpath40-ElseIfAction"><span class="deltaxml-new" style="background:#90EE90">ElseIfActions</span></a><span class="deltaxml-new" style="background:#90EE90"> (if any) are processed in order as follows:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">Let </span><var><span class="deltaxml-new" style="background:#90EE90">C′</span></var><span class="deltaxml-new" style="background:#90EE90"> be the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of the test expression, as defined in </span><a href="#id-ebv"><b><span class="deltaxml-new" style="background:#90EE90">2.5.4 Effective Boolean Value</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><var><span class="deltaxml-new" style="background:#90EE90">C′</span></var><span class="deltaxml-new" style="background:#90EE90"> is true, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is the value of the </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-ElseIfAction"><span class="deltaxml-new" style="background:#90EE90">ElseIfAction</span></a></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If there is an </span><a href="#doc-xpath40-ElseAction"><span class="deltaxml-new" style="background:#90EE90">ElseAction</span></a><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is the value of its </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is the empty sequence.</span></p></li></ol></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Conditional expressions have a special rule for propagating </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><span><span class="deltaxml-new" style="background:#90EE90">expressions whose value is not needed for computing the result are </span><a title="guarded" class="termref" href="#dt-guarded"><span class="deltaxml-new" style="background:#90EE90">guarded</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#id-guarded-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.5 Guarded Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">, to prevent spurious dynamic errors.</span></span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of conditional expressions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">In this example, the test expression is a comparison expression:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">if ($widget1/unit-cost &lt; $widget2/unit-cost)
  then $widget1
  else $widget2</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">In this example, the test expression tests for the existence of an attribute named </span><code><span class="deltaxml-new" style="background:#90EE90">discounted</span></code><span class="deltaxml-new" style="background:#90EE90">, independently of its value:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">if ($part/@discounted)
  then $part/wholesale
  else $part/retail</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The above expression can equivalently be written:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">if ($part/@discounted) {
  $part/wholesale
} else {
  $part/retail
}</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example returns the attribute node </span><code><span class="deltaxml-new" style="background:#90EE90">@discount</span></code><span class="deltaxml-new" style="background:#90EE90"> provided the value of </span><code><span class="deltaxml-new" style="background:#90EE90">@price</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than 100; otherwise it returns the empty sequence:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">if (@price gt 100) {@discount}</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following example tests a number of conditions:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">if (@code = 1) {
  "food"
} else if (@code = 2) {
  "fashion"
} else if (@code = 3) {
  "household"
} else {
  "general"
}</span></pre></div></div></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The “dangling else ambiguity” found in many other languages cannot arise:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">In the unbraced format, both the </span><code><span class="deltaxml-new" style="background:#90EE90">then</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses are mandatory.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In the braced format, an </span><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is always unambiguously associated with the immediately containing </span><a href="#doc-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">IfExpr</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div></div><div class="div2"><h3><a id="id-otherwise"></a><span class="deltaxml-new" style="background:#90EE90">4.17 Otherwise Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-switch"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-conditionals"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> An </span><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><span class="deltaxml-new" style="background:#90EE90"> operator is introduced: </span><code><span class="deltaxml-new" style="background:#90EE90">A otherwise B</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the value of </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90">, unless it is an empty sequence, in which case it returns the value of </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90">. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1024"><span class="deltaxml-new" style="background:#90EE90">1024</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1031"><span class="deltaxml-new" style="background:#90EE90">1031</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;27 February 2024]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OtherwiseExpr" id="doc-xpath40-OtherwiseExpr"></a><span class="deltaxml-new" style="background:#90EE90">[110]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">OtherwiseExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringConcatExpr"><span class="deltaxml-new" style="background:#90EE90">StringConcatExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "otherwise" </span><a href="#doc-xpath40-StringConcatExpr"><span class="deltaxml-new" style="background:#90EE90">StringConcatExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><span class="deltaxml-new" style="background:#90EE90"> expression returns the value of its first operand, unless this is an empty sequence, in which case it returns the value of its second operand.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, </span><code><span class="deltaxml-new" style="background:#90EE90">@price - (@discount otherwise 0)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the value of </span><code><span class="deltaxml-new" style="background:#90EE90">@price - @discount</span></code><span class="deltaxml-new" style="background:#90EE90">, if the attribute </span><code><span class="deltaxml-new" style="background:#90EE90">@discount</span></code><span class="deltaxml-new" style="background:#90EE90"> exists, or the value of </span><code><span class="deltaxml-new" style="background:#90EE90">@price</span></code><span class="deltaxml-new" style="background:#90EE90"> if the </span><code><span class="deltaxml-new" style="background:#90EE90">@discount</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is absent.</span></p><p><span class="deltaxml-new" style="background:#90EE90">To prevent spurious errors, the right hand operand is </span><a title="guarded" class="termref" href="#dt-guarded"><span class="deltaxml-new" style="background:#90EE90">guarded</span></a><span class="deltaxml-new" style="background:#90EE90">: it cannot throw any dynamic error unless the left-hand operand returns an empty sequence.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The operator is associative (even under error conditions): </span><code><span class="deltaxml-new" style="background:#90EE90">A otherwise (B otherwise C)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the same result as </span><code><span class="deltaxml-new" style="background:#90EE90">(A otherwise B) otherwise C</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><span class="deltaxml-new" style="background:#90EE90"> operator binds more tightly than comparison operators such as </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90">, but less tightly than string concatenation (</span><code><span class="deltaxml-new" style="background:#90EE90">||</span></code><span class="deltaxml-new" style="background:#90EE90">) or arithemetic operators. The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$a = @x otherwise @y + 1</span></code><span class="deltaxml-new" style="background:#90EE90"> parses as </span><code><span class="deltaxml-new" style="background:#90EE90">$a = (@x otherwise (@y + 1))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-switch"></a><span class="deltaxml-new" style="background:#90EE90">4.18 Switch Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-quantified-expressions"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-otherwise"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Switch expressions now allow a </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause to match multiple atomic items. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/328"><span class="deltaxml-new" style="background:#90EE90">328</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/364"><span class="deltaxml-new" style="background:#90EE90">364</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;7 March 2023]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Switch and typeswitch expressions can now be written with curly braces, to improve readability. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/365"><span class="deltaxml-new" style="background:#90EE90">365</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/587"><span class="deltaxml-new" style="background:#90EE90">587</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;7 November 2023]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The comparand expression in a switch expression can be omitted, allowing the switch cases to be provided as arbitrary boolean expressions. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/671"><span class="deltaxml-new" style="background:#90EE90">671</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/678"><span class="deltaxml-new" style="background:#90EE90">678</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;12 September 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SwitchExpr" id="doc-xpath40-SwitchExpr"></a><span class="deltaxml-new" style="background:#90EE90">[86]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SwitchExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"switch" </span><a href="#doc-xpath40-SwitchComparand" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchComparand</span></a><span class="deltaxml-new" style="background:#90EE90">? (</span><a href="#doc-xpath40-SwitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-BracedSwitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BracedSwitchCases</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SwitchComparand" id="doc-xpath40-SwitchComparand"></a><span class="deltaxml-new" style="background:#90EE90">[87]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SwitchComparand" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchComparand</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SwitchCases" id="doc-xpath40-SwitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[88]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SwitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SwitchCaseClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseClause</span></a><span class="deltaxml-new" style="background:#90EE90">+ "default" "return" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BracedSwitchCases" id="doc-xpath40-BracedSwitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[89]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BracedSwitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BracedSwitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-SwitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SwitchCaseClause" id="doc-xpath40-SwitchCaseClause"></a><span class="deltaxml-new" style="background:#90EE90">[90]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SwitchCaseClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("case" </span><a href="#doc-xpath40-SwitchCaseOperand" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseOperand</span></a><span class="deltaxml-new" style="background:#90EE90">)+ "return" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SwitchCaseOperand" id="doc-xpath40-SwitchCaseOperand"></a><span class="deltaxml-new" style="background:#90EE90">[91]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SwitchCaseOperand" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseOperand</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> The </span><b><span class="deltaxml-new" style="background:#90EE90">switch expression</span></b><span class="deltaxml-new" style="background:#90EE90"> chooses one of several expressions to evaluate based on the input value. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> In a </span><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, the </span><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is followed by an expression enclosed in parentheses, called the </span><b><span class="deltaxml-new" style="background:#90EE90">switch comparand</span></b><span class="deltaxml-new" style="background:#90EE90">. This is the expression whose value is being compared. </span><span><span class="deltaxml-new" style="background:#90EE90">This expression is optional, and defaults to </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></span><span class="deltaxml-new" style="background:#90EE90"> The remainder of the </span><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression consists of one or more </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses, with one or more </span><code><span class="deltaxml-new" style="background:#90EE90">case operand expressions</span></code><span class="deltaxml-new" style="background:#90EE90"> each, and a </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The first step in evaluating a switch expression is to apply atomization to the value of the switch comparand. </span><span><span class="deltaxml-new" style="background:#90EE90">Call the result the </span><b><span class="deltaxml-new" style="background:#90EE90">switch value</span></b><span class="deltaxml-new" style="background:#90EE90">. If the </span><b><span class="deltaxml-new" style="background:#90EE90">switch value</span></b></span><span class="deltaxml-new" style="background:#90EE90"> is a sequence of length greater than one, a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">]. In the absence of a switch comparand, the switch value is the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><span><b><span class="deltaxml-new" style="background:#90EE90">switch value</span></b><span class="deltaxml-new" style="background:#90EE90"> is compared to</span></span><span class="deltaxml-new" style="background:#90EE90"> each </span><a href="#doc-xpath40-SwitchCaseOperand"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseOperand</span></a><span class="deltaxml-new" style="background:#90EE90"> in turn until a match is found or the list is exhausted. The matching is performed as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#doc-xpath40-SwitchCaseOperand"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseOperand</span></a><span class="deltaxml-new" style="background:#90EE90"> is evaluated.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The resulting value is atomized: call this the </span><b><span class="deltaxml-new" style="background:#90EE90">case value</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><b><span class="deltaxml-new" style="background:#90EE90">case value</span></b><span class="deltaxml-new" style="background:#90EE90"> is an empty sequence, then a match occurs if and only if the </span><b><span class="deltaxml-new" style="background:#90EE90">switch value</span></b><span class="deltaxml-new" style="background:#90EE90"> is an empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the singleton </span><b><span class="deltaxml-new" style="background:#90EE90">switch value</span></b><span class="deltaxml-new" style="background:#90EE90"> is compared individually with each item in the </span><b><span class="deltaxml-new" style="background:#90EE90">case value</span></b><span class="deltaxml-new" style="background:#90EE90"> in turn, and a match occurs if and only if these two atomic items compare equal under the rules of the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> function with default options, using the default collation in the static context.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="id-effective-case-switch-expression" title="effective case"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">effective case</span></b><span class="deltaxml-new" style="background:#90EE90"> of a switch expression is the first case clause that matches, using the rules given above, or the default clause if no such case clause exists.] The value of the switch expression is the value of the return expression in the effective case.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Switch expressions have rules regarding the propagation of dynamic errors: </span><span><span class="deltaxml-new" style="background:#90EE90">see </span><a href="#id-guarded-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.5 Guarded Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">. These rules mean that</span></span><span class="deltaxml-new" style="background:#90EE90"> the return clauses of a switch expression must not raise any dynamic errors except in the effective case. Dynamic errors raised in the operand expressions of the switch or the case clauses are propagated; however, an implementation must not raise dynamic errors in the operand expressions of case clauses that occur after the effective case. An implementation is permitted to raise dynamic errors in the operand expressions of case clauses that occur before the effective case, but not required to do so.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example shows how a switch expression might be used:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">switch ($animal) {
  case "Cow" return "Moo"
  case "Cat" return "Meow"
  case "Duck", "Goose" return "Quack"
  default return "What's that odd noise?"
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The curly braces in a switch expression are optional. The above example can equally be written:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">switch ($animal) 
  case "Cow" return "Moo"
  case "Cat" return "Meow"
  case "Duck", "Goose" return "Quack"
  default return "What's that odd noise?"</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a switch expression where the comparand is defaulted to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">switch {
  case ($a le $b) return "lesser"
  case ($a ge $b) return "greater"
  case ($a eq $b) return "equal"
  default return "not comparable"
}</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The comparisons are performed using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> function, after atomization. This means that a case expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">@married</span></code><span class="deltaxml-new" style="background:#90EE90"> tests </span><code><span class="deltaxml-new" style="background:#90EE90">fn:data(@married)</span></code><span class="deltaxml-new" style="background:#90EE90"> rather than </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean(@married)</span></code><span class="deltaxml-new" style="background:#90EE90">. If the effective boolean value of the expression is wanted, this can be achieved with an explicit call of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div></div><div class="div2"><h3><a id="id-quantified-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.19 Quantified Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-typeswitch"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-switch"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> If a type declaration is present, the supplied values in the input sequence are now coerced to the required type. Type declarations are now permitted in XPath as well as XQuery. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1316"><span class="deltaxml-new" style="background:#90EE90">1316</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1384"><span class="deltaxml-new" style="background:#90EE90">1384</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;13 August 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">Quantified expressions support existential and universal quantification. The value of a quantified expression is always </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-QuantifiedExpr" id="doc-xpath40-QuantifiedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[84]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("some" | "every") </span><a href="#doc-xpath40-QuantifierBinding"><span class="deltaxml-new" style="background:#90EE90">QuantifierBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-QuantifierBinding"><span class="deltaxml-new" style="background:#90EE90">QuantifierBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)* "satisfies" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-QuantifierBinding" id="doc-xpath40-QuantifierBinding"></a><span class="deltaxml-new" style="background:#90EE90">[85]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QuantifierBinding"><span class="deltaxml-new" style="background:#90EE90">QuantifierBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e31383.doc-xpath40-TypeDeclaration" id="noid_d4e31383.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">quantified expression</span></b><span class="deltaxml-new" style="background:#90EE90"> begins with a </span><b><span class="deltaxml-new" style="background:#90EE90">quantifier</span></b><span class="deltaxml-new" style="background:#90EE90">, which is the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><span class="deltaxml-new" style="background:#90EE90">, followed by one or more in-clauses that are used to bind variables, followed by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">satisfies</span></code><span class="deltaxml-new" style="background:#90EE90"> and a test expression. Each in-clause associates a variable with an expression that returns a sequence of items, called the binding sequence for that variable. The value of the quantified expression is defined by the following rules:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> contains more than one </span><a href="#doc-xpath40-QuantifierBinding"><span class="deltaxml-new" style="background:#90EE90">QuantifierBinding</span></a><span class="deltaxml-new" style="background:#90EE90">, then it is equivalent to the expression obtained by replacing each comma with </span><code><span class="deltaxml-new" style="background:#90EE90">satisfies some</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">satisfies every</span></code><span class="deltaxml-new" style="background:#90EE90"> respectively. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">some $x in X, $y in Y satisfies $x = $y</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">some $x in X satisfies some $y in Y satisfies $x = $y</span></code><span class="deltaxml-new" style="background:#90EE90">, while the expression </span><code><span class="deltaxml-new" style="background:#90EE90">every $x in X, $y in Y satisfies $x lt $y</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">every $x in X satisfies every $y in Y satisfies $x lt $y</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the quantifier is </span><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if at least one evaluation of the test expression has the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. In consequence, if the binding sequence is empty, the result of the </span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the quantifier is </span><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if every evaluation of the test expression has the </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. In consequence, if the binding sequence is empty, the result of the </span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The scope of a variable bound in a quantified expression comprises all subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Each variable binding may be accompanied by a </span><b><span class="deltaxml-new" style="background:#90EE90">type declaration</span></b><span class="deltaxml-new" style="background:#90EE90">, which consists of the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the static type of the variable, declared using the syntax in </span><a href="#id-sequencetype-syntax"><b><span class="deltaxml-new" style="background:#90EE90">3.1 Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The type declaration defines a required type for the value. At run-time, the supplied value for the variable is converted to the required type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. If conversion is not possible, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The order in which test expressions are evaluated for the various items in the binding sequence is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">. If the quantifier is </span><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><span class="deltaxml-new" style="background:#90EE90">, an implementation may return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> as soon as it finds one item for which the test expression has an </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, and it may raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> as soon as it finds one item for which the test expression raises an error. Similarly, if the quantifier is </span><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><span class="deltaxml-new" style="background:#90EE90">, an implementation may return </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> as soon as it finds one item for which the test expression has an </span><a title="effective boolean value" class="termref" href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, and it may raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> as soon as it finds one item for which the test expression raises an error. As a result of these rules, the value of a quantified expression is not deterministic in the presence of errors, as illustrated in the examples below.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of quantified expressions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This expression is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if every </span><code><span class="deltaxml-new" style="background:#90EE90">part</span></code><span class="deltaxml-new" style="background:#90EE90"> element has a </span><code><span class="deltaxml-new" style="background:#90EE90">discounted</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute (regardless of the values of these attributes):</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">every $part in /parts/part satisfies $part/@discounted</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This expression is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if at least one </span><code><span class="deltaxml-new" style="background:#90EE90">employee</span></code><span class="deltaxml-new" style="background:#90EE90"> element satisfies the given comparison expression:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">some $emp in /emps/employee satisfies
  ($emp/bonus &gt; 0.25 * $emp/salary)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This expression is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if every </span><code><span class="deltaxml-new" style="background:#90EE90">employee</span></code><span class="deltaxml-new" style="background:#90EE90"> element has at least one </span><code><span class="deltaxml-new" style="background:#90EE90">salary</span></code><span class="deltaxml-new" style="background:#90EE90"> child with the attribute </span><code><span class="deltaxml-new" style="background:#90EE90">current="true"</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">every $emp in /emps/employee satisfies (
  some $sal in $emp/salary satisfies $sal/@current = 'true'              
)</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Like many quantified expressions, this can be simplified. This example can be written </span><code><span class="deltaxml-new" style="background:#90EE90">every $emp in /emps/employee satisfies $emp/salary[@current = 'true']</span></code><span class="deltaxml-new" style="background:#90EE90">, or even more concisely as </span><code><span class="deltaxml-new" style="background:#90EE90">empty(/emps/employee[not(salary/@current = 'true')]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Another alternative in XQuery 4.0 and XPath 4.0 is to use the higher-order functions </span><code><span class="deltaxml-new" style="background:#90EE90">fn:some</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:every</span></code><span class="deltaxml-new" style="background:#90EE90">. This example can be written </span><code><span class="deltaxml-new" style="background:#90EE90">fn:every(/emps/employee, fn { salary/@current = 'true' })</span></code></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">In the following examples, each quantified expression evaluates its test expression over nine pairs of items, formed from the Cartesian product of the sequences </span><code><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">(2, 3, 4)</span></code><span class="deltaxml-new" style="background:#90EE90">. The expression beginning with </span><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, and the expression beginning with </span><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</span></pre></div></div><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">every $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This quantified expression may either return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or raise a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90">, since its test expression returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> for one item and raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> for another:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">some $x in (1, 2, "cat") satisfies $x * 2 = 4</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This quantified expression may either return </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> or raise a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90">, since its test expression returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> for one item and raises a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> for another:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">every $x in (1, 2, "cat") satisfies $x * 2 = 4</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This quantified expression returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, because the binding sequence is empty, despite the fact that the condition can never be satisfied:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">every $x in () satisfies ($x lt 0 and $x gt 0)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This quantified expression is </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> because it will always fail with a type error except in the case where </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> is an empty sequence. If </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> contains one or more </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90"> values, a processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90"> raise a type error on the grounds that an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90"> cannot be compared to an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">. If </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, the processor </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> (or may not) report this error:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">every $x as xs:date in $input satisfies ($x lt 0)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This quantified expression contains a </span><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">type declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> that is not satisfied by every item in the test expression. The expression may either return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> or raise a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4</span></pre></div></div></li></ul></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-try-catch"></a><span class="deltaxml-new" style="background:#90EE90">4.20 Try/Catch Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The try/catch expression provides error handling for dynamic errors and type errors raised during dynamic evaluation, including errors raised by the XQuery implementation and errors explicitly raised in a query using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:error()</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TryCatchExpr" id="doc-xpath40-TryCatchExpr"></a><span class="deltaxml-new" style="background:#90EE90">[103]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TryCatchExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TryCatchExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TryClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TryClause</span></a><a href="#doc-xpath40-CatchClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CatchClause</span></a><span class="deltaxml-new" style="background:#90EE90">+</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TryClause" id="doc-xpath40-TryClause"></a><span class="deltaxml-new" style="background:#90EE90">[104]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TryClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TryClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"try" </span><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CatchClause" id="doc-xpath40-CatchClause"></a><span class="deltaxml-new" style="background:#90EE90">[105]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CatchClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CatchClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"catch" </span><a href="#doc-xpath40-NameTestUnion" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e31727.doc-xpath40-NameTestUnion" id="noid_d4e31727.doc-xpath40-NameTestUnion"></a><span class="deltaxml-new" style="background:#90EE90">[106]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTestUnion" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NameTest" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-NameTest" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e31728.doc-xpath40-NameTest" id="noid_d4e31728.doc-xpath40-NameTest"></a><span class="deltaxml-new" style="background:#90EE90">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTest" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-Wildcard" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e31729.doc-xpath40-EnclosedExpr" id="noid_d4e31729.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A try/catch expression catches </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90"> raised by the evaluation of the target expression of the </span><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><span class="deltaxml-new" style="background:#90EE90"> clause. If the the </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of the try clause does not raise a dynamic error or a type error, the result of the try/catch expression is the result of the content expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the target expression raises a dynamic error or a type error, the result of the try/catch expression is obtained by evaluating the first </span><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><span class="deltaxml-new" style="background:#90EE90"> clause that “matches” the error value, as described below. If no catch clause “matches” the error value, then the try/catch expression raises the error that was raised by the target expression. A </span><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><span class="deltaxml-new" style="background:#90EE90"> clause with one or more NameTests matches any error whose error code matches one of these NameTests. For instance, if the error code is </span><code><span class="deltaxml-new" style="background:#90EE90">err:FOER0000</span></code><span class="deltaxml-new" style="background:#90EE90">, then it matches a </span><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><span class="deltaxml-new" style="background:#90EE90"> clause whose ErrorList is </span><code><span class="deltaxml-new" style="background:#90EE90">err:FOER0000 | err:FOER0001</span></code><span class="deltaxml-new" style="background:#90EE90">. Wildcards may be used in NameTests; thus, the error code </span><code><span class="deltaxml-new" style="background:#90EE90">err:FOER0000</span></code><span class="deltaxml-new" style="background:#90EE90"> also matches a </span><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><span class="deltaxml-new" style="background:#90EE90"> clause whose ErrorList is </span><code><span class="deltaxml-new" style="background:#90EE90">err:*</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">*:FOER0000</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Within the scope of the </span><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, a number of variables are implicitly declared, giving information about the error that occurred. These variables are initialized as described in the following table:</span></p><div class="medium"><table class="medium"><thead><tr><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Variable</span></th><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Type</span></th><th style="text-align:left"><span class="deltaxml-new" style="background:#90EE90">Value</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:code</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">The error code</span></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:description</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">xs:string?</span></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">A description of the error condition; an empty sequence if no description is available (for example, if the </span><code><span class="deltaxml-new" style="background:#90EE90">error</span></code><span class="deltaxml-new" style="background:#90EE90"> function was called with one argument).</span></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:value</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">item()*</span></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">Value associated with the error. For an error raised by calling the </span><code><span class="deltaxml-new" style="background:#90EE90">error</span></code><span class="deltaxml-new" style="background:#90EE90"> function, this is the value of the third argument (if supplied).</span></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:module</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">xs:string?</span></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">The URI (or system ID) of the module containing the expression where the error occurred, or an empty sequence if the information is not available.</span></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:line-number</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">xs:integer?</span></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">The line number within the module where the error occurred, or an empty sequence if the information is not available. The value </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be approximate.</span></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:column-number</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">xs:integer?</span></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">The column number within the module where the error occurred, or an empty sequence if the information is not available. The value </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be approximate.</span></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:additional</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">item()*</span></td><td style="vertical-align:top"><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">Implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. This variable must be bound so that a query can reference it without raising an error. The purpose of this variable is to allow implementations to provide any additional information that might be useful.</span></td></tr><tr><td style="vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">$err:map</span></code></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">map(*)</span></td><td style="vertical-align:top"><span class="deltaxml-new" style="background:#90EE90">A map with entries for all values that are bound to the variables above. The local names of the variables are assigned as keys. No map entries are created for those values that are empty sequences. The variable can be used to pass on all error information to another function.</span></td></tr></tbody></table></div><p><span class="deltaxml-new" style="background:#90EE90">Try/catch expressions have a special rule for propagating dynamic errors. The try/catch expression ignores any dynamic errors encountered in catch clauses other than the first catch clause that matches an error raised by the try clause, and these catch clause expressions need not be evaluated.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Static errors are not caught by the try/catch expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a function call occurs within a </span><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, errors raised by evaluating the corresponding function are caught by the try/catch expression. If a variable reference is used in a </span><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, errors raised by binding a value to the variable are not caught unless the binding expression occurs within the </span><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><span class="deltaxml-new" style="background:#90EE90"> clause.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The presence of a try/catch expression does not prevent an implementation from using a lazy evaluation strategy, nor does it prevent an optimizer performing expression rewrites. However, if the evaluation of an expression inside a try/catch is rewritten or deferred in this way, it must take its try/catch context with it. Similarly, expressions that were written outside the try/catch expression may be evaluated inside the try/catch, but only if they retain their original try/catch behavior. The presence of a try/catch does not change the rules that allow the processor to evaluate expressions in such a way that may avoid the detection of some errors. </span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of try/catch expressions.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A try/catch expression without name tests catches any error:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">try {
  $x cast as xs:integer
} catch * {
  0
}</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">With the following catch clause, only </span><code><span class="deltaxml-new" style="background:#90EE90">err:FORG0001</span></code><span class="deltaxml-new" style="background:#90EE90"> is caught:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">try {
  $x cast as xs:integer
} catch err:FORG0001 {
  0
}</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This try/catch expression specifies that errors </span><code><span class="deltaxml-new" style="background:#90EE90">err:FORG0001</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></code><span class="deltaxml-new" style="background:#90EE90"> are caught:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">try {
  $x cast as xs:integer
} catch err:FORG0001 | err:XPTY0004 {
  0
}</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In some implementations, </span><code><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></code><span class="deltaxml-new" style="background:#90EE90"> is detected during static evaluation; it can only be caught if it is raised during dynamic evaluation.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This try/catch expression shows how to return information about the error using implicitly defined error variables:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">try {
  error(QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
} catch * {
  $err:code, $err:value, " module: ",
  $err:module, "(", $err:line-number, ",", $err:column-number, ")"
}</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Errors raised by using the result of a try/catch expression are not caught, since they are outside the scope of the </span><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><span class="deltaxml-new" style="background:#90EE90"> expression.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:thrice($x as xs:integer) as xs:integer {
  3 * $x
};

local:thrice(try { "oops" } catch * { 3 } )</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">In this example, the try block succeeds, returning the string </span><code><span class="deltaxml-new" style="background:#90EE90">"oops"</span></code><span class="deltaxml-new" style="background:#90EE90">, which is not a valid argument to the function.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">All available information about the error is serialized:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">try {
  1 + &lt;empty/&gt;
} catch * {
  serialize($err:map, {'method':'adaptive'})
}</span></pre></div></div></li></ul></div></div><div class="div2"><h3><a id="id-expressions-on-datatypes"></a><span class="deltaxml-new" style="background:#90EE90">4.21 Expressions on SequenceTypes</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">instance of</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">castable</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> expressions are used to test whether a value conforms to a given type or to convert it to an instance of a given type. </span></p><div class="div3"><h4><a id="id-instance-of"></a><span class="deltaxml-new" style="background:#90EE90">4.21.1 Instance Of</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-InstanceofExpr" id="doc-xpath40-InstanceofExpr"></a><span class="deltaxml-new" style="background:#90EE90">[117]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InstanceofExpr"><span class="deltaxml-new" style="background:#90EE90">InstanceofExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TreatExpr"><span class="deltaxml-new" style="background:#90EE90">TreatExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "instance" "of" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The boolean operator </span><code><span class="deltaxml-new" style="background:#90EE90">instance of</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the value of its first operand matches the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> in its second operand, according to the rules for </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a><span class="deltaxml-new" style="background:#90EE90">; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. For example:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">5 instance of xs:integer</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This example returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> because the given value is an instance of the given type.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">5 instance of xs:decimal</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This example returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> because the given value is an integer literal, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This example returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> because the given value is an element rather than an integer.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">(5, 6) instance of xs:integer+</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This example returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> because the given sequence contains two integers, and is a valid instance of the specified type.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">. instance of element()</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This example returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the context value is a single element node or </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> if the context value is defined but is not a single element node. If the context value is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">An </span><code><span class="deltaxml-new" style="background:#90EE90">instance of</span></code><span class="deltaxml-new" style="background:#90EE90"> test does not allow any kind of casting or coercion. The results may therefore be counterintuitive. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">3 instance of xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, because the expression </span><code><span class="deltaxml-new" style="background:#90EE90">3</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, not </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">. For similar reasons, </span><code><span class="deltaxml-new" style="background:#90EE90">"red" instance of enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> returns false.</span></p><p><span class="deltaxml-new" style="background:#90EE90">On such occasions, a </span><code><span class="deltaxml-new" style="background:#90EE90">castable as</span></code><span class="deltaxml-new" style="background:#90EE90"> test may be more appropriate: see </span><a href="#id-castable"><b><span class="deltaxml-new" style="background:#90EE90">4.21.4 Castable</span></b></a></p></div></div><div class="xquery"><div class="div3 xquery"><h4><a id="id-typeswitch"></a><span class="deltaxml-new" style="background:#90EE90">4.21.2 Typeswitch</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-mapping-arrow-expression"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-quantified-expressions"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Switch and typeswitch expressions can now be written with curly braces, to improve readability. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/365"><span class="deltaxml-new" style="background:#90EE90">365</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/587"><span class="deltaxml-new" style="background:#90EE90">587</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;7 November 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypeswitchExpr" id="doc-xpath40-TypeswitchExpr"></a><span class="deltaxml-new" style="background:#90EE90">[92]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeswitchExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeswitchExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"typeswitch" "(" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")" (</span><a href="#doc-xpath40-TypeswitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeswitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-BracedTypeswitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BracedTypeswitchCases</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TypeswitchCases" id="doc-xpath40-TypeswitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[93]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeswitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeswitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CaseClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CaseClause</span></a><span class="deltaxml-new" style="background:#90EE90">+ "default" ("$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><span class="deltaxml-new" style="background:#90EE90">)? "return" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BracedTypeswitchCases" id="doc-xpath40-BracedTypeswitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[94]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BracedTypeswitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BracedTypeswitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-TypeswitchCases" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeswitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CaseClause" id="doc-xpath40-CaseClause"></a><span class="deltaxml-new" style="background:#90EE90">[95]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CaseClause" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CaseClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"case" ("$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><span class="deltaxml-new" style="background:#90EE90"> "as")? </span><a href="#doc-xpath40-SequenceTypeUnion" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceTypeUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> "return" </span><a href="#doc-xpath40-ExprSingle" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SequenceTypeUnion" id="doc-xpath40-SequenceTypeUnion"></a><span class="deltaxml-new" style="background:#90EE90">[96]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SequenceTypeUnion" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceTypeUnion</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SequenceType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-SequenceType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody></table><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></b><span class="deltaxml-new" style="background:#90EE90"> expression chooses one of several expressions to evaluate based on the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of an input value.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, the </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword is followed by an expression enclosed in parentheses, called the </span><b><span class="deltaxml-new" style="background:#90EE90">operand expression</span></b><span class="deltaxml-new" style="background:#90EE90">. This is the expression whose type is being tested. The remainder of the </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression consists of one or more </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses and a </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Each </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause specifies one or more </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">s followed by a </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> expression. [</span><a id="dt-effective-case" title="effective case"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">effective case</span></b><span class="deltaxml-new" style="background:#90EE90"> in a </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the first </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in which the value of the operand expression matches a </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceTypeUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, using the rules of </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a><span class="deltaxml-new" style="background:#90EE90">. ] The value of the </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the value of the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> expression in the effective case. If the value of the operand expression does not match any </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> named in a </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, the value of the </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the value of the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> expression in the </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, if the value to be returned depends on the value of the operand expression, the clause must specify a variable name. Within the </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> expression of the </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, this variable name is bound to the value of the operand expression. Inside a </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the variable is the union of the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">s named in the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceTypeUnion</span></a><span class="deltaxml-new" style="background:#90EE90">. Inside a </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, the static type of the variable is the same as the static type of the operand expression. If the value to be returned by a </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause does not depend on the value of the operand expression, the clause need not specify a variable.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The scope of a variable binding in a </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause comprises that clause. It is not an error for more than one </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in the same </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression to bind variables with the same name. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Typeswitch expressions have rules regarding the propagation of dynamic errors: </span><span><span class="deltaxml-new" style="background:#90EE90">see </span><a href="#id-guarded-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.5 Guarded Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">. These rules mean that</span></span><span class="deltaxml-new" style="background:#90EE90"> a </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression ignores (does not raise) any dynamic errors encountered in </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses other than the </span><a title="effective case" class="termref" href="#dt-effective-case"><span class="deltaxml-new" style="background:#90EE90">effective case</span></a><span class="deltaxml-new" style="background:#90EE90">. Dynamic errors encountered in the </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90"> clause are raised only if there is no </span><a title="effective case" class="termref" href="#dt-effective-case"><span class="deltaxml-new" style="background:#90EE90">effective case</span></a><span class="deltaxml-new" style="background:#90EE90">. An implementation is permitted to raise dynamic errors in the operand expressions of case clauses that occur before the </span><a title="effective case" class="termref" href="#dt-effective-case"><span class="deltaxml-new" style="background:#90EE90">effective case</span></a><span class="deltaxml-new" style="background:#90EE90">, but not required to do so.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The following example shows how a </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression might be used to process an expression in a way that depends on its </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">typeswitch($customer/billing-address) {
  case $a as element(*, USAddress)     return $a/state
  case $a as element(*, CanadaAddress) return $a/province
  case $a as element(*, JapanAddress)  return $a/prefecture
  default return "unknown"
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The curly braces in a </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression are optional. The above example can equally be written:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">typeswitch($customer/billing-address)
  case $a as element(*, USAddress)     return $a/state
  case $a as element(*, CanadaAddress) return $a/province
  case $a as element(*, JapanAddress)  return $a/prefecture
  default return "unknown"</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following example shows a union of sequence types in a single case:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">typeswitch($customer/billing-address) {
  case $a as element(*, USAddress) | element(*, MexicoAddress)
    return $a/state
  case $a as element(*, CanadaAddress)
    return $a/province
  case $a as element(*, JapanAddress)
    return $a/prefecture
  default
    return "unknown"
}</span></pre></div></div></div></div><div class="div3"><h4><a id="id-cast"></a><span class="deltaxml-new" style="background:#90EE90">4.21.3 Cast</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CastExpr" id="doc-xpath40-CastExpr"></a><span class="deltaxml-new" style="background:#90EE90">[120]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CastExpr"><span class="deltaxml-new" style="background:#90EE90">CastExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArrowExpr"><span class="deltaxml-new" style="background:#90EE90">ArrowExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "cast" "as" </span><a href="#doc-xpath40-CastTarget"><span class="deltaxml-new" style="background:#90EE90">CastTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"? )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CastTarget" id="doc-xpath40-CastTarget"></a><span class="deltaxml-new" style="background:#90EE90">[246]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CastTarget"><span class="deltaxml-new" style="background:#90EE90">CastTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e32298.doc-xpath40-ChoiceItemType" id="noid_d4e32298.doc-xpath40-ChoiceItemType"></a><span class="deltaxml-new" style="background:#90EE90">[264]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e32299.doc-xpath40-EnumerationType" id="noid_d4e32299.doc-xpath40-EnumerationType"></a><span class="deltaxml-new" style="background:#90EE90">[260]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"enum" "(" </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Sometimes it is necessary to convert a value to a specific datatype. For this purpose, XQuery 4.0 and XPath 4.0 provides a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression that creates a new value of a specific type based on an existing value. A </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression takes two operands: an </span><b><span class="deltaxml-new" style="background:#90EE90">input expression</span></b><span class="deltaxml-new" style="background:#90EE90"> and a </span><b><span class="deltaxml-new" style="background:#90EE90">target type</span></b><span class="deltaxml-new" style="background:#90EE90">. The type of the atomized value of the input expression is called the </span><b><span class="deltaxml-new" style="background:#90EE90">input type</span></b><span class="deltaxml-new" style="background:#90EE90">. The target type must be a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90">. In practice this means it may be any of:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The name of an </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><span class="deltaxml-new" style="background:#90EE90"> defined in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, which in turn must refer to an item type in one of the following categories.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The name of a type defined in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90">, which must be a simple type (of variety atomic, list or union) [</span><a href="#ERRXQST0052" title="err:XQST0052"><span class="deltaxml-new" style="background:#90EE90">err:XQST0052</span></a><span class="deltaxml-new" style="background:#90EE90">] . In addition, the target type cannot be </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anySimpleType</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></code><span class="deltaxml-new" style="background:#90EE90"> representing a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> (such as </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:date | xs:dateTime)</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An </span><code><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></code><span class="deltaxml-new" style="background:#90EE90"> such as </span><code><span class="deltaxml-new" style="background:#90EE90">enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, a static error is raised [</span><a href="#ERRXPST0080" title="err:XPST0080"><span class="deltaxml-new" style="background:#90EE90">err:XPST0080</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The optional occurrence indicator </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> denotes that an empty sequence is permitted.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Casting a node to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90"> can cause surprises because it uses the static context of the cast expression to provide the namespace bindings for this operation. Instead of casting to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">, it is generally preferable to use the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:QName</span></code><span class="deltaxml-new" style="background:#90EE90"> function, which allows the namespace context to be taken from the document containing the QName.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The semantics of the </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression are as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The input expression is evaluated.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The result of the first step is </span><a title="atomization" class="termref" href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomized</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If the result of atomization is a sequence of more than one atomic item, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is an empty sequence:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified after the target type, the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is an empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> is not specified after the target type, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the result of atomization is a single atomic item, the result of the cast expression is determined by casting to the target type as described in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#casting"><span class="deltaxml-new" style="background:#90EE90">Section 20 Casting</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. When casting, an implementation may need to determine whether one type is derived by restriction from another. An implementation can determine this either by examining the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> or by using an alternative, </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> mechanism such as a data dictionary. The result of a cast expression is one of the following: </span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90"> A value of the target type (or, in the case of list types, a sequence of values that are instances of the item type of the list type). </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> A type error, if casting from the source type to the target type is not supported (for example attempting to convert an integer to a date). </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> A dynamic error, if the particular input value cannot be converted to the target type (for example, attempting to convert the string </span><code><span class="deltaxml-new" style="background:#90EE90">"three"</span></code><span class="deltaxml-new" style="background:#90EE90"> to an integer). </span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Casting to an enumeration type relies on the fact that an enumeration type is a generalized atomic type. So </span><code><span class="deltaxml-new" style="background:#90EE90">cast $x as enum("red")</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to casting to an anonymous atomic type derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> whose enumeration facet restricts the value space to the single string </span><code><span class="deltaxml-new" style="background:#90EE90">"red"</span></code><span class="deltaxml-new" style="background:#90EE90">, while </span><code><span class="deltaxml-new" style="background:#90EE90">cast $x as enum("red", "green")</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to casting to </span><code><span class="deltaxml-new" style="background:#90EE90">(enum("red") | enum("green"))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ol></div><div class="div3"><h4><a id="id-castable"></a><span class="deltaxml-new" style="background:#90EE90">4.21.4 Castable</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CastableExpr" id="doc-xpath40-CastableExpr"></a><span class="deltaxml-new" style="background:#90EE90">[119]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CastableExpr"><span class="deltaxml-new" style="background:#90EE90">CastableExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CastExpr"><span class="deltaxml-new" style="background:#90EE90">CastExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "castable" "as" </span><a href="#doc-xpath40-CastTarget"><span class="deltaxml-new" style="background:#90EE90">CastTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"? )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e32474.doc-xpath40-CastTarget" id="noid_d4e32474.doc-xpath40-CastTarget"></a><span class="deltaxml-new" style="background:#90EE90">[246]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CastTarget"><span class="deltaxml-new" style="background:#90EE90">CastTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e32475.doc-xpath40-ChoiceItemType" id="noid_d4e32475.doc-xpath40-ChoiceItemType"></a><span class="deltaxml-new" style="background:#90EE90">[264]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e32476.doc-xpath40-EnumerationType" id="noid_d4e32476.doc-xpath40-EnumerationType"></a><span class="deltaxml-new" style="background:#90EE90">[260]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"enum" "(" </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 provides an expression that tests whether a given value is castable into a given target type. The </span><span><span class="deltaxml-new" style="background:#90EE90">target type</span></span><span class="deltaxml-new" style="background:#90EE90"> is subject to the same rules as the target type of a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">E castable as T</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> can be successfully cast into the target type </span><code><span class="deltaxml-new" style="background:#90EE90">T</span></code><span class="deltaxml-new" style="background:#90EE90"> by using a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> expression; otherwise it returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. If evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> fails with a dynamic error or if the value of </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> cannot be atomized, the </span><code><span class="deltaxml-new" style="background:#90EE90">castable</span></code><span class="deltaxml-new" style="background:#90EE90"> expression as a whole fails.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">castable</span></code><span class="deltaxml-new" style="background:#90EE90"> expression can be used as a </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new" style="background:#90EE90">predicate</span></a><span class="deltaxml-new" style="background:#90EE90"> to avoid errors at evaluation time. It can also be used to select an appropriate type for processing of a given value, as illustrated in the following example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">if ($x castable as hatsize)
  then $x cast as hatsize
  else if ($x castable as IQ)
  then $x cast as IQ
  else $x cast as xs:string</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$x castable as enum("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90"> is for most practical purposes equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">$x = ("red", "green", "blue")</span></code><span class="deltaxml-new" style="background:#90EE90">; the main difference is that it uses the Unicode codepoint collation for comparing strings, not the default collation from the static context.</span></p></div></div><div class="div3"><h4><a id="id-constructor-functions"></a><span class="deltaxml-new" style="background:#90EE90">4.21.5 Constructor Functions</span></h4><p><span class="deltaxml-new" style="background:#90EE90">For every simple type in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90"> (except </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anySimpleType</span></code><span class="deltaxml-new" style="background:#90EE90">, which are not instantiable), a </span><b><span class="deltaxml-new" style="background:#90EE90">constructor function</span></b><span class="deltaxml-new" style="background:#90EE90"> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for a given type depends on the type that is being constructed, and can be found in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#constructor-functions"><span class="deltaxml-new" style="background:#90EE90">Section 19 Constructor functions</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">There is also a constructor function for every </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> that expands either to a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span><span class="deltaxml-new" style="background:#90EE90">or to a </span><a href="#doc-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a></span><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">All such constructor functions are classified as </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system functions</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The constructor function is present in the static context if and only if the corresponding type is present in the static context.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For XSLT, this means that a constructor function corresponding to an imported schema type is private to the stylesheet package, and a constructor function corresponding to an </span><code><span class="deltaxml-new" style="background:#90EE90">xsl:item-type</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration has the same visibility as the </span><code><span class="deltaxml-new" style="background:#90EE90">xsl:item-type</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For XQuery, this means that a constructor function corresponding to an imported schema type is private to the query module, and a constructor function corresponding to a named item type declaration is </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> according to the annotations on the item type declaration.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-constructor-function" title="constructor function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">constructor function</span></b><span class="deltaxml-new" style="background:#90EE90"> for a given simple type is used to convert instances of other simple types into the given type. The semantics of the constructor function call </span><code><span class="deltaxml-new" style="background:#90EE90">T($arg)</span></code><span class="deltaxml-new" style="background:#90EE90"> are defined to be equivalent to the expression </span><code><span class="deltaxml-new" style="background:#90EE90">(($arg) cast as T?)</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate the use of constructor functions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This example is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">("2000-01-01" cast as xs:date?)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">xs:date("2000-01-01")</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">(($floatvalue * 0.2E-5) cast as xs:decimal?)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">xs:decimal($floatvalue * 0.2E-5)</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This example returns an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> value equal to 21 days. It is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">("P21D" cast as xs:dayTimeDuration?)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration("P21D")</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">usa:zipcode</span></code><span class="deltaxml-new" style="background:#90EE90"> is a user-defined </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90">, then the following expression is equivalent to the expression </span><code><span class="deltaxml-new" style="background:#90EE90">("12345" cast as usa:zipcode?)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">usa:zipcode("12345")</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">my:chrono</span></code><span class="deltaxml-new" style="background:#90EE90"> is a named item type that expands to </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:date | xs:time | xs:dateTime)</span></code><span class="deltaxml-new" style="background:#90EE90">, then the result of </span><code><span class="deltaxml-new" style="background:#90EE90">my:chrono("12:00:00Z")</span></code><span class="deltaxml-new" style="background:#90EE90"> is the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:time</span></code><span class="deltaxml-new" style="background:#90EE90"> value </span><code><span class="deltaxml-new" style="background:#90EE90">12:00:00Z</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">my:location</span></code><span class="deltaxml-new" style="background:#90EE90"> is a named item type that expands to </span><code><span class="deltaxml-new" style="background:#90EE90">record(latitude as xs:double, longitude as xs:double)</span></code><span class="deltaxml-new" style="background:#90EE90">, then the result of </span><code><span class="deltaxml-new" style="background:#90EE90">my:location(50.52, -3.02)</span></code><span class="deltaxml-new" style="background:#90EE90"> is the map </span><code><span class="deltaxml-new" style="background:#90EE90">{ 'latitude': 50.52e0, 'longitude': -3.02e0 }</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> An instance of an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> whose name is in no namespace can be constructed by using a </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a><span class="deltaxml-new" style="background:#90EE90"> in either a cast expression or a constructor function call. Examples: </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">17 cast as Q{}apple</span></pre></div></div><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">Q{}apple(17)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">In either context, using an unqualified NCName might not work: in a cast expression, an unqualified name is it is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">, while an unqualified name in a constructor function call is resolved using the </span><a title="default function namespace" class="termref" href="#dt-default-function-namespace"><span class="deltaxml-new" style="background:#90EE90">default function namespace</span></a><span class="deltaxml-new" style="background:#90EE90"> which will often be inappropriate. </span></p></div></div><div class="div3"><h4><a id="id-treat"></a><span class="deltaxml-new" style="background:#90EE90">4.21.6 Treat</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-TreatExpr" id="doc-xpath40-TreatExpr"></a><span class="deltaxml-new" style="background:#90EE90">[118]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TreatExpr"><span class="deltaxml-new" style="background:#90EE90">TreatExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CastableExpr"><span class="deltaxml-new" style="background:#90EE90">CastableExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "treat" "as" </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 provides an expression called </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> that can be used to modify the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of its operand.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Like </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> expression takes two operands: an expression and a </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">. Unlike </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90">, however, </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> does not change the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> or value of its operand. Instead, the purpose of </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> is to ensure that an expression has an expected dynamic type at evaluation time.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The semantics of </span><em><code><span class="deltaxml-new" style="background:#90EE90">expr1</span></code></em><code><span class="deltaxml-new" style="background:#90EE90"> treat as </span></code><em><code><span class="deltaxml-new" style="background:#90EE90">type1</span></code></em><span class="deltaxml-new" style="background:#90EE90"> are as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">During static analysis:</span></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is </span><em><code><span class="deltaxml-new" style="background:#90EE90">type1</span></code></em><span class="deltaxml-new" style="background:#90EE90">. This enables the expression to be used as an argument of a function that requires a parameter of </span><em><code><span class="deltaxml-new" style="background:#90EE90">type1</span></code></em><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">During expression evaluation:</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><em><code><span class="deltaxml-new" style="background:#90EE90">expr1</span></code></em><span class="deltaxml-new" style="background:#90EE90"> matches </span><em><code><span class="deltaxml-new" style="background:#90EE90">type1</span></code></em><span class="deltaxml-new" style="background:#90EE90">, using the rules for </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> expression returns the value of </span><em><code><span class="deltaxml-new" style="background:#90EE90">expr1</span></code></em><span class="deltaxml-new" style="background:#90EE90">; otherwise, it raises a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0050</span></a><span class="deltaxml-new" style="background:#90EE90">]. If the value of </span><em><code><span class="deltaxml-new" style="background:#90EE90">expr1</span></code></em><span class="deltaxml-new" style="background:#90EE90"> is returned, the identity of any nodes in the value is preserved. The </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> expression ensures that the value of its expression operand conforms to the expected type at run-time.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$myaddress treat as element(*, USAddress)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><code><span class="deltaxml-new" style="background:#90EE90">$myaddress</span></code><span class="deltaxml-new" style="background:#90EE90"> may be </span><code><span class="deltaxml-new" style="background:#90EE90">element(*, Address)</span></code><span class="deltaxml-new" style="background:#90EE90">, a less specific type than </span><code><span class="deltaxml-new" style="background:#90EE90">element(*, USAddress)</span></code><span class="deltaxml-new" style="background:#90EE90">. However, at run-time, the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$myaddress</span></code><span class="deltaxml-new" style="background:#90EE90"> must match the type </span><code><span class="deltaxml-new" style="background:#90EE90">element(*, USAddress)</span></code><span class="deltaxml-new" style="background:#90EE90"> using rules for </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a><span class="deltaxml-new" style="background:#90EE90">; otherwise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPDY0050" title="err:XPDY0050"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0050</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Earlier releases of XPath and XQuery defined a mode of operation, sometimes called strict static typing, in which it was required that the static type of every expression should conform to the required type of the context in which it appeared. In this situation it was often necessary to define a more precise static type for an expression by the use of </span><code><span class="deltaxml-new" style="background:#90EE90">treat as</span></code><span class="deltaxml-new" style="background:#90EE90">. In the absence of this feature, the </span><code><span class="deltaxml-new" style="background:#90EE90">treat as</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is rarely necessary, though it can be useful for documentation, and might in some cases (depending on the processor) have performance benefits. </span></p></div></div></div><div class="div2"><h3><a id="id-map-operator"></a><span class="deltaxml-new" style="background:#90EE90">4.22 Simple map operator (</span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SimpleMapExpr" id="doc-xpath40-SimpleMapExpr"></a><span class="deltaxml-new" style="background:#90EE90">[136]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SimpleMapExpr"><span class="deltaxml-new" style="background:#90EE90">SimpleMapExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ("!" </span><a href="#doc-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> A mapping expression </span><code><span class="deltaxml-new" style="background:#90EE90">S!E</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates the expression </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> once for every item in the sequence obtained by evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90">. The simple mapping operator </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90"> can be applied to any sequence, regardless of the types of its items, and it can deliver a mixed sequence of nodes, atomic items, and functions. Unlike the similar </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> operator, it does not sort nodes into document order or eliminate duplicates. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Each operation </span><code><span class="deltaxml-new" style="background:#90EE90">E1!E2</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated as follows: Expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated to a sequence </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90">. Each item in </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> then serves in turn to provide an inner focus (the item as the context value, its position in </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> as the context position, the length of </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> as the context size) for an evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">. The sequences resulting from all the evaluations of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> are combined as follows: Every evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a (possibly empty) sequence of items. The final result is the </span><a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a><span class="deltaxml-new" style="background:#90EE90"> of these sequences. The returned sequence preserves the orderings within and among the subsequences generated by the evaluations of </span><code><span class="deltaxml-new" style="background:#90EE90">E2</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Simple map operators have functionality similar to </span><a href="#id-path-operator"><b><span class="deltaxml-new" style="background:#90EE90">4.6.3 Path operator (/)</span></b></a><span class="deltaxml-new" style="background:#90EE90">. The following table summarizes the differences between these two operators</span></p><div class="medium"><table style="width:100%" class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Operator</span></th><th><span class="deltaxml-new" style="background:#90EE90">Path operator (</span><code><span class="deltaxml-new" style="background:#90EE90">E1 / E2</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></th><th><span class="deltaxml-new" style="background:#90EE90">Simple map operator (</span><code><span class="deltaxml-new" style="background:#90EE90">E1 ! E2</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></th></tr></thead><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">E1</span></th><td><span class="deltaxml-new" style="background:#90EE90">Any sequence of nodes</span></td><td><span class="deltaxml-new" style="background:#90EE90">Any sequence of items</span></td></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">E2</span></th><td><span class="deltaxml-new" style="background:#90EE90">Either a sequence of nodes or a sequence of non-node items</span></td><td><span class="deltaxml-new" style="background:#90EE90">A sequence of items</span></td></tr><tr><th><span class="deltaxml-new" style="background:#90EE90">Additional processing</span></th><td><span class="deltaxml-new" style="background:#90EE90">Duplicate elimination and document ordering</span></td><td><span class="deltaxml-new" style="background:#90EE90">Simple </span><a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a></td></tr></tbody></table></div><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate the use of simple map operators combined with path expressions.</span></p><div class="example"><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">child::div1 / child::para / string() ! concat("id-", .)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Selects the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the </span><code><span class="deltaxml-new" style="background:#90EE90">div1</span></code><span class="deltaxml-new" style="background:#90EE90"> element children of the context node; that is, the </span><code><span class="deltaxml-new" style="background:#90EE90">para</span></code><span class="deltaxml-new" style="background:#90EE90"> element grandchildren of the context node that have </span><code><span class="deltaxml-new" style="background:#90EE90">div1</span></code><span class="deltaxml-new" style="background:#90EE90"> parents. It then outputs the strings obtained by prepending </span><code><span class="deltaxml-new" style="background:#90EE90">"id-"</span></code><span class="deltaxml-new" style="background:#90EE90"> to each of the string values of these grandchildren.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$emp ! (@first, @middle, @last)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Returns the values of the attributes </span><code><span class="deltaxml-new" style="background:#90EE90">first</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">middle</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">last</span></code><span class="deltaxml-new" style="background:#90EE90"> for each element in </span><code><span class="deltaxml-new" style="background:#90EE90">$emp</span></code><span class="deltaxml-new" style="background:#90EE90">, in the order given. (The </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> operator, if used here, would return the attributes in an unpredictable order.)</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$docs ! ( //employee)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Returns all the </span><code><span class="deltaxml-new" style="background:#90EE90">employee</span></code><span class="deltaxml-new" style="background:#90EE90"> elements within all the documents identified by the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$docs</span></code><span class="deltaxml-new" style="background:#90EE90">, in document order within each document, but retaining the order of documents.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">avg( //employee / salary ! translate(., '$', '') ! number(.))</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Returns the average salary of the employees, having converted the salary to a number by removing any </span><code><span class="deltaxml-new" style="background:#90EE90">$</span></code><span class="deltaxml-new" style="background:#90EE90"> sign and then converting to a number. (The second occurrence of </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90"> could not be written as </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> because the left-hand operand of </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> cannot be an atomic item.)</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">string-join((1 to $n)!"*")</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Returns a string containing </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> asterisks.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$values!(.*.) =&gt; sum()</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Returns the sum of the squares of a sequence of numbers.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">string-join(ancestor::*!name(), '/')</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Returns the names of ancestor elements, joined by </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> characters, i.e., the path to the parent of the context.</span></p></li></ul></div></div><div class="div2"><h3><a id="id-arrow-operator"></a><span class="deltaxml-new" style="background:#90EE90">4.23 Arrow Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">Arrow expressions apply a function to a value, using the value of the left-hand expression as the first argument to the function.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArrowExpr" id="doc-xpath40-ArrowExpr"></a><span class="deltaxml-new" style="background:#90EE90">[121]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrowExpr"><span class="deltaxml-new" style="background:#90EE90">ArrowExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( (</span><a href="#doc-xpath40-SequenceArrowTarget"><span class="deltaxml-new" style="background:#90EE90">SequenceArrowTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-MappingArrowTarget"><span class="deltaxml-new" style="background:#90EE90">MappingArrowTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-LookupArrowTarget"><span class="deltaxml-new" style="background:#90EE90">LookupArrowTarget</span></a><span class="deltaxml-new" style="background:#90EE90">) )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SequenceArrowTarget" id="doc-xpath40-SequenceArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[124]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SequenceArrowTarget"><span class="deltaxml-new" style="background:#90EE90">SequenceArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=&gt;" </span><a href="#doc-xpath40-ArrowTarget"><span class="deltaxml-new" style="background:#90EE90">ArrowTarget</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MappingArrowTarget" id="doc-xpath40-MappingArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[125]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MappingArrowTarget"><span class="deltaxml-new" style="background:#90EE90">MappingArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=!&gt;" </span><a href="#doc-xpath40-ArrowTarget"><span class="deltaxml-new" style="background:#90EE90">ArrowTarget</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-LookupArrowTarget" id="doc-xpath40-LookupArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[127]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LookupArrowTarget"><span class="deltaxml-new" style="background:#90EE90">LookupArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=?&gt;" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><a href="#doc-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArrowTarget" id="doc-xpath40-ArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[126]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrowTarget"><span class="deltaxml-new" style="background:#90EE90">ArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#doc-xpath40-ArrowStaticFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowStaticFunction</span></a><a href="#doc-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a><span class="deltaxml-new" style="background:#90EE90">) | (</span><a href="#doc-xpath40-ArrowDynamicFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowDynamicFunction</span></a><a href="#doc-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArrowStaticFunction" id="doc-xpath40-ArrowStaticFunction"></a><span class="deltaxml-new" style="background:#90EE90">[168]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrowStaticFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowStaticFunction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ArrowDynamicFunction" id="doc-xpath40-ArrowDynamicFunction"></a><span class="deltaxml-new" style="background:#90EE90">[169]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrowDynamicFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowDynamicFunction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-InlineFunctionExpr"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e33096.doc-xpath40-InlineFunctionExpr" id="noid_d4e33096.doc-xpath40-InlineFunctionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[211]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InlineFunctionExpr"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* ("function" | "fn") </span><a href="#doc-xpath40-FunctionSignature"><span class="deltaxml-new" style="background:#90EE90">FunctionSignature</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-FunctionBody"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e33097.doc-xpath40-ArgumentList" id="noid_d4e33097.doc-xpath40-ArgumentList"></a><span class="deltaxml-new" style="background:#90EE90">[155]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" ((</span><a href="#doc-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)?) | </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e33098.doc-xpath40-PositionalArgumentList" id="noid_d4e33098.doc-xpath40-PositionalArgumentList"></a><span class="deltaxml-new" style="background:#90EE90">[156]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#doc-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a><span class="deltaxml-new" style="background:#90EE90">? ")"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The arrow syntax is particularly helpful when applying multiple functions to a value in turn. For example, the following expression invites syntax errors due to misplaced parentheses: </span></p><div class="parsetest"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">tokenize((normalize-unicode(upper-case($string))),"\s+")</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">In the following reformulation, it is easier to see that the parentheses are balanced:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$string =&gt; upper-case() =&gt; normalize-unicode() =&gt; tokenize("\s+")</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">When the operator is written as </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, the function is applied to each item in the sequence in turn. Assuming that </span><code><span class="deltaxml-new" style="background:#90EE90">$string</span></code><span class="deltaxml-new" style="background:#90EE90"> is a single string, the above example could equally be written:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$string =!&gt; upper-case() =!&gt; normalize-unicode() =!&gt; tokenize("\s+")</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The difference between the two operators is seen when the left-hand operand evaluates to a sequence:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3) =&gt; avg()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">returns a value of only one item, </span><code><span class="deltaxml-new" style="background:#90EE90">2</span></code><span class="deltaxml-new" style="background:#90EE90">, the average of all three items, whereas </span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3) =!&gt; avg()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">returns the original sequence of three items, </span><code><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3)</span></code><span class="deltaxml-new" style="background:#90EE90">, each item being the average of itself. The following example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">"The cat sat on the mat"
=&gt; tokenize()
=!&gt; concat(".")
=!&gt; upper-case()
=&gt; string-join(" ")</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">returns </span><code><span class="deltaxml-new" style="background:#90EE90">"THE. CAT. SAT. ON. THE. MAT."</span></code><span class="deltaxml-new" style="background:#90EE90">. The first arrow could be written either as </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> because the operand is a singleton; the next two arrows have to be </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> because the function is applied to each item in the tokenized sequence individually; the final arrow must be </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> because the </span><code><span class="deltaxml-new" style="background:#90EE90">string-join</span></code><span class="deltaxml-new" style="background:#90EE90"> function applies to the sequence as a whole.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">It may be useful to think of this as a map/reduce pipeline. The functions introduced by </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> are mapping operations; the function introduced by </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> is a reduce operation.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The following example introduces an inline function to the pipeline:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(1 to 5) =!&gt; xs:double() =!&gt; math:sqrt() =!&gt; fn($a) { $a + 1 }() =&gt; sum()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">This is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">sum((1 to 5) ! (math:sqrt(xs:double(.)) + 1))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The same effect can be achieved using a </span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-new" style="background:#90EE90">focus function</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(1 to 5) =!&gt; xs:double() =!&gt; math:sqrt() =!&gt; fn { . + 1 }() =&gt; sum()</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Where the value of an expression is a map containing functions, simulating the behavior of objects in object-oriented languages, then the </span><b><span class="deltaxml-new" style="background:#90EE90">lookup arrow operator</span></b><code><span class="deltaxml-new" style="background:#90EE90">=?&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> can be used to retrive a function from the map and to invoke the function with the map as its first argument. For example, if </span><code><span class="deltaxml-new" style="background:#90EE90">my:rectangle</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a map with entries </span><code><span class="deltaxml-new" style="background:#90EE90">width</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">height</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">expand</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">area</span></code><span class="deltaxml-new" style="background:#90EE90">, then it becomes possible to write:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">my:rectangle(3,5) =?&gt; expand(2) =?&gt; area()</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></code><span class="deltaxml-new" style="background:#90EE90"> may include </span><code><span class="deltaxml-new" style="background:#90EE90">PlaceHolders</span></code><span class="deltaxml-new" style="background:#90EE90">, though this is not especially useful. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">"$" =&gt; concat(?)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">concat("$", ?)</span></code><span class="deltaxml-new" style="background:#90EE90">: its value is a function that prepends a supplied string with a </span><code><span class="deltaxml-new" style="background:#90EE90">$</span></code><span class="deltaxml-new" style="background:#90EE90"> symbol.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></code><span class="deltaxml-new" style="background:#90EE90"> may include keyword arguments if the function is identified statically (that is, by name). For example, the following is valid: </span><code><span class="deltaxml-new" style="background:#90EE90">$xml =&gt; xml-to-json(indent := true()) =&gt; parse-json(escape := false())</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The sequence arrow operator thus applies the supplied function to the left-hand operand as a whole, while the mapping arrow operator applies the function to each item in the value of the left-hand operand individually. In the case where the result of the left-hand operand is a single item, the two operators have the same effect.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The mapping arrow symbol </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> is intended to suggest a combination of function application (</span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">) and sequence mapping (</span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90">) combined in a single operation.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, the lookup arrow symbol </span><code><span class="deltaxml-new" style="background:#90EE90">=?&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> is intended to suggest a combination of function application (</span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">) and map lookup (</span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90">) in a single operation.</span></p></div><div class="div3"><h4><a id="id-sequence-arrow-expression"></a><span class="deltaxml-new" style="background:#90EE90">4.23.1 Sequence Arrow Expressions</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-sequence-arrow-operator" title="sequence arrow operator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">sequence arrow operator</span></b><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> applies a function to a supplied sequence.] It is defined as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Given a </span><a href="#doc-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a><code><span class="deltaxml-new" style="background:#90EE90">U</span></code><span class="deltaxml-new" style="background:#90EE90">, an </span><a href="#doc-xpath40-ArrowStaticFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowStaticFunction</span></a><code><span class="deltaxml-new" style="background:#90EE90">F</span></code><span class="deltaxml-new" style="background:#90EE90">, and an </span><a href="#doc-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a><code><span class="deltaxml-new" style="background:#90EE90">(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">U =&gt; F(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to the expression </span><code><span class="deltaxml-new" style="background:#90EE90">F(U, A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Given a </span><a href="#doc-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a><code><span class="deltaxml-new" style="background:#90EE90">U</span></code><span class="deltaxml-new" style="background:#90EE90">, an </span><a href="#doc-xpath40-ArrowDynamicFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowDynamicFunction</span></a><code><span class="deltaxml-new" style="background:#90EE90">F</span></code><span class="deltaxml-new" style="background:#90EE90">, and an </span><a href="#doc-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a><code><span class="deltaxml-new" style="background:#90EE90">(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">U =&gt; F(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to the expression </span><code><span class="deltaxml-new" style="background:#90EE90">F(U, A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div><div class="div3"><h4><a id="id-mapping-arrow-expression"></a><span class="deltaxml-new" style="background:#90EE90">4.23.2 Mapping Arrow Expressions</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-validate"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-typeswitch"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The arrow operator </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> is now complemented by a “mapping arrow” operator </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> which applies the supplied function to each item in the input sequence independently. </span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-mapping-arrow-operator" title="mapping arrow operator"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">mapping arrow operator</span></b><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> applies a function to each item in a sequence.] It is defined as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the arrow is followed by an </span><a href="#doc-xpath40-ArrowStaticFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowStaticFunction</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><p><span class="deltaxml-new" style="background:#90EE90">Given a </span><a href="#doc-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a><code><span class="deltaxml-new" style="background:#90EE90">U</span></code><span class="deltaxml-new" style="background:#90EE90">, an </span><a href="#doc-xpath40-ArrowStaticFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowStaticFunction</span></a><code><span class="deltaxml-new" style="background:#90EE90">F</span></code><span class="deltaxml-new" style="background:#90EE90">, and an </span><a href="#doc-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a><code><span class="deltaxml-new" style="background:#90EE90">(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">U =!&gt; F(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to the expression </span><code><span class="deltaxml-new" style="background:#90EE90">(for $u in U return F($u, A, B, C...))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the arrow is followed by an </span><a href="#doc-xpath40-ArrowDynamicFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowDynamicFunction</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><p><span class="deltaxml-new" style="background:#90EE90">Given a </span><a href="#doc-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a><code><span class="deltaxml-new" style="background:#90EE90">U</span></code><span class="deltaxml-new" style="background:#90EE90">, an </span><a href="#doc-xpath40-ArrowDynamicFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowDynamicFunction</span></a><code><span class="deltaxml-new" style="background:#90EE90">F</span></code><span class="deltaxml-new" style="background:#90EE90">, and an </span><a href="#doc-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a><code><span class="deltaxml-new" style="background:#90EE90">(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90">, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">U =!&gt; F(A, B, C...)</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to the expression </span><code><span class="deltaxml-new" style="background:#90EE90">(for $u in U return F($u, A, B, C...))</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div><div class="div3"><h4><a id="lookup-arrow-expression"></a><span class="deltaxml-new" style="background:#90EE90">4.23.3 Lookup Arrow Expressions</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The lookup arrow expression simulates the behavior of method invocations in object-oriented languages. It is useful for invoking functions that are contained as entries in maps.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For example, the expression</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">let $rectangle := {
  "width": 20,
  "height": 12,
  "area": fn($this) { $this?width * $this?height }
} 
return $rectangle =?&gt; area()</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">returns the value </span><code><span class="deltaxml-new" style="background:#90EE90">240</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">M =?&gt; N(A, B, C)</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The left-hand expression </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> is evaluated. If the value is an empty sequence, then the result of the expression is an empty sequence. If it is non-empty then it must be a single map: call it </span><code><span class="deltaxml-new" style="background:#90EE90">$m</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">$m?N</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated. The result must be a single function item: call it </span><code><span class="deltaxml-new" style="background:#90EE90">$f</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The dynamic function call </span><code><span class="deltaxml-new" style="background:#90EE90">$f($m, A, B, C)</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, and the result is returned.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">Any of the above steps can lead to errors:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">A type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised if the value of the left hand expression does not match the type </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)?</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised if the value of the lookup expression </span><code><span class="deltaxml-new" style="background:#90EE90">$m?N</span></code><span class="deltaxml-new" style="background:#90EE90"> does not match the type </span><code><span class="deltaxml-new" style="background:#90EE90">function(*)</span></code><span class="deltaxml-new" style="background:#90EE90">, or if the arity of the function is not equal to the number of arguments in the argument list plus one.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An error may occur in evaluating the dynamic function call, for example if the function does not expect a map to be supplied as the first argument.</span></p></li></ol></div></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-validate"></a><span class="deltaxml-new" style="background:#90EE90">4.24 Validate Expressions</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-default-ordering-decl"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-mapping-arrow-expression"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules concerning the interpretation of </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:schemaLocation</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:noNamespaceSchemaLocation</span></code><span class="deltaxml-new" style="background:#90EE90"> attributes have been tightened up. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/729"><span class="deltaxml-new" style="background:#90EE90">729</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1254"><span class="deltaxml-new" style="background:#90EE90">1254</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;8 June 2024]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ValidateExpr" id="doc-xpath40-ValidateExpr"></a><span class="deltaxml-new" style="background:#90EE90">[131]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ValidateExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ValidateExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"validate" (</span><a href="#doc-xpath40-ValidationMode" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ValidationMode</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("type" </span><a href="#doc-xpath40-TypeName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">))? "{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ValidationMode" id="doc-xpath40-ValidationMode"></a><span class="deltaxml-new" style="background:#90EE90">[132]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ValidationMode" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ValidationMode</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"lax" | "strict"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e33492.doc-xpath40-EnclosedExpr" id="noid_d4e33492.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression can be used to validate a document node or an element node with respect to the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">, using the schema validation process defined in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. If the operand of a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression does not evaluate to exactly one document or element node, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQTY0030" title="err:XQTY0030"><span class="deltaxml-new" style="background:#90EE90">err:XQTY0030</span></a><span class="deltaxml-new" style="background:#90EE90">]. In this specification, the node that is the operand of a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is called the </span><b><span class="deltaxml-new" style="background:#90EE90">operand node</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression returns a new node with its own identity and with no parent. The new node and its descendants are given </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> that are generated by applying a validation process to the operand node. In some cases, default values may also be generated by the validation process.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression may optionally specify a </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90">. The default </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> (applicable when no type name is provided) is </span><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression may optionally specify a </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">. This type name must be found in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">; if it is not, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0104" title="err:XQST0104"><span class="deltaxml-new" style="background:#90EE90">err:XQST0104</span></a><span class="deltaxml-new" style="background:#90EE90">]. If the type name is unprefixed, it is interpreted according to the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The result of a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is defined by the following rules.</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90"> If the operand node is a document node, its children must consist of exactly one element node and zero or more comment and processing instruction nodes, in any order; otherwise, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQDY0061" title="err:XQDY0061"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0061</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The operand node is converted to an XML Information Set (</span><a href="#XINFO"><span class="deltaxml-new" style="background:#90EE90">[XML Infoset]</span></a><span class="deltaxml-new" style="background:#90EE90">) according to the “Infoset Mapping” rules defined in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. Note that this process discards any existing </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotations</span></a><span class="deltaxml-new" style="background:#90EE90">. Validity assessment is carried out on the root element information item of the resulting Infoset, using the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> as the effective schema. The process of validation applies recursively to contained elements and attributes to the extent required by the effective schema. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a type name is provided, and the type name is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">, all elements receive the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">, and all attributes receive the type annotation </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. If the type name is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, the node receives the type annotation xs:untypedAtomic; a type error [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised if the node has element children. Otherwise, schema-validity assessment is carried out according to the rules defined in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> Part 1, section 3.3.4 "Element Declaration Validation Rules", “Validation Rule: Schema-Validity Assessment (Element)”, clauses 1.2 and 2, using this type definition as the “processor-stipulated type definition” for validation.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the instance being validated contains an xml:id attribute, both lax and strict validation cause this attribute to be subjected to [xml:id] processing: that is, the attribute is checked for uniqueness, and is typed as xs:ID, and the containing element is therefore eligible as a target for the id() function.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation defined</span></a><span class="deltaxml-new" style="background:#90EE90"> whether the validity assessment process takes account of any </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:schemaLocation</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:noNamespaceSchemaLocation</span></code><span class="deltaxml-new" style="background:#90EE90"> attributes in the tree being validated. If it does so, then it </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should</span></span><span class="deltaxml-new" style="background:#90EE90"> adhere to the following rules:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">Any schema loaded using these attributes must be </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-new" style="background:#90EE90">compatible</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> with the schema in the static context from which validation is invoked.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Any schema loaded using these attributes must not override or redefine any schema components in the static context.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Any schema components loaded using this mechanism must be used for this validity assessment only, and must not affect the outcome of any subsequent validity assessments of other documents.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A processor may choose to cache such schema components but the existence of such a cache should only affect performance, not the validation outcome.</span></p></div></li></ol><p><span class="deltaxml-new" style="background:#90EE90">A consequence of validating a document using schema components that are not in the static context is that nodes may be annotated with types that are not in the static context. But the rules for </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible"><span class="deltaxml-new" style="background:#90EE90">schema compatibility</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> mean that this is not a problem.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When no type name is provided:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><span class="deltaxml-new" style="background:#90EE90">, then there must be a top-level element declaration in the </span><a title="in-scope element declarations" class="termref" href="#dt-is-elems"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a><span class="deltaxml-new" style="background:#90EE90"> that matches the root element information item in the Infoset, and schema-validity assessment is carried out using that declaration in accordance with </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> Part 1, section 5.2, “Assessing Schema-Validity”, item 2, or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> Part 1, section 5.2, “Assessing Schema-Validity”, “element-driven validation”. If there is no such element declaration, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0084" title="err:XQDY0084"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0084</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><span class="deltaxml-new" style="background:#90EE90">, then schema-validity assessment is carried out in accordance with </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> Part 1, section 5.2, “Assessing Schema-Validity”, item 3, or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> Part 1, section 5.2, “Assessing Schema-Validity”, “lax wildcard validation”.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><span class="deltaxml-new" style="background:#90EE90"> and the root element information item has neither a top-level element declaration nor an </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute, </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> defines the recursive checking of children and attributes as optional. During processing of an XQuery </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, this recursive checking is required.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the operand node is an element node, the validation rules named “Validation Root Valid (ID/IDREF)” are not applied. This means that document-level constraints relating to uniqueness and referential integrity are not enforced.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">There is no check that the document contains unparsed entities whose names match the values of nodes of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:ENTITY</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:ENTITIES</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Validity assessment is affected by the presence or absence of </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:type</span></code><span class="deltaxml-new" style="background:#90EE90"> attributes on the elements being validated, and may generate new information items such as default attributes.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The outcome of the validation expression depends on the </span><code><span class="deltaxml-new" style="background:#90EE90">validity</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the root element information item in the PSVI that results from the validation process.</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><code><span class="deltaxml-new" style="background:#90EE90">validity</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the root element information item is </span><code><span class="deltaxml-new" style="background:#90EE90">valid</span></code><span class="deltaxml-new" style="background:#90EE90">, or if </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><span class="deltaxml-new" style="background:#90EE90"> and the </span><code><span class="deltaxml-new" style="background:#90EE90">validity</span></code><span class="deltaxml-new" style="background:#90EE90"> property of the root element information item is </span><code><span class="deltaxml-new" style="background:#90EE90">notKnown</span></code><span class="deltaxml-new" style="background:#90EE90">, the PSVI is converted back into an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> as described in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> Section 3.3, “Construction from a PSVI”. The resulting node (a new node of the same kind as the operand node) is returned as the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQDY0027" title="err:XQDY0027"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0027</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li></ol></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The effect of these rules is as follows, where the </span><em><span class="deltaxml-new" style="background:#90EE90">validated element</span></em><span class="deltaxml-new" style="background:#90EE90"> means either the operand node or (if the operand node is a document node) its element child.: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><span class="deltaxml-new" style="background:#90EE90">, the validated element must have a top-level element declaration in the effective schema, and must conform to this declaration.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><span class="deltaxml-new" style="background:#90EE90">, the validated element must conform to its top-level element declaration if such a declaration exists in the effective schema. If </span><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">validation mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><span class="deltaxml-new" style="background:#90EE90"> and there is no top-level element declaration for the element, and the element has an </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute, then the </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:type</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute must name a top-level type definition in the effective schema, and the element must conform to that type.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a type name is specified in the validate expression, no attempt is made to locate an element declaration matching the name of the validated element; the element can have any name, and its content is validated against the named type. </span></p></li></ul></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">During conversion of the PSVI into an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> after validation, any element information items whose validity property is </span><code><span class="deltaxml-new" style="background:#90EE90">notKnown</span></code><span class="deltaxml-new" style="background:#90EE90"> are converted into element nodes with </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">, and any attribute information items whose validity property is </span><code><span class="deltaxml-new" style="background:#90EE90">notKnown</span></code><span class="deltaxml-new" style="background:#90EE90"> are converted into attribute nodes with </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#PSVI2NodeTypes"><span class="deltaxml-new" style="background:#90EE90">Section 3.3.1.1 Element and Attribute Node Types</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A query might take as its primary input a document conforming to schema </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90">, and produce as its primary output a document conforming to schema </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90">. To be sure that the output is indeed valid against schema </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90">, the safest course of action is to evaluate a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression within a query module that imports schema </span><var><span class="deltaxml-new" style="background:#90EE90">Y</span></var><span class="deltaxml-new" style="background:#90EE90"> and nothing else. Otherwise, if the validation occurs within a module that imports both </span><var><span class="deltaxml-new" style="background:#90EE90">X</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">Y</span></code><span class="deltaxml-new" style="background:#90EE90">, the outcome of validation might differ because of the differences between the two schemas.</span></p></div></div></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-extension-expressions"></a><span class="deltaxml-new" style="background:#90EE90">4.25 Extension Expressions</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-extension-expression" title="extension expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">extension expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression whose semantics are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">.] Typically a particular extension will be recognized by some implementations and not by others. The syntax is designed so that extension expressions can be successfully parsed by all implementations, and so that fallback behavior can be defined for implementations that do not recognize a particular extension.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ExtensionExpr" id="doc-xpath40-ExtensionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[133]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ExtensionExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Pragma" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Pragma</span></a><span class="deltaxml-new" style="background:#90EE90">+ "{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Pragma" id="doc-xpath40-Pragma"></a><span class="deltaxml-new" style="background:#90EE90">[134]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Pragma" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Pragma</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(#" </span><a href="#prod-xpath40-S" class="xquery"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#prod-xpath40-S" class="xquery"><span class="deltaxml-new" style="background:#90EE90">S</span></a><a href="#doc-xpath40-PragmaContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PragmaContents</span></a><span class="deltaxml-new" style="background:#90EE90">)? "#)"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PragmaContents" id="doc-xpath40-PragmaContents"></a><span class="deltaxml-new" style="background:#90EE90">[135]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PragmaContents" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PragmaContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* '#)' Char*))</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">An extension expression consists of one or more </span><b><span class="deltaxml-new" style="background:#90EE90">pragmas</span></b><span class="deltaxml-new" style="background:#90EE90">, followed by an optional expression (the </span><b><span class="deltaxml-new" style="background:#90EE90">associated expression</span></b><span class="deltaxml-new" style="background:#90EE90">). [</span><a id="dt-pragma" title="pragma"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">pragma</span></b><span class="deltaxml-new" style="background:#90EE90"> is denoted by the delimiters </span><code><span class="deltaxml-new" style="background:#90EE90">(#</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">#)</span></code><span class="deltaxml-new" style="background:#90EE90">, and consists of an identifying EQName followed by </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> content.] The content of a pragma may consist of any string of characters that does not contain the ending delimiter </span><code><span class="deltaxml-new" style="background:#90EE90">#)</span></code><span class="deltaxml-new" style="background:#90EE90">. If the EQName of a pragma is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, it must resolve to a namespace URI and local name, using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">]. If the EQName is an unprefixed NCName, it is interpreted as a name in no namespace (and the pragma is therefore ignored).</span></p><p><span class="deltaxml-new" style="background:#90EE90">Each implementation recognizes an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> set of namespace URIs used to denote pragmas.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the namespace URI of a pragma’s </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is not recognized by the implementation as a pragma namespace, or if the name is in no namespace, then the pragma is ignored. If all the pragmas in an </span><a href="#doc-xpath40-ExtensionExpr"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> are ignored, then the value of the </span><a href="#doc-xpath40-ExtensionExpr"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> is the value of the associated expression; if no associated expression is provided, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0079" title="err:XQST0079"><span class="deltaxml-new" style="background:#90EE90">err:XQST0079</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90">If an implementation recognizes the namespace of one or more pragmas in an </span><a href="#doc-xpath40-ExtensionExpr"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, then the value of the </span><a href="#doc-xpath40-ExtensionExpr"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, including its error behavior, is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, an implementation that recognizes the namespace of a pragma’s </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">, but does not recognize the local part of the name, might choose either to raise an error or to ignore the pragma.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0013" title="err:XQST0013"><span class="deltaxml-new" style="background:#90EE90">err:XQST0013</span></a><span class="deltaxml-new" style="background:#90EE90">] if an implementation recognizes a pragma but determines that its content is invalid.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If an implementation recognizes a pragma, it must report any static errors in the following expression even if it will not evaluate that expression.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate three ways in which extension expressions might be used.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A pragma can be used to furnish a hint for how to evaluate the following expression, without actually changing the result. For example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace exq = "http://example.org/XQueryImplementation";
(# exq:use-index #) {
  $bib/book/author[name = 'Berners-Lee']
}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">An implementation that recognizes the </span><code><span class="deltaxml-new" style="background:#90EE90">exq:use-index</span></code><span class="deltaxml-new" style="background:#90EE90"> pragma might use an index to evaluate the expression that follows. An implementation that does not recognize this pragma would evaluate the expression in its normal way.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A pragma might be used to modify the semantics of the following expression in ways that would not (in the absence of the pragma) be conformant with this specification. For example, a pragma might be used to permit comparison of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></code><span class="deltaxml-new" style="background:#90EE90"> values using implementation-defined semantics (this would normally be an error). Such changes to the language semantics must be scoped to the </span><a title="enclosed expression" class="termref" href="#dt-enclosed-expression"><span class="deltaxml-new" style="background:#90EE90">enclosed expression</span></a><span class="deltaxml-new" style="background:#90EE90"> following the pragma.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A pragma might contain syntactic constructs that are evaluated in place of the following expression. In this case, the following expression itself (if it is present) provides a fallback for use by implementations that do not recognize the pragma. For example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace exq = "http://example.org/XQueryImplementation";

for $x in (# exq:distinct //city by @country #) {
  //city[not(@country = preceding::city/@country)]
}
return f:show-city($x)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Here an implementation that recognizes the pragma will return the result of evaluating the proprietary syntax </span><code><span class="deltaxml-new" style="background:#90EE90">exq:distinct //city by @country</span></code><span class="deltaxml-new" style="background:#90EE90">, while an implementation that does not recognize the pragma will instead return the result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">//city[not(@country = preceding::city/@country)]</span></code><span class="deltaxml-new" style="background:#90EE90">. If no fallback expression is required, or if none is feasible, then the expression between the curly braces may be omitted, in which case implementations that do not recognize the pragma will raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></div></div></div></div><div class="xquery"><div class="div1 xquery"><div class="xquery"><h2><a id="id-query-prolog"></a><span class="deltaxml-new" style="background:#90EE90">5 Modules and Prologs</span></h2></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Module" id="doc-xpath40-Module"></a><span class="deltaxml-new" style="background:#90EE90">[2]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Module" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Module</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VersionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VersionDecl</span></a><span class="deltaxml-new" style="background:#90EE90">? (</span><a href="#doc-xpath40-LibraryModule" class="xquery"><span class="deltaxml-new" style="background:#90EE90">LibraryModule</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-MainModule" class="xquery"><span class="deltaxml-new" style="background:#90EE90">MainModule</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-MainModule" id="doc-xpath40-MainModule"></a><span class="deltaxml-new" style="background:#90EE90">[4]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MainModule" class="xquery"><span class="deltaxml-new" style="background:#90EE90">MainModule</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Prolog" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><a href="#doc-xpath40-QueryBody" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-LibraryModule" id="doc-xpath40-LibraryModule"></a><span class="deltaxml-new" style="background:#90EE90">[5]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LibraryModule" class="xquery"><span class="deltaxml-new" style="background:#90EE90">LibraryModule</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ModuleDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ModuleDecl</span></a><a href="#doc-xpath40-Prolog" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Prolog" id="doc-xpath40-Prolog"></a><span class="deltaxml-new" style="background:#90EE90">[7]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Prolog" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#doc-xpath40-DefaultNamespaceDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DefaultNamespaceDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-Setter" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Setter</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-NamespaceDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NamespaceDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-Import" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Import</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-Separator" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a><span class="deltaxml-new" style="background:#90EE90">)* ((</span><a href="#doc-xpath40-ContextValueDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ContextValueDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-AnnotatedDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotatedDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-OptionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OptionDecl</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#doc-xpath40-Separator" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Setter" id="doc-xpath40-Setter"></a><span class="deltaxml-new" style="background:#90EE90">[9]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Setter" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Setter</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BoundarySpaceDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BoundarySpaceDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-DefaultCollationDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DefaultCollationDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-BaseURIDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BaseURIDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ConstructionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ConstructionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-OrderingModeDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderingModeDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-EmptyOrderDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EmptyOrderDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-CopyNamespacesDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CopyNamespacesDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-DecimalFormatDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DecimalFormatDecl</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Import" id="doc-xpath40-Import"></a><span class="deltaxml-new" style="background:#90EE90">[21]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Import" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Import</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SchemaImport" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SchemaImport</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ModuleImport" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ModuleImport</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Separator" id="doc-xpath40-Separator"></a><span class="deltaxml-new" style="background:#90EE90">[8]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Separator" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">";"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-QueryBody" id="doc-xpath40-QueryBody"></a><span class="deltaxml-new" style="background:#90EE90">[44]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QueryBody" class="xquery"><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A query can be assembled from one or more fragments called </span><b><span class="deltaxml-new" style="background:#90EE90">modules</span></b><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="dt-module" title="module"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">module</span></b><span class="deltaxml-new" style="background:#90EE90"> is a fragment of XQuery code that conforms to the </span><a href="#doc-xpath40-Module"><span class="deltaxml-new" style="background:#90EE90">Module</span></a><span class="deltaxml-new" style="background:#90EE90"> grammar and can independently undergo the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90"> described in </span><a href="#id-expression-processing"><b><span class="deltaxml-new" style="background:#90EE90">2.3.3 Expression Processing</span></b></a><span class="deltaxml-new" style="background:#90EE90">. Each module is either a </span><a title="main module" class="termref" href="#dt-main-module"><span class="deltaxml-new" style="background:#90EE90">main module</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-main-module" title="main module"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">main module</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by a </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a><span class="deltaxml-new" style="background:#90EE90">.] A query has exactly one main module. In a main module, the </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a><span class="deltaxml-new" style="background:#90EE90"> is evaluated with respect to the static and dynamic contexts of the main module in which it is found, and its value is the result of the query.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-library-module" title="library module"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A module that does not contain a </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a><span class="deltaxml-new" style="background:#90EE90"> is called a </span><b><span class="deltaxml-new" style="background:#90EE90">library module</span></b><span class="deltaxml-new" style="background:#90EE90">. A library module consists of a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90">.] A library module cannot be evaluated directly; instead, it provides function and variable declarations that can be imported into other modules.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The XQuery syntax does not allow a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> to contain both a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> and a </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-prolog" title="Prolog"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">Prolog</span></b><span class="deltaxml-new" style="background:#90EE90"> is a series of declarations and imports that define the processing environment for the </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> that contains the Prolog.] Each declaration or import is followed by a semicolon. A Prolog is organized into two parts. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The first part of the Prolog consists of setters, imports, namespace declarations, and default namespace declarations. [</span><a id="dt-setter" title="setter"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Setters</span></b><span class="deltaxml-new" style="background:#90EE90"> are declarations that set the value of some property that affects query processing, such as construction mode or default collation.] Namespace declarations and default namespace declarations affect the interpretation of </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> within the query. Imports are used to import definitions from schemas and modules. [</span><a id="dt-target-namespace" title="target namespace"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">target namespace</span></b><span class="deltaxml-new" style="background:#90EE90"> of a module is the namespace of the objects (such as elements or functions) that it defines. ] </span></p><p><span class="deltaxml-new" style="background:#90EE90">The second part of the Prolog consists of declarations of variables, functions, and options. These declarations appear at the end of the Prolog because they may be affected by declarations and imports in the first part of the Prolog.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-queryBody" title="query body"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">Query Body</span></b><span class="deltaxml-new" style="background:#90EE90">, if present, consists of an expression that defines the result of the query.] Evaluation of expressions is described in </span><a href="#id-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4 Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">. A module can be evaluated only if it has a Query Body.</span></p><div class="div2"><h3><a id="id-version-declaration"></a><span class="deltaxml-new" style="background:#90EE90">5.1 Version Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-VersionDecl" id="doc-xpath40-VersionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[3]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VersionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VersionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"xquery" (("encoding" </span><a href="#doc-xpath40-StringLiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("version" </span><a href="#doc-xpath40-StringLiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("encoding" </span><a href="#doc-xpath40-StringLiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?)) </span><a href="#doc-xpath40-Separator" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-version-declaration" title="version declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">version declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> can identify the applicable XQuery syntax and semantics for a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90">, as well as its encoding.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-version-number" title="XQuery version number"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery version number</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of two integers separated by a dot. The first integer is referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">major version number</span></b><span class="deltaxml-new" style="background:#90EE90">; the second as the </span><b><span class="deltaxml-new" style="background:#90EE90">minor version number</span></b><span class="deltaxml-new" style="background:#90EE90">.] </span><span><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">integer</span></b><span class="deltaxml-new" style="background:#90EE90"> here means a sequence of decimal digits with no sign or other punctuation.</span></span></p><p><span class="deltaxml-new" style="background:#90EE90">Any XQuery processor that implements any version of XQuery with a given major number must accept any query with the same major version number. The processor may reject queries labeled with a different major version number. The processor may reject queries with the same major version number and a greater minor version number than the processor recognizes.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The version numbers </span><code><span class="deltaxml-new" style="background:#90EE90">4.01</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">4.1</span></code><span class="deltaxml-new" style="background:#90EE90"> are equivalent: both have a major number of 4 and a minor number of 1. Version </span><code><span class="deltaxml-new" style="background:#90EE90">4.10</span></code><span class="deltaxml-new" style="background:#90EE90"> by the same reasoning has a higher minor number than version </span><code><span class="deltaxml-new" style="background:#90EE90">4.2</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">If a query is rejected because of a version mismatch with the processor, a static error [</span><a href="#ERRXQST0031" title="err:XQST0031"><span class="deltaxml-new" style="background:#90EE90">err:XQST0031</span></a><span class="deltaxml-new" style="background:#90EE90">] must be raised.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The processor is allowed to provide an option to require that minor versions also match, or that the minor number of the version in the query is not larger than the largest minor version understood by the processor in this major release of XQuery, or to allow more permissive version matching, perhaps with warnings, but the behavior is then outside the scope of this specification.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The version number “4.0” indicates the intent that the module be processed by an </span><a title="XQuery 4.0 Processor" class="termref" href="#dt-xquery-40-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 processor</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, the version number “1.0” indicates the intent that the module be processed by an </span><a title="XQuery 1.0 Processor" class="termref" href="#dt-xquery-10-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0 processor</span></a><span class="deltaxml-new" style="background:#90EE90">, “3.0” an </span><a title="XQuery 3.0 Processor" class="termref" href="#dt-xquery-30-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0 processor</span></a><span class="deltaxml-new" style="background:#90EE90">, and “3.1” an </span><a title="XQuery 3.1 Processor" class="termref" href="#dt-xquery-31-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1 processor</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the version declaration is not present or the version is not included in the declaration, an XQuery 4.0 processor assumes a version of “4.0”.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This does not preclude the use of an external API or other configuration mechanism that instructs a piece of software to behave as an XQuery 4.0 processor.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-encoding-declaration" title="encoding declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: If present, a version declaration may optionally include an </span><b><span class="deltaxml-new" style="background:#90EE90">encoding declaration</span></b><span class="deltaxml-new" style="background:#90EE90">. The value of the string literal following the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">encoding</span></code><span class="deltaxml-new" style="background:#90EE90"> is an encoding name, and must conform to the definition of </span><code><span class="deltaxml-new" style="background:#90EE90">EncName</span></code><span class="deltaxml-new" style="background:#90EE90"> specified in </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0087" title="err:XQST0087"><span class="deltaxml-new" style="background:#90EE90">err:XQST0087</span></a><span class="deltaxml-new" style="background:#90EE90">]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as </span><code><span class="deltaxml-new" style="background:#90EE90">"UTF-8"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"UTF-16"</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">"US-ASCII"</span></code><span class="deltaxml-new" style="background:#90EE90">.] Since the encoding of a query may change as the query moves from one environment to another, there can be no guarantee that the encoding declaration is correct.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The handling of an encoding declaration is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">. If an implementation has </span><em><span class="deltaxml-new" style="background:#90EE90">a priori</span></em><span class="deltaxml-new" style="background:#90EE90"> knowledge of the encoding of a query, it may use this knowledge and disregard the encoding declaration. The semantics of a query are not affected by the presence or absence of an encoding declaration.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a version declaration is present, no </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90"> may occur before the end of the version declaration. If such a </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90"> is present, the result is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">; an implementation may raise an implementation-dependent static error, or ignore the comment. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The effect of a </span><code><span class="deltaxml-new" style="background:#90EE90">Comment</span></code><span class="deltaxml-new" style="background:#90EE90"> before the end of a version declaration is implementation-dependent because it may suppress query processing by interfering with detection of the encoding declaration.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate version declarations:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">xquery version "3.1";</span></pre></div></div><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">xquery version "4.0" encoding "utf-8";</span></pre></div></div></div><div class="div2"><h3><a id="id-module-declaration"></a><span class="deltaxml-new" style="background:#90EE90">5.2 Module Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ModuleDecl" id="doc-xpath40-ModuleDecl"></a><span class="deltaxml-new" style="background:#90EE90">[6]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ModuleDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ModuleDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"module" "namespace" </span><a href="#prod-xpath40-NCName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><a href="#doc-xpath40-Separator" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-module-declaration" title="module declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">module declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> serves to identify a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> as a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">. A module declaration begins with the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">module</span></code><span class="deltaxml-new" style="background:#90EE90"> and contains a namespace prefix and a </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">.] The URILiteral must be of nonzero length [</span><a href="#ERRXQST0088" title="err:XQST0088"><span class="deltaxml-new" style="background:#90EE90">err:XQST0088</span></a><span class="deltaxml-new" style="background:#90EE90">]. The URILiteral identifies the </span><a title="target namespace" class="termref" href="#dt-target-namespace"><span class="deltaxml-new" style="background:#90EE90">target namespace</span></a><span class="deltaxml-new" style="background:#90EE90"> of the library module, which is the namespace for all variables and functions exported by the library module. The name of every variable and function declared in a library module must have a namespace URI that is the same as the target namespace of the module; otherwise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0048" title="err:XQST0048"><span class="deltaxml-new" style="background:#90EE90">err:XQST0048</span></a><span class="deltaxml-new" style="background:#90EE90">]. The (prefix,URI) pair is added to the set of </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The namespace prefix specified in a module declaration must not be </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">], and must not be the same as any namespace prefix bound in the same module by a </span><a title="schema import" class="termref" href="#dt-schema-import"><span class="deltaxml-new" style="background:#90EE90">schema import</span></a><span class="deltaxml-new" style="background:#90EE90">, by a </span><a title="namespace declaration" class="termref" href="#dt-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">namespace declaration</span></a><span class="deltaxml-new" style="background:#90EE90">, or by a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90"> with a different target namespace [</span><a href="#ERRXQST0033" title="err:XQST0033"><span class="deltaxml-new" style="background:#90EE90">err:XQST0033</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">Any </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> may import one or more library modules by means of a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90"> that specifies the target namespace of the library modules to be imported. When a module imports one or more library modules, the variables and functions declared in the imported modules are added to the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> and (where applicable) to the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> of the importing module.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following is an example of a module declaration:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">module namespace gis =
      "http://example.org/gis-functions";</span></pre></div></div></div><div class="div2"><h3><a id="id-boundary-space-decls"></a><span class="deltaxml-new" style="background:#90EE90">5.3 Boundary-space Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BoundarySpaceDecl" id="doc-xpath40-BoundarySpaceDecl"></a><span class="deltaxml-new" style="background:#90EE90">[10]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BoundarySpaceDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BoundarySpaceDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "boundary-space" ("preserve" | "strip")</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-boundary-space-decl" title="boundary-space declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">boundary-space declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the </span><a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy"><span class="deltaxml-new" style="background:#90EE90">boundary-space policy</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default. Boundary-space policy controls whether </span><a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace"><span class="deltaxml-new" style="background:#90EE90">boundary whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> is preserved by element constructors during processing of the query.] If boundary-space policy is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, boundary whitespace is preserved. If boundary-space policy is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, boundary whitespace is stripped (deleted). A further discussion of whitespace in constructed elements can be found in </span><a href="#id-whitespace"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.4 Boundary Whitespace</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a boundary-space declaration:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare boundary-space preserve;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If a Prolog contains more than one boundary-space declaration, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0068" title="err:XQST0068"><span class="deltaxml-new" style="background:#90EE90">err:XQST0068</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div2"><h3><a id="id-default-collation-declaration"></a><span class="deltaxml-new" style="background:#90EE90">5.4 Default Collation Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DefaultCollationDecl" id="doc-xpath40-DefaultCollationDecl"></a><span class="deltaxml-new" style="background:#90EE90">[11]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DefaultCollationDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DefaultCollationDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "default" "collation" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-default-collation-decl" title="default collation declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">default collation declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the value of the </span><a title="default collation" class="termref" href="#dt-def-collation"><span class="deltaxml-new" style="background:#90EE90">default collation</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default.] The default collation is the collation that is used by functions and operators that require a collation if no other collation is specified. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90"> operator on strings is defined by a call to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare</span></code><span class="deltaxml-new" style="background:#90EE90"> function, which takes an optional collation parameter. Since the </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90"> operator does not specify a collation, the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:compare</span></code><span class="deltaxml-new" style="background:#90EE90"> function implements </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90"> by using the default collation.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If neither the implementation nor the Prolog specifies a default collation, the Unicode codepoint collation (</span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/collation/codepoint</span></code><span class="deltaxml-new" style="background:#90EE90">) is used. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a default collation declaration:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare default collation "http://example.org/languages/Icelandic";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If a default collation declaration specifies a collation by a relative URI, that relative URI is </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolved to an absolute URI</span></a><span class="deltaxml-new" style="background:#90EE90"> using the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">. If a Prolog contains more than one default collation declaration, or the value specified by a default collation declaration (after resolution of a relative URI, if necessary) is not present in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically known collations</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0038" title="err:XQST0038"><span class="deltaxml-new" style="background:#90EE90">err:XQST0038</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div2"><h3><a id="id-base-uri-decl"></a><span class="deltaxml-new" style="background:#90EE90">5.5 Base URI Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-BaseURIDecl" id="doc-xpath40-BaseURIDecl"></a><span class="deltaxml-new" style="background:#90EE90">[12]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BaseURIDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">BaseURIDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "base-uri" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-base-uri-decl" title="base URI declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">base URI declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> specifies the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property. The </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property is used when resolving relative URI references.] For example, the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property is used when resolving relative references for </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90"> and for the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">As discussed in the definition of </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90">, if there is no base URI declaration, or if the value of the declaration is a relative URI reference, then the value of the Static Base URI may depend on the location of the query, and it is permissible for this to vary between the static analysis phase and the dynamic evaluation phase.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The following is an example of a base URI declaration:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare base-uri "http://example.org";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If a Prolog contains more than one base URI declaration, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0032" title="err:XQST0032"><span class="deltaxml-new" style="background:#90EE90">err:XQST0032</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the terminology of </span><a href="#RFC3986"><span class="deltaxml-new" style="background:#90EE90">[RFC3986]</span></a><span class="deltaxml-new" style="background:#90EE90"> Section 5.1, the URILiteral of the base URI declaration is considered to be a “base URI embedded in content”. If no base URI declaration is present, </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property is established according to the principles outlined in </span><a href="#RFC3986"><span class="deltaxml-new" style="background:#90EE90">[RFC3986]</span></a><span class="deltaxml-new" style="background:#90EE90"> Section 5.1—that is, it defaults first to the base URI of the encapsulating entity, then to the URI used to retrieve the entity, and finally to an implementation-defined default. If the URILiteral in the base URI declaration is a relative URI, then it is made absolute by resolving it with respect to this same hierarchy. For example, if the URILiteral in the base URI declaration is </span><code><span class="deltaxml-new" style="background:#90EE90">../data/</span></code><span class="deltaxml-new" style="background:#90EE90">, and the query is contained in a file whose URI is </span><code><span class="deltaxml-new" style="background:#90EE90">file:///C:/temp/queries/query.xq</span></code><span class="deltaxml-new" style="background:#90EE90">, then the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property is </span><code><span class="deltaxml-new" style="background:#90EE90">file:///C:/temp/data/</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is not intrinsically an error if this process fails to establish an absolute base URI; however, the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property is then </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0001" title="err:XPST0001"><span class="deltaxml-new" style="background:#90EE90">err:XPST0001</span></a><span class="deltaxml-new" style="background:#90EE90">]. When the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, any attempt to use its value to </span><a title="resolve" class="termref" href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolve a relative URI reference</span></a><span class="deltaxml-new" style="background:#90EE90"> will result in an error [</span><a href="#ERRXPST0001" title="err:XPST0001"><span class="deltaxml-new" style="background:#90EE90">err:XPST0001</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p></div><div class="div2"><h3><a id="id-construction-declaration"></a><span class="deltaxml-new" style="background:#90EE90">5.6 Construction Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ConstructionDecl" id="doc-xpath40-ConstructionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[13]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ConstructionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ConstructionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "construction" ("strip" | "preserve")</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-construction-decl" title="construction declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">construction declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default.] The construction mode governs the behavior of element and document node constructors. If construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, the type of a constructed element node is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">, and all attribute and element nodes copied during node construction retain their original types. If construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, the type of a constructed element node is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">; all element nodes copied during node construction receive the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">, and all attribute nodes copied during node construction receive the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a construction declaration:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare construction strip;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If a Prolog specifies more than one construction declaration, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0067" title="err:XQST0067"><span class="deltaxml-new" style="background:#90EE90">err:XQST0067</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div2"><h3><a id="id-default-ordering-decl"></a><span class="deltaxml-new" style="background:#90EE90">5.7 Ordering Mode Declaration</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-decimal-format-decl"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-validate"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The ordering mode declaration is retained for backwards compatibility reasons, but in XQuery 4.0 it is deprecated and has no useful effect. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1339"><span class="deltaxml-new" style="background:#90EE90">1339</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OrderingModeDecl" id="doc-xpath40-OrderingModeDecl"></a><span class="deltaxml-new" style="background:#90EE90">[14]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OrderingModeDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OrderingModeDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "ordering" ("ordered" | "unordered")</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> The ordering mode declaration is retained from earlier XQuery versions, but in XQuery 4.0 it is deprecated and has no effect.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">That is to say, XQuery 4.0 always operates as if ordering mode were set to </span><code><span class="deltaxml-new" style="background:#90EE90">ordered</span></code><span class="deltaxml-new" style="background:#90EE90"> in earlier versions.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">If a Prolog contains more than one ordering mode declaration, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0065" title="err:XQST0065"><span class="deltaxml-new" style="background:#90EE90">err:XQST0065</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div2"><h3><a id="id-empty-order-decl"></a><span class="deltaxml-new" style="background:#90EE90">5.8 Empty Order Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-EmptyOrderDecl" id="doc-xpath40-EmptyOrderDecl"></a><span class="deltaxml-new" style="background:#90EE90">[15]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EmptyOrderDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EmptyOrderDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "default" "order" "empty" ("greatest" | "least")</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-empty-order-decl" title="empty order declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">empty order declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the </span><a title="default order for empty sequences" class="termref" href="#dt-default-empty-order"><span class="deltaxml-new" style="background:#90EE90">default order for empty sequences</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context,</span></a><span class="deltaxml-new" style="background:#90EE90"> overriding any implementation-defined default. This declaration controls the processing of empty sequences and </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> values as ordering keys in an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in a FLWOR expression.] An individual </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause may override the default order for empty sequences by specifying </span><code><span class="deltaxml-new" style="background:#90EE90">empty greatest</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">empty least</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates an empty order declaration:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare default order empty least;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If a Prolog contains more than one empty order declaration, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0069" title="err:XQST0069"><span class="deltaxml-new" style="background:#90EE90">err:XQST0069</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div2"><h3><a id="id-copy-namespaces-decl"></a><span class="deltaxml-new" style="background:#90EE90">5.9 Copy-Namespaces Declaration</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-CopyNamespacesDecl" id="doc-xpath40-CopyNamespacesDecl"></a><span class="deltaxml-new" style="background:#90EE90">[16]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CopyNamespacesDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">CopyNamespacesDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "copy-namespaces" </span><a href="#doc-xpath40-PreserveMode" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PreserveMode</span></a><span class="deltaxml-new" style="background:#90EE90"> "," </span><a href="#doc-xpath40-InheritMode" class="xquery"><span class="deltaxml-new" style="background:#90EE90">InheritMode</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-PreserveMode" id="doc-xpath40-PreserveMode"></a><span class="deltaxml-new" style="background:#90EE90">[17]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PreserveMode" class="xquery"><span class="deltaxml-new" style="background:#90EE90">PreserveMode</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"preserve" | "no-preserve"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-InheritMode" id="doc-xpath40-InheritMode"></a><span class="deltaxml-new" style="background:#90EE90">[18]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InheritMode" class="xquery"><span class="deltaxml-new" style="background:#90EE90">InheritMode</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"inherit" | "no-inherit"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-copy-namespaces-decl" title="copy-namespaces declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">copy-namespaces declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the value of </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default. Copy-namespaces mode controls the namespace bindings that are assigned when an existing element node is copied by an element constructor or document constructor.] Handling of namespace bindings by element constructors is described in </span><a href="#id-element-constructor"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a copy-namespaces declaration:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare copy-namespaces preserve, no-inherit;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If a Prolog contains more than one copy-namespaces declaration, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0055" title="err:XQST0055"><span class="deltaxml-new" style="background:#90EE90">err:XQST0055</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div2"><h3><a id="id-decimal-format-decl"></a><span class="deltaxml-new" style="background:#90EE90">5.10 Decimal Format Declaration</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-schema-import"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-default-ordering-decl"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Several decimal format properties, including minus sign, exponent separator, percent, and per-mille, can now be rendered as arbitrary strings rather than being confined to a single character. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1048"><span class="deltaxml-new" style="background:#90EE90">1048</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1250"><span class="deltaxml-new" style="background:#90EE90">1250</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;3 June 2024]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DecimalFormatDecl" id="doc-xpath40-DecimalFormatDecl"></a><span class="deltaxml-new" style="background:#90EE90">[19]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DecimalFormatDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DecimalFormatDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" (("decimal-format" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("default" "decimal-format")) (</span><a href="#doc-xpath40-DFPropertyName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DFPropertyName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=" </span><a href="#doc-xpath40-StringLiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DFPropertyName" id="doc-xpath40-DFPropertyName"></a><span class="deltaxml-new" style="background:#90EE90">[20]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DFPropertyName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DFPropertyName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"decimal-separator" | "grouping-separator" | "infinity" | "minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" | "digit" | "pattern-separator" | "exponent-separator"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-decimal-format-decl" title="decimal-format         declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">decimal format declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> adds a decimal format to the </span><a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">statically known decimal formats</span></a><span class="deltaxml-new" style="background:#90EE90">, which define the properties used to format numbers using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-number()</span></code><span class="deltaxml-new" style="background:#90EE90"> function], as described in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. If the form </span><code><span class="deltaxml-new" style="background:#90EE90">decimal-format EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> is used, then the declaration defines the properties of the decimal format whose name is </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90">, while the form </span><code><span class="deltaxml-new" style="background:#90EE90">default decimal-format</span></code><span class="deltaxml-new" style="background:#90EE90"> defines the properties of the unnamed decimal format. The declaration contains a set of (</span><code><span class="deltaxml-new" style="background:#90EE90">DFPropertyName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></code><span class="deltaxml-new" style="background:#90EE90">) pairs, where the </span><code><span class="deltaxml-new" style="background:#90EE90">DFPropertyName</span></code><span class="deltaxml-new" style="background:#90EE90"> is the name of the property and the </span><code><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></code><span class="deltaxml-new" style="background:#90EE90"> is its value. The valid values and default values for each property are defined in </span><a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">statically known decimal formats</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">If a format declares no properties, default values are used for all properties.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Error conditions are defined as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> for a query prolog to contain two decimal format declarations with the same name, or to contain two default decimal format declarations [</span><a href="#ERRXQST0111" title="err:XQST0111"><span class="deltaxml-new" style="background:#90EE90">err:XQST0111</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> for a decimal format declaration to define the same property more than once [</span><a href="#ERRXQST0114" title="err:XQST0114"><span class="deltaxml-new" style="background:#90EE90">err:XQST0114</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> for a decimal format declaration to specify a value that is not valid for a given property, as described in </span><a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">statically known decimal formats</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0097" title="err:XQST0097"><span class="deltaxml-new" style="background:#90EE90">err:XQST0097</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if, for any named or unnamed decimal format, the properties identifying </span><b><span class="deltaxml-new" style="background:#90EE90">marker</span></b><span class="deltaxml-new" style="background:#90EE90"> characters to be used in a picture string do identify distinct values [</span><a href="#ERRXQST0098" title="err:XQST0098"><span class="deltaxml-new" style="background:#90EE90">err:XQST0098</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following properties identify </span><b><span class="deltaxml-new" style="background:#90EE90">marker</span></b><span class="deltaxml-new" style="background:#90EE90"> characters used in a picture string: </span><a title="decimal-separator" class="termref" href="#id-static-decimal-format-decimal-separator"><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="exponent-separator" class="termref" href="#id-static-decimal-format-exponent-separator"><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="grouping-separator" class="termref" href="#id-static-decimal-format-grouping-separator"><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="percent" class="termref" href="#id-static-decimal-format-percent"><span class="deltaxml-new" style="background:#90EE90">percent</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="per-mille" class="termref" href="#id-static-decimal-format-per-mille"><span class="deltaxml-new" style="background:#90EE90">per-mille</span></a><span class="deltaxml-new" style="background:#90EE90">, the family of ten decimal digits starting with </span><a title="zero-digit" class="termref" href="#id-static-decimal-format-zero-digit"><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="digit" class="termref" href="#id-static-decimal-format-digit"><span class="deltaxml-new" style="background:#90EE90">digit</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="pattern-separator" class="termref" href="#id-static-decimal-format-pattern-separator"><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="example"><p><span class="deltaxml-new" style="background:#90EE90">The following query formats numbers using two different decimal format declarations:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare decimal-format local:de decimal-separator = "," grouping-separator = "."; 
declare decimal-format local:en decimal-separator = "." grouping-separator = ","; 
       
let $numbers := (1234.567, 789, 1234567.765) 
for $i in $numbers
return ( 
  format-number($i, "#.###,##", "local:de"), 
  format-number($i, "#,###.##", "local:en") 
)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The output of this query is:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">1.234,57 1,234.57 789 789 1.234.567,76 1,234,567.76</span></pre></div></div></div><div class="div2"><h3><a id="id-schema-import"></a><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-decimal-format-decl"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">In previous versions the interpretation of location hints in </span><code><span class="deltaxml-new" style="background:#90EE90">import schema</span></code><span class="deltaxml-new" style="background:#90EE90"> declarations was entirely at the discretion of the processor. To improve interoperability, XQuery 4.0 recommends (but does not mandate) a specific strategy for interpreting these hints.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The rules for the consistency of schemas imported by different query modules, and for consistency between imported schemas and those used for validating input documents, have been defined with greater precision. It is now recognized that these schemas will not always be identical, and that validation with respect to different schemas may produce different outcomes, even if the components of one are a subset of the components of the other.</span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SchemaImport" id="doc-xpath40-SchemaImport"></a><span class="deltaxml-new" style="background:#90EE90">[22]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SchemaImport" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SchemaImport</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"import" "schema" </span><a href="#doc-xpath40-SchemaPrefix" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SchemaPrefix</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("at" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)*)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-SchemaPrefix" id="doc-xpath40-SchemaPrefix"></a><span class="deltaxml-new" style="background:#90EE90">[23]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SchemaPrefix" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SchemaPrefix</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("namespace" </span><a href="#prod-xpath40-NCName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=") | ("fixed"? "default" "element" "namespace")</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-schema-import" title="schema import"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">schema import</span></b><span class="deltaxml-new" style="background:#90EE90"> imports the element declarations, attribute declarations, and type definitions from a schema into the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">. For each named user-defined simple type in the schema, schema import also adds a corresponding </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor function</span></a><span class="deltaxml-new" style="background:#90EE90">. ] The schema to be imported is identified by its </span><a title="target namespace" class="termref" href="#dt-target-namespace"><span class="deltaxml-new" style="background:#90EE90">target namespace</span></a><span class="deltaxml-new" style="background:#90EE90">. The schema import may bind a namespace prefix to the target namespace of the imported schema, adding the (prefix, URI) pair to the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, or it may declare that target namespace to be the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">. The schema import may also provide optional hints for locating the schema.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The namespace prefix specified in a schema import must not be </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">], and must not be the same as any namespace prefix bound in the same module by another schema import, a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="namespace declaration" class="termref" href="#dt-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">namespace declaration</span></a><span class="deltaxml-new" style="background:#90EE90">, or a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0033" title="err:XQST0033"><span class="deltaxml-new" style="background:#90EE90">err:XQST0033</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If schema definitions from the </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace are to be used (for example, </span><code><span class="deltaxml-new" style="background:#90EE90">schema-attribute(xml:space)</span></code><span class="deltaxml-new" style="background:#90EE90">, then the prolog should include a declaration in the form </span><code><span class="deltaxml-new" style="background:#90EE90">import schema "http://www.w3.org/XML/1998/namespace"</span></code><span class="deltaxml-new" style="background:#90EE90">. No prefix should be supplied (the </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> prefix is predeclared), and no location hint should be provided (the schema definitions for the namespace are built in, and cannot be varied).</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">If the schema import declaration specifies </span><code><span class="deltaxml-new" style="background:#90EE90">default element namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> then the prolog must not contain a </span><a title="namespace declaration" class="termref" href="#dt-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">namespace declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> that specifies </span><code><span class="deltaxml-new" style="background:#90EE90">default element namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default type namespace</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">"fixed"</span></code><span class="deltaxml-new" style="background:#90EE90">, is present, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is fixed throughout the module, and is not affected by default namespace declarations (</span><code><span class="deltaxml-new" style="background:#90EE90">xmlns=""</span></code><span class="deltaxml-new" style="background:#90EE90">) appearing on direct element constructors.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> The first </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> in a schema import specifies the target namespace of the schema to be imported. The URILiterals that follow the </span><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword are optional location hints, and can be interpreted or disregarded in an implementation-dependent way. Multiple location hints might be used to indicate more than one possible place to look for the schema or multiple physical resources to be assembled to form the schema. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> If the target namespace is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions</span></code><span class="deltaxml-new" style="background:#90EE90"> then the schema described in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#schemata"><span class="deltaxml-new" style="background:#90EE90">Section C Schemas</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> is imported; any location hints are ignored. </span></p><p><span class="deltaxml-new" style="background:#90EE90">A schema import that specifies a zero-length string as target namespace is considered to import a schema that has no target namespace. Such a schema import must not bind a namespace prefix [</span><a href="#ERRXQST0057" title="err:XQST0057"><span class="deltaxml-new" style="background:#90EE90">err:XQST0057</span></a><span class="deltaxml-new" style="background:#90EE90">], but it may set the default element and/or type namespace to a zero-length string (representing “no namespace”), thus enabling the definitions in the imported namespace to be referenced. If the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is not set to "no namespace", </span><span><span class="deltaxml-new" style="background:#90EE90">the only way to reference the definitions in an imported schema that has no target namespace is using the EQName syntax </span><code><span class="deltaxml-new" style="background:#90EE90">Q{}local-name</span></code></span><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiterals</span></a><span class="deltaxml-new" style="background:#90EE90"> that follow the </span><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword are optional location hints, intended to allow a processor to locate schema documents containing definitions of the required schema components in the target namespace. Processors </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> interpret or disregard these hints in an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> way. The preferred strategy, which </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should</span></span><span class="deltaxml-new" style="background:#90EE90"> be used by default unless the user indicates otherwise, is as follows:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">If the target namespace is one for which the processor has built-in knowledge, for example the schema for a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></a><span class="deltaxml-new" style="background:#90EE90">, the location hints </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should</span></span><span class="deltaxml-new" style="background:#90EE90"> be ignored, and the built-in schema used in preference.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In other cases, the location hints are taken in order, treating them as URI references relative to the static base URI of the query module.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the first location hint cannot be successfully dereferenced, then that location hint is disregarded (optionally with a warning), and the process continues with the next location hint, until one is found that can be successfully dereferenced; if none of the location hints can be dereferenced, then a static error is reported.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The dereferencing of a location hint </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> make use of implementation-defined indirection mechanisms such as resolver callbacks and catalog files.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a location hint is successfully dereferenced, but yields a resource that cannot be parsed as a valid XSD schema document with the correct target namespace, then a static error is reported.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If a valid schema document is located, then it is combined with the schema documents obtained from other import schema declarations, in the same way as a schema is assembled from multiple schema documents referenced using </span><code><span class="deltaxml-new" style="background:#90EE90">xs:import</span></code><span class="deltaxml-new" style="background:#90EE90"> declarations. This implies that the several schema documents must together comprise a valid schema, for example there cannot be two different type definitions with the same name.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Once one location hint has been successfully processed, subsequent location hints are ignored.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Processors that adopted a different strategy in earlier releases </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> continue to use that strategy by default, in order to retain compatibility; however such processors </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">should</span></span><span class="deltaxml-new" style="background:#90EE90"> offer the above strategy as an option. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The process described above is not intended to be totally prescriptive, or to guarantee complete interoperability. Processors are likely to exhibit variations, depending both on design decisions made by the product vendor, and on decisions made when configuring the platform and network infrastructure on which it runs. For example, when retrieving HTTP resources, the details of the HTTP request are likely to vary, and the criteria used to decide whether a request was successful may also vary. In addition, the XSD specification itself describes some aspects of the process incompletely, including for example the criteria used to decide whether two components (such as type definitions) should be considered identical.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Different query modules may import different schemas, but there is a requirement that all the schemas used by a query </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">must</span></span><span class="deltaxml-new" style="background:#90EE90"> be compatible. The rules for compatibility are defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#schema-consistency"><span class="deltaxml-new" style="background:#90EE90">Section 2.8.1 Schema Consistency</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. This means, for example:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If any schema component (such as an element declaration or complex type definition) is imported into more than one query module, the definitions of these components must effectively be the same.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">This leaves room, however, for some differences between modules. For example, the substitution group membership of an element declaration may vary between one module and another, depending on what other element declarations are present in the schema. This means that an element can be validated in one module and passed as a function parameter to another module in which the element would be considered invalid. Any static type inferencing that is performed must take such possibilities into account; this is particularly important if query modules are compiled independently from one another.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> If the target namespace is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions</span></code><span class="deltaxml-new" style="background:#90EE90"> then the schema described in </span><a href="https://www.w3.org/TR/xpath-functions-31/#schemata"><span class="deltaxml-new" style="background:#90EE90">Section C Schemas </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO31</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> is imported; any location hints are ignored. </span></p><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0058" title="err:XQST0058"><span class="deltaxml-new" style="background:#90EE90">err:XQST0058</span></a><span class="deltaxml-new" style="background:#90EE90">] if more than one schema import in the same </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> specifies the same target namespace. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0059" title="err:XQST0059"><span class="deltaxml-new" style="background:#90EE90">err:XQST0059</span></a><span class="deltaxml-new" style="background:#90EE90">] if the implementation is not able to process a schema import by finding a valid schema with the specified target namespace. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0012" title="err:XQST0012"><span class="deltaxml-new" style="background:#90EE90">err:XQST0012</span></a><span class="deltaxml-new" style="background:#90EE90">] if the set of definitions contained in all schemas imported by a Prolog do not satisfy the conditions for schema validity specified in Sections 3 and 5 of </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> Part 1: in particular, each definition must be valid, complete, and unique.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0149" title="err:XQST0149"><span class="deltaxml-new" style="background:#90EE90">err:XQST0149</span></a><span class="deltaxml-new" style="background:#90EE90">] if the schemas imported by different modules of a query are not compatible as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#schema-consistency"><span class="deltaxml-new" style="background:#90EE90">Section 2.8.1 Schema Consistency</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example imports a schema, specifying both its target namespace and its location, and binding the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">soap</span></code><span class="deltaxml-new" style="background:#90EE90"> to the target namespace:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">import schema namespace soap="http://www.w3.org/2003/05/soap-envelope" 
  at "http://www.w3.org/2003/05/soap-envelope/";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following example imports a schema by specifying only its target namespace, and makes it the </span><span><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></span><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">import schema default element namespace "http://example.org/abc";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following example imports a schema that has no target namespace, providing a location hint, and sets the </span><span><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></span><span class="deltaxml-new" style="background:#90EE90"> to “no namespace” so that the definitions in the imported schema can be referenced:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">import schema default element namespace "" at "http://example.org/xyz.xsd";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The following example imports a schema that has no target namespace and sets the </span><span><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></span><span class="deltaxml-new" style="background:#90EE90"> to “no namespace”. Since no location hint is provided, it is up to the implementation to find the schema to be imported.</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">import schema default element namespace "";</span></pre></div></div></div><div class="div2"><h3><a id="id-module-import"></a><span class="deltaxml-new" style="background:#90EE90">5.12 Module Import</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ModuleImport" id="doc-xpath40-ModuleImport"></a><span class="deltaxml-new" style="background:#90EE90">[24]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ModuleImport" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ModuleImport</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"import" "module" ("namespace" </span><a href="#prod-xpath40-NCName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=")? </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("at" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)*)?</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-module-import" title="module import"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">module import</span></b><span class="deltaxml-new" style="background:#90EE90"> imports the public variable declarations, public function declarations</span><span><span class="deltaxml-new" style="background:#90EE90">, and public item type declarations</span></span><span class="deltaxml-new" style="background:#90EE90"> from one or more </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library modules</span></a><span class="deltaxml-new" style="background:#90EE90"> into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span><span class="deltaxml-new" style="background:#90EE90">, or </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a></span><span class="deltaxml-new" style="background:#90EE90"> of the importing </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90">.] Each module import names a </span><a title="target namespace" class="termref" href="#dt-target-namespace"><span class="deltaxml-new" style="background:#90EE90">target namespace</span></a><span class="deltaxml-new" style="background:#90EE90"> and imports an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> set of modules that share this target namespace. The module import may bind a namespace prefix to the target namespace, adding the (prefix, URI) pair to the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">, and it may provide optional hints for locating the modules to be imported.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a module </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> imports module </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, the static context of module </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> will contain the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span><span class="deltaxml-new" style="background:#90EE90">, or </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a></span><span class="deltaxml-new" style="background:#90EE90"> of module </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, and the dynamic context of module </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> will contain the public </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">dynamically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of module </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">. It will not contain:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Private functions, variables, and item types declared in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Functions, variables, and item types not declared directly in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, but imported from some other library module.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Other components such as </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> declared in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates a module import:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">import module namespace gis="http://example.org/gis-functions";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If a query imports the same module via multiple paths, only one instance of the module is imported. Because only one instance of a module is imported, there is only one instance of each variable declared in a module's prolog.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A module may import its own target namespace (this is interpreted as importing an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> set of other modules that share its target namespace.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">The namespace prefix specified in a module import must not be </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">], and must not be the same as any namespace prefix bound in the same module by another module import, a </span><a title="schema import" class="termref" href="#dt-schema-import"><span class="deltaxml-new" style="background:#90EE90">schema import</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="namespace declaration" class="termref" href="#dt-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">namespace declaration</span></a><span class="deltaxml-new" style="background:#90EE90">, or a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> with a different target namespace [</span><a href="#ERRXQST0033" title="err:XQST0033"><span class="deltaxml-new" style="background:#90EE90">err:XQST0033</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The first </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> in a module import must be of nonzero length [</span><a href="#ERRXQST0088" title="err:XQST0088"><span class="deltaxml-new" style="background:#90EE90">err:XQST0088</span></a><span class="deltaxml-new" style="background:#90EE90">], and specifies the target namespace of the modules to be imported. The </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiterals</span></a><span class="deltaxml-new" style="background:#90EE90"> that follow the </span><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword are optional location hints, and can be interpreted or disregarded in an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> way.</span></p><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0047" title="err:XQST0047"><span class="deltaxml-new" style="background:#90EE90">err:XQST0047</span></a><span class="deltaxml-new" style="background:#90EE90">] if more than one module import in a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> specifies the same target namespace. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0059" title="err:XQST0059"><span class="deltaxml-new" style="background:#90EE90">err:XQST0059</span></a><span class="deltaxml-new" style="background:#90EE90">] if the implementation is not able to process a module import by finding a valid module definition with the specified target namespace. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if two or more variables declared or imported by a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> have equal </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> (as defined by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator) [</span><a href="#ERRXQST0049" title="err:XQST0049"><span class="deltaxml-new" style="background:#90EE90">err:XQST0049</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">Module imports are not transitive. Importing a module provides access only to declarations contained directly in the imported module. For example, if module </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> imports module </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, and module </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> imports module </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90">, module </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> does not have access to the functions and variables declared in module </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="example"><div class="exampleHeader"><a id="d5e39343"></a><span class="deltaxml-new" style="background:#90EE90">Example: Schema Information and Module Import</span></div><p><span class="deltaxml-new" style="background:#90EE90">A module import does not import schema definitions from the imported module. In the following query, the type </span><code><span class="deltaxml-new" style="background:#90EE90">geometry:triangle</span></code><span class="deltaxml-new" style="background:#90EE90"> is not defined, even if it is known in the imported module, so the variable declaration raises an error [</span><a href="#ERRXPST0051" title="err:XPST0051"><span class="deltaxml-new" style="background:#90EE90">err:XPST0051</span></a><span class="deltaxml-new" style="background:#90EE90">]:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">(: Error - geometry:triangle is not defined :) 
import module namespace geo = "http://example.org/geo-functions"; 
declare variable $triangle as geometry:triangle := geo:make-triangle(); 
$triangle</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Without the type declaration for the variable, the variable declaration succeeds:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">import module namespace geo = "http://example.org/geo-functions";
declare variable $triangle := geo:make-triangle();
$triangle</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Importing the schema that defines the type of the variable, the variable declaration succeeds:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">import schema namespace geometry = "http://example.org/geo-schema-declarations"; 
import module namespace geo = "http://example.org/geo-functions"; 
declare variable $triangle as geometry:triangle := geo:make-triangle();
$triangle</span></pre></div></div></div><div class="div3"><h4><a id="id-module-handling-module-uris"></a><span class="deltaxml-new" style="background:#90EE90">5.12.1 The Target Namespace of a Module</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The target namespace of a module should be treated in the same way as other namespace URIs.</span></p><p><span class="deltaxml-new" style="background:#90EE90">To maximize interoperability, query authors should use a string that is a valid absolute IRI.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Implementions must accept any string of Unicode characters. Target namespace URIs are compared using the Unicode codepoint collation rather than any concept of semantic equivalence.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Implementations may provide mechanisms allowing the target namespace URI to be used as input to a process that delivers the module as a resource, for example a catalog, module repository, or URI resolver. For interoperability, such mechanisms should not prevent the user from choosing an arbitrary URI for naming a module.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, implementations may perform syntactic transformations on the target namespace URI to obtain the names of related resources, for example to implement a convention relating the name or location of compiled code to the target namespace URI; but again, such mechanisms should not prevent the user from choosing an arbitrary target namespace URI.</span></p><p><span class="deltaxml-new" style="background:#90EE90">As with other namespace URIs, it is common practice to use target namespace URIs whose scheme is </span><code><span class="deltaxml-new" style="background:#90EE90">http</span></code><span class="deltaxml-new" style="background:#90EE90"> and whose authority part uses a DNS domain name under the control of the user.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The specifications allow, and some users might consider it good practice, for the target namespace URI of a function library to be the same as the namespace URI of the XML vocabulary manipulated by the functions in that library.</span></p></div><div class="div3"><h4><a id="id-module-handling-multiple-same"></a><span class="deltaxml-new" style="background:#90EE90">5.12.2 Multiple Modules with the same Namespace</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Several different modules with the same target namespace can be used in the same query. The names of public variables and public functions must be unique within the </span><a title="module context" class="termref" href="#dt-module-context"><span class="deltaxml-new" style="background:#90EE90">module contexts</span></a><span class="deltaxml-new" style="background:#90EE90"> of a query: that is, if two modules with the same target namespace URI are used in the same query, the names of the public variables and functions in their module contexts must not overlap.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If one module contains an </span><code><span class="deltaxml-new" style="background:#90EE90">import module</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration with the target namespace </span><code><span class="deltaxml-new" style="background:#90EE90">M</span></code><span class="deltaxml-new" style="background:#90EE90">, then all public variables and public functions in the contexts of modules whose target namespace is </span><code><span class="deltaxml-new" style="background:#90EE90">M</span></code><span class="deltaxml-new" style="background:#90EE90"> must be accessible in the importing module, regardless whether the participation of the imported module was directly due to this "import module" declaration.</span></p></div><div class="div3"><h4><a id="id-module-handling-location-uris"></a><span class="deltaxml-new" style="background:#90EE90">5.12.3 Location URIs</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The term “location URIs” refers to the URIs in the </span><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><span class="deltaxml-new" style="background:#90EE90"> clause of an </span><code><span class="deltaxml-new" style="background:#90EE90">import module</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Products should (by default or at user option) take account of all the location URIs in an </span><code><span class="deltaxml-new" style="background:#90EE90">import module</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration, treating each location URI as a reference to a module with the specified target namespace URI. Location URIs should be made absolute with respect to the static base URI of the module containing the </span><code><span class="deltaxml-new" style="background:#90EE90">import module</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration where they appear. The mapping from location URIs to module source code or compiled code MAY be done in any way convenient to the implementation. If possible given the product’s architecture, security requirements, etc, the product should allow this to fetch the source code of the module to use the standard web mechanisms for dereferencing URIs in standard schemes such as the </span><code><span class="deltaxml-new" style="background:#90EE90">http</span></code><span class="deltaxml-new" style="background:#90EE90"> URI scheme.</span></p><p><span class="deltaxml-new" style="background:#90EE90">When the same absolutized location URI is used more than once, either in the same </span><code><span class="deltaxml-new" style="background:#90EE90">import module</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration or in different </span><code><span class="deltaxml-new" style="background:#90EE90">import module</span></code><span class="deltaxml-new" style="background:#90EE90"> declarations within the same query, a single copy of the resource containing the module is loaded. When different absolutized location URIs are used, each results in a single module being loaded, unless the implementation is able to determine that the different URIs are references to the same resource. No error due to duplicate variable or functions names should arise from the same module being imported more than once, so long as the absolute location URI is the same in each case.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Implementations must report a static error if a location URI cannot be resolved after all available recovery strategies have been exhausted.</span></p></div><div class="div3"><h4><a id="id-module-handling-cycles"></a><span class="deltaxml-new" style="background:#90EE90">5.12.4 Cycles</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Implementations must resolve cycles in the import graph, either at the level of target namespace URIs or at the level of location URIs, and ensure that each module is imported only once. </span></p></div></div><div class="div2"><h3><a id="id-namespace-declaration"></a><span class="deltaxml-new" style="background:#90EE90">5.13 Namespace Declaration</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-default-namespace"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-schema-import"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> All implementations must now predeclare the namespace prefixes </span><code><span class="deltaxml-new" style="background:#90EE90">math</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">err</span></code><span class="deltaxml-new" style="background:#90EE90">. In XQuery 3.1 it was permitted but not required to predeclare these namespaces. </span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-NamespaceDecl" id="doc-xpath40-NamespaceDecl"></a><span class="deltaxml-new" style="background:#90EE90">[25]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NamespaceDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NamespaceDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "namespace" </span><a href="#prod-xpath40-NCName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-namespace-declaration" title="namespace declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">namespace declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> declares a namespace prefix and associates it with a namespace URI, adding the (prefix, URI) pair to the set of </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.] The namespace declaration is in scope throughout the query in which it is declared, unless it is overridden by a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></a><span class="deltaxml-new" style="background:#90EE90"> in a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the URILiteral part of a namespace declaration is a zero-length string, any existing namespace binding for the given prefix is removed from the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">. This feature provides a way to remove predeclared namespace prefixes such as </span><code><span class="deltaxml-new" style="background:#90EE90">local</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following query illustrates a namespace declaration:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace foo = "http://example.org";
&lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">In the query result, the newly created node is in the namespace associated with the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://example.org</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The namespace prefix specified in a namespace declaration must not be </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">]. The namespace URI specified in a namespace declaration must not be </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">]. The namespace prefix specified in a namespace declaration must not be the same as any namespace prefix bound in the same module by a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="schema import" class="termref" href="#dt-schema-import"><span class="deltaxml-new" style="background:#90EE90">schema import</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90">, or another namespace declaration [</span><a href="#ERRXQST0033" title="err:XQST0033"><span class="deltaxml-new" style="background:#90EE90">err:XQST0033</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">] if an expression contains a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> with a namespace prefix that is not in the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery has several predeclared namespace prefixes, which are listed in </span><a href="#id-namespaces-and-qnames"><b><span class="deltaxml-new" style="background:#90EE90">2.1.2 Namespaces and QNames</span></b></a><span class="deltaxml-new" style="background:#90EE90">. These prefixes may be used without an explicit declaration; they are present in the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> before each query is processed. They may be overridden by </span><a title="namespace declaration" class="termref" href="#dt-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">namespace declarations</span></a><span class="deltaxml-new" style="background:#90EE90"> in a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> or by </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attributes</span></a><span class="deltaxml-new" style="background:#90EE90"> on constructed elements (however, the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> must not be redeclared, and no other prefix may be bound to the namespace URI associated with the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">]). </span></p><p><span class="deltaxml-new" style="background:#90EE90">Additional predeclared namespace prefixes may be added to the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> by an implementation.</span></p><p><span class="deltaxml-new" style="background:#90EE90">When element or attribute names are compared, they are considered identical if the local parts and namespace URIs match on a codepoint basis. Namespace prefixes need not be identical for two names to match, as illustrated by the following example:</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace xx = "http://example.org";

let $node := &lt;foo:bar xmlns:foo = "http://example.org"&gt;
  &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt;
&lt;/foo:bar&gt;
return $node/xx:bing</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">Although the namespace prefixes </span><code><span class="deltaxml-new" style="background:#90EE90">xx</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">foo</span></code><span class="deltaxml-new" style="background:#90EE90"> differ, both are bound to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://example.org</span></code><span class="deltaxml-new" style="background:#90EE90">. Since </span><code><span class="deltaxml-new" style="background:#90EE90">xx:bing</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">foo:bing</span></code><span class="deltaxml-new" style="background:#90EE90"> have the same local name and the same namespace URI, they match. The output of the above query is as follows.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;foo:bing xmlns:foo="http://example.org"&gt; Lentils &lt;/foo:bing&gt;</span></pre></div></div></div><div class="div2"><h3><a id="id-default-namespace"></a><span class="deltaxml-new" style="background:#90EE90">5.14 Default Namespace Declaration</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-variable-declarations"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> can now be declared to be fixed for a query module, meaning it is unaffected by a namespace declaration appearing on a direct element constructor. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> can be set to the value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/296"><span class="deltaxml-new" style="background:#90EE90">296</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1181"><span class="deltaxml-new" style="background:#90EE90">1181</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;30 April 2023]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-DefaultNamespaceDecl" id="doc-xpath40-DefaultNamespaceDecl"></a><span class="deltaxml-new" style="background:#90EE90">[26]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DefaultNamespaceDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">DefaultNamespaceDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "fixed"? "default" ("element" | "function") "namespace" </span><a href="#doc-xpath40-URILiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody></table><p><b><span class="deltaxml-new" style="background:#90EE90">Default namespace declarations</span></b><span class="deltaxml-new" style="background:#90EE90"> can be used in a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> to facilitate the use of unprefixed QNames.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The namespace URI specified in a default namespace declaration must not be </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0070" title="err:XQST0070"><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following kinds of default namespace declarations are supported:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">default element namespace declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> declares how unprefixed element and type names are to be interpreted. The relevant value is recorded as the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> for the query module. A </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> may contain at most one default element namespace declaration </span><span><span class="deltaxml-new" style="background:#90EE90">and it must not contain both a default element namespace declaration and an </span><code><span class="deltaxml-new" style="background:#90EE90">import schema</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration that specifies a default element namespace</span></span><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0066" title="err:XQST0066"><span class="deltaxml-new" style="background:#90EE90">err:XQST0066</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></code><span class="deltaxml-new" style="background:#90EE90"> may take one of the following forms:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A namespace URI. This namespace will be used for all unprefixed names appearing where an element or type name is expected.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The empty string </span><code><span class="deltaxml-new" style="background:#90EE90">""</span></code><span class="deltaxml-new" style="background:#90EE90">. In this case unprefixed names appearing where an element or type name is expected are treated as being in no namespace: the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is set to </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The string </span><code><span class="deltaxml-new" style="background:#90EE90">"##any"</span></code><span class="deltaxml-new" style="background:#90EE90">. In this case an unprefixed name appearing as a </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90"> in an axis step whose principal node kind is element is interpreted as a wildcard (the unprefixed name </span><code><span class="deltaxml-new" style="background:#90EE90">N</span></code><span class="deltaxml-new" style="background:#90EE90"> is treated as equivalent to the wildcard </span><code><span class="deltaxml-new" style="background:#90EE90">*:N</span></code><span class="deltaxml-new" style="background:#90EE90">); an unprefixed name used appearing where an item type name is expected is interpreted as a local name in namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema</span></code><span class="deltaxml-new" style="background:#90EE90">, while an unprefixed name appearing in any other context where an element or type name is expected is treated as being in no namespace.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the declaration of a default namespace for elements and types:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare default element namespace "http://example.org/names";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If no default element namespace declaration is present, unprefixed element and type names are in no namespace (however, an implementation may define a different default as specified in </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">"fixed"</span></code><span class="deltaxml-new" style="background:#90EE90">, is present, the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> is fixed throughout the module, and is not affected by default namespace declarations (</span><code><span class="deltaxml-new" style="background:#90EE90">xmlns=""</span></code><span class="deltaxml-new" style="background:#90EE90">) appearing on direct element constructors.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">default function namespace declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> declares a namespace URI that is associated with unprefixed function names in static function calls and function declarations.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> may contain at most one default function namespace declaration [</span><a href="#ERRXQST0066" title="err:XQST0066"><span class="deltaxml-new" style="background:#90EE90">err:XQST0066</span></a><span class="deltaxml-new" style="background:#90EE90">]. If the </span><code><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></code><span class="deltaxml-new" style="background:#90EE90"> in a default function namespace declaration is a zero-length string, the default function namespace is undeclared (set to </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">). In that case, any functions that are associated with a namespace can be called only by using an explicit namespace prefix.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If no default function namespace declaration is present, the default function namespace is the namespace of XPath/XQuery functions, </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions</span></code><span class="deltaxml-new" style="background:#90EE90"> (however, an implementation may define a different default as specified in </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">.)</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the declaration of a default function namespace:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare default function namespace "http://www.w3.org/2005/xpath-functions/math";</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">The effect of declaring a default function namespace is that all functions in the default function namespace, including implicitly declared </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor functions</span></a><span class="deltaxml-new" style="background:#90EE90">, can be invoked without specifying a namespace prefix. When a static function call uses a function name with no prefix, the local name of the function must match a function (including implicitly declared </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor functions</span></a><span class="deltaxml-new" style="background:#90EE90">) in the default function namespace [</span><a href="#ERRXPST0017" title="err:XPST0017"><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Only </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor functions</span></a><span class="deltaxml-new" style="background:#90EE90"> can be in no namespace.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The keyword </span><code><span class="deltaxml-new" style="background:#90EE90">"fixed"</span></code><span class="deltaxml-new" style="background:#90EE90"> has no effect when declaring a default function namespace, since there is no mechanism to change the default function namespace within a query module.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> Unprefixed attribute names and variable names are in no namespace.</span></p></div><div class="div2"><h3><a id="id-annotations"></a><span class="deltaxml-new" style="background:#90EE90">5.15 Annotations</span></h3><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnnotatedDecl" id="doc-xpath40-AnnotatedDecl"></a><span class="deltaxml-new" style="background:#90EE90">[27]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnnotatedDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotatedDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" </span><a href="#doc-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#doc-xpath40-VarDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-FunctionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ItemTypeDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ItemTypeDecl</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e35605.doc-xpath40-InlineFunctionExpr" id="noid_d4e35605.doc-xpath40-InlineFunctionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[211]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InlineFunctionExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* ("function" | "fn") </span><a href="#doc-xpath40-FunctionSignature" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionSignature</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#doc-xpath40-FunctionBody" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-Annotation" id="doc-xpath40-Annotation"></a><span class="deltaxml-new" style="background:#90EE90">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"%" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ("(" </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")")?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-AnnotationValue" id="doc-xpath40-AnnotationValue"></a><span class="deltaxml-new" style="background:#90EE90">[29]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringLiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("-"? </span><a href="#doc-xpath40-NumericLiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("true" "(" ")") | ("false" "(" ")")</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">XQuery uses annotations to declare properties associated with functions (inline or declared in the prolog) and variables. For instance, a function may be declared </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90">. The semantics associated with these properties are described in </span><a href="#FunctionDeclns"><b><span class="deltaxml-new" style="background:#90EE90">5.18 Function Declarations</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Annotations are </span><code><span class="deltaxml-new" style="background:#90EE90">(QName, value)</span></code><span class="deltaxml-new" style="background:#90EE90"> pairs. If the EQName of the annotation is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90">, the prefix of the QName is resolved using the statically known namespaces; if no prefix is present, the name is in the </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2012/xquery</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The default namespace is a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></a><span class="deltaxml-new" style="background:#90EE90">, which means that unprefixed names cannot be used for implementation-defined or user-defined annotations. It is permitted to use a no-namespace name, which might be written, for example, as </span><code><span class="deltaxml-new" style="background:#90EE90">%Q{}inline</span></code><span class="deltaxml-new" style="background:#90EE90">; however, this is discouraged because it is likely to reduce portability across implementations.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">In general there is no rule preventing two annotations on the same declaration having the same name, although this is disallowed for some specific annotations such as </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90">. The order of annotations may be significant.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If there is no value associated with an annotation, the effective value is the empty sequence. This is the case, for example, with the annotations </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90"> A few annotations, such as </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90">, have rules defined by this specification. Implementations may define further annotations, whose behavior is implementation-defined. For instance, if the </span><code><span class="deltaxml-new" style="background:#90EE90">eg</span></code><span class="deltaxml-new" style="background:#90EE90"> prefix is bound to a namespace recognized by a particular implementation, then it could be used to define an annotation like </span><code><span class="deltaxml-new" style="background:#90EE90">eg:sequential</span></code><span class="deltaxml-new" style="background:#90EE90">. If the namespace URI of an annotation is not recognized by the implementation, then the annotation has no effect, other than being available for inspection using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:function-annotations</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Implementations may also provide a way for users to define their own annotations. Implementations must not define annotations, or allow users to define annotations, in </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">; it is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0045" title="err:XQST0045"><span class="deltaxml-new" style="background:#90EE90">err:XQST0045</span></a><span class="deltaxml-new" style="background:#90EE90">] for the name of an annotation to be in a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> An annotation can provide values explicitly using a parenthesized list of constant values. These values may take any of the following forms:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A string literal, for example </span><code><span class="deltaxml-new" style="background:#90EE90">"Paris"</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">'London'</span></code><span class="deltaxml-new" style="background:#90EE90">, denoting a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A numeric literal, for example </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">0.1</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">0x7FFF</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">1e-6</span></code><span class="deltaxml-new" style="background:#90EE90">, denoting a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">. The literal may be preceded by a minus sign to represent a negative number.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">One of the constructs </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">, denoting the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> values </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> respectively.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">For example, the annotation </span><code><span class="deltaxml-new" style="background:#90EE90">%java:method("java.lang.Math.sin")</span></code><span class="deltaxml-new" style="background:#90EE90"> sets the value of the </span><code><span class="deltaxml-new" style="background:#90EE90">java:method</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation to the string value </span><code><span class="deltaxml-new" style="background:#90EE90">java.lang.Math.sin</span></code><span class="deltaxml-new" style="background:#90EE90">. An implementation might define such annotations to facilitate calling external functions. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The constructs </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> must be written as prescribed by the grammar. No namespace prefix is allowed. Although the values resemble calls to functions in the default function namespace, they are unaffected by the namespace context.</span></p></div></div><div class="div2"><h3><a id="id-variable-declarations"></a><span class="deltaxml-new" style="background:#90EE90">5.16 Variable Declaration</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-context-value-declarations"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-default-namespace"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The coercion rules are now used when binding values to variables (both global variable declarations and local variable bindings). This aligns XQuery with XSLT, and means that the rules for binding to variables are the same as the rules for binding to function parameters. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/189"><span class="deltaxml-new" style="background:#90EE90">189</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/254"><span class="deltaxml-new" style="background:#90EE90">254</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;29 November 2022]</span></i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e35770.doc-xpath40-AnnotatedDecl" id="noid_d4e35770.doc-xpath40-AnnotatedDecl"></a><span class="deltaxml-new" style="background:#90EE90">[27]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnnotatedDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotatedDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" </span><a href="#doc-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#doc-xpath40-VarDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-FunctionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ItemTypeDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ItemTypeDecl</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e35771.doc-xpath40-Annotation" id="noid_d4e35771.doc-xpath40-Annotation"></a><span class="deltaxml-new" style="background:#90EE90">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"%" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ("(" </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")")?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-VarDecl" id="doc-xpath40-VarDecl"></a><span class="deltaxml-new" style="background:#90EE90">[30]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VarDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"variable" "$" </span><a href="#doc-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ((":=" </span><a href="#doc-xpath40-VarValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("external" (":=" </span><a href="#doc-xpath40-VarDefaultValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a><span class="deltaxml-new" style="background:#90EE90">)?))</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e35773.doc-xpath40-VarName" id="noid_d4e35773.doc-xpath40-VarName"></a><span class="deltaxml-new" style="background:#90EE90">[174]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VarName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e35774.doc-xpath40-TypeDeclaration" id="noid_d4e35774.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-VarValue" id="doc-xpath40-VarValue"></a><span class="deltaxml-new" style="background:#90EE90">[31]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VarValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-VarDefaultValue" id="doc-xpath40-VarDefaultValue"></a><span class="deltaxml-new" style="background:#90EE90">[32]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VarDefaultValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-variable-declartion" title="variable declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">variable declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> in the XQuery prolog defines the name and </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of a variable, and optionally a value for the variable. It adds to the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, and may also add to the </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The term </span><b><span class="deltaxml-new" style="background:#90EE90">variable declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> always refers to a declaration of a variable in a Prolog. The binding of a variable to a value in a query expression, such as a FLWOR expression, is known as a </span><b><span class="deltaxml-new" style="background:#90EE90">variable binding</span></b><span class="deltaxml-new" style="background:#90EE90">, and does not make the variable visible to an importing module.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">During static analysis, a variable declaration causes a pair </span><code><span class="deltaxml-new" style="background:#90EE90">(expanded QName N, type T)</span></code><span class="deltaxml-new" style="background:#90EE90"> to be added to the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90">. The expanded QName N is the </span><code><span class="deltaxml-new" style="background:#90EE90">VarName</span></code><span class="deltaxml-new" style="background:#90EE90">. If N is equal (as defined by the eq operator) to the expanded QName of another variable in in-scope variables, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0049" title="err:XQST0049"><span class="deltaxml-new" style="background:#90EE90">err:XQST0049</span></a><span class="deltaxml-new" style="background:#90EE90">]. The type T of the declared variable is as follows: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></code><span class="deltaxml-new" style="background:#90EE90"> is present, then the </span><code><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></code><span class="deltaxml-new" style="background:#90EE90"> in the </span><code><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the Static Typing Feature is in effect and </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is present, then the static type inferred from static analysis of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90">;</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Type inference might not be computable until after the check for circular dependencies, described below, is complete.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Otherwise, </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">All variable names declared in a library module must (when expanded) be in the target namespace of the library module [</span><a href="#ERRXQST0048" title="err:XQST0048"><span class="deltaxml-new" style="background:#90EE90">err:XQST0048</span></a><span class="deltaxml-new" style="background:#90EE90">]. A variable declaration may use annotations to specify that the variable is </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> (which is the default). [</span><a id="dt-private-variable" title="private   variable"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">private variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is a variable with a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A private variable is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can not import it into the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module.] [</span><a id="dt-public-variable" title="public variable"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">public variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is a variable without a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A public variable is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can import it into the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. Using </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0116" title="err:XQST0116"><span class="deltaxml-new" style="background:#90EE90">err:XQST0116</span></a><span class="deltaxml-new" style="background:#90EE90">] if a variable declaration contains both a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> and a </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, or more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">Variable names that have no namespace prefix are in no namespace. Variable declarations that have no namespace prefix may appear only in a main module.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of variable declarations:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The following declaration specifies both the type and the value of a variable. This declaration causes the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> to be associated with variable </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, and the value </span><code><span class="deltaxml-new" style="background:#90EE90">7</span></code><span class="deltaxml-new" style="background:#90EE90"> to be associated with variable </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $x as xs:integer := 7;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following declaration specifies a value but not a type. The </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the variable is inferred from the static type of its value. In this case, the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> has a static type of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, inferred from its value which is 7.5.</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $x := 7.5;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following declaration specifies a type but not a value. The keyword </span><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><span class="deltaxml-new" style="background:#90EE90"> indicates that the value of the variable will be provided by the external environment. At evaluation time, if the variable </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> does not have a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised.</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $x as xs:integer external;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following declaration specifies neither a type nor a value. It simply declares that the query depends on the existence of a variable named </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">, whose type and value will be provided by the external environment. During query analysis, the type of </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90"> is considered to be </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">. During query evaluation, the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> must include a type and a value for </span><code><span class="deltaxml-new" style="background:#90EE90">$x</span></code><span class="deltaxml-new" style="background:#90EE90">, and its value must be compatible with its type.</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $x external;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">The following declaration, which might appear in a library module, declares a variable whose name includes a namespace prefix:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $sasl:username as xs:string := "jonathan@example.com";</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This is an example of an external variable declaration that provides a </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $x as xs:integer external := 47;</span></pre></div></div></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> An implementation can provide annotations it needs. For instance, an implementation that supports volatile external variables might allow them to be declared using an annotation:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare %eg:volatile variable $time as xs:time external;</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-initializing-expression" title="initializing expression"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: If a variable declaration includes an expression (</span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90">), the expression is called an </span><b><span class="deltaxml-new" style="background:#90EE90">initializing expression.</span></b><span class="deltaxml-new" style="background:#90EE90"> The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog, other than the variable being declared.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">If a required type is defined, then the value obtained by evaluating the initializing expression is converted to the required type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. A type error occurs if this is not possible. In invoking the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> does not apply.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In a module's dynamic context, a variable value (or the context value) may </span><a title="depends on" class="termref" href="#dt-depends-on"><span class="deltaxml-new" style="background:#90EE90">depend on</span></a><span class="deltaxml-new" style="background:#90EE90"> another variable value (or the context value). [</span><a id="dt-depends-on" title="depends on"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A variable value (or the context value) </span><b><span class="deltaxml-new" style="background:#90EE90">depends on</span></b><span class="deltaxml-new" style="background:#90EE90"> another variable value (or the context value) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">In the following example, the value of variable </span><code><span class="deltaxml-new" style="background:#90EE90">$a</span></code><a title="depends on" class="termref" href="#dt-depends-on"><span class="deltaxml-new" style="background:#90EE90">depends on</span></a><span class="deltaxml-new" style="background:#90EE90"> the value of variable </span><code><span class="deltaxml-new" style="background:#90EE90">$b</span></code><span class="deltaxml-new" style="background:#90EE90"> because the evaluation of $a's initializing expression accesses the value of $b during the evaluation of </span><code><span class="deltaxml-new" style="background:#90EE90">local:f()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $a := local:f(); 
declare variable $b := 1;
declare function local:f() { $b };</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">A directed graph can be built with all variable values and the context value as nodes, and with the </span><a title="depends on" class="termref" href="#dt-depends-on"><span class="deltaxml-new" style="background:#90EE90">depend on</span></a><span class="deltaxml-new" style="background:#90EE90"> relation as edges. This graph must not contain cycles, as it makes the population of the dynamic context impossible. If it is discovered, during static analysis or during dynamic evaluation, that such a cycle exists, error [</span><a href="#ERRXQDY0054" title="err:XQDY0054"><span class="deltaxml-new" style="background:#90EE90">err:XQDY0054</span></a><span class="deltaxml-new" style="background:#90EE90">] must be raised.</span></p><p><span class="deltaxml-new" style="background:#90EE90">During query evaluation, each variable declaration causes a pair </span><code><span class="deltaxml-new" style="background:#90EE90">(expanded QName </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">, value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> to be added to the </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90">. The expanded QName </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is the </span><code><span class="deltaxml-new" style="background:#90EE90">VarName</span></code><span class="deltaxml-new" style="background:#90EE90">. The value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, then </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> If </span><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, then:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> if a value is provided for the variable by the external environment, then </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is that value. The means by which typed values of external variables are provided by the external environment is implementation-defined.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> if no value is provided for the variable by the external environment, and </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, then </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> is the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If no value is provided for the variable by the external environment, and </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is not specified, then a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPDY0002" title="err:XPDY0002"><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90">It is implementation-dependent whether this error is raised if the evaluation of the query does not reference the value of the variable.</span></p></li></ul></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In all cases the value </span><var><span class="deltaxml-new" style="background:#90EE90">V</span></var><span class="deltaxml-new" style="background:#90EE90"> must match the type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> according to the rules for SequenceType matching; otherwise a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p></div><div class="div2"><h3><a id="id-context-value-declarations"></a><span class="deltaxml-new" style="background:#90EE90">5.17 Context Value Declaration</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#FunctionDeclns"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-variable-declarations"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item. </span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ContextValueDecl" id="doc-xpath40-ContextValueDecl"></a><span class="deltaxml-new" style="background:#90EE90">[33]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ContextValueDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ContextValueDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "context" (("value" ("as" </span><a href="#doc-xpath40-SequenceType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)?) | ("item" ("as" </span><a href="#doc-xpath40-ItemType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">)?)) ((":=" </span><a href="#doc-xpath40-VarValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("external" (":=" </span><a href="#doc-xpath40-VarDefaultValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a><span class="deltaxml-new" style="background:#90EE90">)?))</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">A context value declaration allows a query to specify the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90">, value, or default value for the </span><a title="initial context value" class="termref" href="#dt-initial-context-value"><span class="deltaxml-new" style="background:#90EE90">initial context value</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Only the main module can set the </span><a title="initial context value" class="termref" href="#dt-initial-context-value"><span class="deltaxml-new" style="background:#90EE90">initial context value</span></a><span class="deltaxml-new" style="background:#90EE90">. In a library module, a context value declaration must be external, and specifies only the static type. Specifying a </span><a href="#doc-xpath40-VarValue"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-VarDefaultValue"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a><span class="deltaxml-new" style="background:#90EE90"> for a context value declaration in a library module is a static error [</span><a href="#ERRXQST0113" title="err:XQST0113"><span class="deltaxml-new" style="background:#90EE90">err:XQST0113</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The form </span><code><span class="deltaxml-new" style="background:#90EE90">declare context value</span></code><span class="deltaxml-new" style="background:#90EE90"> allows the </span><a title="initial context value" class="termref" href="#dt-initial-context-value"><span class="deltaxml-new" style="background:#90EE90">initial context value</span></a><span class="deltaxml-new" style="background:#90EE90"> to set to any value, with any sequence type. The alternative form </span><code><span class="deltaxml-new" style="background:#90EE90">declare context item</span></code><span class="deltaxml-new" style="background:#90EE90"> is retained for compatibility with earlier versions of XQuery, and requires the value to be a single item, and the type (if specified) to be an item type.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In every module that does not contain a context value declaration, the effect is as if the declaration</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare context value as item()* external;</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">appeared in that module.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The context value declaration has the effect of setting the context value static type </span><code><span class="deltaxml-new" style="background:#90EE90">T</span></code><span class="deltaxml-new" style="background:#90EE90"> in the static context. When the form </span><code><span class="deltaxml-new" style="background:#90EE90">declare context value</span></code><span class="deltaxml-new" style="background:#90EE90"> is used, the default type is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">. When the alternative form </span><code><span class="deltaxml-new" style="background:#90EE90">declare context item</span></code><span class="deltaxml-new" style="background:#90EE90"> is used, the default type is </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a module contains more than one context value declaration, a static error is raised [</span><a href="#ERRXQST0099" title="err:XQST0099"><span class="deltaxml-new" style="background:#90EE90">err:XQST0099</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog.</span></p><p><span class="deltaxml-new" style="background:#90EE90">During query evaluation, a </span><a title="fixed focus" class="termref" href="#dt-fixed-focus"><span class="deltaxml-new" style="background:#90EE90">fixed focus</span></a><span class="deltaxml-new" style="background:#90EE90"> is created in the dynamic context for the evaluation of the </span><code><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></code><span class="deltaxml-new" style="background:#90EE90"> in the main module, and for the initializing expression of every variable declaration in every module. The context value of this fixed focus is called the </span><a title="initial context value" class="termref" href="#dt-initial-context-value"><span class="deltaxml-new" style="background:#90EE90">initial context value</span></a><span class="deltaxml-new" style="background:#90EE90">, which is selected as follows: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, then the initial context value is the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> In such a case, the initial context value does not obtain its value from the external environment. If the external environment attempts to provide a value for the initial context value, it is outside the scope of this specification whether that is ignored, or results in an error. </span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, then:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the declaration occurs in a main module and a value is provided for the context value by the external environment, then the initial context value is that value. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">If the declaration occurs in a library module, then it does not set the value of the initial context value, the value is set by the main module.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">The means by which an external value is provided by the external environment is implementation-defined.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If no value is provided for the context value by the external environment, and </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is specified, then the initial context value is the result of evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90"> as described below. </span></p></li></ul></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In all cases where the context value has a value, that value must match the type </span><code><span class="deltaxml-new" style="background:#90EE90">T</span></code><span class="deltaxml-new" style="background:#90EE90"> according to the rules for SequenceType matching; otherwise a type error is raised [</span><a href="#ERRXPTY0004" title="err:XPTY0004"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></a><span class="deltaxml-new" style="background:#90EE90">]. If more than one module contains a context value declaration, the context value must match the type declared in each one.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is evaluated, the static and dynamic contexts for the evaluation are the current module's static and dynamic context.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a required type is defined, then the value obtained by evaluating </span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90"> is converted to the required type by applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">. A type error occurs if this is not possible. In invoking the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a><span class="deltaxml-new" style="background:#90EE90"> does not apply.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples of context value declarations.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Declare the type of the context value as a single element item with a required element name:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace env = "http://www.w3.org/2003/05/soap-envelope"; 
declare context item as element(env:Envelope) external;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Declare a default context value, which is a system log in a default location. If the system log is in a different location, it can be specified in the external environment:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare context value as element(sys:log) external := doc("/var/xlogs/sysevent.xml")/sys:log;</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Declare a context value, which is collection whose collection URI is supplied as an external parameter to the query. If the system log is in a different location, it can be specified in the external environment:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $uri as xs:string external;
declare context value as document-node()* := collection($uri);</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">With this declaration, a query body such as </span><code><span class="deltaxml-new" style="background:#90EE90">//person[name="Mandela"]</span></code><span class="deltaxml-new" style="background:#90EE90"> returns all matching </span><code><span class="deltaxml-new" style="background:#90EE90">person</span></code><span class="deltaxml-new" style="background:#90EE90"> elements appearing in any document in the collection.</span></p></li></ul></div><div class="div2"><h3><a id="FunctionDeclns"></a><span class="deltaxml-new" style="background:#90EE90">5.18 Function Declarations</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-function-annotations"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-context-value-declarations"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Function definitions in the static context may now have optional parameters, provided this does not cause ambiguity across multiple function definitions with the same name. Optional parameters are given a default value, which can be any expression, including one that depends on the context of the caller (so an argument can default to the context value). </span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">In addition to the </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system functions</span></a><span class="deltaxml-new" style="background:#90EE90">, XQuery allows users to declare functions of their own. A function declaration declares a family of functions having the same name and similar parameters. The declaration specifies the name of the function, the names and datatypes of the parameters, and the datatype of the result. All datatypes are specified using the syntax described in </span><a href="#id-types"><b><span class="deltaxml-new" style="background:#90EE90">3 Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Including a function declaration in the query causes a corresponding </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> to be added to the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">. The associated functions also become available in the </span><a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">dynamically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e36333.doc-xpath40-AnnotatedDecl" id="noid_d4e36333.doc-xpath40-AnnotatedDecl"></a><span class="deltaxml-new" style="background:#90EE90">[27]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnnotatedDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotatedDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" </span><a href="#doc-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#doc-xpath40-VarDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-FunctionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ItemTypeDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ItemTypeDecl</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e36334.doc-xpath40-Annotation" id="noid_d4e36334.doc-xpath40-Annotation"></a><span class="deltaxml-new" style="background:#90EE90">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"%" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ("(" </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")")?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FunctionDecl" id="doc-xpath40-FunctionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[34]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"function" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> "(" </span><a href="#doc-xpath40-ParamListWithDefaults" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ParamListWithDefaults</span></a><span class="deltaxml-new" style="background:#90EE90">? ")" </span><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? (</span><a href="#doc-xpath40-FunctionBody" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a><span class="deltaxml-new" style="background:#90EE90"> | "external")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-reserved-function-names"><span class="deltaxml-new" style="background:#90EE90">xgc: reserved-function-names</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ParamListWithDefaults" id="doc-xpath40-ParamListWithDefaults"></a><span class="deltaxml-new" style="background:#90EE90">[36]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ParamListWithDefaults" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ParamListWithDefaults</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ParamWithDefault" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-ParamWithDefault" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ParamWithDefault" id="doc-xpath40-ParamWithDefault"></a><span class="deltaxml-new" style="background:#90EE90">[37]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ParamWithDefault" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Param" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Param</span></a><span class="deltaxml-new" style="background:#90EE90"> (":=" </span><a href="#doc-xpath40-StandaloneExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e36338.doc-xpath40-Param" id="noid_d4e36338.doc-xpath40-Param"></a><span class="deltaxml-new" style="background:#90EE90">[39]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Param" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Param</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#doc-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-FunctionBody" id="doc-xpath40-FunctionBody"></a><span class="deltaxml-new" style="background:#90EE90">[40]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FunctionBody" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e36340.doc-xpath40-TypeDeclaration" id="noid_d4e36340.doc-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeDeclaration" class="xquery"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#doc-xpath40-SequenceType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e36341.doc-xpath40-EnclosedExpr" id="noid_d4e36341.doc-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#doc-xpath40-Expr" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90"> A function declaration specifies whether the implementation of the function is </span><a title="user-defined function" class="termref" href="#dt-udf"><span class="deltaxml-new" style="background:#90EE90">user-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="external function" class="termref" href="#dt-external-function"><span class="deltaxml-new" style="background:#90EE90">external</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In addition to </span><a title="user-defined function" class="termref" href="#dt-udf"><span class="deltaxml-new" style="background:#90EE90">user-defined functions</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="external function" class="termref" href="#dt-external-function"><span class="deltaxml-new" style="background:#90EE90">external functions</span></a><span class="deltaxml-new" style="background:#90EE90">, XQuery 4.0 and XPath 4.0 allows anonymous functions to be declared in the body of a query using </span><a title="inline function expression" class="termref" href="#dt-inline-func"><span class="deltaxml-new" style="background:#90EE90">inline function expressions</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following example illustrates the declaration and use of a local function that accepts a sequence of </span><code><span class="deltaxml-new" style="background:#90EE90">employee</span></code><span class="deltaxml-new" style="background:#90EE90"> elements, summarizes them by department, and returns a sequence of </span><code><span class="deltaxml-new" style="background:#90EE90">dept</span></code><span class="deltaxml-new" style="background:#90EE90"> elements.</span></p><div class="example"><div class="exampleHeader"><a id="d5e40749"></a><span class="deltaxml-new" style="background:#90EE90">Example: Using a function, prepare a summary of employees that are located in Denver.</span></div><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:summary($emps as element(employee)*) as element(dept)* { 
  for $no in distinct-values($emps/deptno) 
  let $emp := $emps[deptno = $no]
  return &lt;dept&gt; 
    &lt;deptno&gt;{ $no }&lt;/deptno&gt; 
    &lt;headcount&gt;{ count($emp) }&lt;/headcount&gt; 
    &lt;payroll&gt;{ sum($emp/salary) }&lt;/payroll&gt; 
  &lt;/dept&gt; 
};
local:summary(doc("acme_corp.xml")//employee[location = "Denver"])</span></pre></div></div></div><div class="div3"><h4><a id="id-user-defined-functions"></a><span class="deltaxml-new" style="background:#90EE90">5.18.1 User-Defined Functions</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-udf" title="user-defined function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">User defined functions</span></b><span class="deltaxml-new" style="background:#90EE90"> are functions that contain a </span><b><span class="deltaxml-new" style="background:#90EE90">function body</span></b><span class="deltaxml-new" style="background:#90EE90">, which provides the implementation of the function as a </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90">.] The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> for a function body includes all functions, variables, and namespaces that are declared or imported anywhere in the </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90">, including the function being declared. Its </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> component also includes the parameters of the function being declared. However, its </span><a title="context value static type" class="termref" href="#dt-context-value-static-type"><span class="deltaxml-new" style="background:#90EE90">context value static type</span></a><span class="deltaxml-new" style="background:#90EE90"> component is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, and an implementation should raise a static error [</span><a href="#ERRXPST0008" title="err:XPST0008"><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></a><span class="deltaxml-new" style="background:#90EE90">] if an expression depends on the context value. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The properties of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> are derived from the syntax of the function declaration as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The name of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> obtained by expanding the </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> that follows the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The parameters of </span><var><span class="deltaxml-new" style="background:#90EE90">F</span></var><span class="deltaxml-new" style="background:#90EE90"> are derived from the </span><code><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></code><span class="deltaxml-new" style="background:#90EE90"> entries in the </span><code><span class="deltaxml-new" style="background:#90EE90">ParamListWithDefaults</span></code><span class="deltaxml-new" style="background:#90EE90">:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The parameter name is the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> obtained by expanding the </span><code><span class="deltaxml-new" style="background:#90EE90">EQName</span></code><span class="deltaxml-new" style="background:#90EE90"> that follows the </span><code><span class="deltaxml-new" style="background:#90EE90">$</span></code><span class="deltaxml-new" style="background:#90EE90"> symbol.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The required type of the parameter is given by the </span><code><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></code><span class="deltaxml-new" style="background:#90EE90">, defaulting to </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The default value of the parameter is given by the expression that follows the </span><code><span class="deltaxml-new" style="background:#90EE90">:=</span></code><span class="deltaxml-new" style="background:#90EE90"> symbol; if there is no default value, then the parameter is a required parameter.</span></p></li></ul></li><li><p><span class="deltaxml-new" style="background:#90EE90">The return type of the function is given by the final </span><code><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></code><span class="deltaxml-new" style="background:#90EE90"> that follows the </span><code><span class="deltaxml-new" style="background:#90EE90">ParamListWithDefaults</span></code><span class="deltaxml-new" style="background:#90EE90"> if present, defaulting to </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The function annotations are derived from the annotations that follow the </span><code><span class="deltaxml-new" style="background:#90EE90">%</span></code><span class="deltaxml-new" style="background:#90EE90"> symbol, if present.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The implementation of the function is given by the enclosed expression.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The static context may include more than one declared function with the same name, but their arity ranges must not overlap [</span><a href="#ERRXQST0034" title="err:XQST0034"><span class="deltaxml-new" style="background:#90EE90">err:XQST0034</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A consequence of this rule is that a function declaration must not declare a function that has arity 1 (one) if its name is the same as the name of an imported atomic type, since the name would then clash with the constructor function for that type.</span></p></div></div><div class="div3"><h4><a id="id-function-names"></a><span class="deltaxml-new" style="background:#90EE90">5.18.2 Function Names</span></h4><p><span class="deltaxml-new" style="background:#90EE90">Every declared function must be in a namespace; that is, every declared function name must (when expanded) have a non-null namespace URI [</span><a href="#ERRXQST0060" title="err:XQST0060"><span class="deltaxml-new" style="background:#90EE90">err:XQST0060</span></a><span class="deltaxml-new" style="background:#90EE90">]. If the function name in a function declaration has no namespace prefix, it is considered to be in the </span><b><span class="deltaxml-new" style="background:#90EE90">default function namespace</span></b><span class="deltaxml-new" style="background:#90EE90">. Every function name declared in a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90"> must (when expanded) be in the </span><a title="target namespace" class="termref" href="#dt-target-namespace"><span class="deltaxml-new" style="background:#90EE90">target namespace</span></a><span class="deltaxml-new" style="background:#90EE90"> of the library module [</span><a href="#ERRXQST0048" title="err:XQST0048"><span class="deltaxml-new" style="background:#90EE90">err:XQST0048</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-reserved-namespaces" title="reserved namespaces"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></b><span class="deltaxml-new" style="background:#90EE90"> is a namespace that must not be used in the name of a function declaration.] It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0045" title="err:XQST0045"><span class="deltaxml-new" style="background:#90EE90">err:XQST0045</span></a><span class="deltaxml-new" style="background:#90EE90">] if the function name in a function declaration (when expanded) is in a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></a><span class="deltaxml-new" style="background:#90EE90">. The following namespaces are reserved namespaces: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2001/XMLSchema-instance</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/array</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/map</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/math</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2012/xquery</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In order to allow main modules to declare functions for local use within the module without defining a new namespace, XQuery predefines the namespace prefix </span><code><span class="deltaxml-new" style="background:#90EE90">local</span></code><span class="deltaxml-new" style="background:#90EE90"> to the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xquery-local-functions</span></code><span class="deltaxml-new" style="background:#90EE90">. It is suggested (but not required) that this namespace be used for defining local functions.</span></p></div><div class="div3"><h4><a id="id-function-parameters"></a><span class="deltaxml-new" style="background:#90EE90">5.18.3 Function Parameters</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The function declaration includes a list of zero or more function parameters.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The parameters of a function declaration are considered to be variables whose scope is the function body. It is an </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0039" title="err:XQST0039"><span class="deltaxml-new" style="background:#90EE90">err:XQST0039</span></a><span class="deltaxml-new" style="background:#90EE90">] for a function declaration to have more than one parameter with the same name. The type of a function parameter can be any type that can be expressed as a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If a function parameter is declared using a name but no type, its default type is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">. If the result type is omitted from a function declaration, its default result type is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The function body defines the implementation of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90">. The rules for static function calls (see </span><a href="#id-eval-static-function-call"><b><span class="deltaxml-new" style="background:#90EE90">4.5.1.2 Evaluating Static Function Calls</span></b></a><span class="deltaxml-new" style="background:#90EE90">) ensure that a value is available for each parameter, whether required or optional, and that the value will always be an instance of the declared type. </span></p><p><span class="deltaxml-new" style="background:#90EE90">A parameter is optional if a default value is supplied using the construct </span><code><span class="deltaxml-new" style="background:#90EE90">:= ExprSingle</span></code><span class="deltaxml-new" style="background:#90EE90">; otherwise it is required. If a parameter is optional, then all subsequent parameters in the list must also be optional; otherwise, a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised [</span><a href="#ERRXQST0148" title="err:XQST0148"><span class="deltaxml-new" style="background:#90EE90">err:XQST0148</span></a><span class="deltaxml-new" style="background:#90EE90">]. In other words, the parameter list includes zero or more required parameters followed by zero or more optional parameters.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The number of arguments that may be supplied in a call to this family of functions is thus in the range </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> to </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90">, where </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> is the number of required parameters, and </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is the total number of parameters (whether required or optional). This is refered to as the </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The default value for an optional parameter will often be supplied using a simple literal or constant expression, for example </span><code><span class="deltaxml-new" style="background:#90EE90">$married as xs:boolean := false()</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">$options as map(*) := map { }</span></code><span class="deltaxml-new" style="background:#90EE90">. However, to allow greater flexibility, the initial value can also be context-dependent. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">$node as node() := .</span></code><span class="deltaxml-new" style="background:#90EE90"> declares a parameter whose default value is the context value from the dynamic context of the caller, while </span><code><span class="deltaxml-new" style="background:#90EE90">$collation as xs:string := default-collation()</span></code><span class="deltaxml-new" style="background:#90EE90"> declares a parameter whose default value is the default collation from the dynamic context of the caller. The detailed rules are as follows. In these rules, the term </span><b><span class="deltaxml-new" style="background:#90EE90">caller</span></b><span class="deltaxml-new" style="background:#90EE90"> means the function call or function reference that invokes the function being defined.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> for the initializing expression of an optional parameter is the same as the static context for the </span><a title="initializing expression" class="termref" href="#dt-initializing-expression"><span class="deltaxml-new" style="background:#90EE90">initializing expression</span></a><span class="deltaxml-new" style="background:#90EE90"> of a variable declaration (see </span><a href="#id-variable-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.16 Variable Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90">), with the following exceptions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> component is empty. This means that the initializing expression cannot refer to any variables, other than local variables declared within the expression itself. Note in particular that it cannot refer to other parameters of the function.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="context value static type" class="termref" href="#dt-context-value-static-type"><span class="deltaxml-new" style="background:#90EE90">context value static type</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> excludes all user-defined functions.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> for the initializing expression of an optional parameter is the same as the dynamic context of the </span><b><span class="deltaxml-new" style="background:#90EE90">caller</span></b><span class="deltaxml-new" style="background:#90EE90">, with the following exceptions:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90"> component is empty.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">dynamically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> excludes all user-defined functions.</span></p></li></ul></div><div class="div3"><h4><a id="id-function-annotations"></a><span class="deltaxml-new" style="background:#90EE90">5.18.4 Function Annotations</span></h4><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-conformance"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#FunctionDeclns"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Functions may be declared to be variadic. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/161"><span class="deltaxml-new" style="background:#90EE90">161</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1137"><span class="deltaxml-new" style="background:#90EE90">1137</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;23 April 2024]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The values </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> are allowed in function annotations, and negated numeric literals are also allowed. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/637"><span class="deltaxml-new" style="background:#90EE90">637</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/682"><span class="deltaxml-new" style="background:#90EE90">682</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;12 September 2023]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">A function declaration may use the </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotations to specify that a function is public or private; if neither of these annotations is used, the function is public. [</span><a id="dt-private-function" title="private function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">private function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function with a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A private function is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can not import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. ] [</span><a id="dt-public-function" title="public function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">public function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function without a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A public function is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. ] Using </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0106" title="err:XQST0106"><span class="deltaxml-new" style="background:#90EE90">err:XQST0106</span></a><span class="deltaxml-new" style="background:#90EE90">] if a function declaration contains both a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> and a </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, or more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The function annotation </span><code><span class="deltaxml-new" style="background:#90EE90">%variadic</span></code><span class="deltaxml-new" style="background:#90EE90"> declares the corresponding </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> to be </span><a title="variadic" class="termref" href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a><span class="deltaxml-new" style="background:#90EE90">. If a function is annotated as </span><code><span class="deltaxml-new" style="background:#90EE90">%variadic</span></code><span class="deltaxml-new" style="background:#90EE90"> then there must be at least one parameter, and all parameters including the final parameter must be required parameters [</span><a href="#ERRXQST0150" title="err:XQST0150"><span class="deltaxml-new" style="background:#90EE90">err:XQST0150</span></a><span class="deltaxml-new" style="background:#90EE90">]. For an overview of the behavior of variadic functions, see </span><a href="#id-variadic-functions-overview"><b><span class="deltaxml-new" style="background:#90EE90">4.5.3 Variadic Functions</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation can define annotations, in its own namespace, to support functionality beyond the scope of this specification. For instance, an implementation that supports external Java functions might use an annotation to associate a Java function with an XQuery external function:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare 
  %java:method("java.lang.StrictMath.copySign") 
function smath:copySign($magnitude, $sign) external;</span></pre></div></div></div><div class="div3"><h4><a id="id-external-functions"></a><span class="deltaxml-new" style="background:#90EE90">5.18.5 External Functions</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> In function declarations, </span><a title="external function" class="termref" href="#dt-external-function"><span class="deltaxml-new" style="background:#90EE90">external functions</span></a><span class="deltaxml-new" style="background:#90EE90"> are identified by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><span class="deltaxml-new" style="background:#90EE90">. The purpose of a function declaration for an external function is to declare the datatypes of the function parameters and result, for use in type checking of the query that contains or imports the function declaration.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An XQuery implementation may provide a facility whereby external functions can be implemented, but it is not required to do so. If such a facility is provided, the protocols by which parameters are passed to an external function, and the result of the function is returned to the invoking query, are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. An XQuery implementation may augment the type system of </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> with additional types that are designed to facilitate exchange of data, or it may provide mechanism for the user to define such types. For example, a type might be provided that encapsulates an object returned by an external function, such as an SQL database connection. These additional types, if defined, are considered to be derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div3"><h4><a id="id-recursion"></a><span class="deltaxml-new" style="background:#90EE90">5.18.6 Recursion</span></h4><p><span class="deltaxml-new" style="background:#90EE90">A function declaration may be recursive—that is, it may reference itself. Mutually recursive functions, whose bodies reference each other, are also allowed.</span></p><div class="example"><div class="exampleHeader"><a id="d5e41191"></a><span class="deltaxml-new" style="background:#90EE90">Example: A recursive function to compute the maximum depth of a document</span></div><p><span class="deltaxml-new" style="background:#90EE90">The following example declares a recursive function that computes the maximum depth of a node hierarchy, and calls the function to find the maximum depth of a particular document. The function </span><code><span class="deltaxml-new" style="background:#90EE90">local:depth</span></code><span class="deltaxml-new" style="background:#90EE90"> calls the built-in functions </span><code><span class="deltaxml-new" style="background:#90EE90">empty</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">max</span></code><span class="deltaxml-new" style="background:#90EE90">, which are in the default function namespace.</span></p><div class="parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare function local:depth($e as node()) as xs:integer {
  (: A node with no children has depth 1 :)
  (: Otherwise, add 1 to max depth of children :)

  if (empty($e/*)) 
  then 1
  else max(for $c in $e/* return local:depth($c)) + 1
};
local:depth(doc("partlist.xml"))</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">[TODO: add an example of a function with an optional parameter.]</span></p></div></div></div><div class="div2"><h3><a id="id-item-type-declaration"></a><span class="deltaxml-new" style="background:#90EE90">5.19 Item Type Declarations</span></h3><p><span class="deltaxml-new" style="background:#90EE90">An item type declaration defines a name for an item type. Defining a name for an item type allows it to be referenced </span><span><span class="deltaxml-new" style="background:#90EE90">by name</span></span><span class="deltaxml-new" style="background:#90EE90"> rather than repeating the item type definition in full. It also allows recursive types to be defined.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e36836.doc-xpath40-AnnotatedDecl" id="noid_d4e36836.doc-xpath40-AnnotatedDecl"></a><span class="deltaxml-new" style="background:#90EE90">[27]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnnotatedDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotatedDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" </span><a href="#doc-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#doc-xpath40-VarDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">VarDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-FunctionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">FunctionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#doc-xpath40-ItemTypeDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ItemTypeDecl</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="noid_d4e36837.doc-xpath40-Annotation" id="noid_d4e36837.doc-xpath40-Annotation"></a><span class="deltaxml-new" style="background:#90EE90">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Annotation" class="xquery"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"%" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ("(" </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#doc-xpath40-AnnotationValue" class="xquery"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")")?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-ItemTypeDecl" id="doc-xpath40-ItemTypeDecl"></a><span class="deltaxml-new" style="background:#90EE90">[42]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ItemTypeDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ItemTypeDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"item-type" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> "as" </span><a href="#doc-xpath40-ItemType" class="xquery"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">An item-type declaration adds a named item type to the </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a><span class="deltaxml-new" style="background:#90EE90"> of the containing module. This enables the item type to be referred to using a simple name.</span></p><div class="example"><p><span class="deltaxml-new" style="background:#90EE90">For example, given the declaration:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare item-type app:invoice as map("xs:string", element(inv:paid-invoice))</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">It becomes possible to declare a variable containing a sequence of such items as:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare variable $invoices as app:invoice*</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">The definition can also be used within another item-type declaration:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare item-type app:overdue-invoices as map("xs:date", app:invoice*)</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90">If the name of the item type being declared is written as an (unprefixed) NCName, then it is interpreted as being in the </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">All item type names declared in a library module must (when expanded) be in the target namespace of the library module [</span><a href="#ERRXQST0048" title="err:XQST0048"><span class="deltaxml-new" style="background:#90EE90">err:XQST0048</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><p><span class="deltaxml-new" style="background:#90EE90">An item type declaration may use the </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotations to specify that an item type name is public or private; if neither of these annotations is used, the declaration is public. [</span><a id="dt-private-item-type" title="private item type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">private item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a named item type with a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A private item type is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can not import it into the </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. ] [</span><a id="dt-public-item-type" title="public item type"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">public item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is an item type declaration without a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A public item type is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can import it into the </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. ] Using </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0106" title="err:XQST0106"><span class="deltaxml-new" style="background:#90EE90">err:XQST0106</span></a><span class="deltaxml-new" style="background:#90EE90">] if an item type declaration contains both a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> and a </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, or more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The declaration of an item type (whether locally declared in a module or imported from a public declaration in an imported module) must precede any use of the item type name: that is, the name only becomes available in the static context of constructs that lexically follow the relevant item type declaration or module import. A consequence of this rule is that cyclic and self-referential definitions are not allowed.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The name of an item type must be unique among the names of all declared item types and </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic types</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> of the query module. [</span><a href="#ERRXQST0146" title="err:XQST0146"><span class="deltaxml-new" style="background:#90EE90">err:XQST0146</span></a><span class="deltaxml-new" style="background:#90EE90">] </span></p><p><span class="deltaxml-new" style="background:#90EE90">A recursive named item type is one whose expansion refers directly or indirectly to itself. A named item type is allowed to be recursive only if it satisfies the conditions defined in </span><a href="#id-recursive-record-tests"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.4 Recursive Record Tests</span></b></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0140" title="err:XQST0140"><span class="deltaxml-new" style="background:#90EE90">err:XQST0140</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">It is possible to import a public variable or function into a different module even if its declaration refers to named item types that are not themselves imported (because they are declared as </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90">). This is because it is entirely possible to use and create instances of an item type even when the name of the item type is not known. This is true even for recursive item types. However, it is generally more convenient if any named item types used in public function and variable declarations are themselves public. This is likely to be especially true in the case of higher-order functions.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Declaring a named item type will in many cases implicitly create a constructor function, having the same name as the type, for use when creating instances of the type. For details see </span><a href="#id-constructor-functions"><b><span class="deltaxml-new" style="background:#90EE90">4.21.5 Constructor Functions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div2"><h3><a id="id-option-declaration"></a><span class="deltaxml-new" style="background:#90EE90">5.20 Option Declaration</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-option-declaration" title="option declaration"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">option declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> declares an option that affects the behavior of a particular implementation. Each option consists of an identifying EQName and a StringLiteral.] </span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="doc-xpath40-OptionDecl" id="doc-xpath40-OptionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[43]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OptionDecl" class="xquery"><span class="deltaxml-new" style="background:#90EE90">OptionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "option" </span><a href="#doc-xpath40-EQName" class="xquery"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#doc-xpath40-StringLiteral" class="xquery"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">Typically, a particular option will be recognized by some implementations and not by others. The syntax is designed so that option declarations can be successfully parsed by all implementations.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the EQName of an option is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> with a prefix, it must resolve to a namespace URI and local name, using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPST0081" title="err:XPST0081"><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the EQName of an option </span><span><span class="deltaxml-new" style="background:#90EE90">is a </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> that</span></span><span class="deltaxml-new" style="background:#90EE90"> does not have a prefix, the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is in the </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2012/xquery</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace, which is reserved for option declarations defined by the XQuery family of specifications. XQuery does not currently define declaration options in this namespace.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Each implementation recognizes the </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2012/xquery</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace URI and and all options defined in this namespace in this specification. In addition, each implementation recognizes an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> set of namespace URIs and an implementation-defined set of option names defined in those namespaces. If the namespace part of an option declaration's name is not recognized, the option declaration is ignored.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the effect of the option declaration, including its error behavior, is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, if the local part of the QName is not recognized, or if the StringLiteral does not conform to the rules defined by the implementation for the particular option declaration, the implementation may choose whether to raise an error, ignore the option declaration, or take some other action.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Implementations may impose rules on where particular option declarations may appear relative to variable declarations and function declarations, and the interpretation of an option declaration may depend on its position.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An option declaration must not be used to change the syntax accepted by the processor, or to suppress the detection of </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static errors</span></a><span class="deltaxml-new" style="background:#90EE90">. However, it may be used without restriction to modify the semantics of the query. The scope of the option declaration is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">—for example, an option declaration might apply to the whole query, to the current module, or to the immediately following function declaration.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The following examples illustrate several possible uses for option declarations:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">This option declaration might be used to specify how comments in source documents returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc()</span></code><span class="deltaxml-new" style="background:#90EE90"> function should be handled:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare option exq:strip-comments "true";</span></pre></div></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">This option declaration might be used to associate a namespace used in function names with a Java class: </span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">declare namespace smath = "http://example.org/MathLibrary";
declare option exq:java-class "smath = java.lang.StrictMath";</span></pre></div></div></li></ul></div></div></div><div class="div1"><h2><a id="id-conformance"></a><span class="deltaxml-new" style="background:#90EE90">6 Conformance</span></h2><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#lexical-structure"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-function-annotations"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Support for higher-order functions is now a mandatory feature (in 3.1 it was optional). </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/205"><span class="deltaxml-new" style="background:#90EE90">205</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/326"><span class="deltaxml-new" style="background:#90EE90">326</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;1 February 2023]</span></i></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The static typing feature has been dropped. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1343"><span class="deltaxml-new" style="background:#90EE90">1343</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">This section defines the conformance criteria for an XQuery 4.0 and XPath 4.0 processor. In this section, the following terms are used to indicate the requirement levels defined in </span><a href="#RFC2119"><span class="deltaxml-new" style="background:#90EE90">[RFC2119]</span></a><span class="deltaxml-new" style="background:#90EE90">. [</span><a id="must" title="must"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">MUST</span></b><span class="deltaxml-new" style="background:#90EE90"> means that the item is an absolute requirement of the specification.] [</span><a id="mustnot" title="must not"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">MUST NOT</span></b><span class="deltaxml-new" style="background:#90EE90"> means that the item is an absolute prohibition of the specification.] [</span><a id="may" title="may"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">MAY</span></b><span class="deltaxml-new" style="background:#90EE90"> means that an item is truly optional.] </span><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">[</span><a id="should" title="should"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">SHOULD</span></b><span class="deltaxml-new" style="background:#90EE90"> means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.]</span></span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath is intended primarily as a component that can be used by other specifications. Therefore, XPath relies on specifications that use it (such as </span><a href="#XPTR"><span class="deltaxml-new" style="background:#90EE90">[XPointer]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#xslt-40"><span class="deltaxml-new" style="background:#90EE90">[XSL Transformations (XSLT) Version 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">) to specify conformance criteria for XPath in their respective environments. Specifications that set conformance criteria for their use of XPath </span><a title="must not" class="termref" href="#mustnot"><span class="deltaxml-new" style="background:#90EE90">MUST NOT</span></a><span class="deltaxml-new" style="background:#90EE90"> change the syntactic or semantic definitions of XPath as given in this specification, except by subsetting and/or compatible extensions.</span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">If a language is described as an extension of XPath, then every expression that conforms to the XPath grammar </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> behave as described in this specification. </span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">An XQuery processor that claims to conform to this specification </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> include a claim of Minimal Conformance as defined in </span><a href="#id-minimal-conformance"><b><span class="deltaxml-new" style="background:#90EE90">6.1 Minimal Conformance</span></b></a><span class="deltaxml-new" style="background:#90EE90">. In addition to a claim of Minimal Conformance, it </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> claim conformance to one or more optional features defined in </span><a href="#id-conform-optional-features"><b><span class="deltaxml-new" style="background:#90EE90">6.2 Optional Features</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-minimal-conformance"></a><span class="deltaxml-new" style="background:#90EE90">6.1 Minimal Conformance</span></h3><p><span class="deltaxml-new" style="background:#90EE90">An implementation that claims </span><b><span class="deltaxml-new" style="background:#90EE90">Minimal Conformance</span></b><span class="deltaxml-new" style="background:#90EE90"> to this specification </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> provide all of the following items:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">An implementation of everything specified in this document except those features specified in </span><a href="#id-conform-optional-features"><b><span class="deltaxml-new" style="background:#90EE90">6.2 Optional Features</span></b></a><span class="deltaxml-new" style="background:#90EE90"> to be optional. If an implementation does not provide a given optional feature, it </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> implement any requirements specified in </span><a href="#id-conform-optional-features"><b><span class="deltaxml-new" style="background:#90EE90">6.2 Optional Features</span></b></a><span class="deltaxml-new" style="background:#90EE90"> for implementations that do not provide that feature.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A definition of every item specified to be </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">, unless that item is part of an optional feature that is not provided by the implementation. A list of </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> items can be found in </span><a href="#id-impl-defined-items"><b><span class="deltaxml-new" style="background:#90EE90">E Implementation-Defined Items</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Implementations are not required to define items specified to be </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">An implementation of </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, as specified in </span><a href="#id-data-model-conformance"><b><span class="deltaxml-new" style="background:#90EE90">6.3 Data Model Conformance</span></b></a><span class="deltaxml-new" style="background:#90EE90">, and a definition of every item specified to be </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">, unless that item is part of an optional feature that is not provided by the implementation.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">An implementation of all functions defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, and a definition of every item specified to be </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">, unless that function or item is part of an optional feature that is not provided by the implementation.</span></p></li></ol></div></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-conform-optional-features"></a><span class="deltaxml-new" style="background:#90EE90">6.2 Optional Features</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The features discussed in this section are optional. An implementation </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> claim conformance to one or more of these features.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The description of each feature mentions any errors that occur if a query relies on a feature that is not present.</span></p><div class="div3"><h4><a id="id-schema-aware-feature"></a><span class="deltaxml-new" style="background:#90EE90">6.2.1 Schema Aware Feature</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-schema-aware-feature" title="schema aware feature"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> permits the query Prolog to contain a </span><a title="schema import" class="termref" href="#dt-schema-import"><span class="deltaxml-new" style="background:#90EE90">schema import</span></a><span class="deltaxml-new" style="background:#90EE90">, and permits a query to contain a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (see </span><a href="#id-validate"><b><span class="deltaxml-new" style="background:#90EE90">4.24 Validate Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">). ] </span></p><p><span class="deltaxml-new" style="background:#90EE90">If an XQuery implementation does not provide the Schema Aware Feature, it </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> raise a static error [</span><a href="#ERRXQST0009" title="err:XQST0009"><span class="deltaxml-new" style="background:#90EE90">err:XQST0009</span></a><span class="deltaxml-new" style="background:#90EE90">] if it encounters a schema import, and it </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> raise a static error [</span><a href="#ERRXQST0075" title="err:XQST0075"><span class="deltaxml-new" style="background:#90EE90">err:XQST0075</span></a><span class="deltaxml-new" style="background:#90EE90">] if it encounters a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If an implementation provides the Schema Aware Feature, it </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> also provide the </span><a href="#id-typed-data-feature"><b><span class="deltaxml-new" style="background:#90EE90">6.2.2 Typed Data Feature</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div3"><h4><a id="id-typed-data-feature"></a><span class="deltaxml-new" style="background:#90EE90">6.2.2 Typed Data Feature</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-typed-data-feature" title="typed data feature"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">Typed Data Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> permits an XDM instance to contain element node types other than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> and attributes node types other than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">If an XQuery implementation does not provide the Typed Data Feature, it </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> guarantee that:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The XDM has the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> for every element node and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> for every attribute node, including nodes created by the query.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Elements constructed by the query always have the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">; attributes constructed by the query always have the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. (This is equivalent to using </span><code><span class="deltaxml-new" style="background:#90EE90">construction mode = strip</span></code><span class="deltaxml-new" style="background:#90EE90">.)</span></p></li></ol></div><div class="div3"><h4><a id="id-module-feature"></a><span class="deltaxml-new" style="background:#90EE90">6.2.3 Module Feature</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-module-feature" title="module feature"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">Module Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> allows a query Prolog to contain a </span><b><span class="deltaxml-new" style="background:#90EE90">Module Import</span></b><span class="deltaxml-new" style="background:#90EE90"> and allows </span><b><span class="deltaxml-new" style="background:#90EE90">library modules</span></b><span class="deltaxml-new" style="background:#90EE90"> to be created.] </span></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation that does not provide the Module Feature </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0016" title="err:XQST0016"><span class="deltaxml-new" style="background:#90EE90">err:XQST0016</span></a><span class="deltaxml-new" style="background:#90EE90">] if it encounters a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">. Since a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> is required in a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">, the Module Feature is required in order to create a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In the absence of the Module Feature, each query consists of a single </span><a title="main module" class="termref" href="#dt-main-module"><span class="deltaxml-new" style="background:#90EE90">main module</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div3"><h4><a id="id-serialization-feature"></a><span class="deltaxml-new" style="background:#90EE90">6.2.4 Serialization Feature</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-serialization-feature" title="serialization feature"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">Serialization Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> provides means for serializing the result of a query as specified in </span><a href="#id-serialization"><b><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></b></a><span class="deltaxml-new" style="background:#90EE90">.] A conforming XQuery implementation that provides the Serialization Feature </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> conform to </span><a href="#id-serialization"><b><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></b></a><span class="deltaxml-new" style="background:#90EE90">. An implementation </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> provide other forms of serialization, which do not conform to the Serialization Feature, and are beyond the scope of this specification. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The means by which serialization is invoked is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If an error is raised during the serialization process as specified in </span><a href="#xslt-xquery-serialization-40"><span class="deltaxml-new" style="background:#90EE90">[XSLT and XQuery Serialization 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, an implementation </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> report the error to the calling environment.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An implementation that does not provide the Serialization Feature </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST NOT</span></a><span class="deltaxml-new" style="background:#90EE90"> raise errors when reading an </span><a title="output declaration" class="termref" href="#dt-output-declaration"><span class="deltaxml-new" style="background:#90EE90">output declaration</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> implement </span><code><span class="deltaxml-new" style="background:#90EE90">fn:serialize</span></code><span class="deltaxml-new" style="background:#90EE90">; it </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90">, however, raise an error when </span><code><span class="deltaxml-new" style="background:#90EE90">fn:serialize</span></code><span class="deltaxml-new" style="background:#90EE90"> is invoked, as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-serialize"><span class="deltaxml-new" style="background:#90EE90">Section 14.1.3 fn:serialize</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. An implementation that does not provide the Serialization Feature </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> provide results of a query using a vendor-defined serialization.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Some implementations return query results without serialization. For instance, an implementation might provide results via an XML API or a binary representation such as a persistent DOM.</span></p></div></div></div></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-data-model-conformance"></a><span class="deltaxml-new" style="background:#90EE90">6.3 Data Model Conformance</span></h3><p><span class="deltaxml-new" style="background:#90EE90">All XQuery implementations process data represented in the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90"> as specified in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. The data model specification relies on languages such as XQuery to specify conformance criteria for the data model in their respective environments, and suggests that the following issues should be considered:</span></p><ol class="enumar"><li><p><em><span class="deltaxml-new" style="background:#90EE90">Support for normative construction from an infoset.</span></em><span class="deltaxml-new" style="background:#90EE90"> An implementation </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> choose to claim conformance to </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#const-infoset"><span class="deltaxml-new" style="background:#90EE90">Section 3.2 Construction from an Infoset</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, which defines a normative way to construct an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> from an XML document that is merely well-formed or is governed by a DTD.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Support for normative construction from a PSVI.</span></em><span class="deltaxml-new" style="background:#90EE90"> An implementation </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> choose to claim conformance to </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#const-psvi"><span class="deltaxml-new" style="background:#90EE90">Section 3.3 Construction from a PSVI</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, which defines a normative way to construct an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> from an XML document that is governed by a W3C XML Schema.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Support for versions of XML and XSD.</span></em><span class="deltaxml-new" style="background:#90EE90"> As stated in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, the definitions of primitives such as strings, characters, and names </span><a title="should" class="termref" href="#should"><span class="deltaxml-new" style="background:#90EE90">SHOULD</span></a><span class="deltaxml-new" style="background:#90EE90"> be taken from the latest applicable version of the base specifications in which they are defined; it is implementation-defined which definitions are used in cases where these differ. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">For suggestions on processing XML 1.1 documents with XSD 1.0, see </span><a href="#xml11schema10"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1 and Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Ranges of data values.</span></em><span class="deltaxml-new" style="background:#90EE90"> In XQuery, the following limits are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">For the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> type, the maximum number of decimal digits (</span><code><span class="deltaxml-new" style="background:#90EE90">totalDigits</span></code><span class="deltaxml-new" style="background:#90EE90"> facet) </span><a title="must" class="termref" href="#must"><span class="deltaxml-new" style="background:#90EE90">MUST</span></a><span class="deltaxml-new" style="background:#90EE90"> be at least 18. This limit </span><a title="should" class="termref" href="#should"><span class="deltaxml-new" style="background:#90EE90">SHOULD</span></a><span class="deltaxml-new" style="background:#90EE90"> be at least 20 digits in order to accommodate the full range of values of built-in subtypes of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:long</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:unsignedLong</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gYear</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gYearMonth</span></code><span class="deltaxml-new" style="background:#90EE90">: the minimum and maximum value of the year component (must be at least 1 to 9999).</span></p><p><span class="deltaxml-new" style="background:#90EE90">For the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:time</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">: the maximum number of fractional second digits (must be at least 3).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:duration type</span></code><span class="deltaxml-new" style="background:#90EE90">: the maximum absolute values of the years, months, days, hours, minutes, and seconds components.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> type: the maximum absolute value, expressed as an integer number of months.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> type: the maximum absolute value, expressed as a decimal number of seconds.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90">, and types derived from them: limitations (if any) imposed by the implementation on lengths of values.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The limits listed above need not be fixed, but </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> depend on environmental factors such as system resources. For example, the length of a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> might be limited by available memory.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">For discussion of errors due to </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> limits, see </span><a href="#id-kinds-of-errors"><b><span class="deltaxml-new" style="background:#90EE90">2.4.1 Kinds of Errors</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></li></ol></div></div><div class="xquery"><div class="div2 xquery"><h3><a id="id-syntax-extensions"></a><span class="deltaxml-new" style="background:#90EE90">6.4 Syntax Extensions</span></h3><p><span class="deltaxml-new" style="background:#90EE90">Any syntactic extensions to XQuery are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. The effect of syntactic extensions, including their error behavior, is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. Syntactic extensions </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> be used without restriction to modify the semantics of a XQuery expression.</span></p></div></div></div></div><div class="back"><h1><span class="deltaxml-old" style="background:#FF5555">404</span></h1><p><strong><span class="deltaxml-old" style="background:#FF5555">File not found</span></strong></p><p><span class="deltaxml-old" style="background:#FF5555"> The site configured at this address does not contain the requested file. </span></p><p><span class="deltaxml-old" style="background:#FF5555"> If this is your site, make sure that the filename case matches the URL as well as any file permissions.</span><span class="deltaxml-old" style="background:#FF5555"> For root URLs (like </span><code><span class="deltaxml-old" style="background:#FF5555">http://example.com/</span></code><span class="deltaxml-old" style="background:#FF5555">) you must provide an </span><code><span class="deltaxml-old" style="background:#FF5555">index.html</span></code><span class="deltaxml-old" style="background:#FF5555"> file. </span></p><p><a href="https://help.github.com/pages/"><span class="deltaxml-old" style="background:#FF5555">Read the full documentation</span></a><span class="deltaxml-old" style="background:#FF5555"> for more information about using </span><strong><span class="deltaxml-old" style="background:#FF5555">GitHub Pages</span></strong><span class="deltaxml-old" style="background:#FF5555">. </span></p><div id="suggestions"><a href="https://githubstatus.com"><span class="deltaxml-old" style="background:#FF5555">GitHub Status</span></a><span class="deltaxml-old" style="background:#FF5555"> — </span><a href="https://twitter.com/githubstatus"><span class="deltaxml-old" style="background:#FF5555">@githubstatus</span></a></div><a href="/" class="logo logo-img-1x"><span class="deltaxml-old-img"><img style="border: 2px solid red" width="32" height="32" title="" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTZCRDY3REIzRjAxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTZCRDY3RUIzRjAxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdCQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjdDQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+SM9MCAAAA+5JREFUeNrEV11Ik1EY3s4+ddOp29Q5b0opCgKFsoKoi5Kg6CIhuwi6zLJLoYLopq4qsKKgi4i6CYIoU/q5iDAKs6syoS76IRWtyJ+p7cdt7sf1PGOD+e0c3dygAx/67ZzzPM95/877GYdHRg3ZjMXFxepQKNS6sLCwJxqNNuFpiMfjVs4ZjUa/pmmjeD6VlJS8NpvNT4QQ7mxwjSsJiEQim/1+/9lgMHgIr5ohuxG1WCw9Vqv1clFR0dCqBODElV6v90ogEDjGdYbVjXhpaendioqK07CIR7ZAqE49PT09BPL2PMgTByQGsYiZlQD4uMXtdr+JxWINhgINYhGT2MsKgMrm2dnZXgRXhaHAg5jEJodUAHxux4LudHJE9RdEdA+i3Juz7bGHe4mhE9FNrgwBCLirMFV9Okh5eflFh8PR5nK5nDabrR2BNJlKO0T35+Li4n4+/J+/JQCxhmu5h3uJoXNHPbmWZAHMshWB8l5/ipqammaAf0zPDDx1ONV3vurdidqwAQL+pEc8sLcAe1CCvQ3YHxIW8Pl85xSWNC1hADDIv0rIE/o4J0k3kww4xSlwIhcq3EFFOm7KN/hUGOQkt0CFa5WpNJlMvxBEz/IVQAxg/ZRZl9wiHA63yDYieM7DnLP5CiAGsC7I5sgtYKJGWe2A8seFqgFJrJjEPY1Cn3pJ8/9W1e5VWsFDTEmFrBcoDhZJEQkXuhICMyKpjhahqN21hRYATKfUOlDmkygrR4o4C0VOLGJKrOITKB4jijzdXygBKixyC5TDQdnk/Pz8qRw6oOWGlsTKGOQW6OH6FBWsyePxdOXLTgxiyebILZCjz+GLgMIKnXNzc49YMlcRdHXcSwxFVgTInQhC9G33UhNoJLuqq6t345p9y3eUy8OTk5PjAHuI9uo4b07FBaOhsu0A4Unc+T1TU1Nj3KsSSE5yJ65jqF2DDd8QqWYmAZrIM2VlZTdnZmb6AbpdV9V6ec9znf5Q7HjYumdRE0JOp3MjitO4SFa+cZz8Umqe3TCbSLvdfkR/kWDdNQl5InuTcysOcpFT35ZrbBxx4p3JAHlZVVW1D/634VRt+FvLBgK/v5LV9WS+10xMTEwtRw7XvqOL+e2Q8V3AYIOIAXQ26/heWVnZCVfcyKHg2CBgTpmPmjYM8l24GyaUHyaIh7XwfR9ErE8qHoDfn2LTNAVC0HX6MFcBIP8Bi+6F6cdW/DICkANRfx99fEYFQ7Nph5i/uQiA214gno7K+guhaiKg9gC62+M8eR7XsBsYJ4ilam60Fb7r7uAj8wFyuwM1oIOWgfmDy6RXEEQzJMPe23DXrVS7rtyD3Df8z/FPgAEAzWU5Ku59ZAUAAAAASUVORK5CYII="></span></a><a href="/" class="logo logo-img-2x"><span class="deltaxml-old-img"><img style="border: 2px solid red" width="32" height="32" title="" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEQUM1QkUxRUI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEQUM1QkUxRkI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdGQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjgwQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hfPRaQAAB6lJREFUeNrsW2mME2UYbodtt+2222u35QheoCCYGBQligIJgkZJNPzgigoaTEj8AdFEMfADfyABkgWiiWcieK4S+QOiHAYUj2hMNKgYlEujpNttu9vttbvdw+chU1K6M535pt3ubHCSyezR+b73eb73+t7vrfXsufOW4bz6+vom9/b23ovnNNw34b5xYGAgODg46Mbt4mesVmsWd1qSpHhdXd2fuP/Afcput5/A88xwymcdBgLqenp6FuRyuWV4zu/v759QyWBjxoz5t76+/gun09mK5xFyakoCAPSaTCazNpvNPoYVbh6O1YKGRF0u13sNDQ27QMzfpiAAKj0lnU6/gBVfAZW2WWpwwVzy0IgP3G73FpjI6REhAGA9qVRqA1b9mVoBVyIC2tDi8Xg24+dUzQiAbS/s7Ox8G2o/3mKCC+Zw0efzPQEfcVjYrARX3dbV1bUtHo8fMgt42f+Mp0yUTVQbdWsAHVsikdiHkHaPxcQXQufXgUBgMRxme9U0AAxfH4vFvjM7eF6UkbJS5qoQwEQGA57Ac5JllFyUVZZ5ckUEgMVxsK2jlSYzI+QXJsiyjzNEAJyJAzb/KQa41jJKL8pODMQiTEAymXw5n8/P0IjD3bh7Rgog59aanxiIRTVvV/oj0tnHca/WMrVwODwB3raTGxzkBg/gnZVapFV62Wy2n5AO70HM/5wbJ0QnXyQSaVPDIuNZzY0V3ntHMwxiwHA0Gj2Np7ecIBDgaDAYXKCQJM1DhrgJ3nhulcPbl8j4NmHe46X/g60fwbz3aewjkqFQaAqebWU1AOqyQwt8Id6qEHMc97zu7u7FGGsn7HAiVuosVw7P35C1nccdgSCxop1dHeZswmfHMnxBo6ZTk+jN8dl/vF7vWofDsa+MLN9oEUBMxOb3+1eoEsBVw6Zmua49r8YmhAKDiEPcMwBsxMiqQ+ixzPFxZyqRpXARG/YOr1ObFJ0gUskXBbamcR1OKmMUvDxHRAu8/LmY3jFLMUpFqz9HxG65smYJdyKyECOxDiEAe/p1gjF2oonivZAsxVgl2daa4EQWCW6J55qFAFFZiJWYLxNQy2qOSUzGRsyXCUDIeliwAHEO4WSlWQBRFoZakXcKmCXmyXAKs0Ve9vl8q42WoIYpJU4hV3hKcNs8m9gl7p/xQ73eF5kB4j5mNrWmTJRNwAzqiV1CxjVTZCIkEq+Z1bZFZSN2CenmVAFVy4Plz8xKAGWjjAKFk6lCBMDR/MJjLLMSQNm43xAiQKTaA+9/wewhDjL+JVI1kkTSSOTcKbMTwPqESAot6dn6Fr1gHwVJju6IRuyiByPuUUBAg5DGkAgBmxlvdgIEK9gDkohdY/BJo4CAG0R8miRSsGABkgVQs4KXu098IgUXSSRsFAoKZiVAVDY2WUiiPTjYRi41KwGisrGsLtlsth8Fiwnz2fBkQvWfRtlE3iF2yW63/yCacXZ1dW02GwGyTFaRd4idJnCKHRaCxYRHoG5LTKT6SyiToP1fJHbmAYPYRR0UnZQtMnA6s0zg+GZBlt0Gdo7EPHgpE3Q6nZ8YyLhc8Xj8MJh/aKTAY+5FPAKHLE7RdwuYJZmNwzyCMkBCYyKROJBMJl9B/PXXCjjmCmDOVzH3fiPpObEWGqoKe4EBl8v1hlqsdLvd23mkxHM9pc9kMpmno9HoeTii7ewbHEZPPx1ztLS1tV3AnGuMjiNjvbQFuHw6zDo5By7dTPAQNBgMLrRarTkSls1mnwT7uwp9virx9QzbW/HuV/j5d/b+6jniKlllP8lkeONJDk+dq9GsQTnC4fB1heO0K47Hwe7WdDr9nAKgXwOBwHI+C45Htj1d6sd429TUNEcmUdc+PRaLHcvn87dXW4ugzdsaGxufL94NFv9zi1J7GVbhlvb2dnaJ3SVrxfc+n2+NTsZ7/H7/Mr3g5XdSIHyJSH1PZ+7fToyl2+ErqilgZ4NaLYB9goVGaHjR93Hv1ZrU4XDsFT20kH3PObzbWk0CgG1jacVIUnAQb9F+VexyLMzkpcLv0IJV7AHQIOCAUYHx7v5qgScmYHtTqSAyZLEJTK22Bie4iq3xsqpm4SAf9Hq9a2DnJ4uLK3SEULcdRvp3i3zHySqpficxEdsQc1NrlYXXvR+O7qASSezXB+h1SuUomgg9LL8BUoV4749EIolKh+EiqWmqVEZlDgHks2pxHw7xTqUQw9J5NcAXOK10AGIoZ6Zli6JY6Z1Q461KoZ4NiKLHarW+KDsxlDUPHZ5zPQZqUVDPJsTqb5n9malbpAh8C2XXDLl62+WZIDFRUlNVOiwencnNU3aQEkL+cDMSoLvZo2fQB7AJssNAuFuvorlDVVkkg2I87+jo2K2QAVphDrfyViK5VqtO34OkaxXCp+7drdDBCAdubm6eidX+2WwqT5komwh4YQLk+H4aE93h8Xg2gvHekQZOGSgLZTLyDTLJ4Lx9/KZWKBSainT4Iy3FqQBfnUZR42PKQFksBr9QKVXCPusD3OiA/RkQ5kP8qV/Jl1WywAp/6+dcmPM2zL1UrUahe4JqfnWWKXIul3uUbfP8njAFLW1OFr3gdFtZ72cNH+PtQT7/brW+NXqJAHh0y9V8/U/A1U7AfwIMAD7mS3pCbuWJAAAAAElFTkSuQmCC"></span></a><div class="div1"><h2><a id="nt-bnf"></a><span class="deltaxml-new" style="background:#90EE90">A XQuery 4.0 and XPath 4.0 Grammar</span></h2><div class="div2"><h3><a id="id-grammar"></a><span class="deltaxml-new" style="background:#90EE90">A.1 EBNF</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The grammar of XQuery 4.0 and XPath 4.0 uses the same simple Extended Backus-Naur Form (EBNF) notation as </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> with the following minor differences.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">All named symbols have a name that begins with an uppercase letter.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It adds a notation for referring to productions in external specifications.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comments or extra-grammatical constraints on grammar productions are between '/*' and '*/' symbols.</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A 'xgc:' prefix is an extra-grammatical constraint, the details of which are explained in </span><a href="#extra-grammatical-constraints"><b><span class="deltaxml-new" style="background:#90EE90">A.1.2 Extra-grammatical Constraints</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A 'ws:' prefix explains the whitespace rules for the production, the details of which are explained in </span><a href="#whitespace-rules"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5 Whitespace Rules</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification for parsing rules, and is explained in </span><a href="#notes-on-parsing"><b><span class="deltaxml-new" style="background:#90EE90">A.1.3 Grammar Notes</span></b></a><span class="deltaxml-new" style="background:#90EE90">. These notes are not normative.</span></p></li></ul></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The terminal symbols for this grammar include the quoted strings used in the production rules below, and the terminal symbols defined in section </span><a href="#terminal-symbols"><b><span class="deltaxml-new" style="background:#90EE90">A.3.1 Terminal Symbols</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span><span><span class="deltaxml-new" style="background:#90EE90">The grammar is a little unusual in that parsing and tokenization are somewhat intertwined: for more details see </span><a href="#lexical-structure"><b><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></p><p><span class="deltaxml-new" style="background:#90EE90">The EBNF notation is described in more detail in </span><a href="#EBNFNotation"><b><span class="deltaxml-new" style="background:#90EE90">A.1.1 Notation</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-XPath" id="prod-xpath40-XPath"></a><span class="deltaxml-new" style="background:#90EE90">[1]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-XPath"><span class="deltaxml-new" style="background:#90EE90">XPath</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Module" id="prod-xpath40-Module"></a><span class="deltaxml-new" style="background:#90EE90">[2]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Module"><span class="deltaxml-new" style="background:#90EE90">Module</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VersionDecl"><span class="deltaxml-new" style="background:#90EE90">VersionDecl</span></a><span class="deltaxml-new" style="background:#90EE90">? (</span><a href="#prod-xpath40-LibraryModule"><span class="deltaxml-new" style="background:#90EE90">LibraryModule</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-MainModule"><span class="deltaxml-new" style="background:#90EE90">MainModule</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-VersionDecl" id="prod-xpath40-VersionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[3]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VersionDecl"><span class="deltaxml-new" style="background:#90EE90">VersionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"xquery" (("encoding" </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("version" </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("encoding" </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?)) </span><a href="#prod-xpath40-Separator"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MainModule" id="prod-xpath40-MainModule"></a><span class="deltaxml-new" style="background:#90EE90">[4]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MainModule"><span class="deltaxml-new" style="background:#90EE90">MainModule</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><a href="#prod-xpath40-QueryBody"><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-LibraryModule" id="prod-xpath40-LibraryModule"></a><span class="deltaxml-new" style="background:#90EE90">[5]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LibraryModule"><span class="deltaxml-new" style="background:#90EE90">LibraryModule</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ModuleDecl"><span class="deltaxml-new" style="background:#90EE90">ModuleDecl</span></a><a href="#prod-xpath40-Prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ModuleDecl" id="prod-xpath40-ModuleDecl"></a><span class="deltaxml-new" style="background:#90EE90">[6]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ModuleDecl"><span class="deltaxml-new" style="background:#90EE90">ModuleDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"module" "namespace" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><a href="#prod-xpath40-Separator"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Prolog" id="prod-xpath40-Prolog"></a><span class="deltaxml-new" style="background:#90EE90">[7]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#prod-xpath40-DefaultNamespaceDecl"><span class="deltaxml-new" style="background:#90EE90">DefaultNamespaceDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-Setter"><span class="deltaxml-new" style="background:#90EE90">Setter</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-NamespaceDecl"><span class="deltaxml-new" style="background:#90EE90">NamespaceDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-Import"><span class="deltaxml-new" style="background:#90EE90">Import</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#prod-xpath40-Separator"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a><span class="deltaxml-new" style="background:#90EE90">)* ((</span><a href="#prod-xpath40-ContextValueDecl"><span class="deltaxml-new" style="background:#90EE90">ContextValueDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-AnnotatedDecl"><span class="deltaxml-new" style="background:#90EE90">AnnotatedDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-OptionDecl"><span class="deltaxml-new" style="background:#90EE90">OptionDecl</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#prod-xpath40-Separator"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Separator" id="prod-xpath40-Separator"></a><span class="deltaxml-new" style="background:#90EE90">[8]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Separator"><span class="deltaxml-new" style="background:#90EE90">Separator</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">";"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Setter" id="prod-xpath40-Setter"></a><span class="deltaxml-new" style="background:#90EE90">[9]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Setter"><span class="deltaxml-new" style="background:#90EE90">Setter</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BoundarySpaceDecl"><span class="deltaxml-new" style="background:#90EE90">BoundarySpaceDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-DefaultCollationDecl"><span class="deltaxml-new" style="background:#90EE90">DefaultCollationDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-BaseURIDecl"><span class="deltaxml-new" style="background:#90EE90">BaseURIDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ConstructionDecl"><span class="deltaxml-new" style="background:#90EE90">ConstructionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-OrderingModeDecl"><span class="deltaxml-new" style="background:#90EE90">OrderingModeDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-EmptyOrderDecl"><span class="deltaxml-new" style="background:#90EE90">EmptyOrderDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-CopyNamespacesDecl"><span class="deltaxml-new" style="background:#90EE90">CopyNamespacesDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-DecimalFormatDecl"><span class="deltaxml-new" style="background:#90EE90">DecimalFormatDecl</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BoundarySpaceDecl" id="prod-xpath40-BoundarySpaceDecl"></a><span class="deltaxml-new" style="background:#90EE90">[10]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BoundarySpaceDecl"><span class="deltaxml-new" style="background:#90EE90">BoundarySpaceDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "boundary-space" ("preserve" | "strip")</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DefaultCollationDecl" id="prod-xpath40-DefaultCollationDecl"></a><span class="deltaxml-new" style="background:#90EE90">[11]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DefaultCollationDecl"><span class="deltaxml-new" style="background:#90EE90">DefaultCollationDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "default" "collation" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BaseURIDecl" id="prod-xpath40-BaseURIDecl"></a><span class="deltaxml-new" style="background:#90EE90">[12]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BaseURIDecl"><span class="deltaxml-new" style="background:#90EE90">BaseURIDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "base-uri" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ConstructionDecl" id="prod-xpath40-ConstructionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[13]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ConstructionDecl"><span class="deltaxml-new" style="background:#90EE90">ConstructionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "construction" ("strip" | "preserve")</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OrderingModeDecl" id="prod-xpath40-OrderingModeDecl"></a><span class="deltaxml-new" style="background:#90EE90">[14]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OrderingModeDecl"><span class="deltaxml-new" style="background:#90EE90">OrderingModeDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "ordering" ("ordered" | "unordered")</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EmptyOrderDecl" id="prod-xpath40-EmptyOrderDecl"></a><span class="deltaxml-new" style="background:#90EE90">[15]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EmptyOrderDecl"><span class="deltaxml-new" style="background:#90EE90">EmptyOrderDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "default" "order" "empty" ("greatest" | "least")</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CopyNamespacesDecl" id="prod-xpath40-CopyNamespacesDecl"></a><span class="deltaxml-new" style="background:#90EE90">[16]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CopyNamespacesDecl"><span class="deltaxml-new" style="background:#90EE90">CopyNamespacesDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "copy-namespaces" </span><a href="#prod-xpath40-PreserveMode"><span class="deltaxml-new" style="background:#90EE90">PreserveMode</span></a><span class="deltaxml-new" style="background:#90EE90"> "," </span><a href="#prod-xpath40-InheritMode"><span class="deltaxml-new" style="background:#90EE90">InheritMode</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PreserveMode" id="prod-xpath40-PreserveMode"></a><span class="deltaxml-new" style="background:#90EE90">[17]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PreserveMode"><span class="deltaxml-new" style="background:#90EE90">PreserveMode</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"preserve" | "no-preserve"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-InheritMode" id="prod-xpath40-InheritMode"></a><span class="deltaxml-new" style="background:#90EE90">[18]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-InheritMode"><span class="deltaxml-new" style="background:#90EE90">InheritMode</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"inherit" | "no-inherit"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DecimalFormatDecl" id="prod-xpath40-DecimalFormatDecl"></a><span class="deltaxml-new" style="background:#90EE90">[19]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DecimalFormatDecl"><span class="deltaxml-new" style="background:#90EE90">DecimalFormatDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" (("decimal-format" </span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("default" "decimal-format")) (</span><a href="#prod-xpath40-DFPropertyName"><span class="deltaxml-new" style="background:#90EE90">DFPropertyName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=" </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DFPropertyName" id="prod-xpath40-DFPropertyName"></a><span class="deltaxml-new" style="background:#90EE90">[20]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DFPropertyName"><span class="deltaxml-new" style="background:#90EE90">DFPropertyName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"decimal-separator" | "grouping-separator" | "infinity" | "minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" | "digit" | "pattern-separator" | "exponent-separator"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Import" id="prod-xpath40-Import"></a><span class="deltaxml-new" style="background:#90EE90">[21]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Import"><span class="deltaxml-new" style="background:#90EE90">Import</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SchemaImport"><span class="deltaxml-new" style="background:#90EE90">SchemaImport</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ModuleImport"><span class="deltaxml-new" style="background:#90EE90">ModuleImport</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SchemaImport" id="prod-xpath40-SchemaImport"></a><span class="deltaxml-new" style="background:#90EE90">[22]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SchemaImport"><span class="deltaxml-new" style="background:#90EE90">SchemaImport</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"import" "schema" </span><a href="#prod-xpath40-SchemaPrefix"><span class="deltaxml-new" style="background:#90EE90">SchemaPrefix</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("at" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)*)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SchemaPrefix" id="prod-xpath40-SchemaPrefix"></a><span class="deltaxml-new" style="background:#90EE90">[23]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SchemaPrefix"><span class="deltaxml-new" style="background:#90EE90">SchemaPrefix</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("namespace" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=") | ("fixed"? "default" "element" "namespace")</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ModuleImport" id="prod-xpath40-ModuleImport"></a><span class="deltaxml-new" style="background:#90EE90">[24]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ModuleImport"><span class="deltaxml-new" style="background:#90EE90">ModuleImport</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"import" "module" ("namespace" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=")? </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("at" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)*)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NamespaceDecl" id="prod-xpath40-NamespaceDecl"></a><span class="deltaxml-new" style="background:#90EE90">[25]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NamespaceDecl"><span class="deltaxml-new" style="background:#90EE90">NamespaceDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "namespace" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> "=" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DefaultNamespaceDecl" id="prod-xpath40-DefaultNamespaceDecl"></a><span class="deltaxml-new" style="background:#90EE90">[26]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DefaultNamespaceDecl"><span class="deltaxml-new" style="background:#90EE90">DefaultNamespaceDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "fixed"? "default" ("element" | "function") "namespace" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnnotatedDecl" id="prod-xpath40-AnnotatedDecl"></a><span class="deltaxml-new" style="background:#90EE90">[27]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnnotatedDecl"><span class="deltaxml-new" style="background:#90EE90">AnnotatedDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" </span><a href="#prod-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#prod-xpath40-VarDecl"><span class="deltaxml-new" style="background:#90EE90">VarDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-FunctionDecl"><span class="deltaxml-new" style="background:#90EE90">FunctionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ItemTypeDecl"><span class="deltaxml-new" style="background:#90EE90">ItemTypeDecl</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Annotation" id="prod-xpath40-Annotation"></a><span class="deltaxml-new" style="background:#90EE90">[28]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"%" </span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ("(" </span><a href="#prod-xpath40-AnnotationValue"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-AnnotationValue"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")")?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnnotationValue" id="prod-xpath40-AnnotationValue"></a><span class="deltaxml-new" style="background:#90EE90">[29]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnnotationValue"><span class="deltaxml-new" style="background:#90EE90">AnnotationValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("-"? </span><a href="#prod-xpath40-NumericLiteral"><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("true" "(" ")") | ("false" "(" ")")</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-VarDecl" id="prod-xpath40-VarDecl"></a><span class="deltaxml-new" style="background:#90EE90">[30]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VarDecl"><span class="deltaxml-new" style="background:#90EE90">VarDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"variable" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ((":=" </span><a href="#prod-xpath40-VarValue"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("external" (":=" </span><a href="#prod-xpath40-VarDefaultValue"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a><span class="deltaxml-new" style="background:#90EE90">)?))</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-VarValue" id="prod-xpath40-VarValue"></a><span class="deltaxml-new" style="background:#90EE90">[31]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VarValue"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-VarDefaultValue" id="prod-xpath40-VarDefaultValue"></a><span class="deltaxml-new" style="background:#90EE90">[32]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VarDefaultValue"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ContextValueDecl" id="prod-xpath40-ContextValueDecl"></a><span class="deltaxml-new" style="background:#90EE90">[33]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ContextValueDecl"><span class="deltaxml-new" style="background:#90EE90">ContextValueDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "context" (("value" ("as" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)?) | ("item" ("as" </span><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">)?)) ((":=" </span><a href="#prod-xpath40-VarValue"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a><span class="deltaxml-new" style="background:#90EE90">) | ("external" (":=" </span><a href="#prod-xpath40-VarDefaultValue"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a><span class="deltaxml-new" style="background:#90EE90">)?))</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FunctionDecl" id="prod-xpath40-FunctionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[34]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FunctionDecl"><span class="deltaxml-new" style="background:#90EE90">FunctionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"function" </span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> "(" </span><a href="#prod-xpath40-ParamListWithDefaults"><span class="deltaxml-new" style="background:#90EE90">ParamListWithDefaults</span></a><span class="deltaxml-new" style="background:#90EE90">? ")" </span><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? (</span><a href="#prod-xpath40-FunctionBody"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a><span class="deltaxml-new" style="background:#90EE90"> | "external")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-reserved-function-names"><span class="deltaxml-new" style="background:#90EE90">xgc: reserved-function-names</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FunctionSignature" id="prod-xpath40-FunctionSignature"></a><span class="deltaxml-new" style="background:#90EE90">[35]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FunctionSignature"><span class="deltaxml-new" style="background:#90EE90">FunctionSignature</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#prod-xpath40-ParamList"><span class="deltaxml-new" style="background:#90EE90">ParamList</span></a><span class="deltaxml-new" style="background:#90EE90">? ")" </span><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ParamListWithDefaults" id="prod-xpath40-ParamListWithDefaults"></a><span class="deltaxml-new" style="background:#90EE90">[36]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ParamListWithDefaults"><span class="deltaxml-new" style="background:#90EE90">ParamListWithDefaults</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ParamWithDefault"><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-ParamWithDefault"><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ParamWithDefault" id="prod-xpath40-ParamWithDefault"></a><span class="deltaxml-new" style="background:#90EE90">[37]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ParamWithDefault"><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Param"><span class="deltaxml-new" style="background:#90EE90">Param</span></a><span class="deltaxml-new" style="background:#90EE90"> (":=" </span><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ParamList" id="prod-xpath40-ParamList"></a><span class="deltaxml-new" style="background:#90EE90">[38]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ParamList"><span class="deltaxml-new" style="background:#90EE90">ParamList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Param"><span class="deltaxml-new" style="background:#90EE90">Param</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-Param"><span class="deltaxml-new" style="background:#90EE90">Param</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Param" id="prod-xpath40-Param"></a><span class="deltaxml-new" style="background:#90EE90">[39]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Param"><span class="deltaxml-new" style="background:#90EE90">Param</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FunctionBody" id="prod-xpath40-FunctionBody"></a><span class="deltaxml-new" style="background:#90EE90">[40]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FunctionBody"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EnclosedExpr" id="prod-xpath40-EnclosedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[41]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ItemTypeDecl" id="prod-xpath40-ItemTypeDecl"></a><span class="deltaxml-new" style="background:#90EE90">[42]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ItemTypeDecl"><span class="deltaxml-new" style="background:#90EE90">ItemTypeDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"item-type" </span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> "as" </span><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OptionDecl" id="prod-xpath40-OptionDecl"></a><span class="deltaxml-new" style="background:#90EE90">[43]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OptionDecl"><span class="deltaxml-new" style="background:#90EE90">OptionDecl</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"declare" "option" </span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-QueryBody" id="prod-xpath40-QueryBody"></a><span class="deltaxml-new" style="background:#90EE90">[44]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QueryBody"><span class="deltaxml-new" style="background:#90EE90">QueryBody</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Expr" id="prod-xpath40-Expr"></a><span class="deltaxml-new" style="background:#90EE90">[45]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StandaloneExpr" id="prod-xpath40-StandaloneExpr"></a><span class="deltaxml-new" style="background:#90EE90">[46]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ExprSingle" id="prod-xpath40-ExprSingle"></a><span class="deltaxml-new" style="background:#90EE90">[47]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-FLWORExpr"><span class="deltaxml-new" style="background:#90EE90">FLWORExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-SwitchExpr"><span class="deltaxml-new" style="background:#90EE90">SwitchExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-TypeswitchExpr"><span class="deltaxml-new" style="background:#90EE90">TypeswitchExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">IfExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-TryCatchExpr"><span class="deltaxml-new" style="background:#90EE90">TryCatchExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-OrExpr"><span class="deltaxml-new" style="background:#90EE90">OrExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForExpr" id="prod-xpath40-ForExpr"></a><span class="deltaxml-new" style="background:#90EE90">[48]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a><a href="#prod-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForLetReturn" id="prod-xpath40-ForLetReturn"></a><span class="deltaxml-new" style="background:#90EE90">[49]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">ForExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("return" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-LetExpr" id="prod-xpath40-LetExpr"></a><span class="deltaxml-new" style="background:#90EE90">[50]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">LetExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-LetClause"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a><a href="#prod-xpath40-ForLetReturn"><span class="deltaxml-new" style="background:#90EE90">ForLetReturn</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FLWORExpr" id="prod-xpath40-FLWORExpr"></a><span class="deltaxml-new" style="background:#90EE90">[51]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FLWORExpr"><span class="deltaxml-new" style="background:#90EE90">FLWORExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InitialClause"><span class="deltaxml-new" style="background:#90EE90">InitialClause</span></a><a href="#prod-xpath40-IntermediateClause"><span class="deltaxml-new" style="background:#90EE90">IntermediateClause</span></a><span class="deltaxml-new" style="background:#90EE90">* </span><a href="#prod-xpath40-ReturnClause"><span class="deltaxml-new" style="background:#90EE90">ReturnClause</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-InitialClause" id="prod-xpath40-InitialClause"></a><span class="deltaxml-new" style="background:#90EE90">[52]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-InitialClause"><span class="deltaxml-new" style="background:#90EE90">InitialClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LetClause"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-WindowClause"><span class="deltaxml-new" style="background:#90EE90">WindowClause</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-IntermediateClause" id="prod-xpath40-IntermediateClause"></a><span class="deltaxml-new" style="background:#90EE90">[53]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-IntermediateClause"><span class="deltaxml-new" style="background:#90EE90">IntermediateClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InitialClause"><span class="deltaxml-new" style="background:#90EE90">InitialClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-WhereClause"><span class="deltaxml-new" style="background:#90EE90">WhereClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-WhileClause"><span class="deltaxml-new" style="background:#90EE90">WhileClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-GroupByClause"><span class="deltaxml-new" style="background:#90EE90">GroupByClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-OrderByClause"><span class="deltaxml-new" style="background:#90EE90">OrderByClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-CountClause"><span class="deltaxml-new" style="background:#90EE90">CountClause</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForClause" id="prod-xpath40-ForClause"></a><span class="deltaxml-new" style="background:#90EE90">[54]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForClause"><span class="deltaxml-new" style="background:#90EE90">ForClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"for" </span><a href="#prod-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForBinding" id="prod-xpath40-ForBinding"></a><span class="deltaxml-new" style="background:#90EE90">[55]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForBinding"><span class="deltaxml-new" style="background:#90EE90">ForBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ForMemberBinding"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ForEntryBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForItemBinding" id="prod-xpath40-ForItemBinding"></a><span class="deltaxml-new" style="background:#90EE90">[56]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForItemBinding"><span class="deltaxml-new" style="background:#90EE90">ForItemBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-AllowingEmpty"><span class="deltaxml-new" style="background:#90EE90">AllowingEmpty</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForMemberBinding" id="prod-xpath40-ForMemberBinding"></a><span class="deltaxml-new" style="background:#90EE90">[57]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForMemberBinding"><span class="deltaxml-new" style="background:#90EE90">ForMemberBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"member" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AllowingEmpty" id="prod-xpath40-AllowingEmpty"></a><span class="deltaxml-new" style="background:#90EE90">[58]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AllowingEmpty"><span class="deltaxml-new" style="background:#90EE90">AllowingEmpty</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"allowing" "empty"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForEntryBinding" id="prod-xpath40-ForEntryBinding"></a><span class="deltaxml-new" style="background:#90EE90">[59]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForEntryBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#prod-xpath40-ForEntryKeyBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryKeyBinding</span></a><a href="#prod-xpath40-ForEntryValueBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">?) | </span><a href="#prod-xpath40-ForEntryValueBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#prod-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForEntryKeyBinding" id="prod-xpath40-ForEntryKeyBinding"></a><span class="deltaxml-new" style="background:#90EE90">[60]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForEntryKeyBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryKeyBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"key" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForEntryValueBinding" id="prod-xpath40-ForEntryValueBinding"></a><span class="deltaxml-new" style="background:#90EE90">[61]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForEntryValueBinding"><span class="deltaxml-new" style="background:#90EE90">ForEntryValueBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"value" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PositionalVar" id="prod-xpath40-PositionalVar"></a><span class="deltaxml-new" style="background:#90EE90">[62]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"at" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-LetClause" id="prod-xpath40-LetClause"></a><span class="deltaxml-new" style="background:#90EE90">[63]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LetClause"><span class="deltaxml-new" style="background:#90EE90">LetClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"let" </span><a href="#prod-xpath40-LetBinding"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-LetBinding"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-LetBinding" id="prod-xpath40-LetBinding"></a><span class="deltaxml-new" style="background:#90EE90">[64]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LetBinding"><span class="deltaxml-new" style="background:#90EE90">LetBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ":=" </span><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-WindowClause" id="prod-xpath40-WindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[65]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-WindowClause"><span class="deltaxml-new" style="background:#90EE90">WindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"for" (</span><a href="#prod-xpath40-TumblingWindowClause"><span class="deltaxml-new" style="background:#90EE90">TumblingWindowClause</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-SlidingWindowClause"><span class="deltaxml-new" style="background:#90EE90">SlidingWindowClause</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TumblingWindowClause" id="prod-xpath40-TumblingWindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[66]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TumblingWindowClause"><span class="deltaxml-new" style="background:#90EE90">TumblingWindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"tumbling" "window" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#prod-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SlidingWindowClause" id="prod-xpath40-SlidingWindowClause"></a><span class="deltaxml-new" style="background:#90EE90">[67]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SlidingWindowClause"><span class="deltaxml-new" style="background:#90EE90">SlidingWindowClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"sliding" "window" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#prod-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-WindowStartCondition" id="prod-xpath40-WindowStartCondition"></a><span class="deltaxml-new" style="background:#90EE90">[68]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-WindowStartCondition"><span class="deltaxml-new" style="background:#90EE90">WindowStartCondition</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"start" </span><a href="#prod-xpath40-WindowVars"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a><span class="deltaxml-new" style="background:#90EE90"> ("when" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-WindowEndCondition" id="prod-xpath40-WindowEndCondition"></a><span class="deltaxml-new" style="background:#90EE90">[69]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-WindowEndCondition"><span class="deltaxml-new" style="background:#90EE90">WindowEndCondition</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"only"? "end" </span><a href="#prod-xpath40-WindowVars"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a><span class="deltaxml-new" style="background:#90EE90"> ("when" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-WindowVars" id="prod-xpath40-WindowVars"></a><span class="deltaxml-new" style="background:#90EE90">[70]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-WindowVars"><span class="deltaxml-new" style="background:#90EE90">WindowVars</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("$" </span><a href="#prod-xpath40-CurrentItem"><span class="deltaxml-new" style="background:#90EE90">CurrentItem</span></a><span class="deltaxml-new" style="background:#90EE90">)? </span><a href="#prod-xpath40-PositionalVar"><span class="deltaxml-new" style="background:#90EE90">PositionalVar</span></a><span class="deltaxml-new" style="background:#90EE90">? ("previous" "$" </span><a href="#prod-xpath40-PreviousItem"><span class="deltaxml-new" style="background:#90EE90">PreviousItem</span></a><span class="deltaxml-new" style="background:#90EE90">)? ("next" "$" </span><a href="#prod-xpath40-NextItem"><span class="deltaxml-new" style="background:#90EE90">NextItem</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CurrentItem" id="prod-xpath40-CurrentItem"></a><span class="deltaxml-new" style="background:#90EE90">[71]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CurrentItem"><span class="deltaxml-new" style="background:#90EE90">CurrentItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PreviousItem" id="prod-xpath40-PreviousItem"></a><span class="deltaxml-new" style="background:#90EE90">[72]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PreviousItem"><span class="deltaxml-new" style="background:#90EE90">PreviousItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NextItem" id="prod-xpath40-NextItem"></a><span class="deltaxml-new" style="background:#90EE90">[73]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NextItem"><span class="deltaxml-new" style="background:#90EE90">NextItem</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CountClause" id="prod-xpath40-CountClause"></a><span class="deltaxml-new" style="background:#90EE90">[74]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CountClause"><span class="deltaxml-new" style="background:#90EE90">CountClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"count" "$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-WhereClause" id="prod-xpath40-WhereClause"></a><span class="deltaxml-new" style="background:#90EE90">[75]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-WhereClause"><span class="deltaxml-new" style="background:#90EE90">WhereClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"where" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-WhileClause" id="prod-xpath40-WhileClause"></a><span class="deltaxml-new" style="background:#90EE90">[76]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-WhileClause"><span class="deltaxml-new" style="background:#90EE90">WhileClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"while" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-GroupByClause" id="prod-xpath40-GroupByClause"></a><span class="deltaxml-new" style="background:#90EE90">[77]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-GroupByClause"><span class="deltaxml-new" style="background:#90EE90">GroupByClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"group" "by" </span><a href="#prod-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-GroupingSpec" id="prod-xpath40-GroupingSpec"></a><span class="deltaxml-new" style="background:#90EE90">[78]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-GroupingSpec"><span class="deltaxml-new" style="background:#90EE90">GroupingSpec</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-GroupingVariable"><span class="deltaxml-new" style="background:#90EE90">GroupingVariable</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? ":=" </span><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)? ("collation" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-GroupingVariable" id="prod-xpath40-GroupingVariable"></a><span class="deltaxml-new" style="background:#90EE90">[79]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-GroupingVariable"><span class="deltaxml-new" style="background:#90EE90">GroupingVariable</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OrderByClause" id="prod-xpath40-OrderByClause"></a><span class="deltaxml-new" style="background:#90EE90">[80]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OrderByClause"><span class="deltaxml-new" style="background:#90EE90">OrderByClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"stable"? "order" "by" </span><a href="#prod-xpath40-OrderSpec"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-OrderSpec"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OrderSpec" id="prod-xpath40-OrderSpec"></a><span class="deltaxml-new" style="background:#90EE90">[81]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OrderSpec"><span class="deltaxml-new" style="background:#90EE90">OrderSpec</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><a href="#prod-xpath40-OrderModifier"><span class="deltaxml-new" style="background:#90EE90">OrderModifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OrderModifier" id="prod-xpath40-OrderModifier"></a><span class="deltaxml-new" style="background:#90EE90">[82]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OrderModifier"><span class="deltaxml-new" style="background:#90EE90">OrderModifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" </span><a href="#prod-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ReturnClause" id="prod-xpath40-ReturnClause"></a><span class="deltaxml-new" style="background:#90EE90">[83]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ReturnClause"><span class="deltaxml-new" style="background:#90EE90">ReturnClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"return" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-QuantifiedExpr" id="prod-xpath40-QuantifiedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[84]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">QuantifiedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("some" | "every") </span><a href="#prod-xpath40-QuantifierBinding"><span class="deltaxml-new" style="background:#90EE90">QuantifierBinding</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-QuantifierBinding"><span class="deltaxml-new" style="background:#90EE90">QuantifierBinding</span></a><span class="deltaxml-new" style="background:#90EE90">)* "satisfies" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-QuantifierBinding" id="prod-xpath40-QuantifierBinding"></a><span class="deltaxml-new" style="background:#90EE90">[85]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QuantifierBinding"><span class="deltaxml-new" style="background:#90EE90">QuantifierBinding</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><a href="#prod-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">? "in" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SwitchExpr" id="prod-xpath40-SwitchExpr"></a><span class="deltaxml-new" style="background:#90EE90">[86]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SwitchExpr"><span class="deltaxml-new" style="background:#90EE90">SwitchExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"switch" </span><a href="#prod-xpath40-SwitchComparand"><span class="deltaxml-new" style="background:#90EE90">SwitchComparand</span></a><span class="deltaxml-new" style="background:#90EE90">? (</span><a href="#prod-xpath40-SwitchCases"><span class="deltaxml-new" style="background:#90EE90">SwitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-BracedSwitchCases"><span class="deltaxml-new" style="background:#90EE90">BracedSwitchCases</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SwitchComparand" id="prod-xpath40-SwitchComparand"></a><span class="deltaxml-new" style="background:#90EE90">[87]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SwitchComparand"><span class="deltaxml-new" style="background:#90EE90">SwitchComparand</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SwitchCases" id="prod-xpath40-SwitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[88]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SwitchCases"><span class="deltaxml-new" style="background:#90EE90">SwitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SwitchCaseClause"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseClause</span></a><span class="deltaxml-new" style="background:#90EE90">+ "default" "return" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BracedSwitchCases" id="prod-xpath40-BracedSwitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[89]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BracedSwitchCases"><span class="deltaxml-new" style="background:#90EE90">BracedSwitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#prod-xpath40-SwitchCases"><span class="deltaxml-new" style="background:#90EE90">SwitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SwitchCaseClause" id="prod-xpath40-SwitchCaseClause"></a><span class="deltaxml-new" style="background:#90EE90">[90]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SwitchCaseClause"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("case" </span><a href="#prod-xpath40-SwitchCaseOperand"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseOperand</span></a><span class="deltaxml-new" style="background:#90EE90">)+ "return" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SwitchCaseOperand" id="prod-xpath40-SwitchCaseOperand"></a><span class="deltaxml-new" style="background:#90EE90">[91]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SwitchCaseOperand"><span class="deltaxml-new" style="background:#90EE90">SwitchCaseOperand</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypeswitchExpr" id="prod-xpath40-TypeswitchExpr"></a><span class="deltaxml-new" style="background:#90EE90">[92]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypeswitchExpr"><span class="deltaxml-new" style="background:#90EE90">TypeswitchExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"typeswitch" "(" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")" (</span><a href="#prod-xpath40-TypeswitchCases"><span class="deltaxml-new" style="background:#90EE90">TypeswitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-BracedTypeswitchCases"><span class="deltaxml-new" style="background:#90EE90">BracedTypeswitchCases</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypeswitchCases" id="prod-xpath40-TypeswitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[93]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypeswitchCases"><span class="deltaxml-new" style="background:#90EE90">TypeswitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CaseClause"><span class="deltaxml-new" style="background:#90EE90">CaseClause</span></a><span class="deltaxml-new" style="background:#90EE90">+ "default" ("$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><span class="deltaxml-new" style="background:#90EE90">)? "return" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BracedTypeswitchCases" id="prod-xpath40-BracedTypeswitchCases"></a><span class="deltaxml-new" style="background:#90EE90">[94]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BracedTypeswitchCases"><span class="deltaxml-new" style="background:#90EE90">BracedTypeswitchCases</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" </span><a href="#prod-xpath40-TypeswitchCases"><span class="deltaxml-new" style="background:#90EE90">TypeswitchCases</span></a><span class="deltaxml-new" style="background:#90EE90"> "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CaseClause" id="prod-xpath40-CaseClause"></a><span class="deltaxml-new" style="background:#90EE90">[95]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CaseClause"><span class="deltaxml-new" style="background:#90EE90">CaseClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"case" ("$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a><span class="deltaxml-new" style="background:#90EE90"> "as")? </span><a href="#prod-xpath40-SequenceTypeUnion"><span class="deltaxml-new" style="background:#90EE90">SequenceTypeUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> "return" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SequenceTypeUnion" id="prod-xpath40-SequenceTypeUnion"></a><span class="deltaxml-new" style="background:#90EE90">[96]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SequenceTypeUnion"><span class="deltaxml-new" style="background:#90EE90">SequenceTypeUnion</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-IfExpr" id="prod-xpath40-IfExpr"></a><span class="deltaxml-new" style="background:#90EE90">[97]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">IfExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"if" "(" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")" (</span><a href="#prod-xpath40-UnbracedActions"><span class="deltaxml-new" style="background:#90EE90">UnbracedActions</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-BracedActions"><span class="deltaxml-new" style="background:#90EE90">BracedActions</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-UnbracedActions" id="prod-xpath40-UnbracedActions"></a><span class="deltaxml-new" style="background:#90EE90">[98]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnbracedActions"><span class="deltaxml-new" style="background:#90EE90">UnbracedActions</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"then" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a><span class="deltaxml-new" style="background:#90EE90"> "else" </span><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BracedActions" id="prod-xpath40-BracedActions"></a><span class="deltaxml-new" style="background:#90EE90">[99]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BracedActions"><span class="deltaxml-new" style="background:#90EE90">BracedActions</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ThenAction"><span class="deltaxml-new" style="background:#90EE90">ThenAction</span></a><a href="#prod-xpath40-ElseIfAction"><span class="deltaxml-new" style="background:#90EE90">ElseIfAction</span></a><span class="deltaxml-new" style="background:#90EE90">* </span><a href="#prod-xpath40-ElseAction"><span class="deltaxml-new" style="background:#90EE90">ElseAction</span></a><span class="deltaxml-new" style="background:#90EE90">?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ThenAction" id="prod-xpath40-ThenAction"></a><span class="deltaxml-new" style="background:#90EE90">[100]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ThenAction"><span class="deltaxml-new" style="background:#90EE90">ThenAction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ElseIfAction" id="prod-xpath40-ElseIfAction"></a><span class="deltaxml-new" style="background:#90EE90">[101]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ElseIfAction"><span class="deltaxml-new" style="background:#90EE90">ElseIfAction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"else" "if" "(" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> ")" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ElseAction" id="prod-xpath40-ElseAction"></a><span class="deltaxml-new" style="background:#90EE90">[102]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ElseAction"><span class="deltaxml-new" style="background:#90EE90">ElseAction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"else" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TryCatchExpr" id="prod-xpath40-TryCatchExpr"></a><span class="deltaxml-new" style="background:#90EE90">[103]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TryCatchExpr"><span class="deltaxml-new" style="background:#90EE90">TryCatchExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TryClause"><span class="deltaxml-new" style="background:#90EE90">TryClause</span></a><a href="#prod-xpath40-CatchClause"><span class="deltaxml-new" style="background:#90EE90">CatchClause</span></a><span class="deltaxml-new" style="background:#90EE90">+</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TryClause" id="prod-xpath40-TryClause"></a><span class="deltaxml-new" style="background:#90EE90">[104]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TryClause"><span class="deltaxml-new" style="background:#90EE90">TryClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"try" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CatchClause" id="prod-xpath40-CatchClause"></a><span class="deltaxml-new" style="background:#90EE90">[105]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CatchClause"><span class="deltaxml-new" style="background:#90EE90">CatchClause</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"catch" </span><a href="#prod-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NameTestUnion" id="prod-xpath40-NameTestUnion"></a><span class="deltaxml-new" style="background:#90EE90">[106]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#prod-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OrExpr" id="prod-xpath40-OrExpr"></a><span class="deltaxml-new" style="background:#90EE90">[107]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OrExpr"><span class="deltaxml-new" style="background:#90EE90">OrExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">AndExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "or" </span><a href="#prod-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">AndExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AndExpr" id="prod-xpath40-AndExpr"></a><span class="deltaxml-new" style="background:#90EE90">[108]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">AndExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ComparisonExpr"><span class="deltaxml-new" style="background:#90EE90">ComparisonExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "and" </span><a href="#prod-xpath40-ComparisonExpr"><span class="deltaxml-new" style="background:#90EE90">ComparisonExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ComparisonExpr" id="prod-xpath40-ComparisonExpr"></a><span class="deltaxml-new" style="background:#90EE90">[109]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ComparisonExpr"><span class="deltaxml-new" style="background:#90EE90">ComparisonExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">OtherwiseExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( (</span><a href="#prod-xpath40-ValueComp"><span class="deltaxml-new" style="background:#90EE90">ValueComp</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-GeneralComp"><span class="deltaxml-new" style="background:#90EE90">GeneralComp</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-NodeComp"><span class="deltaxml-new" style="background:#90EE90">NodeComp</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#prod-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">OtherwiseExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OtherwiseExpr" id="prod-xpath40-OtherwiseExpr"></a><span class="deltaxml-new" style="background:#90EE90">[110]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">OtherwiseExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringConcatExpr"><span class="deltaxml-new" style="background:#90EE90">StringConcatExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "otherwise" </span><a href="#prod-xpath40-StringConcatExpr"><span class="deltaxml-new" style="background:#90EE90">StringConcatExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringConcatExpr" id="prod-xpath40-StringConcatExpr"></a><span class="deltaxml-new" style="background:#90EE90">[111]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringConcatExpr"><span class="deltaxml-new" style="background:#90EE90">StringConcatExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-RangeExpr"><span class="deltaxml-new" style="background:#90EE90">RangeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "||" </span><a href="#prod-xpath40-RangeExpr"><span class="deltaxml-new" style="background:#90EE90">RangeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-RangeExpr" id="prod-xpath40-RangeExpr"></a><span class="deltaxml-new" style="background:#90EE90">[112]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-RangeExpr"><span class="deltaxml-new" style="background:#90EE90">RangeExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AdditiveExpr"><span class="deltaxml-new" style="background:#90EE90">AdditiveExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "to" </span><a href="#prod-xpath40-AdditiveExpr"><span class="deltaxml-new" style="background:#90EE90">AdditiveExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AdditiveExpr" id="prod-xpath40-AdditiveExpr"></a><span class="deltaxml-new" style="background:#90EE90">[113]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AdditiveExpr"><span class="deltaxml-new" style="background:#90EE90">AdditiveExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MultiplicativeExpr"><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("+" | "-") </span><a href="#prod-xpath40-MultiplicativeExpr"><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MultiplicativeExpr" id="prod-xpath40-MultiplicativeExpr"></a><span class="deltaxml-new" style="background:#90EE90">[114]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MultiplicativeExpr"><span class="deltaxml-new" style="background:#90EE90">MultiplicativeExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnionExpr"><span class="deltaxml-new" style="background:#90EE90">UnionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("*" | "×" | "div" | "÷" | "idiv" | "mod") </span><a href="#prod-xpath40-UnionExpr"><span class="deltaxml-new" style="background:#90EE90">UnionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-UnionExpr" id="prod-xpath40-UnionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[115]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnionExpr"><span class="deltaxml-new" style="background:#90EE90">UnionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-IntersectExceptExpr"><span class="deltaxml-new" style="background:#90EE90">IntersectExceptExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("union" | "|") </span><a href="#prod-xpath40-IntersectExceptExpr"><span class="deltaxml-new" style="background:#90EE90">IntersectExceptExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-IntersectExceptExpr" id="prod-xpath40-IntersectExceptExpr"></a><span class="deltaxml-new" style="background:#90EE90">[116]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-IntersectExceptExpr"><span class="deltaxml-new" style="background:#90EE90">IntersectExceptExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-InstanceofExpr"><span class="deltaxml-new" style="background:#90EE90">InstanceofExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( ("intersect" | "except") </span><a href="#prod-xpath40-InstanceofExpr"><span class="deltaxml-new" style="background:#90EE90">InstanceofExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-InstanceofExpr" id="prod-xpath40-InstanceofExpr"></a><span class="deltaxml-new" style="background:#90EE90">[117]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-InstanceofExpr"><span class="deltaxml-new" style="background:#90EE90">InstanceofExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TreatExpr"><span class="deltaxml-new" style="background:#90EE90">TreatExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "instance" "of" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TreatExpr" id="prod-xpath40-TreatExpr"></a><span class="deltaxml-new" style="background:#90EE90">[118]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TreatExpr"><span class="deltaxml-new" style="background:#90EE90">TreatExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CastableExpr"><span class="deltaxml-new" style="background:#90EE90">CastableExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "treat" "as" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CastableExpr" id="prod-xpath40-CastableExpr"></a><span class="deltaxml-new" style="background:#90EE90">[119]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CastableExpr"><span class="deltaxml-new" style="background:#90EE90">CastableExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CastExpr"><span class="deltaxml-new" style="background:#90EE90">CastExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "castable" "as" </span><a href="#prod-xpath40-CastTarget"><span class="deltaxml-new" style="background:#90EE90">CastTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"? )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CastExpr" id="prod-xpath40-CastExpr"></a><span class="deltaxml-new" style="background:#90EE90">[120]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CastExpr"><span class="deltaxml-new" style="background:#90EE90">CastExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ArrowExpr"><span class="deltaxml-new" style="background:#90EE90">ArrowExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( "cast" "as" </span><a href="#prod-xpath40-CastTarget"><span class="deltaxml-new" style="background:#90EE90">CastTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"? )?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArrowExpr" id="prod-xpath40-ArrowExpr"></a><span class="deltaxml-new" style="background:#90EE90">[121]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArrowExpr"><span class="deltaxml-new" style="background:#90EE90">ArrowExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ( (</span><a href="#prod-xpath40-SequenceArrowTarget"><span class="deltaxml-new" style="background:#90EE90">SequenceArrowTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-MappingArrowTarget"><span class="deltaxml-new" style="background:#90EE90">MappingArrowTarget</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LookupArrowTarget"><span class="deltaxml-new" style="background:#90EE90">LookupArrowTarget</span></a><span class="deltaxml-new" style="background:#90EE90">) )*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-UnaryExpr" id="prod-xpath40-UnaryExpr"></a><span class="deltaxml-new" style="background:#90EE90">[122]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">UnaryExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("-" | "+")* </span><a href="#prod-xpath40-ValueExpr"><span class="deltaxml-new" style="background:#90EE90">ValueExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ValueExpr" id="prod-xpath40-ValueExpr"></a><span class="deltaxml-new" style="background:#90EE90">[123]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ValueExpr"><span class="deltaxml-new" style="background:#90EE90">ValueExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ValidateExpr"><span class="deltaxml-new" style="background:#90EE90">ValidateExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ExtensionExpr"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-SimpleMapExpr"><span class="deltaxml-new" style="background:#90EE90">SimpleMapExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SequenceArrowTarget" id="prod-xpath40-SequenceArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[124]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SequenceArrowTarget"><span class="deltaxml-new" style="background:#90EE90">SequenceArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=&gt;" </span><a href="#prod-xpath40-ArrowTarget"><span class="deltaxml-new" style="background:#90EE90">ArrowTarget</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MappingArrowTarget" id="prod-xpath40-MappingArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[125]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MappingArrowTarget"><span class="deltaxml-new" style="background:#90EE90">MappingArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=!&gt;" </span><a href="#prod-xpath40-ArrowTarget"><span class="deltaxml-new" style="background:#90EE90">ArrowTarget</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArrowTarget" id="prod-xpath40-ArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[126]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArrowTarget"><span class="deltaxml-new" style="background:#90EE90">ArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-ArrowStaticFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowStaticFunction</span></a><a href="#prod-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a><span class="deltaxml-new" style="background:#90EE90">) | (</span><a href="#prod-xpath40-ArrowDynamicFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowDynamicFunction</span></a><a href="#prod-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-LookupArrowTarget" id="prod-xpath40-LookupArrowTarget"></a><span class="deltaxml-new" style="background:#90EE90">[127]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LookupArrowTarget"><span class="deltaxml-new" style="background:#90EE90">LookupArrowTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=?&gt;" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><a href="#prod-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-GeneralComp" id="prod-xpath40-GeneralComp"></a><span class="deltaxml-new" style="background:#90EE90">[128]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-GeneralComp"><span class="deltaxml-new" style="background:#90EE90">GeneralComp</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ValueComp" id="prod-xpath40-ValueComp"></a><span class="deltaxml-new" style="background:#90EE90">[129]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ValueComp"><span class="deltaxml-new" style="background:#90EE90">ValueComp</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"eq" | "ne" | "lt" | "le" | "gt" | "ge"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NodeComp" id="prod-xpath40-NodeComp"></a><span class="deltaxml-new" style="background:#90EE90">[130]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NodeComp"><span class="deltaxml-new" style="background:#90EE90">NodeComp</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"is" | "&lt;&lt;" | "&gt;&gt;"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ValidateExpr" id="prod-xpath40-ValidateExpr"></a><span class="deltaxml-new" style="background:#90EE90">[131]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ValidateExpr"><span class="deltaxml-new" style="background:#90EE90">ValidateExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"validate" (</span><a href="#prod-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">ValidationMode</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("type" </span><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">))? "{" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ValidationMode" id="prod-xpath40-ValidationMode"></a><span class="deltaxml-new" style="background:#90EE90">[132]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ValidationMode"><span class="deltaxml-new" style="background:#90EE90">ValidationMode</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"lax" | "strict"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ExtensionExpr" id="prod-xpath40-ExtensionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[133]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ExtensionExpr"><span class="deltaxml-new" style="background:#90EE90">ExtensionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Pragma"><span class="deltaxml-new" style="background:#90EE90">Pragma</span></a><span class="deltaxml-new" style="background:#90EE90">+ "{" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Pragma" id="prod-xpath40-Pragma"></a><span class="deltaxml-new" style="background:#90EE90">[134]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Pragma"><span class="deltaxml-new" style="background:#90EE90">Pragma</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(#" </span><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><a href="#prod-xpath40-PragmaContents"><span class="deltaxml-new" style="background:#90EE90">PragmaContents</span></a><span class="deltaxml-new" style="background:#90EE90">)? "#)"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PragmaContents" id="prod-xpath40-PragmaContents"></a><span class="deltaxml-new" style="background:#90EE90">[135]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PragmaContents"><span class="deltaxml-new" style="background:#90EE90">PragmaContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* '#)' Char*))</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SimpleMapExpr" id="prod-xpath40-SimpleMapExpr"></a><span class="deltaxml-new" style="background:#90EE90">[136]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SimpleMapExpr"><span class="deltaxml-new" style="background:#90EE90">SimpleMapExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ("!" </span><a href="#prod-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PathExpr" id="prod-xpath40-PathExpr"></a><span class="deltaxml-new" style="background:#90EE90">[137]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("/" </span><a href="#prod-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">?)</span><br><span class="deltaxml-new" style="background:#90EE90">| ("//" </span><a href="#prod-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)</span><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-leading-lone-slash"><span class="deltaxml-new" style="background:#90EE90">xgc: leading-lone-slash</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-RelativePathExpr" id="prod-xpath40-RelativePathExpr"></a><span class="deltaxml-new" style="background:#90EE90">[138]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> (("/" | "//") </span><a href="#prod-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StepExpr" id="prod-xpath40-StepExpr"></a><span class="deltaxml-new" style="background:#90EE90">[139]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StepExpr"><span class="deltaxml-new" style="background:#90EE90">StepExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-AxisStep"><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AxisStep" id="prod-xpath40-AxisStep"></a><span class="deltaxml-new" style="background:#90EE90">[140]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AxisStep"><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-ReverseStep"><span class="deltaxml-new" style="background:#90EE90">ReverseStep</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ForwardStep"><span class="deltaxml-new" style="background:#90EE90">ForwardStep</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#prod-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a><span class="deltaxml-new" style="background:#90EE90">*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForwardStep" id="prod-xpath40-ForwardStep"></a><span class="deltaxml-new" style="background:#90EE90">[141]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForwardStep"><span class="deltaxml-new" style="background:#90EE90">ForwardStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-ForwardAxis"><span class="deltaxml-new" style="background:#90EE90">ForwardAxis</span></a><a href="#prod-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">) | </span><a href="#prod-xpath40-AbbrevForwardStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevForwardStep</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ForwardAxis" id="prod-xpath40-ForwardAxis"></a><span class="deltaxml-new" style="background:#90EE90">[142]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ForwardAxis"><span class="deltaxml-new" style="background:#90EE90">ForwardAxis</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("attribute"</span><br><span class="deltaxml-new" style="background:#90EE90">| "child"</span><br><span class="deltaxml-new" style="background:#90EE90">| "descendant"</span><br><span class="deltaxml-new" style="background:#90EE90">| "descendant-or-self"</span><br><span class="deltaxml-new" style="background:#90EE90">| "following"</span><br><span class="deltaxml-new" style="background:#90EE90">| "following-sibling"</span><br><span class="deltaxml-new" style="background:#90EE90">| "namespace"</span><br><span class="deltaxml-new" style="background:#90EE90">| "self") "::"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AbbrevForwardStep" id="prod-xpath40-AbbrevForwardStep"></a><span class="deltaxml-new" style="background:#90EE90">[143]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AbbrevForwardStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevForwardStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("@" </span><a href="#prod-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">) | </span><a href="#prod-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ReverseStep" id="prod-xpath40-ReverseStep"></a><span class="deltaxml-new" style="background:#90EE90">[144]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ReverseStep"><span class="deltaxml-new" style="background:#90EE90">ReverseStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-ReverseAxis"><span class="deltaxml-new" style="background:#90EE90">ReverseAxis</span></a><a href="#prod-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">) | </span><a href="#prod-xpath40-AbbrevReverseStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevReverseStep</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ReverseAxis" id="prod-xpath40-ReverseAxis"></a><span class="deltaxml-new" style="background:#90EE90">[145]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ReverseAxis"><span class="deltaxml-new" style="background:#90EE90">ReverseAxis</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("ancestor"</span><br><span class="deltaxml-new" style="background:#90EE90">| "ancestor-or-self"</span><br><span class="deltaxml-new" style="background:#90EE90">| "parent"</span><br><span class="deltaxml-new" style="background:#90EE90">| "preceding"</span><br><span class="deltaxml-new" style="background:#90EE90">| "preceding-sibling") "::"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AbbrevReverseStep" id="prod-xpath40-AbbrevReverseStep"></a><span class="deltaxml-new" style="background:#90EE90">[146]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AbbrevReverseStep"><span class="deltaxml-new" style="background:#90EE90">AbbrevReverseStep</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">".."</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NodeTest" id="prod-xpath40-NodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[147]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NodeTest"><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-UnionNodeTest"><span class="deltaxml-new" style="background:#90EE90">UnionNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-UnionNodeTest" id="prod-xpath40-UnionNodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[148]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnionNodeTest"><span class="deltaxml-new" style="background:#90EE90">UnionNodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#prod-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#prod-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SimpleNodeTest" id="prod-xpath40-SimpleNodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[149]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SimpleNodeTest"><span class="deltaxml-new" style="background:#90EE90">SimpleNodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NameTest" id="prod-xpath40-NameTest"></a><span class="deltaxml-new" style="background:#90EE90">[150]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Wildcard" id="prod-xpath40-Wildcard"></a><span class="deltaxml-new" style="background:#90EE90">[151]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"*"</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> ":*")</span><br><span class="deltaxml-new" style="background:#90EE90">| ("*:" </span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90">)</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#prod-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> "*")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FilterExpr" id="prod-xpath40-FilterExpr"></a><span class="deltaxml-new" style="background:#90EE90">[152]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FilterExpr"><span class="deltaxml-new" style="background:#90EE90">FilterExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#prod-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PostfixExpr" id="prod-xpath40-PostfixExpr"></a><span class="deltaxml-new" style="background:#90EE90">[153]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PrimaryExpr"><span class="deltaxml-new" style="background:#90EE90">PrimaryExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-FilterExpr"><span class="deltaxml-new" style="background:#90EE90">FilterExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-DynamicFunctionCall"><span class="deltaxml-new" style="background:#90EE90">DynamicFunctionCall</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LookupExpr"><span class="deltaxml-new" style="background:#90EE90">LookupExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-FilterExprAM"><span class="deltaxml-new" style="background:#90EE90">FilterExprAM</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DynamicFunctionCall" id="prod-xpath40-DynamicFunctionCall"></a><span class="deltaxml-new" style="background:#90EE90">[154]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DynamicFunctionCall"><span class="deltaxml-new" style="background:#90EE90">DynamicFunctionCall</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#prod-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArgumentList" id="prod-xpath40-ArgumentList"></a><span class="deltaxml-new" style="background:#90EE90">[155]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" ((</span><a href="#prod-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)?) | </span><a href="#prod-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PositionalArgumentList" id="prod-xpath40-PositionalArgumentList"></a><span class="deltaxml-new" style="background:#90EE90">[156]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PositionalArgumentList"><span class="deltaxml-new" style="background:#90EE90">PositionalArgumentList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#prod-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a><span class="deltaxml-new" style="background:#90EE90">? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PositionalArguments" id="prod-xpath40-PositionalArguments"></a><span class="deltaxml-new" style="background:#90EE90">[157]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PositionalArguments"><span class="deltaxml-new" style="background:#90EE90">PositionalArguments</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-KeywordArguments" id="prod-xpath40-KeywordArguments"></a><span class="deltaxml-new" style="background:#90EE90">[158]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-KeywordArguments"><span class="deltaxml-new" style="background:#90EE90">KeywordArguments</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-KeywordArgument"><span class="deltaxml-new" style="background:#90EE90">KeywordArgument</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-KeywordArgument"><span class="deltaxml-new" style="background:#90EE90">KeywordArgument</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-KeywordArgument" id="prod-xpath40-KeywordArgument"></a><span class="deltaxml-new" style="background:#90EE90">[159]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-KeywordArgument"><span class="deltaxml-new" style="background:#90EE90">KeywordArgument</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> ":=" </span><a href="#prod-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Predicate" id="prod-xpath40-Predicate"></a><span class="deltaxml-new" style="background:#90EE90">[160]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">Predicate</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"[" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "]"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-LookupExpr" id="prod-xpath40-LookupExpr"></a><span class="deltaxml-new" style="background:#90EE90">[161]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LookupExpr"><span class="deltaxml-new" style="background:#90EE90">LookupExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><a href="#prod-xpath40-Lookup"><span class="deltaxml-new" style="background:#90EE90">Lookup</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FilterExprAM" id="prod-xpath40-FilterExprAM"></a><span class="deltaxml-new" style="background:#90EE90">[162]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FilterExprAM"><span class="deltaxml-new" style="background:#90EE90">FilterExprAM</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PostfixExpr"><span class="deltaxml-new" style="background:#90EE90">PostfixExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> "?[" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "]"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Lookup" id="prod-xpath40-Lookup"></a><span class="deltaxml-new" style="background:#90EE90">[163]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Lookup"><span class="deltaxml-new" style="background:#90EE90">Lookup</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("?" | "??") (</span><a href="#prod-xpath40-Modifier"><span class="deltaxml-new" style="background:#90EE90">Modifier</span></a><span class="deltaxml-new" style="background:#90EE90"> "::")? </span><a href="#prod-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Modifier" id="prod-xpath40-Modifier"></a><span class="deltaxml-new" style="background:#90EE90">[164]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Modifier"><span class="deltaxml-new" style="background:#90EE90">Modifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"pairs" | "keys" | "values" | "items"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-KeySpecifier" id="prod-xpath40-KeySpecifier"></a><span class="deltaxml-new" style="background:#90EE90">[165]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-LookupWildcard"><span class="deltaxml-new" style="background:#90EE90">LookupWildcard</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-TypeQualifier"><span class="deltaxml-new" style="background:#90EE90">TypeQualifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-LookupWildcard" id="prod-xpath40-LookupWildcard"></a><span class="deltaxml-new" style="background:#90EE90">[166]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-LookupWildcard"><span class="deltaxml-new" style="background:#90EE90">LookupWildcard</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"*"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypeQualifier" id="prod-xpath40-TypeQualifier"></a><span class="deltaxml-new" style="background:#90EE90">[167]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypeQualifier"><span class="deltaxml-new" style="background:#90EE90">TypeQualifier</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"type" "(" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArrowStaticFunction" id="prod-xpath40-ArrowStaticFunction"></a><span class="deltaxml-new" style="background:#90EE90">[168]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArrowStaticFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowStaticFunction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArrowDynamicFunction" id="prod-xpath40-ArrowDynamicFunction"></a><span class="deltaxml-new" style="background:#90EE90">[169]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArrowDynamicFunction"><span class="deltaxml-new" style="background:#90EE90">ArrowDynamicFunction</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-InlineFunctionExpr"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PrimaryExpr" id="prod-xpath40-PrimaryExpr"></a><span class="deltaxml-new" style="background:#90EE90">[170]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PrimaryExpr"><span class="deltaxml-new" style="background:#90EE90">PrimaryExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Literal"><span class="deltaxml-new" style="background:#90EE90">Literal</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-ContextValueRef"><span class="deltaxml-new" style="background:#90EE90">ContextValueRef</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-FunctionCall"><span class="deltaxml-new" style="background:#90EE90">FunctionCall</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-OrderedExpr"><span class="deltaxml-new" style="background:#90EE90">OrderedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-UnorderedExpr"><span class="deltaxml-new" style="background:#90EE90">UnorderedExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-NodeConstructor"><span class="deltaxml-new" style="background:#90EE90">NodeConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-FunctionItemExpr"><span class="deltaxml-new" style="background:#90EE90">FunctionItemExpr</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-MapConstructor"><span class="deltaxml-new" style="background:#90EE90">MapConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-ArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">ArrayConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-StringConstructor"><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-UnaryLookup"><span class="deltaxml-new" style="background:#90EE90">UnaryLookup</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Literal" id="prod-xpath40-Literal"></a><span class="deltaxml-new" style="background:#90EE90">[171]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Literal"><span class="deltaxml-new" style="background:#90EE90">Literal</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NumericLiteral"><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NumericLiteral" id="prod-xpath40-NumericLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[172]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NumericLiteral"><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-BinaryIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-DecimalLiteral"><span class="deltaxml-new" style="background:#90EE90">DecimalLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-DoubleLiteral"><span class="deltaxml-new" style="background:#90EE90">DoubleLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-VarRef" id="prod-xpath40-VarRef"></a><span class="deltaxml-new" style="background:#90EE90">[173]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VarRef"><span class="deltaxml-new" style="background:#90EE90">VarRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"$" </span><a href="#prod-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-VarName" id="prod-xpath40-VarName"></a><span class="deltaxml-new" style="background:#90EE90">[174]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-VarName"><span class="deltaxml-new" style="background:#90EE90">VarName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ParenthesizedExpr" id="prod-xpath40-ParenthesizedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[175]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ParenthesizedExpr"><span class="deltaxml-new" style="background:#90EE90">ParenthesizedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ContextValueRef" id="prod-xpath40-ContextValueRef"></a><span class="deltaxml-new" style="background:#90EE90">[176]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ContextValueRef"><span class="deltaxml-new" style="background:#90EE90">ContextValueRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"."</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OrderedExpr" id="prod-xpath40-OrderedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[177]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OrderedExpr"><span class="deltaxml-new" style="background:#90EE90">OrderedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"ordered" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-UnorderedExpr" id="prod-xpath40-UnorderedExpr"></a><span class="deltaxml-new" style="background:#90EE90">[178]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnorderedExpr"><span class="deltaxml-new" style="background:#90EE90">UnorderedExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"unordered" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FunctionCall" id="prod-xpath40-FunctionCall"></a><span class="deltaxml-new" style="background:#90EE90">[179]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FunctionCall"><span class="deltaxml-new" style="background:#90EE90">FunctionCall</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><a href="#prod-xpath40-ArgumentList"><span class="deltaxml-new" style="background:#90EE90">ArgumentList</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-reserved-function-names"><span class="deltaxml-new" style="background:#90EE90">xgc: reserved-function-names</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-parens"><span class="deltaxml-new" style="background:#90EE90">gn: parens</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Argument" id="prod-xpath40-Argument"></a><span class="deltaxml-new" style="background:#90EE90">[180]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Argument"><span class="deltaxml-new" style="background:#90EE90">Argument</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArgumentPlaceholder" id="prod-xpath40-ArgumentPlaceholder"></a><span class="deltaxml-new" style="background:#90EE90">[181]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"?"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NodeConstructor" id="prod-xpath40-NodeConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[182]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NodeConstructor"><span class="deltaxml-new" style="background:#90EE90">NodeConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirectConstructor"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-ComputedConstructor"><span class="deltaxml-new" style="background:#90EE90">ComputedConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirectConstructor" id="prod-xpath40-DirectConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[183]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirectConstructor"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-DirCommentConstructor"><span class="deltaxml-new" style="background:#90EE90">DirCommentConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-DirPIConstructor"><span class="deltaxml-new" style="background:#90EE90">DirPIConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirElemConstructor" id="prod-xpath40-DirElemConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[184]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;" </span><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-DirAttributeList"><span class="deltaxml-new" style="background:#90EE90">DirAttributeList</span></a><span class="deltaxml-new" style="background:#90EE90"> ("/&gt;" | ("&gt;" </span><a href="#prod-xpath40-DirElemContent"><span class="deltaxml-new" style="background:#90EE90">DirElemContent</span></a><span class="deltaxml-new" style="background:#90EE90">* "&lt;/" </span><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? "&gt;"))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirAttributeList" id="prod-xpath40-DirAttributeList"></a><span class="deltaxml-new" style="background:#90EE90">[185]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirAttributeList"><span class="deltaxml-new" style="background:#90EE90">DirAttributeList</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? "=" </span><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-DirAttributeValue"><span class="deltaxml-new" style="background:#90EE90">DirAttributeValue</span></a><span class="deltaxml-new" style="background:#90EE90">)?)*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirAttributeValue" id="prod-xpath40-DirAttributeValue"></a><span class="deltaxml-new" style="background:#90EE90">[186]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirAttributeValue"><span class="deltaxml-new" style="background:#90EE90">DirAttributeValue</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">('"' (</span><a href="#prod-xpath40-EscapeQuot"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-QuotAttrValueContent"><span class="deltaxml-new" style="background:#90EE90">QuotAttrValueContent</span></a><span class="deltaxml-new" style="background:#90EE90">)* '"')</span><br><span class="deltaxml-new" style="background:#90EE90">| ("'" (</span><a href="#prod-xpath40-EscapeApos"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-AposAttrValueContent"><span class="deltaxml-new" style="background:#90EE90">AposAttrValueContent</span></a><span class="deltaxml-new" style="background:#90EE90">)* "'")</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-QuotAttrValueContent" id="prod-xpath40-QuotAttrValueContent"></a><span class="deltaxml-new" style="background:#90EE90">[187]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QuotAttrValueContent"><span class="deltaxml-new" style="background:#90EE90">QuotAttrValueContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QuotAttrContentChar"><span class="deltaxml-new" style="background:#90EE90">QuotAttrContentChar</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CommonContent"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AposAttrValueContent" id="prod-xpath40-AposAttrValueContent"></a><span class="deltaxml-new" style="background:#90EE90">[188]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AposAttrValueContent"><span class="deltaxml-new" style="background:#90EE90">AposAttrValueContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AposAttrContentChar"><span class="deltaxml-new" style="background:#90EE90">AposAttrContentChar</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CommonContent"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirElemContent" id="prod-xpath40-DirElemContent"></a><span class="deltaxml-new" style="background:#90EE90">[189]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirElemContent"><span class="deltaxml-new" style="background:#90EE90">DirElemContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DirectConstructor"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CommonContent"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-ElementContentChar"><span class="deltaxml-new" style="background:#90EE90">ElementContentChar</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CommonContent" id="prod-xpath40-CommonContent"></a><span class="deltaxml-new" style="background:#90EE90">[190]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CommonContent"><span class="deltaxml-new" style="background:#90EE90">CommonContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | "{{" | "}}" | </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirCommentConstructor" id="prod-xpath40-DirCommentConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[191]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirCommentConstructor"><span class="deltaxml-new" style="background:#90EE90">DirCommentConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;!--" </span><a href="#prod-xpath40-DirCommentContents"><span class="deltaxml-new" style="background:#90EE90">DirCommentContents</span></a><span class="deltaxml-new" style="background:#90EE90"> "--&gt;"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirCommentContents" id="prod-xpath40-DirCommentContents"></a><span class="deltaxml-new" style="background:#90EE90">[192]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirCommentContents"><span class="deltaxml-new" style="background:#90EE90">DirCommentContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - '-') | ('-' (</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - '-')))*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirPIConstructor" id="prod-xpath40-DirPIConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[193]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirPIConstructor"><span class="deltaxml-new" style="background:#90EE90">DirPIConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;?" </span><a href="#prod-xpath40-PITarget"><span class="deltaxml-new" style="background:#90EE90">PITarget</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><a href="#prod-xpath40-DirPIContents"><span class="deltaxml-new" style="background:#90EE90">DirPIContents</span></a><span class="deltaxml-new" style="background:#90EE90">)? "?&gt;"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DirPIContents" id="prod-xpath40-DirPIContents"></a><span class="deltaxml-new" style="background:#90EE90">[194]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DirPIContents"><span class="deltaxml-new" style="background:#90EE90">DirPIContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* '?&gt;' Char*))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CDataSection" id="prod-xpath40-CDataSection"></a><span class="deltaxml-new" style="background:#90EE90">[195]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&lt;![CDATA[" </span><a href="#prod-xpath40-CDataSectionContents"><span class="deltaxml-new" style="background:#90EE90">CDataSectionContents</span></a><span class="deltaxml-new" style="background:#90EE90"> "]]&gt;"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CDataSectionContents" id="prod-xpath40-CDataSectionContents"></a><span class="deltaxml-new" style="background:#90EE90">[196]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CDataSectionContents"><span class="deltaxml-new" style="background:#90EE90">CDataSectionContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* ']]&gt;' Char*))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ComputedConstructor" id="prod-xpath40-ComputedConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[197]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ComputedConstructor"><span class="deltaxml-new" style="background:#90EE90">ComputedConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-CompDocConstructor"><span class="deltaxml-new" style="background:#90EE90">CompDocConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CompElemConstructor"><span class="deltaxml-new" style="background:#90EE90">CompElemConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CompAttrConstructor"><span class="deltaxml-new" style="background:#90EE90">CompAttrConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CompNamespaceConstructor"><span class="deltaxml-new" style="background:#90EE90">CompNamespaceConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CompTextConstructor"><span class="deltaxml-new" style="background:#90EE90">CompTextConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CompCommentConstructor"><span class="deltaxml-new" style="background:#90EE90">CompCommentConstructor</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CompPIConstructor"><span class="deltaxml-new" style="background:#90EE90">CompPIConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CompDocConstructor" id="prod-xpath40-CompDocConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[198]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompDocConstructor"><span class="deltaxml-new" style="background:#90EE90">CompDocConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"document" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CompElemConstructor" id="prod-xpath40-CompElemConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[199]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompElemConstructor"><span class="deltaxml-new" style="background:#90EE90">CompElemConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"element" (</span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("{" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}")) </span><a href="#prod-xpath40-EnclosedContentExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedContentExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EnclosedContentExpr" id="prod-xpath40-EnclosedContentExpr"></a><span class="deltaxml-new" style="background:#90EE90">[200]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedContentExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedContentExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CompAttrConstructor" id="prod-xpath40-CompAttrConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[201]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompAttrConstructor"><span class="deltaxml-new" style="background:#90EE90">CompAttrConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"attribute" (</span><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("{" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}")) </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CompNamespaceConstructor" id="prod-xpath40-CompNamespaceConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[202]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompNamespaceConstructor"><span class="deltaxml-new" style="background:#90EE90">CompNamespaceConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"namespace" (</span><a href="#prod-xpath40-Prefix"><span class="deltaxml-new" style="background:#90EE90">Prefix</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-EnclosedPrefixExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedPrefixExpr</span></a><span class="deltaxml-new" style="background:#90EE90">) </span><a href="#prod-xpath40-EnclosedURIExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedURIExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Prefix" id="prod-xpath40-Prefix"></a><span class="deltaxml-new" style="background:#90EE90">[203]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Prefix"><span class="deltaxml-new" style="background:#90EE90">Prefix</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EnclosedPrefixExpr" id="prod-xpath40-EnclosedPrefixExpr"></a><span class="deltaxml-new" style="background:#90EE90">[204]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedPrefixExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedPrefixExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EnclosedURIExpr" id="prod-xpath40-EnclosedURIExpr"></a><span class="deltaxml-new" style="background:#90EE90">[205]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnclosedURIExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedURIExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CompTextConstructor" id="prod-xpath40-CompTextConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[206]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompTextConstructor"><span class="deltaxml-new" style="background:#90EE90">CompTextConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"text" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CompCommentConstructor" id="prod-xpath40-CompCommentConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[207]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompCommentConstructor"><span class="deltaxml-new" style="background:#90EE90">CompCommentConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"comment" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CompPIConstructor" id="prod-xpath40-CompPIConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[208]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CompPIConstructor"><span class="deltaxml-new" style="background:#90EE90">CompPIConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"processing-instruction" (</span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | ("{" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90"> "}")) </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FunctionItemExpr" id="prod-xpath40-FunctionItemExpr"></a><span class="deltaxml-new" style="background:#90EE90">[209]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FunctionItemExpr"><span class="deltaxml-new" style="background:#90EE90">FunctionItemExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NamedFunctionRef"><span class="deltaxml-new" style="background:#90EE90">NamedFunctionRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-InlineFunctionExpr"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NamedFunctionRef" id="prod-xpath40-NamedFunctionRef"></a><span class="deltaxml-new" style="background:#90EE90">[210]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NamedFunctionRef"><span class="deltaxml-new" style="background:#90EE90">NamedFunctionRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a><span class="deltaxml-new" style="background:#90EE90"> "#" </span><a href="#prod-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-reserved-function-names"><span class="deltaxml-new" style="background:#90EE90">xgc: reserved-function-names</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-InlineFunctionExpr" id="prod-xpath40-InlineFunctionExpr"></a><span class="deltaxml-new" style="background:#90EE90">[211]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-InlineFunctionExpr"><span class="deltaxml-new" style="background:#90EE90">InlineFunctionExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* ("function" | "fn") </span><a href="#prod-xpath40-FunctionSignature"><span class="deltaxml-new" style="background:#90EE90">FunctionSignature</span></a><span class="deltaxml-new" style="background:#90EE90">? </span><a href="#prod-xpath40-FunctionBody"><span class="deltaxml-new" style="background:#90EE90">FunctionBody</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MapConstructor" id="prod-xpath40-MapConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[212]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MapConstructor"><span class="deltaxml-new" style="background:#90EE90">MapConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"map" </span><a href="#prod-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BareMapConstructor" id="prod-xpath40-BareMapConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[213]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BareMapConstructor"><span class="deltaxml-new" style="background:#90EE90">BareMapConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"{" (</span><a href="#prod-xpath40-MapConstructorEntry"><span class="deltaxml-new" style="background:#90EE90">MapConstructorEntry</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-MapConstructorEntry"><span class="deltaxml-new" style="background:#90EE90">MapConstructorEntry</span></a><span class="deltaxml-new" style="background:#90EE90">)*)? "}"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MapConstructorEntry" id="prod-xpath40-MapConstructorEntry"></a><span class="deltaxml-new" style="background:#90EE90">[214]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MapConstructorEntry"><span class="deltaxml-new" style="background:#90EE90">MapConstructorEntry</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-MapKeyExpr"><span class="deltaxml-new" style="background:#90EE90">MapKeyExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ":" </span><a href="#prod-xpath40-MapValueExpr"><span class="deltaxml-new" style="background:#90EE90">MapValueExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MapKeyExpr" id="prod-xpath40-MapKeyExpr"></a><span class="deltaxml-new" style="background:#90EE90">[215]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MapKeyExpr"><span class="deltaxml-new" style="background:#90EE90">MapKeyExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-ExprSingle"><span class="deltaxml-new" style="background:#90EE90">ExprSingle</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MapValueExpr" id="prod-xpath40-MapValueExpr"></a><span class="deltaxml-new" style="background:#90EE90">[216]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MapValueExpr"><span class="deltaxml-new" style="background:#90EE90">MapValueExpr</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArrayConstructor" id="prod-xpath40-ArrayConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[217]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">ArrayConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-SquareArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">SquareArrayConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-CurlyArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">CurlyArrayConstructor</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SquareArrayConstructor" id="prod-xpath40-SquareArrayConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[218]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SquareArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">SquareArrayConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"[" (</span><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-StandaloneExpr"><span class="deltaxml-new" style="background:#90EE90">StandaloneExpr</span></a><span class="deltaxml-new" style="background:#90EE90">)*)? "]"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CurlyArrayConstructor" id="prod-xpath40-CurlyArrayConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[219]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CurlyArrayConstructor"><span class="deltaxml-new" style="background:#90EE90">CurlyArrayConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"array" </span><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringTemplate" id="prod-xpath40-StringTemplate"></a><span class="deltaxml-new" style="background:#90EE90">[220]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"`" (</span><a href="#prod-xpath40-StringTemplateFixedPart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateFixedPart</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-StringTemplateVariablePart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateVariablePart</span></a><span class="deltaxml-new" style="background:#90EE90">)* "`"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringTemplateFixedPart" id="prod-xpath40-StringTemplateFixedPart"></a><span class="deltaxml-new" style="background:#90EE90">[221]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringTemplateFixedPart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateFixedPart</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">((</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - ('{' | '}' | '`')) | "{{" | "}}" | "``")*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringTemplateVariablePart" id="prod-xpath40-StringTemplateVariablePart"></a><span class="deltaxml-new" style="background:#90EE90">[222]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringTemplateVariablePart"><span class="deltaxml-new" style="background:#90EE90">StringTemplateVariablePart</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringConstructor" id="prod-xpath40-StringConstructor"></a><span class="deltaxml-new" style="background:#90EE90">[223]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringConstructor"><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"``[" </span><a href="#prod-xpath40-StringConstructorContent"><span class="deltaxml-new" style="background:#90EE90">StringConstructorContent</span></a><span class="deltaxml-new" style="background:#90EE90"> "]``"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringConstructorContent" id="prod-xpath40-StringConstructorContent"></a><span class="deltaxml-new" style="background:#90EE90">[224]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringConstructorContent"><span class="deltaxml-new" style="background:#90EE90">StringConstructorContent</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringConstructorChars"><span class="deltaxml-new" style="background:#90EE90">StringConstructorChars</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a href="#prod-xpath40-StringInterpolation"><span class="deltaxml-new" style="background:#90EE90">StringInterpolation</span></a><a href="#prod-xpath40-StringConstructorChars"><span class="deltaxml-new" style="background:#90EE90">StringConstructorChars</span></a><span class="deltaxml-new" style="background:#90EE90">)*</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringConstructorChars" id="prod-xpath40-StringConstructorChars"></a><span class="deltaxml-new" style="background:#90EE90">[225]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringConstructorChars"><span class="deltaxml-new" style="background:#90EE90">StringConstructorChars</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">* - (Char* ('`{' | ']``') Char*))</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringInterpolation" id="prod-xpath40-StringInterpolation"></a><span class="deltaxml-new" style="background:#90EE90">[226]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringInterpolation"><span class="deltaxml-new" style="background:#90EE90">StringInterpolation</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"`{" </span><a href="#prod-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">Expr</span></a><span class="deltaxml-new" style="background:#90EE90">? "}`"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-UnaryLookup" id="prod-xpath40-UnaryLookup"></a><span class="deltaxml-new" style="background:#90EE90">[227]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-UnaryLookup"><span class="deltaxml-new" style="background:#90EE90">UnaryLookup</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("?" | "??") (</span><a href="#prod-xpath40-Modifier"><span class="deltaxml-new" style="background:#90EE90">Modifier</span></a><span class="deltaxml-new" style="background:#90EE90"> "::")? </span><a href="#prod-xpath40-KeySpecifier"><span class="deltaxml-new" style="background:#90EE90">KeySpecifier</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypeDeclaration" id="prod-xpath40-TypeDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[228]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypeDeclaration"><span class="deltaxml-new" style="background:#90EE90">TypeDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"as" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SequenceType" id="prod-xpath40-SequenceType"></a><span class="deltaxml-new" style="background:#90EE90">[229]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("empty-sequence" "(" ")")</span><br><span class="deltaxml-new" style="background:#90EE90">| (</span><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><a href="#prod-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90">?)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-OccurrenceIndicator" id="prod-xpath40-OccurrenceIndicator"></a><span class="deltaxml-new" style="background:#90EE90">[230]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"?" | "*" | "+"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-occurrence-indicators"><span class="deltaxml-new" style="background:#90EE90">xgc: occurrence-indicators</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ItemType" id="prod-xpath40-ItemType"></a><span class="deltaxml-new" style="background:#90EE90">[231]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyItemTest"><span class="deltaxml-new" style="background:#90EE90">AnyItemTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ArrayTest"><span class="deltaxml-new" style="background:#90EE90">ArrayTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnyItemTest" id="prod-xpath40-AnyItemTest"></a><span class="deltaxml-new" style="background:#90EE90">[232]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyItemTest"><span class="deltaxml-new" style="background:#90EE90">AnyItemTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"item" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-KindTest" id="prod-xpath40-KindTest"></a><span class="deltaxml-new" style="background:#90EE90">[233]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DocumentTest"><span class="deltaxml-new" style="background:#90EE90">DocumentTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-PITest"><span class="deltaxml-new" style="background:#90EE90">PITest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-CommentTest"><span class="deltaxml-new" style="background:#90EE90">CommentTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-TextTest"><span class="deltaxml-new" style="background:#90EE90">TextTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-NamespaceNodeTest"><span class="deltaxml-new" style="background:#90EE90">NamespaceNodeTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-AnyKindTest"><span class="deltaxml-new" style="background:#90EE90">AnyKindTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnyKindTest" id="prod-xpath40-AnyKindTest"></a><span class="deltaxml-new" style="background:#90EE90">[234]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyKindTest"><span class="deltaxml-new" style="background:#90EE90">AnyKindTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"node" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DocumentTest" id="prod-xpath40-DocumentTest"></a><span class="deltaxml-new" style="background:#90EE90">[235]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DocumentTest"><span class="deltaxml-new" style="background:#90EE90">DocumentTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"document-node" "(" (</span><a href="#prod-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TextTest" id="prod-xpath40-TextTest"></a><span class="deltaxml-new" style="background:#90EE90">[236]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TextTest"><span class="deltaxml-new" style="background:#90EE90">TextTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"text" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CommentTest" id="prod-xpath40-CommentTest"></a><span class="deltaxml-new" style="background:#90EE90">[237]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CommentTest"><span class="deltaxml-new" style="background:#90EE90">CommentTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"comment" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NamespaceNodeTest" id="prod-xpath40-NamespaceNodeTest"></a><span class="deltaxml-new" style="background:#90EE90">[238]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NamespaceNodeTest"><span class="deltaxml-new" style="background:#90EE90">NamespaceNodeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"namespace-node" "(" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PITest" id="prod-xpath40-PITest"></a><span class="deltaxml-new" style="background:#90EE90">[239]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PITest"><span class="deltaxml-new" style="background:#90EE90">PITest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"processing-instruction" "(" (</span><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AttributeTest" id="prod-xpath40-AttributeTest"></a><span class="deltaxml-new" style="background:#90EE90">[240]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"attribute" "(" (</span><a href="#prod-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90">)?)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SchemaAttributeTest" id="prod-xpath40-SchemaAttributeTest"></a><span class="deltaxml-new" style="background:#90EE90">[241]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SchemaAttributeTest"><span class="deltaxml-new" style="background:#90EE90">SchemaAttributeTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"schema-attribute" "(" </span><a href="#prod-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ElementTest" id="prod-xpath40-ElementTest"></a><span class="deltaxml-new" style="background:#90EE90">[242]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"element" "(" (</span><a href="#prod-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"?)?)? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-SchemaElementTest" id="prod-xpath40-SchemaElementTest"></a><span class="deltaxml-new" style="background:#90EE90">[243]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-SchemaElementTest"><span class="deltaxml-new" style="background:#90EE90">SchemaElementTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"schema-element" "(" </span><a href="#prod-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AttributeName" id="prod-xpath40-AttributeName"></a><span class="deltaxml-new" style="background:#90EE90">[244]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AttributeName"><span class="deltaxml-new" style="background:#90EE90">AttributeName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ElementName" id="prod-xpath40-ElementName"></a><span class="deltaxml-new" style="background:#90EE90">[245]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ElementName"><span class="deltaxml-new" style="background:#90EE90">ElementName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CastTarget" id="prod-xpath40-CastTarget"></a><span class="deltaxml-new" style="background:#90EE90">[246]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CastTarget"><span class="deltaxml-new" style="background:#90EE90">CastTarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypeName" id="prod-xpath40-TypeName"></a><span class="deltaxml-new" style="background:#90EE90">[247]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FunctionTest" id="prod-xpath40-FunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[248]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FunctionTest"><span class="deltaxml-new" style="background:#90EE90">FunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Annotation"><span class="deltaxml-new" style="background:#90EE90">Annotation</span></a><span class="deltaxml-new" style="background:#90EE90">* (</span><a href="#prod-xpath40-AnyFunctionTest"><span class="deltaxml-new" style="background:#90EE90">AnyFunctionTest</span></a><br><span class="deltaxml-new" style="background:#90EE90">| </span><a href="#prod-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a><span class="deltaxml-new" style="background:#90EE90">)</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnyFunctionTest" id="prod-xpath40-AnyFunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[249]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyFunctionTest"><span class="deltaxml-new" style="background:#90EE90">AnyFunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("function" | "fn") "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypedFunctionTest" id="prod-xpath40-TypedFunctionTest"></a><span class="deltaxml-new" style="background:#90EE90">[250]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypedFunctionTest"><span class="deltaxml-new" style="background:#90EE90">TypedFunctionTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("function" | "fn") "(" (</span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)*)? ")" "as" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-MapTest" id="prod-xpath40-MapTest"></a><span class="deltaxml-new" style="background:#90EE90">[251]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-MapTest"><span class="deltaxml-new" style="background:#90EE90">MapTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyMapTest"><span class="deltaxml-new" style="background:#90EE90">AnyMapTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-TypedMapTest"><span class="deltaxml-new" style="background:#90EE90">TypedMapTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnyMapTest" id="prod-xpath40-AnyMapTest"></a><span class="deltaxml-new" style="background:#90EE90">[252]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyMapTest"><span class="deltaxml-new" style="background:#90EE90">AnyMapTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"map" "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypedMapTest" id="prod-xpath40-TypedMapTest"></a><span class="deltaxml-new" style="background:#90EE90">[253]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypedMapTest"><span class="deltaxml-new" style="background:#90EE90">TypedMapTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"map" "(" </span><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> "," </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-RecordTest" id="prod-xpath40-RecordTest"></a><span class="deltaxml-new" style="background:#90EE90">[254]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-RecordTest"><span class="deltaxml-new" style="background:#90EE90">RecordTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyRecordTest"><span class="deltaxml-new" style="background:#90EE90">AnyRecordTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-TypedRecordTest"><span class="deltaxml-new" style="background:#90EE90">TypedRecordTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnyRecordTest" id="prod-xpath40-AnyRecordTest"></a><span class="deltaxml-new" style="background:#90EE90">[255]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyRecordTest"><span class="deltaxml-new" style="background:#90EE90">AnyRecordTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"record" "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypedRecordTest" id="prod-xpath40-TypedRecordTest"></a><span class="deltaxml-new" style="background:#90EE90">[256]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypedRecordTest"><span class="deltaxml-new" style="background:#90EE90">TypedRecordTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"record" "(" </span><a href="#prod-xpath40-FieldDeclaration"><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-FieldDeclaration"><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></a><span class="deltaxml-new" style="background:#90EE90">)* </span><a href="#prod-xpath40-ExtensibleFlag"><span class="deltaxml-new" style="background:#90EE90">ExtensibleFlag</span></a><span class="deltaxml-new" style="background:#90EE90">? ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FieldDeclaration" id="prod-xpath40-FieldDeclaration"></a><span class="deltaxml-new" style="background:#90EE90">[257]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FieldDeclaration"><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-FieldName"><span class="deltaxml-new" style="background:#90EE90">FieldName</span></a><span class="deltaxml-new" style="background:#90EE90"> "?"? ("as" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-FieldName" id="prod-xpath40-FieldName"></a><span class="deltaxml-new" style="background:#90EE90">[258]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-FieldName"><span class="deltaxml-new" style="background:#90EE90">FieldName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ExtensibleFlag" id="prod-xpath40-ExtensibleFlag"></a><span class="deltaxml-new" style="background:#90EE90">[259]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ExtensibleFlag"><span class="deltaxml-new" style="background:#90EE90">ExtensibleFlag</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"," "*"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EnumerationType" id="prod-xpath40-EnumerationType"></a><span class="deltaxml-new" style="background:#90EE90">[260]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EnumerationType"><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"enum" "(" </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ("," </span><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ArrayTest" id="prod-xpath40-ArrayTest"></a><span class="deltaxml-new" style="background:#90EE90">[261]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ArrayTest"><span class="deltaxml-new" style="background:#90EE90">ArrayTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AnyArrayTest"><span class="deltaxml-new" style="background:#90EE90">AnyArrayTest</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-TypedArrayTest"><span class="deltaxml-new" style="background:#90EE90">TypedArrayTest</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AnyArrayTest" id="prod-xpath40-AnyArrayTest"></a><span class="deltaxml-new" style="background:#90EE90">[262]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AnyArrayTest"><span class="deltaxml-new" style="background:#90EE90">AnyArrayTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"array" "(" "*" ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-TypedArrayTest" id="prod-xpath40-TypedArrayTest"></a><span class="deltaxml-new" style="background:#90EE90">[263]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-TypedArrayTest"><span class="deltaxml-new" style="background:#90EE90">TypedArrayTest</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"array" "(" </span><a href="#prod-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ChoiceItemType" id="prod-xpath40-ChoiceItemType"></a><span class="deltaxml-new" style="background:#90EE90">[264]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ChoiceItemType"><span class="deltaxml-new" style="background:#90EE90">ChoiceItemType</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(" </span><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> ("|" </span><a href="#prod-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">)* ")"</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-URILiteral" id="prod-xpath40-URILiteral"></a><span class="deltaxml-new" style="background:#90EE90">[265]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EQName" id="prod-xpath40-EQName"></a><span class="deltaxml-new" style="background:#90EE90">[266]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EQName"><span class="deltaxml-new" style="background:#90EE90">EQName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td></tr></tbody></table><div class="div3"><h4><a id="EBNFNotation"></a><span class="deltaxml-new" style="background:#90EE90">A.1.1 Notation</span></h4><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="symbol" title="symbol"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Each rule in the grammar defines one </span><b><span class="deltaxml-new" style="background:#90EE90">symbol</span></b><span class="deltaxml-new" style="background:#90EE90">, using the following format: </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">symbol ::= expression</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90"> ] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="terminal" title="terminal"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a symbol or string or pattern that can appear in the right-hand side of a rule, but never appears on the left-hand side in the main grammar, although it may appear on the left-hand side of a rule in the grammar for terminals.] The following constructs are used to match strings of one or more characters in a terminal:</span></p><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">[a-zA-Z]</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches any </span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> with a value in the range(s) indicated (inclusive).</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">[abc]</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches any </span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> with a value among the characters enumerated. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">[^abc]</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches any </span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> with a value not among the characters given.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">"string"</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches the sequence of characters that appear inside the double quotes.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">'string'</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches the sequence of characters that appear inside the single quotes.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90"> [http://www.w3.org/TR/REC-example/#NT-Example]</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches any string matched by the production defined in the external specification as per the provided reference.</span></p></dd></dl><p><span class="deltaxml-new" style="background:#90EE90">Patterns (including the above constructs) can be combined with grammatical operators to form more complex patterns, matching more complex sets of character strings. In the examples that follow, A and B represent (sub-)patterns.</span></p><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">(A)</span></dt><dd><p><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> is treated as a unit and may be combined as described in this list.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">A?</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> or nothing; optional </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">A B</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90">. This operator has higher precedence than alternation; thus </span><code><span class="deltaxml-new" style="background:#90EE90">A B | C D</span></code><span class="deltaxml-new" style="background:#90EE90"> is identical to </span><code><span class="deltaxml-new" style="background:#90EE90">(A B) | (C D)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">A | B</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90"> but not both.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">A - B</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches any string that matches </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90"> but does not match </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">A+</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches one or more occurrences of </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90">. Concatenation has higher precedence than alternation; thus </span><code><span class="deltaxml-new" style="background:#90EE90">A+ | B+</span></code><span class="deltaxml-new" style="background:#90EE90"> is identical to </span><code><span class="deltaxml-new" style="background:#90EE90">(A+) | (B+)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd></dl><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">A*</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">matches zero or more occurrences of </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90">. Concatenation has higher precedence than alternation; thus </span><code><span class="deltaxml-new" style="background:#90EE90">A* | B*</span></code><span class="deltaxml-new" style="background:#90EE90"> is identical to </span><code><span class="deltaxml-new" style="background:#90EE90">(A*) | (B*)</span></code></p></dd></dl></div><div class="div3"><h4><a id="extra-grammatical-constraints"></a><span class="deltaxml-new" style="background:#90EE90">A.1.2 Extra-grammatical Constraints</span></h4><p><span class="deltaxml-new" style="background:#90EE90">This section contains constraints on the EBNF productions, which are required to parse syntactically valid sentences. The notes below are referenced from the right side of the production, with the notation: </span><em><span class="deltaxml-new" style="background:#90EE90">/* xgc: &lt;id&gt; */</span></em><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="constraint"><p class="prefix"><a id="parse-note-leading-lone-slash"></a><b><span class="deltaxml-new" style="background:#90EE90">Constraint: leading-lone-slash</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">A single slash may appear either as a complete path expression or as the first part of a path expression in which it is followed by a </span><a href="#doc-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">. In some cases, the next terminal after the slash is insufficient to allow a parser to distinguish these two possibilities: a </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90"> symbol or a keyword like </span><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90"> could be either an operator or a </span><a href="#doc-xpath40-NameTest"><span class="deltaxml-new" style="background:#90EE90">NameTest</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">/union/*</span></code><span class="deltaxml-new" style="background:#90EE90"> could be parsed either as </span><code><span class="deltaxml-new" style="background:#90EE90">(/) union (/*)</span></code><span class="deltaxml-new" style="background:#90EE90"> or as </span><code><span class="deltaxml-new" style="background:#90EE90">/child::union/child::*</span></code><span class="deltaxml-new" style="background:#90EE90"> (the second interpretation is the one chosen).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The situation where </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> is followed by </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> is a little more complicated. In XPath, this is unambiguous: the </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> can only indicate one of the operators </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">. In XQuery, however, it can also be the start of a direct constructor: specifically, a direct constructor for an element node, processing instruction node, or comment node. These constructs are identified by the tokenizer, independently of their syntactic context, as described in </span><a href="#lexical-structure"><b><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The rule adopted is as follows: if the terminal immediately following a slash can form the start of a </span><a href="#doc-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, then the slash must be the beginning of a </span><a href="#doc-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">PathExpr</span></a><span class="deltaxml-new" style="background:#90EE90">, not the entirety of it.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The terminals that can form the start of a </span><a href="#doc-xpath40-RelativePathExpr"><span class="deltaxml-new" style="background:#90EE90">RelativePathExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> are: </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">QName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">NumericLiteral</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></code><span class="deltaxml-new" style="background:#90EE90">; plus </span><code><span class="deltaxml-new" style="background:#90EE90">@</span></code><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><code><span class="deltaxml-new" style="background:#90EE90">..</span></code><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><code><span class="deltaxml-new" style="background:#90EE90">$</span></code><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><code><span class="deltaxml-new" style="background:#90EE90">%</span></code><code><span class="deltaxml-new" style="background:#90EE90">(</span></code><code><span class="deltaxml-new" style="background:#90EE90">[</span></code><span class="deltaxml-new" style="background:#90EE90">; and in XQuery </span><code><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">A single slash may be used as the left-hand argument of an operator by parenthesizing it: </span><code><span class="deltaxml-new" style="background:#90EE90">(/) * 5</span></code><span class="deltaxml-new" style="background:#90EE90">. The expression </span><code><span class="deltaxml-new" style="background:#90EE90">5 * /</span></code><span class="deltaxml-new" style="background:#90EE90">, on the other hand, is syntactically valid without parentheses.</span></p></div><div class="constraint"><p class="prefix"><a id="parse-note-xml-version"></a><b><span class="deltaxml-new" style="background:#90EE90">Constraint: xml-version</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The version of XML and XML Names (e.g. </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES"><span class="deltaxml-new" style="background:#90EE90">[XML Names]</span></a><span class="deltaxml-new" style="background:#90EE90">, or </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">) is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">. It is recommended that the latest applicable version be used (even if it is published later than this specification). The EBNF in this specification links only to the 1.0 versions. Note also that these external productions follow the whitespace rules of their respective specifications, and not the rules of this specification, in particular </span><a href="#DefaultWhitespaceHandling"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5.1 Default Whitespace Handling</span></b></a><span class="deltaxml-new" style="background:#90EE90">. Thus </span><code><span class="deltaxml-new" style="background:#90EE90">prefix : localname</span></code><span class="deltaxml-new" style="background:#90EE90"> is not a syntactically valid </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> for purposes of this specification, just as it is not permitted in a XML document. Also, comments are not permissible on either side of the colon. Also extra-grammatical constraints such as well-formedness constraints must be taken into account.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">XML 1.0 and XML 1.1 differ in their handling of C0 control characters (specifically #x1 through #x1F, excluding #x9, #xA, and #xD) and C1 control characters (#x7F through #x9F). In XML 1.0, these C0 characters are prohibited, and the C1 characters are permitted. In XML 1.1, both sets of control characters are permitted, but only if written as character references. It is RECOMMENDED that implementations should follow the XML 1.1 rules in this respect; however, for backwards compatibility with </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath 2.0</span></span></span><span class="deltaxml-new" style="background:#90EE90">, implementations MAY allow C1 control characters to be used directly. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Direct use of C1 control characters often suggests a character encoding error, such as using encoding CP-1252 and mislabeling it as iso-8859-1.</span></p></div></div></div><div class="constraint"><p class="prefix"><a id="parse-note-reserved-function-names"></a><b><span class="deltaxml-new" style="background:#90EE90">Constraint: reserved-function-names</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Unprefixed function names spelled the same way as language keywords could make the language impossible to parse. For instance, </span><code><span class="deltaxml-new" style="background:#90EE90">element(foo)</span></code><span class="deltaxml-new" style="background:#90EE90"> could be taken either as a </span><a href="#doc-xpath40-FunctionCall"><span class="deltaxml-new" style="background:#90EE90">FunctionCall</span></a><span class="deltaxml-new" style="background:#90EE90"> or as an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90">. Therefore, an unprefixed function name must not be any of the names in </span><a href="#id-reserved-fn-names"><b><span class="deltaxml-new" style="background:#90EE90">A.4 Reserved Function Names</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A function named </span><code><span class="deltaxml-new" style="background:#90EE90">if</span></code><span class="deltaxml-new" style="background:#90EE90"> can be called by binding its namespace to a prefix and using the prefixed form: </span><code><span class="deltaxml-new" style="background:#90EE90">library:if(foo)</span></code><span class="deltaxml-new" style="background:#90EE90"> instead of </span><code><span class="deltaxml-new" style="background:#90EE90">if(foo)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="constraint"><p class="prefix"><a id="parse-note-occurrence-indicators"></a><b><span class="deltaxml-new" style="background:#90EE90">Constraint: occurrence-indicators</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">As written, the grammar in </span><a href="#nt-bnf"><b><span class="deltaxml-new" style="background:#90EE90">A XQuery 4.0 and XPath 4.0 Grammar</span></b></a><span class="deltaxml-new" style="background:#90EE90"> is ambiguous for some forms using the </span><code><span class="deltaxml-new" style="background:#90EE90">"+"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"?"</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">"*"</span></code><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicators</span></a><span class="deltaxml-new" style="background:#90EE90">. The ambiguity is resolved as follows: these operators are tightly bound to the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> expression, and have higher precedence than other uses of these symbols. Any occurrence of </span><code><span class="deltaxml-new" style="background:#90EE90">"+"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"?"</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">"*"</span></code><span class="deltaxml-new" style="background:#90EE90">, that follows a sequence type is assumed to be an occurrence indicator, which binds to the last </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Thus, </span><code><span class="deltaxml-new" style="background:#90EE90">4 treat as item() + - 5</span></code><span class="deltaxml-new" style="background:#90EE90"> must be interpreted as </span><code><span class="deltaxml-new" style="background:#90EE90">(4 treat as item()+) - 5</span></code><span class="deltaxml-new" style="background:#90EE90">, taking the '+' as an occurrence indicator and the '-' as a subtraction operator. To force the interpretation of "+" as an addition operator (and the corresponding interpretation of the "-" as a unary minus), parentheses may be used: the form </span><code><span class="deltaxml-new" style="background:#90EE90">(4 treat as item()) + -5</span></code><span class="deltaxml-new" style="background:#90EE90"> surrounds the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> expression with parentheses and leads to the desired interpretation.</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">function () as xs:string *</span></code><span class="deltaxml-new" style="background:#90EE90"> is interpreted as </span><code><span class="deltaxml-new" style="background:#90EE90">function () as (xs:string *)</span></code><span class="deltaxml-new" style="background:#90EE90">, not as </span><code><span class="deltaxml-new" style="background:#90EE90">(function () as xs:string) *</span></code><span class="deltaxml-new" style="background:#90EE90">. Parentheses can be used as shown to force the latter interpretation.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This rule has as a consequence that certain forms which would otherwise be syntactically valid and unambiguous are not recognized: in </span><code><span class="deltaxml-new" style="background:#90EE90">4 treat as item() + 5</span></code><span class="deltaxml-new" style="background:#90EE90">, the </span><code><span class="deltaxml-new" style="background:#90EE90">"+"</span></code><span class="deltaxml-new" style="background:#90EE90"> is taken as an </span><a href="#doc-xpath40-OccurrenceIndicator"><span class="deltaxml-new" style="background:#90EE90">OccurrenceIndicator</span></a><span class="deltaxml-new" style="background:#90EE90">, and not as an operator, which means this is not a syntactically valid expression.</span></p></div></div><div class="div3"><h4><a id="notes-on-parsing"></a><span class="deltaxml-new" style="background:#90EE90">A.1.3 Grammar Notes</span></h4><p><span class="deltaxml-new" style="background:#90EE90">This section contains general notes on the EBNF productions, which may be helpful in understanding how to interpret and implement the EBNF. These notes are not normative. The notes below are referenced from the right side of the production, with the notation: </span><em><span class="deltaxml-new" style="background:#90EE90">/* gn: &lt;id&gt; */</span></em><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><dl><dt class="label"><a id="parse-note-parens"></a><span class="deltaxml-new" style="background:#90EE90">grammar-note: parens</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Lookahead is required to distinguish a </span><a href="#doc-xpath40-FunctionCall"><span class="deltaxml-new" style="background:#90EE90">FunctionCall</span></a><span class="deltaxml-new" style="background:#90EE90"> from an EQName or keyword followed by a </span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-Pragma"><span class="deltaxml-new" style="background:#90EE90">Pragma</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span></span></span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90">. For example: </span><code><span class="deltaxml-new" style="background:#90EE90">address (: this may be empty :)</span></code><span class="deltaxml-new" style="background:#90EE90"> may be mistaken for a call to a function named "address" unless this lookahead is employed. Another example is </span><code><span class="deltaxml-new" style="background:#90EE90">for (: whom the bell :) $tolls in 3 return $tolls</span></code><span class="deltaxml-new" style="background:#90EE90">, where the keyword "for" must not be mistaken for a function name.</span></p></dd><dt class="label"><a id="parse-note-comments"></a><span class="deltaxml-new" style="background:#90EE90">grammar-note: comments</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Comments are allowed everywhere that </span><a title="ignorable whitespace" class="termref" href="#IgnorableWhitespace"><span class="deltaxml-new" style="background:#90EE90">ignorable whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> is allowed, and the </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90"> symbol does not explicitly appear on the right-hand side of the grammar (except in its own production). See </span><a href="#DefaultWhitespaceHandling"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5.1 Default Whitespace Handling</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Note that comments are not allowed in direct constructor content, though they are allowed in nested </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90"> EnclosedExprs</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p><p><span class="deltaxml-new" style="background:#90EE90">A comment can contain nested comments, as long as all </span><code><span class="deltaxml-new" style="background:#90EE90">"(:"</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">":)"</span></code><span class="deltaxml-new" style="background:#90EE90"> patterns are balanced, no matter where they occur within the outer comment.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Lexical analysis may typically handle nested comments by incrementing a counter for each </span><code><span class="deltaxml-new" style="background:#90EE90">"(:"</span></code><span class="deltaxml-new" style="background:#90EE90"> pattern, and decrementing the counter for each </span><code><span class="deltaxml-new" style="background:#90EE90">":)"</span></code><span class="deltaxml-new" style="background:#90EE90"> pattern. The comment does not terminate until the counter is back to zero.</span></p></div><p><span class="deltaxml-new" style="background:#90EE90">Some illustrative examples:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">(: commenting out a (: comment :) may be confusing, but often helpful :)</span></code><span class="deltaxml-new" style="background:#90EE90"> is a syntactically valid </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90">, since balanced nesting of comments is allowed.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">"this is just a string :)"</span></code><span class="deltaxml-new" style="background:#90EE90"> is a syntactically valid expression. However, </span><code><span class="deltaxml-new" style="background:#90EE90">(: "this is just a string :)" :)</span></code><span class="deltaxml-new" style="background:#90EE90"> will cause a syntax error. Likewise, </span><code><span class="deltaxml-new" style="background:#90EE90">"this is another string (:"</span></code><span class="deltaxml-new" style="background:#90EE90"> is a syntactically valid expression, but </span><code><span class="deltaxml-new" style="background:#90EE90">(: "this is another string (:" :)</span></code><span class="deltaxml-new" style="background:#90EE90"> will cause a syntax error. It is a limitation of nested comments that literal content can cause unbalanced nesting of comments.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">for (: set up loop :) $i in $x return $i</span></code><span class="deltaxml-new" style="background:#90EE90"> is syntactically valid, ignoring the comment.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">5 instance (: strange place for a comment :) of xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> is also syntactically valid.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90"> &lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt; </span></code><span class="deltaxml-new" style="background:#90EE90"> is not syntactically valid.</span></p></li><li class="xquery"><p><code><span class="deltaxml-new" style="background:#90EE90"> &lt;eg&gt; (: an example:) &lt;/eg&gt; </span></code><span class="deltaxml-new" style="background:#90EE90"> is syntactically valid, but the characters that look like a comment are in fact literal element content.</span></p></li></ul></dd></dl></div></div></div><div class="div2"><h3><a id="productions-derived-from-XML"></a><span class="deltaxml-new" style="background:#90EE90">A.2 Productions Derived from XML</span></h3><p><span class="deltaxml-new" style="background:#90EE90">Some productions are defined by reference to the XML and XML Names specifications (e.g. </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES"><span class="deltaxml-new" style="background:#90EE90">[XML Names]</span></a><span class="deltaxml-new" style="background:#90EE90">, or </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">A host language may choose</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">It is implementation-defined</span></span></span><span class="deltaxml-new" style="background:#90EE90"> which version of these specifications is used; it is recommended that the latest applicable version be used (even if it is published later than this specification).</span></p><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">host language</span></b><span class="deltaxml-new" style="background:#90EE90"> may choose whether the lexical rules of </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES"><span class="deltaxml-new" style="background:#90EE90">[XML Names]</span></a><span class="deltaxml-new" style="background:#90EE90"> are followed, or alternatively, the lexical rules of </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> are followed.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">It is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90"> implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> whether the lexical rules of </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES"><span class="deltaxml-new" style="background:#90EE90">[XML Names]</span></a><span class="deltaxml-new" style="background:#90EE90"> are followed, or alternatively, the lexical rules of </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> are followed. Implementations that support the full </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> character set </span><a title="should" class="termref" href="#should"><span class="deltaxml-new" style="background:#90EE90">SHOULD</span></a><span class="deltaxml-new" style="background:#90EE90">, for purposes of interoperability, provide a mode that follows only the </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES"><span class="deltaxml-new" style="background:#90EE90">[XML Names]</span></a><span class="deltaxml-new" style="background:#90EE90"> lexical rules.</span></p></div></div><div class="div2"><h3><a id="lexical-structure"></a><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-reserved-fn-names"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-conformance"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules for tokenization have been largely rewritten. In some cases the revised specification may affect edge cases that were handled in different ways by different 3.1 processors, which could lead to incompatible behavior. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/327"><span class="deltaxml-new" style="background:#90EE90">327</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/519"><span class="deltaxml-new" style="background:#90EE90">519</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;30 May 2023]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">This section describes how an XQuery 4.0 and XPath 4.0 text is tokenized prior to parsing.</span></p><p><span class="deltaxml-new" style="background:#90EE90">All keywords are case sensitive. Keywords are not reserved—that is, any </span><a title="lexical QName" class="termref" href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a><span class="deltaxml-new" style="background:#90EE90"> may duplicate a keyword except as noted in </span><a href="#id-reserved-fn-names"><b><span class="deltaxml-new" style="background:#90EE90">A.4 Reserved Function Names</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Tokenizing an input string is a process that follows the following rules:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-ordinary-production-rule" title="ordinary production rule"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: An </span><b><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></b><span class="deltaxml-new" style="background:#90EE90"> is a production rule in </span><a href="#id-grammar"><b><span class="deltaxml-new" style="background:#90EE90">A.1 EBNF</span></b></a><span class="deltaxml-new" style="background:#90EE90"> that is not annotated </span><code><span class="deltaxml-new" style="background:#90EE90">ws:explicit</span></code><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-literal-terminal" title="literal terminal"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">literal terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a token appearing as a string in quotation marks on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Strings that appear in other production rules do not qualify. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">For example, </span><code><span class="deltaxml-new" style="background:#90EE90">"]]&gt;"</span></code><span class="deltaxml-new" style="background:#90EE90"> is not a literal terminal, because it appears only in the rule </span><a href="#doc-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a><span class="deltaxml-new" style="background:#90EE90">, which is not an ordinary production rule; similarly </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> does not qualify because it appears only in </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">"0x"</span></code><span class="deltaxml-new" style="background:#90EE90"> does not qualify because it appears only in </span><a href="#doc-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">For example, </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> does not quality because it appears only in </span><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">"0x"</span></code><span class="deltaxml-new" style="background:#90EE90"> does not qualify because it appears only in </span><a href="#doc-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p></div><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-new" style="background:#90EE90">literal terminals</span></a><span class="deltaxml-new" style="background:#90EE90"> in XQuery 4.0 and XPath 4.0 are: </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><code><span class="deltaxml-new" style="background:#90EE90">!=</span></code><code><span class="deltaxml-new" style="background:#90EE90">#</span></code><code><span class="deltaxml-new" style="background:#90EE90">$</span></code><code><span class="deltaxml-new" style="background:#90EE90">%</span></code><code><span class="deltaxml-new" style="background:#90EE90">(</span></code><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><code><span class="deltaxml-new" style="background:#90EE90">,</span></code><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><code><span class="deltaxml-new" style="background:#90EE90">..</span></code><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><code><span class="deltaxml-new" style="background:#90EE90">:</span></code><code><span class="deltaxml-new" style="background:#90EE90">::</span></code><code><span class="deltaxml-new" style="background:#90EE90">:=</span></code><code><span class="deltaxml-new" style="background:#90EE90">;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;&lt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">=?&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><code><span class="deltaxml-new" style="background:#90EE90">?[</span></code><code><span class="deltaxml-new" style="background:#90EE90">@</span></code><code><span class="deltaxml-new" style="background:#90EE90">[</span></code><code><span class="deltaxml-new" style="background:#90EE90">]</span></code><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><code><span class="deltaxml-new" style="background:#90EE90">|</span></code><code><span class="deltaxml-new" style="background:#90EE90">||</span></code><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><code><span class="deltaxml-new" style="background:#90EE90">×</span></code><code><span class="deltaxml-new" style="background:#90EE90">÷</span></code><code><span class="deltaxml-new" style="background:#90EE90">-</span></code><code><span class="deltaxml-new" style="background:#90EE90">allowing</span></code><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><code><span class="deltaxml-new" style="background:#90EE90">ancestor-or-self</span></code><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><code><span class="deltaxml-new" style="background:#90EE90">ascending</span></code><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><code><span class="deltaxml-new" style="background:#90EE90">boundary-space</span></code><code><span class="deltaxml-new" style="background:#90EE90">by</span></code><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><code><span class="deltaxml-new" style="background:#90EE90">castable</span></code><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><code><span class="deltaxml-new" style="background:#90EE90">collation</span></code><code><span class="deltaxml-new" style="background:#90EE90">comment</span></code><code><span class="deltaxml-new" style="background:#90EE90">construction</span></code><code><span class="deltaxml-new" style="background:#90EE90">context</span></code><code><span class="deltaxml-new" style="background:#90EE90">copy-namespaces</span></code><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><code><span class="deltaxml-new" style="background:#90EE90">decimal-format</span></code><code><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">declare</span></code><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><code><span class="deltaxml-new" style="background:#90EE90">descendant</span></code><code><span class="deltaxml-new" style="background:#90EE90">descendant-or-self</span></code><code><span class="deltaxml-new" style="background:#90EE90">descending</span></code><code><span class="deltaxml-new" style="background:#90EE90">digit</span></code><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><code><span class="deltaxml-new" style="background:#90EE90">document</span></code><code><span class="deltaxml-new" style="background:#90EE90">document-node</span></code><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><code><span class="deltaxml-new" style="background:#90EE90">empty</span></code><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence</span></code><code><span class="deltaxml-new" style="background:#90EE90">encoding</span></code><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><code><span class="deltaxml-new" style="background:#90EE90">enum</span></code><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><code><span class="deltaxml-new" style="background:#90EE90">except</span></code><code><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><code><span class="deltaxml-new" style="background:#90EE90">fixed</span></code><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><code><span class="deltaxml-new" style="background:#90EE90">following</span></code><code><span class="deltaxml-new" style="background:#90EE90">following-sibling</span></code><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><code><span class="deltaxml-new" style="background:#90EE90">greatest</span></code><code><span class="deltaxml-new" style="background:#90EE90">group</span></code><code><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><code><span class="deltaxml-new" style="background:#90EE90">idiv</span></code><code><span class="deltaxml-new" style="background:#90EE90">if</span></code><code><span class="deltaxml-new" style="background:#90EE90">import</span></code><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><code><span class="deltaxml-new" style="background:#90EE90">infinity</span></code><code><span class="deltaxml-new" style="background:#90EE90">inherit</span></code><code><span class="deltaxml-new" style="background:#90EE90">instance</span></code><code><span class="deltaxml-new" style="background:#90EE90">intersect</span></code><code><span class="deltaxml-new" style="background:#90EE90">is</span></code><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><code><span class="deltaxml-new" style="background:#90EE90">item-type</span></code><code><span class="deltaxml-new" style="background:#90EE90">items</span></code><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><code><span class="deltaxml-new" style="background:#90EE90">keys</span></code><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><code><span class="deltaxml-new" style="background:#90EE90">least</span></code><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><code><span class="deltaxml-new" style="background:#90EE90">minus-sign</span></code><code><span class="deltaxml-new" style="background:#90EE90">mod</span></code><code><span class="deltaxml-new" style="background:#90EE90">module</span></code><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><code><span class="deltaxml-new" style="background:#90EE90">namespace-node</span></code><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><code><span class="deltaxml-new" style="background:#90EE90">next</span></code><code><span class="deltaxml-new" style="background:#90EE90">no-inherit</span></code><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><code><span class="deltaxml-new" style="background:#90EE90">node</span></code><code><span class="deltaxml-new" style="background:#90EE90">of</span></code><code><span class="deltaxml-new" style="background:#90EE90">only</span></code><code><span class="deltaxml-new" style="background:#90EE90">option</span></code><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><code><span class="deltaxml-new" style="background:#90EE90">order</span></code><code><span class="deltaxml-new" style="background:#90EE90">ordered</span></code><code><span class="deltaxml-new" style="background:#90EE90">ordering</span></code><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><code><span class="deltaxml-new" style="background:#90EE90">pairs</span></code><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><code><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">per-mille</span></code><code><span class="deltaxml-new" style="background:#90EE90">percent</span></code><code><span class="deltaxml-new" style="background:#90EE90">preceding</span></code><code><span class="deltaxml-new" style="background:#90EE90">preceding-sibling</span></code><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><code><span class="deltaxml-new" style="background:#90EE90">previous</span></code><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction</span></code><code><span class="deltaxml-new" style="background:#90EE90">record</span></code><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><code><span class="deltaxml-new" style="background:#90EE90">satisfies</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema-attribute</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema-element</span></code><code><span class="deltaxml-new" style="background:#90EE90">self</span></code><code><span class="deltaxml-new" style="background:#90EE90">sliding</span></code><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><code><span class="deltaxml-new" style="background:#90EE90">stable</span></code><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><code><span class="deltaxml-new" style="background:#90EE90">text</span></code><code><span class="deltaxml-new" style="background:#90EE90">then</span></code><code><span class="deltaxml-new" style="background:#90EE90">to</span></code><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><code><span class="deltaxml-new" style="background:#90EE90">tumbling</span></code><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><code><span class="deltaxml-new" style="background:#90EE90">unordered</span></code><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><code><span class="deltaxml-new" style="background:#90EE90">values</span></code><code><span class="deltaxml-new" style="background:#90EE90">variable</span></code><code><span class="deltaxml-new" style="background:#90EE90">version</span></code><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><code><span class="deltaxml-new" style="background:#90EE90">xquery</span></code><code><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-variable-terminal" title="variable terminal"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is an instance of a production rule that is not itself an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90"> but that is named (directly) on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminals</span></a><span class="deltaxml-new" style="background:#90EE90"> in XQuery 4.0 and XPath 4.0 are: </span><a href="#prod-xpath40-BinaryIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></a><a href="#prod-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a><a href="#prod-xpath40-DecimalLiteral"><span class="deltaxml-new" style="background:#90EE90">DecimalLiteral</span></a><a href="#prod-xpath40-DirCommentConstructor"><span class="deltaxml-new" style="background:#90EE90">DirCommentConstructor</span></a><a href="#prod-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><a href="#prod-xpath40-DirPIConstructor"><span class="deltaxml-new" style="background:#90EE90">DirPIConstructor</span></a><a href="#prod-xpath40-DoubleLiteral"><span class="deltaxml-new" style="background:#90EE90">DoubleLiteral</span></a><a href="#prod-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><a href="#prod-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><a href="#prod-xpath40-Pragma"><span class="deltaxml-new" style="background:#90EE90">Pragma</span></a><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-StringConstructor"><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></a><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><a href="#prod-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><a href="#prod-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a><a href="#prod-xpath40-Wildcard"><span class="deltaxml-new" style="background:#90EE90">Wildcard</span></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-complex-terminal" title="complex terminal"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">complex terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></a><span class="deltaxml-new" style="background:#90EE90"> whose production rule references, directly or indirectly, an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="complex terminal" class="termref" href="#dt-complex-terminal"><span class="deltaxml-new" style="background:#90EE90">complex terminals</span></a><span class="deltaxml-new" style="background:#90EE90"> in XQuery 4.0 and XPath 4.0 are: </span><a href="#prod-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><a href="#prod-xpath40-Pragma"><span class="deltaxml-new" style="background:#90EE90">Pragma</span></a><a href="#prod-xpath40-StringConstructor"><span class="deltaxml-new" style="background:#90EE90">StringConstructor</span></a><a href="#prod-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The significance of complex terminals is that at one level, a complex terminal is treated as a single token, but internally it may contain arbitrary expressions that must be parsed using the full EBNF grammar.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Tokenization is the process of splitting the supplied input string into a sequence of terminals, where each terminal is either a </span><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-new" style="background:#90EE90">literal terminal</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></a><span class="deltaxml-new" style="background:#90EE90"> (which may itself be a </span><a title="complex terminal" class="termref" href="#dt-complex-terminal"><span class="deltaxml-new" style="background:#90EE90">complex terminal</span></a><span class="deltaxml-new" style="background:#90EE90">). Tokenization is done by repeating the following steps:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Starting at the current position, skip any whitespace and comments.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the current position is not the end of the input, then return the longest </span><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-new" style="background:#90EE90">literal terminal</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></a><span class="deltaxml-new" style="background:#90EE90"> that can be matched starting at the current position, regardless whether this terminal is valid at this point in the grammar. If no such terminal can be identified starting at the current position, or if the terminal that is identified is not a valid continuation of the grammar rules, then a syntax error is reported.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Here are some examples showing the effect of the longest token rule:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">map{a:b}</span></code><span class="deltaxml-new" style="background:#90EE90"> is a syntax error. Although there is a tokenization of this string that satisfies the grammar (by treating </span><code><span class="deltaxml-new" style="background:#90EE90">a</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">b</span></code><span class="deltaxml-new" style="background:#90EE90"> as separate expressions), this tokenization does not satisfy the longest token rule, which requires that </span><code><span class="deltaxml-new" style="background:#90EE90">a:b</span></code><span class="deltaxml-new" style="background:#90EE90"> is interpreted as a single </span><code><span class="deltaxml-new" style="background:#90EE90">QName</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">10 div3</span></code><span class="deltaxml-new" style="background:#90EE90"> is a syntax error. The longest token rule requires that this be interpreted as two tokens (</span><code><span class="deltaxml-new" style="background:#90EE90">"10"</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">"div3"</span></code><span class="deltaxml-new" style="background:#90EE90">) even though it would be a valid expression if treated as three tokens (</span><code><span class="deltaxml-new" style="background:#90EE90">"10"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"div"</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">"3"</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The expression </span><code><span class="deltaxml-new" style="background:#90EE90">$x-$y</span></code><span class="deltaxml-new" style="background:#90EE90"> is a syntax error. This is interpreted as four tokens, (</span><code><span class="deltaxml-new" style="background:#90EE90">"$"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"x-"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"$"</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">"y"</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li></ul></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The lexical production rules for </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminals</span></a><span class="deltaxml-new" style="background:#90EE90"> have been designed so that there is minimal need for backtracking. For example, if the next terminal starts with </span><code><span class="deltaxml-new" style="background:#90EE90">"0x"</span></code><span class="deltaxml-new" style="background:#90EE90">, then it can only be either a </span><a href="#doc-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> or an error; if it starts with </span><code><span class="deltaxml-new" style="background:#90EE90">"`"</span></code><span class="deltaxml-new" style="background:#90EE90"> (and not with </span><code><span class="deltaxml-new" style="background:#90EE90">"```"</span></code><span class="deltaxml-new" style="background:#90EE90">) then it can only be a </span><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><span class="deltaxml-new" style="background:#90EE90"> or an error. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">Direct element constructors in XQuery, however, need special treatment, described below.</span></span></span></p><p><span class="deltaxml-new" style="background:#90EE90">This convention, together with the rules for whitespace separation of tokens (see </span><a href="#id-terminal-delimitation"><b><span class="deltaxml-new" style="background:#90EE90">A.3.2 Terminal Delimitation</span></b></a><span class="deltaxml-new" style="background:#90EE90">) means that the longest-token rule does not normally result in any need for backtracking. For example, suppose that a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></a><span class="deltaxml-new" style="background:#90EE90"> has been identified as a </span><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><span class="deltaxml-new" style="background:#90EE90"> by examining its first few characters. If the construct turns out not to be a valid </span><a href="#doc-xpath40-StringTemplate"><span class="deltaxml-new" style="background:#90EE90">StringTemplate</span></a><span class="deltaxml-new" style="background:#90EE90">, an error can be reported without first considering whether there is some shorter token that might be returned instead.</span></p></div></li></ol></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Tokenization requires special care when the current character is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LESS-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">) :</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the following character is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">EQUALS SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90">) then the token can be identified unambiguously as the operator </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the following character is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LESS-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">) then the token can be identified unambiguously as the operator </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the following character is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0021</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">EXCLAMATION MARK</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><span class="deltaxml-new" style="background:#90EE90">) then the token can be identified unambiguously as being a </span><a href="#doc-xpath40-DirCommentConstructor"><span class="deltaxml-new" style="background:#90EE90">DirCommentConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> (a </span><a href="#doc-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSection</span></a><span class="deltaxml-new" style="background:#90EE90">, which also starts with </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;!</span></code><span class="deltaxml-new" style="background:#90EE90"> can appear only within a direct element constructor, not as a free-standing token).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the following character is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003F</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">QUESTION MARK</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90">) , then the token is identified as a </span><a href="#doc-xpath40-DirPIConstructor"><span class="deltaxml-new" style="background:#90EE90">DirPIConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> if and only if a match for the relevant production (</span><code><span class="deltaxml-new" style="background:#90EE90">"&lt;?" PITarget (S DirPIContents)? "?&gt;"</span></code><span class="deltaxml-new" style="background:#90EE90">) is found. If there is no such match, then the string </span><code><span class="deltaxml-new" style="background:#90EE90">"&lt;?"</span></code><span class="deltaxml-new" style="background:#90EE90"> is identified as a less-than operator followed by a lookup operator.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the following character is a </span><a href="http://www.w3.org/TR/REC-xml/#NameStartChar"><span class="deltaxml-new" style="background:#90EE90">NameStartChar</span></a><span class="deltaxml-new" style="background:#90EE90"> then the token is identified as a </span><a href="#doc-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> if and only if a match for the leading part of a </span><a href="#doc-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> is found: specifically if a substring starting at the </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LESS-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">) character matches one of the following regular expressions:</span></p><blockquote><p><code><span class="deltaxml-new" style="background:#90EE90">^&lt;\i\c*\s*&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> (as in </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;element&gt;...</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><br><code><span class="deltaxml-new" style="background:#90EE90">^&lt;\i\c*\s*/&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">(as in </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;element/&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><br><code><span class="deltaxml-new" style="background:#90EE90">^&lt;\i\c*\s+\i\c*\s*=</span></code><span class="deltaxml-new" style="background:#90EE90">(as in </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;element att=...</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></p></blockquote><p><span class="deltaxml-new" style="background:#90EE90">If the content matches one of these regular expressions but further analysis shows that the subsequent content does not satisfy the </span><a href="#doc-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> production, then a static error is reported.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the content does not match any of these regular expressions then the token is identified as the less-than operator </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the following character is any other character then the token can be identified unambiguously as the less-than operator </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">This analysis is done without regard to the syntactic context of the </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LESS-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">) character. However, a tokenizer </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> avoid looking for a </span><a href="#doc-xpath40-DirPIConstructor"><span class="deltaxml-new" style="background:#90EE90">DirPIConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-DirElemConstructor"><span class="deltaxml-new" style="background:#90EE90">DirElemConstructor</span></a><span class="deltaxml-new" style="background:#90EE90"> if it knows that such a constructor cannot appear in the current syntactic context.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">The rules here are described much more precisely than in XQuery 3.1, and the results in edge cases might be incompatible with some XQuery 3.1 processors.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">To avoid potential confusion, simply add whitespace after any less-than operator.</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">Tokenization unambiguously identifies the boundaries of the terminals in the input, and this can be achieved without backtracking or lookahead. However, tokenization does not unambiguously classify each terminal. For example, it might identify the string </span><code><span class="deltaxml-new" style="background:#90EE90">"div"</span></code><span class="deltaxml-new" style="background:#90EE90"> as a terminal, but it does not resolve whether this is the operator symbol </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90">, or an </span><code><span class="deltaxml-new" style="background:#90EE90">NCName</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">QName</span></code><span class="deltaxml-new" style="background:#90EE90"> used as a node test or as a variable or function name. Classification of terminals generally requires information about the grammatical context, and in some cases requires lookahead.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Operationally, classification of terminals may be done either in the tokenizer or the parser, or in some combination of the two. For example, according to the EBNF, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">"parent::x"</span></code><span class="deltaxml-new" style="background:#90EE90"> is made up of three tokens, </span><code><span class="deltaxml-new" style="background:#90EE90">"parent"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"::"</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">"x"</span></code><span class="deltaxml-new" style="background:#90EE90">. The name </span><code><span class="deltaxml-new" style="background:#90EE90">"parent"</span></code><span class="deltaxml-new" style="background:#90EE90"> can be classified as an axis name as soon as the following token </span><code><span class="deltaxml-new" style="background:#90EE90">"::"</span></code><span class="deltaxml-new" style="background:#90EE90"> is recognized, and this might be done either in the tokenizer or in the parser. (Note that whitespace and comments are allowed both before and after </span><code><span class="deltaxml-new" style="background:#90EE90">"::"</span></code><span class="deltaxml-new" style="background:#90EE90">.)</span></p></div></li><li><p><span class="deltaxml-new" style="background:#90EE90">In the case of a </span><a title="complex terminal" class="termref" href="#dt-complex-terminal"><span class="deltaxml-new" style="background:#90EE90">complex terminal</span></a><span class="deltaxml-new" style="background:#90EE90">, identifying the end of the complex terminal typically involves invoking the parser to process any embedded expressions. Tokenization, as described here, is therefore a recursive process. But other implementations are possible.</span></p></li></ul><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Previous versions of this specification included the statement: </span><em><span class="deltaxml-new" style="background:#90EE90">When tokenizing, the longest possible match that is consistent with the EBNF is used.</span></em></p><p><span class="deltaxml-new" style="background:#90EE90">Different processors are known to have interpreted this in different ways. One interpretation, for example, was that the expression </span><code><span class="deltaxml-new" style="background:#90EE90">10 div-3</span></code><span class="deltaxml-new" style="background:#90EE90"> should be split into four tokens (</span><code><span class="deltaxml-new" style="background:#90EE90">10</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">-</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">3</span></code><span class="deltaxml-new" style="background:#90EE90">) on the grounds that any other tokenization would give a result that was inconsistent with the EBNF grammar. Other processors report a syntax error on this example.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This rule has therefore been rewritten in version 4.0. Tokenization is now entirely insensitive to the grammatical context; </span><code><span class="deltaxml-new" style="background:#90EE90">div-3</span></code><span class="deltaxml-new" style="background:#90EE90"> is recognized as a single token even though this results in a syntax error. For some implementations this may mean that expressions that were accepted in earlier releases are no longer accepted in 4.0.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">A more subtle example is: </span><code><span class="deltaxml-new" style="background:#90EE90">(. &lt;?b ) cast as xs:integer?&gt; 0)</span></code><span class="deltaxml-new" style="background:#90EE90"> in which </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;?b ) cast as xs:integer?&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> is recognized as a single token (a direct processing instruction constructor) even though such a token cannot validly appear in this grammatical context.</span></p></div></div><div class="div3"><h4><a id="terminal-symbols"></a><span class="deltaxml-new" style="background:#90EE90">A.3.1 Terminal Symbols</span></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-IntegerLiteral" id="prod-xpath40-IntegerLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[267]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-HexIntegerLiteral" id="prod-xpath40-HexIntegerLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[268]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"0x" </span><a href="#prod-xpath40-HexDigits"><span class="deltaxml-new" style="background:#90EE90">HexDigits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BinaryIntegerLiteral" id="prod-xpath40-BinaryIntegerLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[269]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BinaryIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"0b" </span><a href="#prod-xpath40-BinaryDigits"><span class="deltaxml-new" style="background:#90EE90">BinaryDigits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DecimalLiteral" id="prod-xpath40-DecimalLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[270]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DecimalLiteral"><span class="deltaxml-new" style="background:#90EE90">DecimalLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">("." </span><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">) | (</span><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90"> "." </span><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">?)</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DoubleLiteral" id="prod-xpath40-DoubleLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[271]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DoubleLiteral"><span class="deltaxml-new" style="background:#90EE90">DoubleLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(("." </span><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">) | (</span><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90"> ("." </span><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a><span class="deltaxml-new" style="background:#90EE90">?)?)) [eE] [+-]? </span><a href="#prod-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-StringLiteral" id="prod-xpath40-StringLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[272]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-AposStringLiteral"><span class="deltaxml-new" style="background:#90EE90">AposStringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-QuotStringLiteral"><span class="deltaxml-new" style="background:#90EE90">QuotStringLiteral</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AposStringLiteral" id="prod-xpath40-AposStringLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[273]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AposStringLiteral"><span class="deltaxml-new" style="background:#90EE90">AposStringLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"'" (</span><a href="#prod-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-EscapeApos"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a><span class="deltaxml-new" style="background:#90EE90"> | [^'&amp;])* "'"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-QuotStringLiteral" id="prod-xpath40-QuotStringLiteral"></a><span class="deltaxml-new" style="background:#90EE90">[274]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QuotStringLiteral"><span class="deltaxml-new" style="background:#90EE90">QuotStringLiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">'"' (</span><a href="#prod-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-EscapeQuot"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a><span class="deltaxml-new" style="background:#90EE90"> | [^"&amp;])* '"'</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-URIQualifiedName" id="prod-xpath40-URIQualifiedName"></a><span class="deltaxml-new" style="background:#90EE90">[275]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BracedURILiteral" id="prod-xpath40-BracedURILiteral"></a><span class="deltaxml-new" style="background:#90EE90">[276]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"Q" "{" (</span><a href="#prod-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a><span class="deltaxml-new" style="background:#90EE90"> | [^&amp;{}])* "}"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PredefinedEntityRef" id="prod-xpath40-PredefinedEntityRef"></a><span class="deltaxml-new" style="background:#90EE90">[277]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PredefinedEntityRef"><span class="deltaxml-new" style="background:#90EE90">PredefinedEntityRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos") ";"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EscapeQuot" id="prod-xpath40-EscapeQuot"></a><span class="deltaxml-new" style="background:#90EE90">[278]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EscapeQuot"><span class="deltaxml-new" style="background:#90EE90">EscapeQuot</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">'""'</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-EscapeApos" id="prod-xpath40-EscapeApos"></a><span class="deltaxml-new" style="background:#90EE90">[279]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-EscapeApos"><span class="deltaxml-new" style="background:#90EE90">EscapeApos</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"''"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-ElementContentChar" id="prod-xpath40-ElementContentChar"></a><span class="deltaxml-new" style="background:#90EE90">[280]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-ElementContentChar"><span class="deltaxml-new" style="background:#90EE90">ElementContentChar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - [{}&lt;&amp;])</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-QuotAttrContentChar" id="prod-xpath40-QuotAttrContentChar"></a><span class="deltaxml-new" style="background:#90EE90">[281]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QuotAttrContentChar"><span class="deltaxml-new" style="background:#90EE90">QuotAttrContentChar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - ["{}&lt;&amp;])</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-AposAttrContentChar" id="prod-xpath40-AposAttrContentChar"></a><span class="deltaxml-new" style="background:#90EE90">[282]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-AposAttrContentChar"><span class="deltaxml-new" style="background:#90EE90">AposAttrContentChar</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90"> - ['{}&lt;&amp;])</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Comment" id="prod-xpath40-Comment"></a><span class="deltaxml-new" style="background:#90EE90">[283]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">"(:" (</span><a href="#prod-xpath40-CommentContents"><span class="deltaxml-new" style="background:#90EE90">CommentContents</span></a><span class="deltaxml-new" style="background:#90EE90"> | </span><a href="#prod-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90">)* ":)"</span></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr><tr style="vertical-align:baseline;"><td></td><td></td><td></td><td></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-comments"><span class="deltaxml-new" style="background:#90EE90">gn: comments</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-PITarget" id="prod-xpath40-PITarget"></a><span class="deltaxml-new" style="background:#90EE90">[284]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-PITarget"><span class="deltaxml-new" style="background:#90EE90">PITarget</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-PITarget"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml#NT-PITarget]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XML</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CharRef" id="prod-xpath40-CharRef"></a><span class="deltaxml-new" style="background:#90EE90">[285]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CharRef"><span class="deltaxml-new" style="background:#90EE90">CharRef</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-CharRef"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml#NT-CharRef]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XML</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-QName" id="prod-xpath40-QName"></a><span class="deltaxml-new" style="background:#90EE90">[286]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-QName"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">Names</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-NCName" id="prod-xpath40-NCName"></a><span class="deltaxml-new" style="background:#90EE90">[287]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">Names</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-S" id="prod-xpath40-S"></a><span class="deltaxml-new" style="background:#90EE90">[288]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-S"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml#NT-S]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XML</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Char" id="prod-xpath40-Char"></a><span class="deltaxml-new" style="background:#90EE90">[289]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-Char"><span class="deltaxml-new" style="background:#90EE90">[http://www.w3.org/TR/REC-xml#NT-Char]</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XML</span></small></sup></code></td><td><i><span class="deltaxml-new" style="background:#90EE90">/* </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">xgc: xml-version</span></a><span class="deltaxml-new" style="background:#90EE90"> */</span></i></td></tr></tbody></table><p><span class="deltaxml-new" style="background:#90EE90">The following symbols are used only in the definition of terminal symbols; they are not terminal symbols in the grammar of </span><a href="#id-grammar"><b><span class="deltaxml-new" style="background:#90EE90">A.1 EBNF</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-Digits" id="prod-xpath40-Digits"></a><span class="deltaxml-new" style="background:#90EE90">[290]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-Digits"><span class="deltaxml-new" style="background:#90EE90">Digits</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> ((</span><a href="#prod-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> | "_")* </span><a href="#prod-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-DecDigit" id="prod-xpath40-DecDigit"></a><span class="deltaxml-new" style="background:#90EE90">[291]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-DecDigit"><span class="deltaxml-new" style="background:#90EE90">DecDigit</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">[0-9]</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-HexDigits" id="prod-xpath40-HexDigits"></a><span class="deltaxml-new" style="background:#90EE90">[292]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-HexDigits"><span class="deltaxml-new" style="background:#90EE90">HexDigits</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> ((</span><a href="#prod-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> | "_")* </span><a href="#prod-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-HexDigit" id="prod-xpath40-HexDigit"></a><span class="deltaxml-new" style="background:#90EE90">[293]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-HexDigit"><span class="deltaxml-new" style="background:#90EE90">HexDigit</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">[0-9a-fA-F]</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BinaryDigits" id="prod-xpath40-BinaryDigits"></a><span class="deltaxml-new" style="background:#90EE90">[294]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BinaryDigits"><span class="deltaxml-new" style="background:#90EE90">BinaryDigits</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#prod-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> ((</span><a href="#prod-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a><span class="deltaxml-new" style="background:#90EE90"> | "_")* </span><a href="#prod-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a><span class="deltaxml-new" style="background:#90EE90">)?</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-BinaryDigit" id="prod-xpath40-BinaryDigit"></a><span class="deltaxml-new" style="background:#90EE90">[295]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-BinaryDigit"><span class="deltaxml-new" style="background:#90EE90">BinaryDigit</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">[01]</span></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a name="prod-xpath40-CommentContents" id="prod-xpath40-CommentContents"></a><span class="deltaxml-new" style="background:#90EE90">[296]&nbsp;&nbsp;&nbsp;</span></td><td><code><a href="#doc-xpath40-CommentContents"><span class="deltaxml-new" style="background:#90EE90">CommentContents</span></a></code></td><td><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">(</span><a href="#prod-xpath40-Char"><span class="deltaxml-new" style="background:#90EE90">Char</span></a><span class="deltaxml-new" style="background:#90EE90">+ - (Char* ('(:' | ':)') Char*))</span></code></td></tr></tbody></table></div><div class="div3"><h4><a id="id-terminal-delimitation"></a><span class="deltaxml-new" style="background:#90EE90">A.3.2 Terminal Delimitation</span></h4><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 expressions consist of </span><a href="#terminal-symbols"><span class="deltaxml-new" style="background:#90EE90">terminal symbols</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="symbol separators" class="termref" href="#symbolseparators"><span class="deltaxml-new" style="background:#90EE90">symbol separators</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span><a title="literal terminal" class="termref" href="#dt-literal-terminal"><span class="deltaxml-new" style="background:#90EE90">Literal</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable</span></a></span><span class="deltaxml-new" style="background:#90EE90"> terminal symbols are of two kinds: delimiting and non-delimiting.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="delimiting-token" title="delimiting terminal symbol"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">delimiting terminal symbols</span></b><span class="deltaxml-new" style="background:#90EE90"> are: </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><code><span class="deltaxml-new" style="background:#90EE90">!=</span></code><code><span class="deltaxml-new" style="background:#90EE90">#</span></code><code><span class="deltaxml-new" style="background:#90EE90">$</span></code><code><span class="deltaxml-new" style="background:#90EE90">%</span></code><code><span class="deltaxml-new" style="background:#90EE90">(</span></code><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><code><span class="deltaxml-new" style="background:#90EE90">*:</span></code><code><span class="deltaxml-new" style="background:#90EE90">,</span></code><code><span class="deltaxml-new" style="background:#90EE90">-</span></code><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><code><span class="deltaxml-new" style="background:#90EE90">..</span></code><code><span class="deltaxml-new" style="background:#90EE90">:</span></code><code><span class="deltaxml-new" style="background:#90EE90">:*</span></code><code><span class="deltaxml-new" style="background:#90EE90">::</span></code><code><span class="deltaxml-new" style="background:#90EE90">:=</span></code><code><span class="deltaxml-new" style="background:#90EE90">;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;&lt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">=?&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><code><span class="deltaxml-new" style="background:#90EE90">?[</span></code><code><span class="deltaxml-new" style="background:#90EE90">@</span></code><code><span class="deltaxml-new" style="background:#90EE90">[</span></code><code><span class="deltaxml-new" style="background:#90EE90">]</span></code><code><span class="deltaxml-new" style="background:#90EE90">`</span></code><code><span class="deltaxml-new" style="background:#90EE90">``</span></code><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><code><span class="deltaxml-new" style="background:#90EE90">{{</span></code><code><span class="deltaxml-new" style="background:#90EE90">|</span></code><code><span class="deltaxml-new" style="background:#90EE90">||</span></code><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><code><span class="deltaxml-new" style="background:#90EE90">}}</span></code><code><span class="deltaxml-new" style="background:#90EE90">×</span></code><code><span class="deltaxml-new" style="background:#90EE90">÷</span></code><a href="#prod-xpath40-AposStringLiteral"><span class="deltaxml-new" style="background:#90EE90">AposStringLiteral</span></a><a href="#prod-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">]]&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;![CDATA[</span></code><code><span class="deltaxml-new" style="background:#90EE90">--&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;!--</span></code><code><span class="deltaxml-new" style="background:#90EE90">/&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;/</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><code><span class="deltaxml-new" style="background:#90EE90">#)</span></code><code><span class="deltaxml-new" style="background:#90EE90">(#</span></code><code><span class="deltaxml-new" style="background:#90EE90">?&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;?</span></code><a href="#prod-xpath40-QuotStringLiteral"><span class="deltaxml-new" style="background:#90EE90">QuotStringLiteral</span></a><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><code><span class="deltaxml-new" style="background:#90EE90">]``</span></code><code><span class="deltaxml-new" style="background:#90EE90">``[</span></code><code><span class="deltaxml-new" style="background:#90EE90">}`</span></code><code><span class="deltaxml-new" style="background:#90EE90">`{</span></code><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> ] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="non-delimiting-token" title="non-delimiting terminal symbol"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The </span><b><span class="deltaxml-new" style="background:#90EE90">non-delimiting terminal symbols</span></b><span class="deltaxml-new" style="background:#90EE90"> are: </span><code><span class="deltaxml-new" style="background:#90EE90">allowing</span></code><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><code><span class="deltaxml-new" style="background:#90EE90">ancestor-or-self</span></code><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><code><span class="deltaxml-new" style="background:#90EE90">boundary-space</span></code><code><span class="deltaxml-new" style="background:#90EE90">by</span></code><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><code><span class="deltaxml-new" style="background:#90EE90">castable</span></code><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><code><span class="deltaxml-new" style="background:#90EE90">collation</span></code><code><span class="deltaxml-new" style="background:#90EE90">comment</span></code><code><span class="deltaxml-new" style="background:#90EE90">construction</span></code><code><span class="deltaxml-new" style="background:#90EE90">context</span></code><code><span class="deltaxml-new" style="background:#90EE90">copy-namespaces</span></code><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><code><span class="deltaxml-new" style="background:#90EE90">decimal-format</span></code><code><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">declare</span></code><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><code><span class="deltaxml-new" style="background:#90EE90">descendant</span></code><code><span class="deltaxml-new" style="background:#90EE90">descendant-or-self</span></code><code><span class="deltaxml-new" style="background:#90EE90">digit</span></code><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><code><span class="deltaxml-new" style="background:#90EE90">document</span></code><code><span class="deltaxml-new" style="background:#90EE90">document-node</span></code><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><code><span class="deltaxml-new" style="background:#90EE90">empty</span></code><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence</span></code><code><span class="deltaxml-new" style="background:#90EE90">encoding</span></code><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><code><span class="deltaxml-new" style="background:#90EE90">enum</span></code><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><code><span class="deltaxml-new" style="background:#90EE90">except</span></code><code><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><code><span class="deltaxml-new" style="background:#90EE90">fixed</span></code><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><code><span class="deltaxml-new" style="background:#90EE90">following</span></code><code><span class="deltaxml-new" style="background:#90EE90">following-sibling</span></code><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><code><span class="deltaxml-new" style="background:#90EE90">group</span></code><code><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><code><span class="deltaxml-new" style="background:#90EE90">idiv</span></code><code><span class="deltaxml-new" style="background:#90EE90">if</span></code><code><span class="deltaxml-new" style="background:#90EE90">import</span></code><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><code><span class="deltaxml-new" style="background:#90EE90">infinity</span></code><code><span class="deltaxml-new" style="background:#90EE90">inherit</span></code><code><span class="deltaxml-new" style="background:#90EE90">instance</span></code><code><span class="deltaxml-new" style="background:#90EE90">intersect</span></code><code><span class="deltaxml-new" style="background:#90EE90">is</span></code><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><code><span class="deltaxml-new" style="background:#90EE90">item-type</span></code><code><span class="deltaxml-new" style="background:#90EE90">items</span></code><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><code><span class="deltaxml-new" style="background:#90EE90">keys</span></code><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><code><span class="deltaxml-new" style="background:#90EE90">minus-sign</span></code><code><span class="deltaxml-new" style="background:#90EE90">mod</span></code><code><span class="deltaxml-new" style="background:#90EE90">module</span></code><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><code><span class="deltaxml-new" style="background:#90EE90">namespace-node</span></code><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><code><span class="deltaxml-new" style="background:#90EE90">next</span></code><code><span class="deltaxml-new" style="background:#90EE90">no-inherit</span></code><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><code><span class="deltaxml-new" style="background:#90EE90">node</span></code><code><span class="deltaxml-new" style="background:#90EE90">of</span></code><code><span class="deltaxml-new" style="background:#90EE90">only</span></code><code><span class="deltaxml-new" style="background:#90EE90">option</span></code><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><code><span class="deltaxml-new" style="background:#90EE90">order</span></code><code><span class="deltaxml-new" style="background:#90EE90">ordered</span></code><code><span class="deltaxml-new" style="background:#90EE90">ordering</span></code><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><code><span class="deltaxml-new" style="background:#90EE90">pairs</span></code><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><code><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">per-mille</span></code><code><span class="deltaxml-new" style="background:#90EE90">percent</span></code><code><span class="deltaxml-new" style="background:#90EE90">preceding</span></code><code><span class="deltaxml-new" style="background:#90EE90">preceding-sibling</span></code><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><code><span class="deltaxml-new" style="background:#90EE90">previous</span></code><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction</span></code><code><span class="deltaxml-new" style="background:#90EE90">record</span></code><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><code><span class="deltaxml-new" style="background:#90EE90">satisfies</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema-attribute</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema-element</span></code><code><span class="deltaxml-new" style="background:#90EE90">self</span></code><code><span class="deltaxml-new" style="background:#90EE90">sliding</span></code><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><code><span class="deltaxml-new" style="background:#90EE90">stable</span></code><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><code><span class="deltaxml-new" style="background:#90EE90">text</span></code><code><span class="deltaxml-new" style="background:#90EE90">then</span></code><code><span class="deltaxml-new" style="background:#90EE90">to</span></code><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><code><span class="deltaxml-new" style="background:#90EE90">tumbling</span></code><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><code><span class="deltaxml-new" style="background:#90EE90">unordered</span></code><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><code><span class="deltaxml-new" style="background:#90EE90">values</span></code><code><span class="deltaxml-new" style="background:#90EE90">variable</span></code><code><span class="deltaxml-new" style="background:#90EE90">version</span></code><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><code><span class="deltaxml-new" style="background:#90EE90">xquery</span></code><code><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></code><code><span class="deltaxml-new" style="background:#90EE90">ascending</span></code><a href="#prod-xpath40-BinaryIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></a><a href="#prod-xpath40-DecimalLiteral"><span class="deltaxml-new" style="background:#90EE90">DecimalLiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">descending</span></code><a href="#prod-xpath40-DoubleLiteral"><span class="deltaxml-new" style="background:#90EE90">DoubleLiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><code><span class="deltaxml-new" style="background:#90EE90">greatest</span></code><a href="#prod-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><a href="#prod-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">least</span></code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a><span class="deltaxml-new" style="background:#90EE90"> ] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="symbolseparators" title="symbol separators"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><a title="whitespace" class="termref" href="#Whitespace"><span class="deltaxml-new" style="background:#90EE90">Whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comments</span></a><span class="deltaxml-new" style="background:#90EE90"> function as </span><b><span class="deltaxml-new" style="background:#90EE90">symbol separators</span></b><span class="deltaxml-new" style="background:#90EE90">. For the most part, they are not mentioned in the grammar, and may occur between any two terminal symbols mentioned in the grammar, except where that is forbidden by the </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">/* ws: explicit */</span></a><span class="deltaxml-new" style="background:#90EE90"> annotation in the EBNF, or by the </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">/* xgc: xml-version */</span></a><span class="deltaxml-new" style="background:#90EE90"> annotation.] </span></p><p><span><span class="deltaxml-new" style="background:#90EE90">As a consequence of the longest token rule (see </span><a href="#lexical-structure"><b><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></b></a><span class="deltaxml-new" style="background:#90EE90">), </span></span><span class="deltaxml-new" style="background:#90EE90"> one or more </span><a title="symbol separators" class="termref" href="#symbolseparators"><span class="deltaxml-new" style="background:#90EE90">symbol separators</span></a><span class="deltaxml-new" style="background:#90EE90"> are required between two consecutive terminal symbols </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90"> (where </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> precedes </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">) when any of the following is true: </span></p><ul><li><p><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90"> are both </span><a title="non-delimiting terminal symbol" class="termref" href="#non-delimiting-token"><span class="deltaxml-new" style="background:#90EE90">non-delimiting terminal symbols</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a QName or an NCName and </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">"."</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">"-"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> is a numeric literal and </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">"."</span></code><span class="deltaxml-new" style="background:#90EE90">, or vice versa.</span></p></li></ul></div><div class="div3"><h4><a id="id-lt-and-gt-characters"></a><span class="deltaxml-new" style="background:#90EE90">A.3.3 Less-Than and Greater-Than Characters</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The operator symbols </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">-&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> have alternative representations using the characters </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+FF1C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">FULL-WIDTH LESS-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">＜</span></code><span class="deltaxml-new" style="background:#90EE90">) and </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+FF1E</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">FULL-WIDTH GREATER-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">＞</span></code><span class="deltaxml-new" style="background:#90EE90">) in place of </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LESS-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">) and </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003E</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">GREATER-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">) . The alternative tokens are respectively </span><code><span class="deltaxml-new" style="background:#90EE90">＜</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">＜=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">＞</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">＞=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">＜＜</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">＞＞</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">=＞</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">=!＞</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">-＞</span></code><span class="deltaxml-new" style="background:#90EE90">. In order to avoid visual confusion these alternatives are not shown explicitly in the grammar.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This option is provided to improve the readability of XPath expressions embedded in XML-based host languages such as XSLT; it enables these operators to be depicted using characters that do not require escaping as XML entities or character references.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">This rule does not apply to the </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> symbols used to delimit node constructor expressions, which (because they mimic XML syntax) must use </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LESS-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90">) and </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003E</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">GREATER-THAN SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">) respectively.</span></p></div></div><div class="div3"><h4><a id="id-eol-handling"></a><span class="deltaxml-new" style="background:#90EE90">A.3.4 End-of-Line Handling</span></h4><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">The host language must specify whether the XQuery 4.0 and XPath 4.0 processor normalizes all line breaks on input, before parsing, and if it does so, whether it uses the rules of </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></div><div class="xpath note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">XML-based host languages such as XSLT and XSD do not normalize line breaks at the XPath level, because it will already have been done by the host XML parser. Use of character or entity references suppresses normalization of line breaks, so the string literal </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#x0D;</span></code><span class="deltaxml-new" style="background:#90EE90"> written within an XSLT-hosted XPath expression represents a string containing a single </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">CARRIAGE RETURN</span></span><span class="deltaxml-new" style="background:#90EE90">) character.</span></p></div><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Prior to parsing, the XQuery 4.0 and XPath 4.0 processor must normalize all line breaks. The rules for line breaking follow the rules of </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. It is implementation-defined which version is used.</span></p></div><div class="div4"><h5><a id="id-xml10-eol-handling"></a><span class="deltaxml-new" style="background:#90EE90">A.3.4.1 XML 1.0 End-of-Line Handling</span></h5><p><span class="deltaxml-new" style="background:#90EE90">For </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> processing, all of the following must be translated to a single </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000A</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEWLINE</span></span><span class="deltaxml-new" style="background:#90EE90">) :</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">the two-character sequence </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">CARRIAGE RETURN</span></span><span class="deltaxml-new" style="background:#90EE90">) , </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000A</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEWLINE</span></span><span class="deltaxml-new" style="background:#90EE90">) ;</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">any </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">CARRIAGE RETURN</span></span><span class="deltaxml-new" style="background:#90EE90">) character that is not immediately followed by </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000A</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEWLINE</span></span><span class="deltaxml-new" style="background:#90EE90">) .</span></p></li></ol></div><div class="div4"><h5><a id="id-xml11-eol-handling"></a><span class="deltaxml-new" style="background:#90EE90">A.3.4.2 XML 1.1 End-of-Line Handling</span></h5><p><span class="deltaxml-new" style="background:#90EE90">For </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> processing, all of the following must be translated to a single </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000A</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEWLINE</span></span><span class="deltaxml-new" style="background:#90EE90">) character:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">the two-character sequence </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">CARRIAGE RETURN</span></span><span class="deltaxml-new" style="background:#90EE90">) , </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000A</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEWLINE</span></span><span class="deltaxml-new" style="background:#90EE90">) ;</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">the two-character sequence </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">CARRIAGE RETURN</span></span><span class="deltaxml-new" style="background:#90EE90">) , </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0085</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEXT LINE, NEL</span></span><span class="deltaxml-new" style="background:#90EE90">) ;</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">the single character </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0085</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEXT LINE, NEL</span></span><span class="deltaxml-new" style="background:#90EE90">) ;</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">the single character </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+2028</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LINE SEPARATOR</span></span><span class="deltaxml-new" style="background:#90EE90">) ;</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">any </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">CARRIAGE RETURN</span></span><span class="deltaxml-new" style="background:#90EE90">) character that is not immediately followed by </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+000A</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEWLINE</span></span><span class="deltaxml-new" style="background:#90EE90">) or </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0085</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEXT LINE, NEL</span></span><span class="deltaxml-new" style="background:#90EE90">) .</span></p></li></ol><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">The characters </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0085</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NEXT LINE, NEL</span></span><span class="deltaxml-new" style="background:#90EE90">) and </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+2028</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LINE SEPARATOR</span></span><span class="deltaxml-new" style="background:#90EE90">) cannot be reliably recognized and translated until the </span><a href="#doc-xpath40-VersionDecl"><span class="deltaxml-new" style="background:#90EE90">VersionDecl</span></a><span class="deltaxml-new" style="background:#90EE90"> declaration (if present) has been read.</span></p></div></div></div><div class="div3"><h4><a id="whitespace-rules"></a><span class="deltaxml-new" style="background:#90EE90">A.3.5 Whitespace Rules</span></h4><div class="div4"><h5><a id="DefaultWhitespaceHandling"></a><span class="deltaxml-new" style="background:#90EE90">A.3.5.1 Default Whitespace Handling</span></h5><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="Whitespace" title="whitespace"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">whitespace</span></b><span class="deltaxml-new" style="background:#90EE90"> character is any of the characters defined by </span><a href="http://www.w3.org/TR/REC-xml/#NT-S"><span class="deltaxml-new" style="background:#90EE90"> [http://www.w3.org/TR/REC-xml/#NT-S]</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="IgnorableWhitespace" title="ignorable whitespace"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: </span><b><span class="deltaxml-new" style="background:#90EE90">Ignorable whitespace</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of any </span><a title="whitespace" class="termref" href="#Whitespace"><span class="deltaxml-new" style="background:#90EE90">whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> characters that may occur between </span><a title="terminal" class="termref" href="#terminal"><span class="deltaxml-new" style="background:#90EE90">terminals</span></a><span class="deltaxml-new" style="background:#90EE90">, unless these characters occur in the context of a production marked with a </span><a href="#ExplicitWhitespaceHandling"><span class="deltaxml-new" style="background:#90EE90"> ws:explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> annotation, in which case they can occur only where explicitly specified (see </span><a href="#ExplicitWhitespaceHandling"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5.2 Explicit Whitespace Handling</span></b></a><span class="deltaxml-new" style="background:#90EE90">).] Ignorable whitespace characters are not significant to the semantics of an expression. Whitespace is allowed before the first terminal and after the last terminal </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">of a module</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">of an XPath expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">. Whitespace is allowed between any two </span><a title="terminal" class="termref" href="#terminal"><span class="deltaxml-new" style="background:#90EE90">terminals</span></a><span class="deltaxml-new" style="background:#90EE90">. </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comments</span></a><span class="deltaxml-new" style="background:#90EE90"> may also act as "whitespace" to prevent two adjacent terminals from being recognized as one. Some illustrative examples are as follows:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">foo- foo</span></code><span class="deltaxml-new" style="background:#90EE90"> results in a syntax error. "foo-" would be recognized as a QName.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">foo -foo</span></code><span class="deltaxml-new" style="background:#90EE90"> is syntactically equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">foo - foo</span></code><span class="deltaxml-new" style="background:#90EE90">, two QNames separated by a subtraction operator.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">foo(: This is a comment :)- foo</span></code><span class="deltaxml-new" style="background:#90EE90"> is syntactically equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">foo - foo</span></code><span class="deltaxml-new" style="background:#90EE90">. This is because the comment prevents the two adjacent terminals from being recognized as one.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">foo-foo</span></code><span class="deltaxml-new" style="background:#90EE90"> is syntactically equivalent to single QName. This is because "-" is a valid character in a QName. When used as an operator after the characters of a name, the "-" must be separated from the name, e.g. by using whitespace or parentheses.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">10div 3</span></code><span class="deltaxml-new" style="background:#90EE90"> results in a syntax error.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">10 div3</span></code><span class="deltaxml-new" style="background:#90EE90"> also results in a syntax error.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">10div3</span></code><span class="deltaxml-new" style="background:#90EE90"> also results in a syntax error.</span></p></li></ul></div><div class="div4"><h5><a id="ExplicitWhitespaceHandling"></a><span class="deltaxml-new" style="background:#90EE90">A.3.5.2 Explicit Whitespace Handling</span></h5><p><span class="deltaxml-new" style="background:#90EE90">Explicit whitespace notation is specified with the EBNF productions, when it is different from the default rules, using the notation shown below. This notation is not inherited. In other words, if an EBNF rule is marked as /* ws: explicit */, the notation does not automatically apply to all the 'child' EBNF productions of that rule.</span></p><dl><dt class="label"><a id="ws-explicit"></a><span class="deltaxml-new" style="background:#90EE90">ws: explicit</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">/* ws: explicit */ means that the EBNF notation explicitly notates, with </span><code><span class="deltaxml-new" style="background:#90EE90">S</span></code><span class="deltaxml-new" style="background:#90EE90"> or otherwise, where </span><a title="whitespace" class="termref" href="#Whitespace"><span class="deltaxml-new" style="background:#90EE90">whitespace characters</span></a><span class="deltaxml-new" style="background:#90EE90"> are allowed. In productions with the /* ws: explicit */ annotation, </span><a href="#DefaultWhitespaceHandling"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5.1 Default Whitespace Handling</span></b></a><span class="deltaxml-new" style="background:#90EE90"> does not apply. Comments are not allowed in these productions except where the </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comment</span></a><span class="deltaxml-new" style="background:#90EE90"> non-terminal appears. </span></p></dd></dl><div class="xquery"><p id="ws-explicit-lex-states" class="xquery"><span class="deltaxml-new" style="background:#90EE90">For example, whitespace is not freely allowed by the direct constructor productions, but is specified explicitly in the grammar, in order to be more consistent with XML.</span></p></div></div></div></div><div class="div2"><h3><a id="id-reserved-fn-names"></a><span class="deltaxml-new" style="background:#90EE90">A.4 Reserved Function Names</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#mapping"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#lexical-structure"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> XQuery and XPath 3.0 included </span><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><span class="deltaxml-new" style="background:#90EE90"> as reserved function names, and XQuery and XPath 3.1 added </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><span class="deltaxml-new" style="background:#90EE90">. This was unnecessary since these names never appear followed by a left parenthesis at the start of an expression. They have therefore been removed from the list. New keywords introducing item types, such as </span><code><span class="deltaxml-new" style="background:#90EE90">record</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">enum</span></code><span class="deltaxml-new" style="background:#90EE90">, have not been included in the list. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1208"><span class="deltaxml-new" style="background:#90EE90">1208</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1212"><span class="deltaxml-new" style="background:#90EE90">1212</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;15 May 2024]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">The following names are not allowed as function names in an unprefixed form, because they can appear, followed by a left parenthesis, at the start of an XPath or XQuery expression that is not a function call.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Names used in </span><a href="#doc-xpath40-KindTest"><span class="deltaxml-new" style="background:#90EE90">KindTests</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><blockquote><p><span class="deltaxml-new" style="background:#90EE90">attribute</span><br><span class="deltaxml-new" style="background:#90EE90">comment</span><br><span class="deltaxml-new" style="background:#90EE90">document-node</span><br><span class="deltaxml-new" style="background:#90EE90">element</span><br><span class="deltaxml-new" style="background:#90EE90">namespace-node</span><br><span class="deltaxml-new" style="background:#90EE90">node</span><br><span class="deltaxml-new" style="background:#90EE90">schema-attribute</span><br><span class="deltaxml-new" style="background:#90EE90">schema-element</span><br><span class="deltaxml-new" style="background:#90EE90">processing-instruction</span><br><span class="deltaxml-new" style="background:#90EE90">text</span></p></blockquote><p><span class="deltaxml-new" style="background:#90EE90">Names used as syntactic keywords:</span></p><blockquote><p><span class="deltaxml-new" style="background:#90EE90">fn</span><br><span class="deltaxml-new" style="background:#90EE90">function</span><br><span class="deltaxml-new" style="background:#90EE90">if</span><br><span class="deltaxml-new" style="background:#90EE90">switch</span><br><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></p></blockquote><div class="xpath note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90"> Although the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> are not used in XPath, they are considered reserved function names for compatibility with XQuery. </span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">As the language evolves in the future, it may become necessary to reserve additional names. Furthermore, use of common programming terms like </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> as function names may cause confusion even though they are not reserved. The easiest way to avoid problems is to use an explicit namespace prefix in all calls to user-defined functions.</span></p></div></div><div class="div2"><h3><a id="id-precedence-order"></a><span class="deltaxml-new" style="background:#90EE90">A.5 Precedence Order (Non-Normative)</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The grammar in </span><a href="#id-grammar"><b><span class="deltaxml-new" style="background:#90EE90">A.1 EBNF</span></b></a><span class="deltaxml-new" style="background:#90EE90"> normatively defines built-in precedence among the operators of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath</span></span></span><span class="deltaxml-new" style="background:#90EE90">. These operators are summarized here to make clear the order of their precedence from lowest to highest. The associativity column indicates the order in which operators of equal precedence in an expression are applied.</span></p><div class="medium"><table class="medium"><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">#</span></th><th><span class="deltaxml-new" style="background:#90EE90">Operator</span></th><th><span class="deltaxml-new" style="background:#90EE90">Associativity</span></th></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">1</span></td><td><a href="#doc-xpath40-Expr"><span class="deltaxml-new" style="background:#90EE90">, (comma)</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">either</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">2</span></td><td><span class="xpath"><span class="xpath"><a href="#doc-xpath40-ForExpr"><span class="deltaxml-new" style="background:#90EE90">for</span></a><span class="deltaxml-new" style="background:#90EE90">,</span></span></span><span class="xpath"><span class="xpath"><a href="#doc-xpath40-LetExpr"><span class="deltaxml-new" style="background:#90EE90">let</span></a><span class="deltaxml-new" style="background:#90EE90">,</span></span></span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-FLWORExpr"><span class="deltaxml-new" style="background:#90EE90">FLWOR</span></a><span class="deltaxml-new" style="background:#90EE90">,</span></span></span><a href="#doc-xpath40-QuantifiedExpr"><span class="deltaxml-new" style="background:#90EE90">some, every</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-SwitchExpr"><span class="deltaxml-new" style="background:#90EE90">switch</span></a><span class="deltaxml-new" style="background:#90EE90">,</span></span></span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-TypeswitchExpr"><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></a><span class="deltaxml-new" style="background:#90EE90">,</span></span></span><span class="xquery"><span class="xquery"><a href="#doc-xpath40-TryCatchExpr"><span class="deltaxml-new" style="background:#90EE90">try</span></a><span class="deltaxml-new" style="background:#90EE90">,</span></span></span><a href="#doc-xpath40-IfExpr"><span class="deltaxml-new" style="background:#90EE90">if</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">3</span></td><td><a href="#doc-xpath40-OrExpr"><span class="deltaxml-new" style="background:#90EE90">or</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">either</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">4</span></td><td><a href="#doc-xpath40-AndExpr"><span class="deltaxml-new" style="background:#90EE90">and</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">either</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">5</span></td><td><a href="#doc-xpath40-ValueComp"><span class="deltaxml-new" style="background:#90EE90">eq, ne, lt, le, gt, ge</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-GeneralComp"><span class="deltaxml-new" style="background:#90EE90">=, !=, &lt;, &lt;=, &gt;, &gt;=</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-NodeComp"><span class="deltaxml-new" style="background:#90EE90">is, &lt;&lt;, &gt;&gt;</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">6</span></td><td><a href="#doc-xpath40-OtherwiseExpr"><span class="deltaxml-new" style="background:#90EE90">otherwise</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">either</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">7</span></td><td><a href="#doc-xpath40-StringConcatExpr"><span class="deltaxml-new" style="background:#90EE90">||</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">8</span></td><td><a href="#doc-xpath40-RangeExpr"><span class="deltaxml-new" style="background:#90EE90">to</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">9</span></td><td><a href="#doc-xpath40-AdditiveExpr"><span class="deltaxml-new" style="background:#90EE90">+, - (binary)</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">10</span></td><td><a href="#doc-xpath40-MultiplicativeExpr"><span class="deltaxml-new" style="background:#90EE90">*, div, idiv, mod</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">11</span></td><td><a href="#doc-xpath40-UnionExpr"><span class="deltaxml-new" style="background:#90EE90">union, |</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">either</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">12</span></td><td><a href="#doc-xpath40-IntersectExceptExpr"><span class="deltaxml-new" style="background:#90EE90">intersect, except</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">13</span></td><td><a href="#doc-xpath40-InstanceofExpr"><span class="deltaxml-new" style="background:#90EE90">instance of</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">14</span></td><td><a href="#doc-xpath40-TreatExpr"><span class="deltaxml-new" style="background:#90EE90">treat as</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">15</span></td><td><a href="#doc-xpath40-CastableExpr"><span class="deltaxml-new" style="background:#90EE90">castable as</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">16</span></td><td><a href="#doc-xpath40-CastExpr"><span class="deltaxml-new" style="background:#90EE90">cast as</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">17</span></td><td><a href="#doc-xpath40-ArrowExpr"><span class="deltaxml-new" style="background:#90EE90">=&gt;, =!&gt;, =?&gt;</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">18</span></td><td><a href="#doc-xpath40-UnaryExpr"><span class="deltaxml-new" style="background:#90EE90">-, + (unary)</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">right-to-left</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">19</span></td><td><a href="#doc-xpath40-SimpleMapExpr"><span class="deltaxml-new" style="background:#90EE90">!</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">20</span></td><td><a href="#doc-xpath40-PathExpr"><span class="deltaxml-new" style="background:#90EE90">/, //</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">21</span></td><td><a href="#doc-xpath40-Predicate"><span class="deltaxml-new" style="background:#90EE90">[ ]</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#doc-xpath40-Lookup"><span class="deltaxml-new" style="background:#90EE90">?, ??</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">left-to-right</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">22</span></td><td><a href="#doc-xpath40-UnaryLookup"><span class="deltaxml-new" style="background:#90EE90">? (unary)</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">NA</span></td></tr></tbody></table></div><p><span class="deltaxml-new" style="background:#90EE90"> In the "Associativity" column, "either" indicates that all the operators at that level have the associative property (i.e., </span><code><span class="deltaxml-new" style="background:#90EE90">(A op B) op C</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">A op (B op C)</span></code><span class="deltaxml-new" style="background:#90EE90">), so their associativity is inconsequential. "NA" (not applicable) indicates that the EBNF does not allow an expression that directly contains multiple operators from that precedence level, so the question of their associativity does not arise. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Parentheses can be used to override the operator precedence in the usual way. Square brackets in an expression such as A[B] serve two roles: they act as an operator causing B to be evaluated once for each item in the value of A, and they act as parentheses enclosing the expression B.</span></p><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">Curly braces in an expression such as validate{E} or ordered{E} perform a similar bracketing role to the parentheses in a function call, but with the difference in most cases that E is an Expr rather than ExprSingle, meaning that it can use the comma operator.</span></p></div></div></div></div><div class="div1"><h2><a id="id-type-promotion-and-operator-mapping"></a><span class="deltaxml-new" style="background:#90EE90">B Type Promotion and Operator Mapping</span></h2><div class="div2"><h3><a id="promotion"></a><span class="deltaxml-new" style="background:#90EE90">B.1 Type Promotion</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-type-promotion" title="type promotion"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: Under certain circumstances, an atomic item can be promoted from one type to another.] </span><b><span class="deltaxml-new" style="background:#90EE90">Type promotion</span></b><span class="deltaxml-new" style="background:#90EE90"> is used in a number of contexts:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">It forms part of the process described by the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, invoked for example when a value of one type is supplied as an argument of a function call where the required type of the corresponding function parameter is declared with a different type.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It forms part of the process described in </span><a href="#mapping"><b><span class="deltaxml-new" style="background:#90EE90">B.2 Operator Mapping</span></b></a><span class="deltaxml-new" style="background:#90EE90">, which selects the implementation of a binary operator based on the types of the supplied operands.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It is invoked (by explicit reference) in a number of other situations, for example when computing an average of a sequence of numeric values (in the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:avg</span></code><span class="deltaxml-new" style="background:#90EE90"> function)</span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">, and in </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses (see </span><a href="#id-order-by-clause"><b><span class="deltaxml-new" style="background:#90EE90">4.13.9 Order By Clause</span></b></a><span class="deltaxml-new" style="background:#90EE90">)</span></span></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">In general, type promotion takes a set of one or more atomic items as input, potentially having different types, and selects a single common type to which all the input values can be converted by casting.</span></p><p><span class="deltaxml-new" style="background:#90EE90">There are three families of atomic types that can be mixed in this way:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Numeric types. This applies when the input contains values of types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> (including types derived from these, such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The rules are:</span></p><ol class="enumla"><li><p><span class="deltaxml-new" style="background:#90EE90">If any of the items is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">, then all the values are cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, if any of the items is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, then all the values are cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, no casting takes place: the values remain as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></li><li><p><span class="deltaxml-new" style="background:#90EE90">String types. This applies when the input contains values of types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> (including types derived from these, such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The rule is that if any of the items is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, then all the values are cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Binary types. This applies when the input contains values of types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90"> (including types derived from these).</span></p><p><span class="deltaxml-new" style="background:#90EE90">The rule is that if any of the items is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90">, then all the values are cast to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></div><div class="div2"><h3><a id="mapping"></a><span class="deltaxml-new" style="background:#90EE90">B.2 Operator Mapping</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#id-xq-static-context-components"><span class="deltaxml-new" style="background:#90EE90">⬇</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span><a href="#id-reserved-fn-names"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90">The operator mapping table has been simplified by removing entries for the operators </span><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><span class="deltaxml-new" style="background:#90EE90">; these are now defined by reference to the rules for the operators </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">The operator mapping tables in this section list the combinations of types for which various operators of XQuery 4.0 and XPath 4.0 are defined. The operators covered by this appendix are the value comparison operators </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><span class="deltaxml-new" style="background:#90EE90">, and the arithmetic operators </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">-</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">idiv</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">mod</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Other operators (such as </span><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">intersect</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">||</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">is</span></code><span class="deltaxml-new" style="background:#90EE90">) are defined directly in the main body of this document, and do not occur in the operator mapping table.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The operators </span><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><span class="deltaxml-new" style="background:#90EE90"> do not occur in the operator mapping table, but are instead defined by the following equivalences:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">A ne B</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">not(A eq B)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">A le B</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">A lt B or A eq B</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">A gt B</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">B lt A</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">A ge B</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">B lt A or B eq A</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-operator-function" title="operator function"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: For each operator and valid combination of operand types, the operator mapping tables specify a result type and an expression that invokes an </span><b><span class="deltaxml-new" style="background:#90EE90">operator function</span></b><span class="deltaxml-new" style="background:#90EE90">; the operator function implements the semantics of the operator for the given types.] The definitions of the operator functions are given in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. The result of an operator may be the raising of an error by its operator function, as defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. The operator function fully defines the semantics of a given operator for the case where the operands are single atomic items of the types given in the table. For the definition of each operator (including its behavior for empty sequences or sequences of length greater than one), see the descriptive material in the main part of this document.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If an operator in the operator mapping tables expects an operand of type </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90">, that operator can be applied to an operand of type </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> if type </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> can be converted to type </span><em><span class="deltaxml-new" style="background:#90EE90">ET</span></em><span class="deltaxml-new" style="background:#90EE90"> by a combination of </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new" style="background:#90EE90">type promotion</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="subtype substitution" class="termref" href="#dt-subtype-substitution"><span class="deltaxml-new" style="background:#90EE90">subtype substitution</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, a table entry indicates that the </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90"> operator may be applied to two </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90"> operands, returning </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">. Therefore, the </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90"> operator may also be applied to two (possibly different) subtypes of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">, also returning </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-numeric" title="numeric"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: When referring to a type, the term </span><b><span class="deltaxml-new" style="background:#90EE90">numeric</span></b><span class="deltaxml-new" style="background:#90EE90"> denotes the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> which are all member types of the built-in union type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90">.] An operator whose operands and result are designated as </span><a title="numeric" class="termref" href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a><span class="deltaxml-new" style="background:#90EE90"> might be thought of as representing four operators, one for each of the numeric types. For example, the numeric </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> operator might be thought of as representing the following four operators:</span></p><div class="medium"><table style="width:80%" class="medium"><tbody><tr><th style="text-align:center"><span class="deltaxml-new" style="background:#90EE90">Operator</span></th><th style="text-align:center"><span class="deltaxml-new" style="background:#90EE90">First operand type</span></th><th style="text-align:center"><span class="deltaxml-new" style="background:#90EE90">Second operand type</span></th><th style="text-align:center"><span class="deltaxml-new" style="background:#90EE90">Result type</span></th></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">+</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">+</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">+</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code></td></tr><tr><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">+</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code></td><td style="text-align:center"><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code></td></tr></tbody></table></div><p><span class="deltaxml-new" style="background:#90EE90">A numeric operator may be validly applied to an operand of type </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> if type </span><em><span class="deltaxml-new" style="background:#90EE90">AT</span></em><span class="deltaxml-new" style="background:#90EE90"> can be converted to any of the four numeric types by a combination of </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new" style="background:#90EE90">type promotion</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="subtype substitution" class="termref" href="#dt-subtype-substitution"><span class="deltaxml-new" style="background:#90EE90">subtype substitution</span></a><span class="deltaxml-new" style="background:#90EE90">. If the result type of an operator is listed as numeric, it means "the first type in the ordered list </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:integer, xs:decimal, xs:float, xs:double)</span></code><span class="deltaxml-new" style="background:#90EE90"> into which all operands can be converted by </span><a title="subtype substitution" class="termref" href="#dt-subtype-substitution"><span class="deltaxml-new" style="background:#90EE90">subtype substitution</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="type promotion" class="termref" href="#dt-type-promotion"><span class="deltaxml-new" style="background:#90EE90">type promotion</span></a><span class="deltaxml-new" style="background:#90EE90">." As an example, suppose that the type </span><code><span class="deltaxml-new" style="background:#90EE90">hatsize</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and the type </span><code><span class="deltaxml-new" style="background:#90EE90">shoesize</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">. Then if the </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> operator is invoked with operands of type </span><code><span class="deltaxml-new" style="background:#90EE90">hatsize</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">shoesize</span></code><span class="deltaxml-new" style="background:#90EE90">, it returns a result of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">. Similarly, if </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> is invoked with two operands of type </span><code><span class="deltaxml-new" style="background:#90EE90">hatsize</span></code><span class="deltaxml-new" style="background:#90EE90"> it returns a result of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-gregorian" title="Gregorian"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In the operator mapping tables, the term </span><b><span class="deltaxml-new" style="background:#90EE90">Gregorian</span></b><span class="deltaxml-new" style="background:#90EE90"> refers to the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gYearMonth</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gYear</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gMonthDay</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gDay</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gMonth</span></code><span class="deltaxml-new" style="background:#90EE90">.] For binary operators that accept two Gregorian-type operands, both operands must have the same type (for example, if one operand is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gDay</span></code><span class="deltaxml-new" style="background:#90EE90">, the other operand must be of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gDay</span></code><span class="deltaxml-new" style="background:#90EE90">.)</span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-binary" title="binary"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: In the operator mapping tables, the term </span><b><span class="deltaxml-new" style="background:#90EE90">binary</span></b><span class="deltaxml-new" style="background:#90EE90"> refers to the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90">.] For operators that accept two binary operands, both operands are promoted to type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="small"><table style="border:1px solid" class="small"><caption><span class="deltaxml-new" style="background:#90EE90">Binary Operators</span></caption><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">Operator</span></th><th><span class="deltaxml-new" style="background:#90EE90">Type(A)</span></th><th><span class="deltaxml-new" style="background:#90EE90">Type(B)</span></th><th><span class="deltaxml-new" style="background:#90EE90">Function</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result type</span></th></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-add(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-yearMonthDuration-to-date(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-yearMonthDuration-to-date(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-dayTimeDuration-to-date(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-dayTimeDuration-to-date(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-dayTimeDuration-to-time(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-dayTimeDuration-to-time(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-yearMonthDuration-to-dateTime(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-yearMonthDuration-to-dateTime(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-dayTimeDuration-to-dateTime(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-dayTimeDuration-to-dateTime(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-yearMonthDurations(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A + B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:add-dayTimeDurations(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-subtract(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-dates(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-yearMonthDuration-from-date(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-dayTimeDuration-from-date(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-times(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-dayTimeDuration-from-time(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-dateTimes(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-yearMonthDuration-from-dateTime(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-dayTimeDuration-from-dateTime(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-yearMonthDurations(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A - B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:subtract-dayTimeDurations(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A * B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-multiply(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A * B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-yearMonthDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A * B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-yearMonthDuration(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A * B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-dayTimeDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A * B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-dayTimeDuration(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A × B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-multiply(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A × B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-yearMonthDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A × B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-yearMonthDuration(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A × B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-dayTimeDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A × B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:multiply-dayTimeDuration(B, A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A idiv B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-integer-divide(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A div B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-divide(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric; but xs:decimal if both operands are xs:integer</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A div B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-yearMonthDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A div B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-dayTimeDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A div B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A div B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A ÷ B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-divide(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric; but xs:decimal if both operands are xs:integer</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A ÷ B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-yearMonthDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A ÷ B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-dayTimeDuration(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A ÷ B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A ÷ B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A mod B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-mod(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:boolean-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:string</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:string</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-equal(fn:compare(A, B), 0)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:date-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:time-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:dateTime-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:duration-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">Gregorian</span></td><td><span class="deltaxml-new" style="background:#90EE90">Gregorian</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:gYear-equal(A, B) etc.</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">binary</span></td><td><span class="deltaxml-new" style="background:#90EE90">binary</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:binary-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:QName-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A eq B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:NOTATION-equal(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:boolean-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:string</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:string</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-less-than(fn:compare(A, B), 0)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:date</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:date-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:time</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:time-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:dateTime-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:yearMonthDuration-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:dayTimeDuration-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">A lt B</span></td><td><span class="deltaxml-new" style="background:#90EE90">binary</span></td><td><span class="deltaxml-new" style="background:#90EE90">binary</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:binary-less-than(A, B)</span></td><td><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></td></tr></tbody></table></div><div class="small"><table style="border:1px solid" class="small"><caption><span class="deltaxml-new" style="background:#90EE90">Unary Operators</span></caption><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Operator</span></th><th><span class="deltaxml-new" style="background:#90EE90">Operand type</span></th><th><span class="deltaxml-new" style="background:#90EE90">Function</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result type</span></th></tr></thead><tbody><tr><td><span class="deltaxml-new" style="background:#90EE90">+ A</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-unary-plus(A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">- A</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td><td><span class="deltaxml-new" style="background:#90EE90">op:numeric-unary-minus(A)</span></td><td><span class="deltaxml-new" style="background:#90EE90">numeric</span></td></tr></tbody></table></div></div></div><div class="xquery"><div class="div1 xquery"><h2><a id="id-xq-context-components"></a><span class="deltaxml-new" style="background:#90EE90">C Context Components</span></h2><p><span class="deltaxml-new" style="background:#90EE90">The tables in this section describe how values are assigned to the various components of the static context and dynamic context, and to the parameters that control the serialization process.</span></p><div class="div2"><h3><a id="id-xq-static-context-components"></a><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></h3><div class="changes"><p class="changesHeading"><span class="deltaxml-new" style="background:#90EE90">Changes in 4.0&nbsp;</span><a href="#mapping"><span class="deltaxml-new" style="background:#90EE90">⬆</span></a></p><ol><li><p><span class="deltaxml-new" style="background:#90EE90"> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1343"><span class="deltaxml-new" style="background:#90EE90">1343</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;]</span></i></p></li></ol></div><p><span class="deltaxml-new" style="background:#90EE90">The following table describes the components of the </span><b><span class="deltaxml-new" style="background:#90EE90">static context</span></b><span class="deltaxml-new" style="background:#90EE90">. The following aspects of each component are described:</span></p><ul><li><p><em><span class="deltaxml-new" style="background:#90EE90">Default initial value:</span></em><span class="deltaxml-new" style="background:#90EE90"> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by implementation:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different, </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> value and/or to augment the default initial value by additional </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> values.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by prolog:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates whether there are prolog declarations that can replace and/or augment the initial value provided by default or by the implementation. </span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by expressions:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates whether there are expressions that can replace and/or augment the value of the component for their subexpressions. </span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Consistency Rules:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in </span><a href="#id-consistency-constraints"><b><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="small"><table style="width:100%; border:1px solid" class="small"><caption><span class="deltaxml-new" style="background:#90EE90">Static Context Components</span></caption><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">Component</span></th><th><span class="deltaxml-new" style="background:#90EE90">Default initial value</span></th><th><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by implementation?</span></th><th><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by prolog?</span></th><th><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by expressions?</span></th><th><span class="deltaxml-new" style="background:#90EE90">Consistency rules</span></th></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known namespaces</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xsi</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">local</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable (except for </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable by </span><a href="#id-namespace-declaration"><b><span class="deltaxml-new" style="background:#90EE90">5.13 Namespace Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable by element constructor</span></td><td><span class="deltaxml-new" style="background:#90EE90">Only one namespace can be assigned to a given prefix per lexical scope.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default element/type namespace</span></td><td><span class="deltaxml-new" style="background:#90EE90">no namespace</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-default-namespace"><b><span class="deltaxml-new" style="background:#90EE90">5.14 Default Namespace Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by element constructor</span></td><td><span class="deltaxml-new" style="background:#90EE90">Only one default namespace per lexical scope.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope variables</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable by </span><a href="#id-variable-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.16 Variable Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-inline-func"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.5 Inline Function Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">, augmentable by </span><a href="#id-module-import"><b><span class="deltaxml-new" style="background:#90EE90">5.12 Module Import</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable by variable-binding expressions</span></td><td><span class="deltaxml-new" style="background:#90EE90">Only one definition per variable per lexical scope.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context value static type</span></td><td><span class="deltaxml-new" style="background:#90EE90">item()</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-context-value-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.17 Context Value Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by expressions that set the context value</span></td><td><span class="deltaxml-new" style="background:#90EE90">None.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Ordering mode</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">ordered</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-default-ordering-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.7 Ordering Mode Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by expression</span></td><td><span class="deltaxml-new" style="background:#90EE90">Value must be </span><code><span class="deltaxml-new" style="background:#90EE90">ordered</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">unordered</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default function namespace</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable (not recommended)</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-default-namespace"><b><span class="deltaxml-new" style="background:#90EE90">5.14 Default Namespace Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope schema types</span></td><td><span class="deltaxml-new" style="background:#90EE90">built-in types in </span><code><span class="deltaxml-new" style="background:#90EE90">xs</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable by </span><a href="#id-schema-import"><b><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Only one definition per global or local type.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope element declarations</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable by </span><a href="#id-schema-import"><b><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Only one definition per global or local element name.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope attribute declarations</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable by </span><a href="#id-schema-import"><b><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Only one definition per global or local attribute name.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known function signatures</span></td><td><span class="deltaxml-new" style="background:#90EE90">the signatures of the </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system functions</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable by </span><a href="#id-module-import"><b><span class="deltaxml-new" style="background:#90EE90">5.12 Module Import</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and by </span><a href="#FunctionDeclns"><b><span class="deltaxml-new" style="background:#90EE90">5.18 Function Declarations</span></b></a><span class="deltaxml-new" style="background:#90EE90">; augmentable by </span><a href="#id-schema-import"><b><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></b></a><span class="deltaxml-new" style="background:#90EE90"> (which adds constructor functions for user-defined types)</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Each function must have a unique </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> and number of arguments.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default collation</span></td><td><span class="deltaxml-new" style="background:#90EE90">Unicode codepoint collation</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-default-collation-declaration"><b><span class="deltaxml-new" style="background:#90EE90">5.4 Default Collation Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Construction mode</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-construction-declaration"><b><span class="deltaxml-new" style="background:#90EE90">5.6 Construction Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Value must be </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default order for empty sequences</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-empty-order-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.8 Empty Order Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Value must be </span><code><span class="deltaxml-new" style="background:#90EE90">greatest</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">least</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Boundary-space policy</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-boundary-space-decls"><b><span class="deltaxml-new" style="background:#90EE90">5.3 Boundary-space Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Value must be </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Copy-namespaces mode</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">inherit, preserve</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-copy-namespaces-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.9 Copy-Namespaces Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Value consists of </span><code><span class="deltaxml-new" style="background:#90EE90">inherit</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">no-inherit</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></td><td><span class="deltaxml-new" style="background:#90EE90">See rules in </span><a href="#id-base-uri-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.5 Base URI Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by </span><a href="#id-base-uri-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.5 Base URI Declaration</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Value must be a valid lexical representation of the type xs:anyURI.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known decimal formats</span></td><td><span class="deltaxml-new" style="background:#90EE90">the default (unnamed) decimal format, which has an implementation-dependent value</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable, using </span><a title="decimal-format         declaration" class="termref" href="#dt-decimal-format-decl"><span class="deltaxml-new" style="background:#90EE90">decimal format declarations</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">each QName uniquely identifies a decimal format</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known collations</span></td><td><span class="deltaxml-new" style="background:#90EE90">only the default collation</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Each URI uniquely identifies a collation.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 Compatibility Mode</span></td><td><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Must be </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><th colspan="6"><span class="deltaxml-new" style="background:#90EE90">Serialization Parameters</span></th></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">allow-duplicate-names</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">byte-order-mark</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">cdata-section-elements</span></td><td><span class="deltaxml-new" style="background:#90EE90">empty</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">doctype-public</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">doctype-system</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">encoding</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined choice between </span><code><span class="deltaxml-new" style="background:#90EE90">"utf-8"</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">"utf-16"</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">escape-solidus</span></td><td><span class="deltaxml-new" style="background:#90EE90">yes</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">yes</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">escape-uri-attributes</span></td><td><span class="deltaxml-new" style="background:#90EE90">yes</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">html-version</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">include-content-type</span></td><td><span class="deltaxml-new" style="background:#90EE90">yes</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">indent</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">item-separator</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">json-node-output-method</span></td><td><span class="deltaxml-new" style="background:#90EE90">xml</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">media-type</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">method</span></td><td><span class="deltaxml-new" style="background:#90EE90">xml</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">normalization-form</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">omit-xml-declaration</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">standalone</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">suppress-indentation</span></td><td><span class="deltaxml-new" style="background:#90EE90">empty</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">undeclare-prefixes</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">use-character-maps</span></td><td><span class="deltaxml-new" style="background:#90EE90">empty</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">version</span></td><td><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by prolog</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#serparam"><span class="deltaxml-new" style="background:#90EE90">Section 3 Serialization Parameters </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">SER31</span></small></sup></td></tr></tbody></table></div></div><div class="div2"><h3><a id="id-xq-evaluation-context-components"></a><span class="deltaxml-new" style="background:#90EE90">C.2 Dynamic Context Components</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The following table describes the components of the </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></b><span class="deltaxml-new" style="background:#90EE90">. The following aspects of each component are described:</span></p><ul><li><p><em><span class="deltaxml-new" style="background:#90EE90">Default initial value:</span></em><span class="deltaxml-new" style="background:#90EE90"> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by implementation:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> value and/or to augment the default initial value by additional </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> values.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by prolog:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates whether there are prolog declarations that can replace and/or augment the initial value provided by default or by the implementation.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by expressions:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates whether there are expressions that can replace and/or augment the value of the component for their subexpressions.</span></p></li><li><p><em><span class="deltaxml-new" style="background:#90EE90">Consistency Rules:</span></em><span class="deltaxml-new" style="background:#90EE90"> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in </span><a href="#id-consistency-constraints"><b><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><div class="small"><table style="width:100%; border:1px solid" class="small"><caption><span class="deltaxml-new" style="background:#90EE90">Dynamic Context Components</span></caption><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">Component</span></th><th><span class="deltaxml-new" style="background:#90EE90">Default initial value</span></th><th><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by implementation?</span></th><th><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by prolog?</span></th><th><span class="deltaxml-new" style="background:#90EE90">Can be overwritten or augmented by expressions?</span></th><th><span class="deltaxml-new" style="background:#90EE90">Consistency rules</span></th></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context value</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by a </span><a href="#id-context-value-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.17 Context Value Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90"> in the main module </span></td><td><span class="deltaxml-new" style="background:#90EE90">overwritten during evaluation of path expressions and predicates</span></td><td><span class="deltaxml-new" style="background:#90EE90">Must be the same in the dynamic context of every module in a query. </span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context position</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by a </span><a href="#id-context-value-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.17 Context Value Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90"> in the main module </span></td><td><span class="deltaxml-new" style="background:#90EE90">overwritten during evaluation of path expressions and predicates</span></td><td><span class="deltaxml-new" style="background:#90EE90">If context value is defined, context position must be &gt;0 and &lt;= context size; else context position is </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM31</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context size</span></td><td><span class="deltaxml-new" style="background:#90EE90">none </span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable by a </span><a href="#id-context-value-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.17 Context Value Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90"> in the main module </span></td><td><span class="deltaxml-new" style="background:#90EE90">overwritten during evaluation of path expressions and predicates</span></td><td><span class="deltaxml-new" style="background:#90EE90">If context value is defined, context size must be &gt;0; else context size is </span><a href="https://www.w3.org/TR/xpath-datamodel-31/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM31</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Variable values</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable by </span><a href="#id-variable-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.16 Variable Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#id-inline-func"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.5 Inline Function Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">, augmentable by </span><a href="#id-module-import"><b><span class="deltaxml-new" style="background:#90EE90">5.12 Module Import</span></b></a></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable and augmentable by variable-binding expressions</span></td><td><span class="deltaxml-new" style="background:#90EE90">Names and values must be consistent with in-scope variables.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Named functions</span></td><td><span class="deltaxml-new" style="background:#90EE90">the </span><a title="system function" class="termref" href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system functions</span></a></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable</span></td><td><span class="deltaxml-new" style="background:#90EE90">augmentable by </span><a href="#FunctionDeclns"><b><span class="deltaxml-new" style="background:#90EE90">5.18 Function Declarations</span></b></a><span class="deltaxml-new" style="background:#90EE90">, </span><a href="#id-module-import"><b><span class="deltaxml-new" style="background:#90EE90">5.12 Module Import</span></b></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a href="#id-schema-import"><b><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></b></a><span class="deltaxml-new" style="background:#90EE90"> ( (which adds constructor functions for user-defined types)</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Must be consistent with statically known function signatures</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Current dateTime</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Must include a timezone. Remains constant during evaluation of a query.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Implicit timezone</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">Remains constant during evaluation of a query.</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Available documents</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Available text resources</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Available collections</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default collection</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Available URI collections</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default URI collection</span></td><td><span class="deltaxml-new" style="background:#90EE90">none</span></td><td><span class="deltaxml-new" style="background:#90EE90">overwriteable</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">no</span></td><td><span class="deltaxml-new" style="background:#90EE90">None</span></td></tr></tbody></table></div></div></div></div><div class="xpath"><div class="div1 xpath"><h2><a id="id-xp-context-components"></a><span class="deltaxml-new" style="background:#90EE90">D Context Components</span></h2><p><span class="deltaxml-new" style="background:#90EE90">The tables in this section describe the scope (range of applicability) of the various components in a module's static context and dynamic context.</span></p><div class="div2"><h3><a id="id-xp-static-context-components"></a><span class="deltaxml-new" style="background:#90EE90">D.1 Static Context Components</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The following table describes the components of the </span><b><span class="deltaxml-new" style="background:#90EE90">static context</span></b><span class="deltaxml-new" style="background:#90EE90">. For each component, “global” indicates that the value of the component applies throughout an XPath expression, whereas “lexical” indicates that the value of the component applies only within the subexpression in which it is defined.</span></p><div class="small"><table style="width:60%; border:1px solid" class="small"><caption><span class="deltaxml-new" style="background:#90EE90">Static Context Components</span></caption><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">Component</span></th><th><span class="deltaxml-new" style="background:#90EE90">Scope</span></th></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 Compatibility Mode</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known namespaces</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default element/type namespace</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default function namespace</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope schema types</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope element declarations</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope attribute declarations</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">In-scope variables</span></td><td><span class="deltaxml-new" style="background:#90EE90">lexical; for-expressions, let-expressions, and quantified expressions can bind new variables</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context value static type</span></td><td><span class="deltaxml-new" style="background:#90EE90">lexical</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known function signatures</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known collations</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default collation</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Base URI</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known documents</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known collections</span></td><td><span class="deltaxml-new" style="background:#90EE90">global </span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Statically known default collection type</span></td><td><span class="deltaxml-new" style="background:#90EE90">global</span></td></tr></tbody></table></div></div><div class="div2"><h3><a id="id-xp-evaluation-context-components"></a><span class="deltaxml-new" style="background:#90EE90">D.2 Dynamic Context Components</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The following table describes how values are assigned to the various components of the </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></b><span class="deltaxml-new" style="background:#90EE90">. All these components are initialized by mechanisms defined by the host language. For each component, “global” indicates that the value of the component remains constant throughout evaluation of the XPath expression, whereas “dynamic” indicates that the value of the component can be modified by the evaluation of subexpressions.</span></p><div class="small"><table style="width:60%; border:1px solid" class="small"><caption><span class="deltaxml-new" style="background:#90EE90">Dynamic Context Components</span></caption><tbody><tr><th><span class="deltaxml-new" style="background:#90EE90">Component</span></th><th><span class="deltaxml-new" style="background:#90EE90">Scope</span></th></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context value</span></td><td><span class="deltaxml-new" style="background:#90EE90">dynamic; changes during evaluation of path expressions and predicates</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context position</span></td><td><span class="deltaxml-new" style="background:#90EE90">dynamic; changes during evaluation of path expressions and predicates</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Context size</span></td><td><span class="deltaxml-new" style="background:#90EE90">dynamic; changes during evaluation of path expressions and predicates</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Variable values</span></td><td><span class="deltaxml-new" style="background:#90EE90">dynamic; for-expressions, let-expressions, and quantified expressions can bind new variables</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Current date and time</span></td><td><span class="deltaxml-new" style="background:#90EE90">global; must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Implicit timezone</span></td><td><span class="deltaxml-new" style="background:#90EE90">global; must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Available documents</span></td><td><span class="deltaxml-new" style="background:#90EE90">global; must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Available node collections</span></td><td><span class="deltaxml-new" style="background:#90EE90">global; must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default collection</span></td><td><span class="deltaxml-new" style="background:#90EE90">global; overwriteable by implementation</span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Available URI collections</span></td><td><span class="deltaxml-new" style="background:#90EE90">global; must be initialized </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">by implementation</span></span></span></td></tr><tr><td><span class="deltaxml-new" style="background:#90EE90">Default URI collection</span></td><td><span class="deltaxml-new" style="background:#90EE90">global; overwriteable by implementation</span></td></tr></tbody></table></div></div></div></div><div class="div1"><h2><a id="id-impl-defined-items"></a><span class="deltaxml-new" style="background:#90EE90">E Implementation-Defined Items</span></h2><p><span class="deltaxml-new" style="background:#90EE90">The following items in this specification are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">The version of Unicode that is used to construct expressions.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically-known collations</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The </span><a title="implicit timezone" class="termref" href="#dt-timezone"><span class="deltaxml-new" style="background:#90EE90">implicit timezone</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The circumstances in which </span><a title="warning" class="termref" href="#dt-warning"><span class="deltaxml-new" style="background:#90EE90">warnings</span></a><span class="deltaxml-new" style="background:#90EE90"> are raised, and the ways in which warnings are handled.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The method by which errors are reported to the external processing environment.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Which version of XML and XML Names (e.g. </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES"><span class="deltaxml-new" style="background:#90EE90">[XML Names]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XML1.1"><span class="deltaxml-new" style="background:#90EE90">[XML 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">) and which version of XML Schema (e.g. </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">) is used for the definitions of primitives such as characters and names, and for the definitions of operations such as normalization of line endings and normalization of whitespace in attribute values. It is recommended that the latest applicable version be used (even if it is published later than this specification).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">How XDM instances are created from sources other than an Infoset or PSVI.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Any components of the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> that are overwritten or augmented by the implementation.</span></p></li><li class="xpath"><p><span class="deltaxml-new" style="background:#90EE90">Whether the implementation supports the namespace axis.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The default handling of empty sequences returned by an ordering key (orderspec) in an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause (</span><code><span class="deltaxml-new" style="background:#90EE90">empty least</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">empty greatest</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The names and semantics of any </span><a title="extension expression" class="termref" href="#dt-extension-expression"><span class="deltaxml-new" style="background:#90EE90">extension expressions</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><a title="pragma" class="termref" href="#dt-pragma"><span class="deltaxml-new" style="background:#90EE90">pragmas</span></a><span class="deltaxml-new" style="background:#90EE90">) recognized by the implementation.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The names and semantics of any </span><a title="option declaration" class="termref" href="#dt-option-declaration"><span class="deltaxml-new" style="background:#90EE90">option declarations</span></a><span class="deltaxml-new" style="background:#90EE90"> recognized by the implementation.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Protocols (if any) by which parameters can be passed to an external function, and the result of the function can returned to the invoking query.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The process by which the specific modules to be imported by a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90"> are identified, if the </span><a title="module feature" class="termref" href="#dt-module-feature"><span class="deltaxml-new" style="background:#90EE90">Module Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported (includes processing of location hints, if any.)</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The means by which serialization is invoked, if the </span><a title="serialization feature" class="termref" href="#dt-serialization-feature"><span class="deltaxml-new" style="background:#90EE90">Serialization Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The default values for the </span><code><span class="deltaxml-new" style="background:#90EE90">byte-order-mark</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">encoding</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">html-version</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">item-separator</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">media-type</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">normalization-form</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">omit-xml-declaration</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">standalone</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">version</span></code><span class="deltaxml-new" style="background:#90EE90"> parameters, if the </span><a title="serialization feature" class="termref" href="#dt-serialization-feature"><span class="deltaxml-new" style="background:#90EE90">Serialization Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The result of an unsuccessful call to an external function (for example, if the function implementation cannot be found or does not return a value of the declared type).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Limits on ranges of values for various data types, as enumerated in </span><a href="#id-data-model-conformance"><b><span class="deltaxml-new" style="background:#90EE90">6.3 Data Model Conformance</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Syntactic extensions to XQuery, including both their syntax and semantics, as discussed in </span><a href="#id-syntax-extensions"><b><span class="deltaxml-new" style="background:#90EE90">6.4 Syntax Extensions</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Whether the type system is based on </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">. An implementation that has based its type system on XML Schema 1.0 is not required to support the use of the </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dateTimeStamp</span></code><span class="deltaxml-new" style="background:#90EE90"> constructor or the use of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dateTimeStamp</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> as </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> in any expression.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The signatures of functions provided by the implementation or via an implementation-defined API (see </span><a href="#static_context"><b><span class="deltaxml-new" style="background:#90EE90">2.2.1 Static Context</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Any </span><a title="environment variables" class="termref" href="#dt-environment-variables"><span class="deltaxml-new" style="background:#90EE90">environment variables</span></a><span class="deltaxml-new" style="background:#90EE90"> provided by the implementation.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Any rules used for static typing (see </span><a href="#id-static-analysis"><b><span class="deltaxml-new" style="background:#90EE90">2.3.3.1 Static Analysis Phase</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Any serialization parameters provided by the implementation</span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> (see </span><a href="#id-serialization"><b><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></span></span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The means by which the location hint for a serialization parameter document identifies the corresponding XDM instance (see </span><a href="#id-serialization"><b><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">What error, if any, is returned if an external function's implementation does not return the declared result type (see </span><a href="#id-consistency-constraints"><b><span class="deltaxml-new" style="background:#90EE90">2.3.6 Consistency Constraints</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Any annotations defined by the implementation, and their associated behavior (see </span><a href="#id-annotations"><b><span class="deltaxml-new" style="background:#90EE90">5.15 Annotations</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Any </span><a title="function assertion" class="termref" href="#dt-function-assertion"><span class="deltaxml-new" style="background:#90EE90">function assertions</span></a><span class="deltaxml-new" style="background:#90EE90"> defined by the implementation.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The effect of function assertions understood by the implementation on </span><a href="#id-assertions-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.3 The judgement subtype-assertions(AnnotationsA, AnnotationsB) </span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Any implementation-defined variables defined by the implementation. (see </span><a href="#id-variables"><b><span class="deltaxml-new" style="background:#90EE90">4.2.2 Variable References</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The ordering associated with </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unordered</span></code><span class="deltaxml-new" style="background:#90EE90"> in the implementation (see </span><a href="#id-unordered-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.15 Ordered and Unordered Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">Any additional information provided for try/catch via the </span><code><span class="deltaxml-new" style="background:#90EE90">err:additional</span></code><span class="deltaxml-new" style="background:#90EE90"> variable (see </span><a href="#id-try-catch"><b><span class="deltaxml-new" style="background:#90EE90">4.20 Try/Catch Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The default boundary-space policy (see </span><a href="#id-boundary-space-decls"><b><span class="deltaxml-new" style="background:#90EE90">5.3 Boundary-space Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The default collation (see </span><a href="#id-default-collation-declaration"><b><span class="deltaxml-new" style="background:#90EE90">5.4 Default Collation Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li><li class="xquery"><p><span class="deltaxml-new" style="background:#90EE90">The default base URI (see </span><a href="#id-base-uri-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.5 Base URI Declaration</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Additional </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> items are listed in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div></div><div class="div1"><h2><a id="id-references"></a><span class="deltaxml-new" style="background:#90EE90">F References</span></h2><div class="div2"><h3><a id="id-normative-references"></a><span class="deltaxml-new" style="background:#90EE90">F.1 Normative References</span></h3><dl><dt class="label"><span><a id="ISO10646"></a><span class="deltaxml-new" style="background:#90EE90">ISO/IEC 10646</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">ISO (International Organization for Standardization). </span><em><span class="deltaxml-new" style="background:#90EE90">ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character Set (UCS)</span></em><span class="deltaxml-new" style="background:#90EE90">, as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts. [Geneva]: International Organization for Standardization. (See </span><a href="http://www.iso.org"><span class="deltaxml-new" style="background:#90EE90">http://www.iso.org</span></a><span class="deltaxml-new" style="background:#90EE90"> for the latest version.)</span></div></dd><dt class="label"><span><a id="RFC2119"></a><span class="deltaxml-new" style="background:#90EE90">RFC2119</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">S. Bradner. </span><em><span class="deltaxml-new" style="background:#90EE90">Key Words for use in RFCs to Indicate Requirement Levels.</span></em><span class="deltaxml-new" style="background:#90EE90"> IETF RFC 2119. See </span><a href="http://www.ietf.org/rfc/rfc2119.txt"><span class="deltaxml-new" style="background:#90EE90">http://www.ietf.org/rfc/rfc2119.txt</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="label"><span><a id="RFC3986"></a><span class="deltaxml-new" style="background:#90EE90">RFC3986</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">T. Berners-Lee, R. Fielding, and L. Masinter. </span><em><span class="deltaxml-new" style="background:#90EE90">Uniform Resource Identifiers (URI): Generic Syntax</span></em><span class="deltaxml-new" style="background:#90EE90">. IETF RFC 3986. See </span><a href="http://www.ietf.org/rfc/rfc3986.txt"><span class="deltaxml-new" style="background:#90EE90">http://www.ietf.org/rfc/rfc3986.txt</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="label"><span><a id="RFC3987"></a><span class="deltaxml-new" style="background:#90EE90">RFC3987</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">M. Duerst and M. Suignard. </span><em><span class="deltaxml-new" style="background:#90EE90">Internationalized Resource Identifiers (IRIs)</span></em><span class="deltaxml-new" style="background:#90EE90">. IETF RFC 3987. See </span><a href="http://www.ietf.org/rfc/rfc3987.txt"><span class="deltaxml-new" style="background:#90EE90">http://www.ietf.org/rfc/rfc3987.txt</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="label"><span><a id="Unicode"></a><span class="deltaxml-new" style="background:#90EE90">Unicode</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">The Unicode Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">The Unicode Standard.</span></em><span class="deltaxml-new" style="background:#90EE90"> Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. See </span><a href="http://www.unicode.org/standard/versions/"><span class="deltaxml-new" style="background:#90EE90">http://www.unicode.org/standard/versions/</span></a><span class="deltaxml-new" style="background:#90EE90"> for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">, but implementations are recommended to use the latest Unicode version.</span></div></dd><dt class="label"><span><a id="XML"></a><span class="deltaxml-new" style="background:#90EE90">XML 1.0</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">Extensible Markup Language (XML) 1.0.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation. See </span><a href="http://www.w3.org/TR/REC-xml/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/REC-xml/</span></a><span class="deltaxml-new" style="background:#90EE90">. The edition of XML 1.0 must be no earlier than the Third Edition; the edition used is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">, but we recommend that implementations use the latest version. </span></div></dd><dt class="label"><span><a id="XML1.1"></a><span class="deltaxml-new" style="background:#90EE90">XML 1.1</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">Extensible Markup Language (XML) 1.1.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation. See </span><a href="http://www.w3.org/TR/xml11/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xml11/</span></a></div></dd><dt class="label"><span><a id="XMLBASE"></a><span class="deltaxml-new" style="background:#90EE90">XML Base</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">XML Base.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation. See </span><a href="http://www.w3.org/TR/xmlbase/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xmlbase/</span></a></div></dd><dt class="label"><span><a id="XMLID"></a><span class="deltaxml-new" style="background:#90EE90">XML ID</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">xml:id Version 1.0.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation. See </span><a href="http://www.w3.org/TR/xml-id/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xml-id/</span></a></div></dd><dt class="label"><span><a id="XMLNAMES"></a><span class="deltaxml-new" style="background:#90EE90">XML Names</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">Namespaces in XML.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation. See </span><a href="http://www.w3.org/TR/REC-xml-names/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/REC-xml-names/</span></a></div></dd><dt class="label"><span><a id="XMLNAMES11"></a><span class="deltaxml-new" style="background:#90EE90">XML Names 1.1</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">Namespaces in XML 1.1.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation. See </span><a href="http://www.w3.org/TR/xml-names11/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xml-names11/</span></a></div></dd><dt class="label"><span><a id="XMLSchema10"></a><span class="deltaxml-new" style="background:#90EE90">XML Schema 1.0</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">XML Schema, Parts 0, 1, and 2 (Second Edition)</span></em><span class="deltaxml-new" style="background:#90EE90">. W3C Recommendation, 28 October 2004. See </span><a href="http://www.w3.org/TR/xmlschema-0/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xmlschema-0/</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a id="schema1" href="http://www.w3.org/TR/xmlschema-1/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xmlschema-1/</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a id="schema2" href="http://www.w3.org/TR/xmlschema-2/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xmlschema-2/</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="label"><span><a id="XMLSchema11"></a><span class="deltaxml-new" style="background:#90EE90">XML Schema 1.1</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">XML Schema, Parts 1, and 2</span></em><span class="deltaxml-new" style="background:#90EE90">. W3C Recommendation 5 April 2012. See </span><a id="schema1-11" href="http://www.w3.org/TR/xmlschema11-1/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xmlschema11-1/</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a id="schema2-11" href="http://www.w3.org/TR/xmlschema11-2/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xmlschema11-2/</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="label"><span><a id="xpath-40"></a><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html"><cite><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) 4.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div></dd><dt class="label"><span><a id="xpath-datamodel-40"></a><span class="deltaxml-new" style="background:#90EE90">XQuery and XPath Data Model (XDM) 4.0</span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xpath-datamodel-40/Overview.html"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery and XPath Data Model (XDM) 4.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div></dd><dt class="label"><span><a id="xpath-functions-40"></a><span class="deltaxml-new" style="background:#90EE90">XQuery and XPath Functions and Operators 4.0</span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery and XPath Functions and Operators 4.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div></dd><dt class="label"><span><a id="xslt-xquery-serialization-40"></a><span class="deltaxml-new" style="background:#90EE90">XSLT and XQuery Serialization 4.0</span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/Overview.html"><cite><span class="deltaxml-new" style="background:#90EE90">XSLT and XQuery Serialization 4.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div></dd></dl></div><div class="div2"><h3><a id="id-non-normative-references"></a><span class="deltaxml-new" style="background:#90EE90">F.2 Non-normative References</span></h3><dl><dt class="xquery label"><span class="xquery"><a id="DOM"></a><span class="deltaxml-new" style="background:#90EE90">Document Object Model</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">Document Object Model (DOM) Level 3 Core Specification.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation, April 7, 2004. See </span><a href="http://www.w3.org/TR/DOM-Level-3-Core/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/DOM-Level-3-Core/</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="ODMG"></a><span class="deltaxml-new" style="background:#90EE90">ODMG</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">Rick Cattell et al. </span><em><span class="deltaxml-new" style="background:#90EE90">The Object Database Standard: ODMG-93, Release 1.2</span></em><span class="deltaxml-new" style="background:#90EE90">. Morgan Kaufmann Publishers, San Francisco, 1996.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="Quilt"></a><span class="deltaxml-new" style="background:#90EE90">Quilt</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">Don Chamberlin, Jonathan Robie, and Daniela Florescu. </span><em><span class="deltaxml-new" style="background:#90EE90">Quilt: an XML Query Language for Heterogeneous Data Sources</span></em><span class="deltaxml-new" style="background:#90EE90">. In </span><em><span class="deltaxml-new" style="background:#90EE90">Lecture Notes in Computer Science</span></em><span class="deltaxml-new" style="background:#90EE90">, Springer-Verlag, Dec. 2000. </span></div></dd><dt class="xquery label"><span class="xquery"><a id="SQL"></a><span class="deltaxml-new" style="background:#90EE90">SQL</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">International Organization for Standardization (ISO). </span><em><span class="deltaxml-new" style="background:#90EE90">Information Technology — Database Language SQL</span></em><span class="deltaxml-new" style="background:#90EE90">. Standard No. ISO/IEC 9075:2011. (Available from American National Standards Institute, New York, NY 10036, (212) 642-4900.)</span></div></dd><dt class="xquery label"><span class="xquery"><a id="RFC1738"></a><span class="deltaxml-new" style="background:#90EE90">Uniform Resource Locators (URL)</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">Internet Engineering Task Force (IETF). </span><em><span class="deltaxml-new" style="background:#90EE90">Uniform Resource Locators (URL)</span></em><span class="deltaxml-new" style="background:#90EE90">. Request For Comment No. 1738, Dec. 1994. See </span><a href="http://www.ietf.org/rfc/rfc1738.txt"><span class="deltaxml-new" style="background:#90EE90">http://www.ietf.org/rfc/rfc1738.txt</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="xml11schema10"></a><span class="deltaxml-new" style="background:#90EE90">XML 1.1 and Schema 1.0</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">Processing XML 1.1 Documents with XML Schema 1.0 Processors</span></em><span class="deltaxml-new" style="background:#90EE90">. W3C Working Group Note, 11 May 2005. See </span><a href="http://www.w3.org/TR/xml11schema10/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xml11schema10/</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="label"><span><a id="XINFO"></a><span class="deltaxml-new" style="background:#90EE90">XML Infoset</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">XML Information Set (Second Edition).</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Recommendation 4 February 2004. See </span><a href="http://www.w3.org/TR/xml-infoset/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xml-infoset/</span></a></div></dd><dt class="label"><span><a id="xpath"></a><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) Version 1.0</span></span></dt><dd><div><a href="http://www.w3.org/TR/xpath/"><cite><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) Version 1.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, James Clark and Steven DeRose, Editors. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999. This version is http://www.w3.org/TR/1999/REC-xpath-19991116. The </span><a href="http://www.w3.org/TR/xpath/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at http://www.w3.org/TR/xpath.</span></div></dd><dt class="label"><span><a id="xpath20"></a><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) Version 2.0</span></span></dt><dd><div><a href="https://www.w3.org/TR/xpath20/"><cite><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) 2.0 (Second Edition)</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Don Chamberlin, Anders Berglund, Scott Boag, </span><em><span class="deltaxml-new" style="background:#90EE90">et. al.</span></em><span class="deltaxml-new" style="background:#90EE90">, Editors. World Wide Web Consortium, 14 December 2010. This version is https://www.w3.org/TR/2010/REC-xpath20-20101214/. The </span><a href="https://www.w3.org/TR/xpath20/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xpath20/.</span></div></dd><dt class="label"><span><a id="xpath-30"></a><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) Version 3.0</span></span></dt><dd><div><a href="https://www.w3.org/TR/xpath-30/"><cite><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) 3.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xpath-30-20140408/. The </span><a href="https://www.w3.org/TR/xpath-30/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xpath-30/.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="xpath-31"></a><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) Version 3.1</span></span></dt><dd class="xquery"><div class="xquery"><a href="https://www.w3.org/TR/xpath-31/"><cite><span class="deltaxml-new" style="background:#90EE90">XML Path Language (XPath) 3.1</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Jonathan Robie, Michael Dyck and Josh Spiegel, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xpath-31-20170321/. The </span><a href="https://www.w3.org/TR/xpath-31/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xpath-31/.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="UseCases"></a><span class="deltaxml-new" style="background:#90EE90">XML Query Use Cases</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">XML Query Use Cases</span></em><span class="deltaxml-new" style="background:#90EE90">. W3C Working Draft, 8 June 2006. See </span><a href="http://www.w3.org/TR/xquery-use-cases/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xquery-use-cases/</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="XML-QL"></a><span class="deltaxml-new" style="background:#90EE90">XML-QL</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon Levy, and Dan Suciu. </span><em><span class="deltaxml-new" style="background:#90EE90">A Query Language for XML</span></em><span class="deltaxml-new" style="background:#90EE90">. </span></div></dd><dt class="label"><span><a id="XPTR"></a><span class="deltaxml-new" style="background:#90EE90">XPointer</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">XML Pointer Language (XPointer).</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Last Call Working Draft 8 January 2001. See </span><a href="http://www.w3.org/TR/WD-xptr"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/WD-xptr</span></a></div></dd><dt class="xquery label"><span class="xquery"><a id="XQL"></a><span class="deltaxml-new" style="background:#90EE90">XQL</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">J. Robie, J. Lapp, D. Schach. </span><em><span class="deltaxml-new" style="background:#90EE90">XML Query Language (XQL)</span></em><span class="deltaxml-new" style="background:#90EE90">. See </span><a href="http://www.w3.org/TandS/QL/QL98/pp/xql.html"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TandS/QL/QL98/pp/xql.html</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="label"><span><a id="xquery-semantics"></a><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0 and XPath 2.0 Formal Semantics</span></span></dt><dd><div><a href="https://www.w3.org/TR/xquery-semantics/"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0 and XPath 2.0 Formal Semantics (Second Edition)</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Jérôme Siméon, Denise Draper, Peter Frankhauser, </span><em><span class="deltaxml-new" style="background:#90EE90">et. al.</span></em><span class="deltaxml-new" style="background:#90EE90">, Editors. World Wide Web Consortium, 14 December 2010. This version is https://www.w3.org/TR/2010/REC-xquery-semantics-20101214/. The </span><a href="https://www.w3.org/TR/xquery-semantics/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xquery-semantics/.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="xquery-30-requirements"></a><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0 Requirements</span></span></dt><dd class="xquery"><div class="xquery"><a href="https://www.w3.org/TR/xquery-30-requirements/"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0 Requirements</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Daniel Engovatov, Jonathan Robie, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/NOTE-xquery-30-requirements-20140408/. The </span><a href="https://www.w3.org/TR/xquery-30-requirements/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xquery-30-requirements/.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="xquery-30"></a><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0: An XML Query Language</span></span></dt><dd class="xquery"><div class="xquery"><a href="https://www.w3.org/TR/xquery-30/"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0: An XML Query Language</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xquery-30-20140408/. The </span><a href="https://www.w3.org/TR/xquery-30/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xquery-30/.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="xquery-31-requirements"></a><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1 Requirements</span></span></dt><dd class="xquery"><div class="xquery"><a href="https://www.w3.org/TR/xquery-31-requirements/"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1 Requirements and Use Cases</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Jonathan Robie, Editor. World Wide Web Consortium, 13 December 2016. This version is https://www.w3.org/TR/2016/NOTE-xquery-31-requirements-20161213/. The </span><a href="https://www.w3.org/TR/xquery-31-requirements/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xquery-31-requirements/.</span></div></dd><dt class="xpath label"><span class="xpath"><a id="xquery-31"></a><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1: An XML Query Language</span></span></dt><dd class="xpath"><div class="xpath"><a href="https://www.w3.org/TR/xquery-31/"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1: An XML Query Language</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, Jonathan Robie, Michael Dyck and Josh Spiegel, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xquery-31-20170321/. The </span><a href="https://www.w3.org/TR/xquery-31/"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at https://www.w3.org/TR/xquery-31/.</span></div></dd><dt class="label"><span><a id="xslt-40"></a><span class="deltaxml-new" style="background:#90EE90">XSL Transformations (XSLT) Version 4.0</span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xslt-40/Overview.html"><cite><span class="deltaxml-new" style="background:#90EE90">XSL Transformations (XSLT) Version 4.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div></dd></dl></div><div class="div2"><h3><a id="id-background-material"></a><span class="deltaxml-new" style="background:#90EE90">F.3 Background Material</span></h3><dl><dt class="label"><span><a id="CHARMOD"></a><span class="deltaxml-new" style="background:#90EE90">Character Model</span></span></dt><dd><div><span class="deltaxml-new" style="background:#90EE90">World Wide Web Consortium. </span><em><span class="deltaxml-new" style="background:#90EE90">Character Model for the World Wide Web.</span></em><span class="deltaxml-new" style="background:#90EE90"> W3C Working Draft. See </span><a href="http://www.w3.org/TR/charmod/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/charmod/</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></div></dd><dt class="xquery label"><span class="xquery"><a id="Moustache"></a><span class="deltaxml-new" style="background:#90EE90">Moustache</span></span></dt><dd class="xquery"><div class="xquery"><em><span class="deltaxml-new" style="background:#90EE90">mustache</span></em><span class="deltaxml-new" style="background:#90EE90"> - Logic-less templates. See </span><a href="http://mustache.github.io/mustache.5.html"><span class="deltaxml-new" style="background:#90EE90">http://mustache.github.io/mustache.5.html</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></div></dd><dt class="xquery label"><span class="xquery"><a id="UseCaseQueries"></a><span class="deltaxml-new" style="background:#90EE90">Use Case Sample Queries</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">Queries from the XQuery 1.0 Use Cases, presented in a single file. See </span><a href="http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></div></dd><dt class="xquery label"><span class="xquery"><a id="XQueryQueries"></a><span class="deltaxml-new" style="background:#90EE90">XQuery Sample Queries</span></span></dt><dd class="xquery"><div class="xquery"><span class="deltaxml-new" style="background:#90EE90">Queries from this document, presented in a single file. See </span><a href="http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></div></dd><dt class="label"><span><a id="xslt"></a><span class="deltaxml-new" style="background:#90EE90">XSL Transformations (XSLT) Version 1.0</span></span></dt><dd><div><a href="http://www.w3.org/TR/xslt"><cite><span class="deltaxml-new" style="background:#90EE90">XSL Transformations (XSLT) Version 1.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, James Clark, Editor. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999. This version is http://www.w3.org/TR/1999/REC-xslt-19991116. The </span><a href="http://www.w3.org/TR/xslt"><span class="deltaxml-new" style="background:#90EE90">latest version</span></a><span class="deltaxml-new" style="background:#90EE90"> is available at http://www.w3.org/TR/xslt.</span></div></dd></dl></div></div><div class="div1"><h2><a id="id-errors"></a><span class="deltaxml-new" style="background:#90EE90">G Error Conditions</span></h2><dl><dt><a id="ERRXPST0001"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0001</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if analysis of an expression relies on some component of the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> that </span><span><span class="deltaxml-new" style="background:#90EE90">is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXPDY0002"></a><span class="deltaxml-new" style="background:#90EE90">err:XPDY0002</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if evaluation of an expression relies on some part of the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> that is </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">In version 4.0 this has been reclassified as a type error rather than a dynamic error. This change allows a processor to report the error during static analysis where possible; for example if the body of a user-defined function is written as </span><code><span class="deltaxml-new" style="background:#90EE90">fn($x){@code}</span></code><span class="deltaxml-new" style="background:#90EE90">. The error code is prefixed </span><code><span class="deltaxml-new" style="background:#90EE90">XPDY</span></code><span class="deltaxml-new" style="background:#90EE90"> rather than </span><code><span class="deltaxml-new" style="background:#90EE90">XPTY</span></code><span class="deltaxml-new" style="background:#90EE90"> for backwards compatibility reasons.</span></p></div></dd><dt><a id="ERRXPST0003"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0003</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an expression is not a valid instance of the grammar defined in </span><a href="#id-grammar"><b><span class="deltaxml-new" style="background:#90EE90">A.1 EBNF</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXPTY0004"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0004</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if, during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90">, an expression is found to have a </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> that is not appropriate for the context in which the expression occurs, or during the </span><a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation"><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></a><span class="deltaxml-new" style="background:#90EE90">, the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of a value does not match a required type as specified by the matching rules in </span><a href="#id-sequencetype-matching"><b><span class="deltaxml-new" style="background:#90EE90">3.1.2 Sequence Type Matching</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXPTY0006"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0006</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">During the analysis phase, an expression is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> if the inferred </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><var><span class="deltaxml-new" style="background:#90EE90">S</span></var><span class="deltaxml-new" style="background:#90EE90"> and the required type </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> are substantively disjoint; more specifically, if neither of the types is a subtype of the other, and if the only values that are instances of both types are one or more of: the empty sequence, the empty map, and the empty array.</span></p></dd><dt><a id="ERRXPST0008"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0008</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an expression refers to an element name, attribute name, schema type name, namespace prefix, or variable name that is not defined in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, except for an ElementName in an </span><a href="#doc-xpath40-ElementTest"><span class="deltaxml-new" style="background:#90EE90">ElementTest</span></a><span class="deltaxml-new" style="background:#90EE90"> or an AttributeName in an </span><a href="#doc-xpath40-AttributeTest"><span class="deltaxml-new" style="background:#90EE90">AttributeTest</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0009"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0009</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An implementation that does not support the Schema Aware Feature must raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a Prolog contains a schema import.</span></p></dd><dt><a id="ERRXPST0010"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0010</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An implementation that does not support the namespace axis must raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if it encounters a reference to the namespace axis and XPath 1.0 compatibility mode is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a id="ERRXQST0012"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0012</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the set of definitions contained in all schemas imported by a Prolog do not satisfy the conditions for schema validity specified in Sections 3 and 5 of Part 1 of </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0013"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0013</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an implementation recognizes a pragma but determines that its content is invalid.</span></p></dd><dt><a id="ERRXQST0016"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0016</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An implementation that does not support the Module Feature raises a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if it encounters a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXPST0017"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0017</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> and number of arguments in a static function call do not match the name and </span><a title="arity range" class="termref" href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a><span class="deltaxml-new" style="background:#90EE90"> of a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, or if an argument keyword in the function call does not match a parameter name in that function definition, or if two arguments in the function call bind to the same parameter in the function definition.</span></p></dd><dt><a id="ERRXPTY0018"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0018</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the result of a path operator contains both nodes and non-nodes.</span></p></dd><dt><a id="ERRXPTY0019"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0019</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> in a path expression </span><code><span class="deltaxml-new" style="background:#90EE90">E1/E2</span></code><span class="deltaxml-new" style="background:#90EE90"> does not evaluate to a sequence of nodes.</span></p></dd><dt><a id="ERRXPTY0020"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0020</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if, in an axis step, the context item is not a node.</span></p></dd><dt><a id="ERRXQST0022"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0022</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a </span><a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></a><span><span class="deltaxml-new" style="background:#90EE90">contains an </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></p></dd><dt><a id="ERRXQTY0024"></a><span class="deltaxml-new" style="background:#90EE90">err:XQTY0024</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the content sequence in an element constructor contains an attribute node following a node that is not an attribute node.</span></p></dd><dt><a id="ERRXQDY0025"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0025</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if any attribute of a constructed element does not have a name that is distinct from the names of all other attributes of the constructed element.</span></p></dd><dt><a id="ERRXQDY0026"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0026</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the result of the content expression of a computed processing instruction constructor contains the string </span><code><span class="deltaxml-new" style="background:#90EE90">"?&gt;"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQDY0027"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0027</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> In a validate expression, it is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the root element information item in the PSVI resulting from validation does not have the expected validity property: </span><code><span class="deltaxml-new" style="background:#90EE90">valid</span></code><span class="deltaxml-new" style="background:#90EE90"> if validation mode is </span><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><span class="deltaxml-new" style="background:#90EE90">, or either </span><code><span class="deltaxml-new" style="background:#90EE90">valid</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">notKnown</span></code><span class="deltaxml-new" style="background:#90EE90"> if validation mode is </span><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQTY0030"></a><span class="deltaxml-new" style="background:#90EE90">err:XQTY0030</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the argument of a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression does not evaluate to exactly one document or element node. </span></p></dd><dt><a id="ERRXQST0031"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0031</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the version number specified in a version declaration is not supported by the implementation. </span></p></dd><dt><a id="ERRXQST0032"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0032</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if a Prolog contains more than one </span><a title="base URI declaration" class="termref" href="#dt-base-uri-decl"><span class="deltaxml-new" style="background:#90EE90">base URI declaration</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0033"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0033</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a module contains multiple bindings for the same namespace prefix.</span></p></dd><dt><a id="ERRXQST0034"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0034</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if multiple functions declared </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">or imported by a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a></span></span><span class="deltaxml-new" style="background:#90EE90"> have the same </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> and overlapping arity ranges (the arity range of a function declaration is </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> to </span><var><span class="deltaxml-new" style="background:#90EE90">M+N</span></var><span class="deltaxml-new" style="background:#90EE90">, where </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> is the number of required parameters and </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is the number of optional parameters).</span></p></dd><dt><a id="ERRXQST0035"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0035</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> to import two schema components that both define the same name in the same symbol space and in the same scope. </span></p></dd><dt><a id="ERRXQST0038"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0038</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a Prolog contains more than one </span><a title="default collation declaration" class="termref" href="#dt-default-collation-decl"><span class="deltaxml-new" style="background:#90EE90">default collation declaration</span></a><span class="deltaxml-new" style="background:#90EE90">, or the value specified by a default collation declaration is not present in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically known collations</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0039"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0039</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> for </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a function declaration or</span></span></span><span><span class="deltaxml-new" style="background:#90EE90">an inline function expression</span></span><span class="deltaxml-new" style="background:#90EE90"> to have more than one parameter with the same name. </span></p></dd><dt><a id="ERRXQST0040"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0040</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the attributes specified by a direct element constructor do not have distinct </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQDY0041"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0041</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the value of the name expression in a computed processing instruction constructor cannot be cast to the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NCName</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQDY0044"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0044</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> the node-name of a node constructed by a computed attribute constructor has any of the following properties: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">It has no namespace prefix and its local name is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is not </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul></dd><dt><a id="ERRXQST0045"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0045</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if </span><span><span class="deltaxml-new" style="background:#90EE90">the name of </span><span><span class="deltaxml-new" style="background:#90EE90">a variable annotation,</span></span><span class="deltaxml-new" style="background:#90EE90"> a function annotation, or</span></span><span class="deltaxml-new" style="background:#90EE90"> the function name in a function declaration is </span><span><span class="deltaxml-new" style="background:#90EE90">in a </span><a title="reserved namespaces" class="termref" href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></span></p></dd><dt><a id="ERRXQST0046"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0046</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An implementation </span><span class="xquery"><span class="xquery"><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">MAY</span></span></span><span class="deltaxml-new" style="background:#90EE90"> raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the value of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span></span></span><span class="deltaxml-new" style="background:#90EE90">a </span><a href="#doc-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><span class="deltaxml-new" style="background:#90EE90"> is of nonzero length and is </span><span><span class="deltaxml-new" style="background:#90EE90">neither an absolute URI nor a relative URI</span></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0047"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0047</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if multiple module imports in the same Prolog specify the same target namespace.</span></p></dd><dt><a id="ERRXQST0048"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0048</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a function or variable declared in a library module is not in the target namespace of the library module.</span></p></dd><dt><a id="ERRXQST0049"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0049</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if two or more variables declared or imported by a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> have equal </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> (as defined by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator.)</span></p></dd><dt><a id="ERRXPDY0050"></a><span class="deltaxml-new" style="background:#90EE90">err:XPDY0050</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the operand of a </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> expression does not match the </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90"> specified by the </span><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><span class="deltaxml-new" style="background:#90EE90"> expression. This error might also be raised by a path expression beginning with </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90"> if the context node is not in a tree that is rooted at a document node. This is because a leading </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90"> in a path expression is an abbreviation for an initial step that includes the clause </span><code><span class="deltaxml-new" style="background:#90EE90">treat as document-node()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXPST0051"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0051</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> used as an </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> in a </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> is not defined in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> either as a </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a><span class="deltaxml-new" style="background:#90EE90">, or as a </span><a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0052"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0052</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The type named in a cast or castable expression must be the name of a type defined in the </span><a title="in-scope schema type" class="termref" href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema types</span></a><span class="deltaxml-new" style="background:#90EE90">, and the type must be </span><code><span class="deltaxml-new" style="background:#90EE90">simple</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQDY0054"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0054</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a cycle is encountered in the definition of a module’s dynamic context components, for example because of a cycle in variable declarations.</span></p></dd><dt><a id="ERRXQST0055"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0055</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a Prolog contains more than one </span><a title="copy-namespaces declaration" class="termref" href="#dt-copy-namespaces-decl"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces declaration</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0057"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0057</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a schema import binds a namespace prefix but does not specify a target namespace other than a zero-length string.</span></p></dd><dt><a id="ERRXQST0058"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0058</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if multiple schema imports specify the same target namespace.</span></p></dd><dt><a id="ERRXQST0059"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0059</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an implementation is unable to process a schema or module import by finding a schema or module with the specified target namespace.</span></p></dd><dt><a id="ERRXQST0060"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0060</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the name of a function in a function declaration is not in a namespace (</span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> has a null namespace URI).</span></p></dd><dt><a id="ERRXQDY0061"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0061</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the operand of a validate expression is a document node whose children do not consist of exactly one element node and zero or more comment and processing instruction nodes, in any order.</span></p></dd><dt><a id="ERRXQDY0064"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0064</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the value of the name expression in a computed processing instruction constructor is equal to </span><code><span class="deltaxml-new" style="background:#90EE90">XML</span></code><span class="deltaxml-new" style="background:#90EE90"> (in any combination of upper and lower case).</span></p></dd><dt><a id="ERRXQST0065"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0065</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if a Prolog contains more than one ordering mode declaration.</span></p></dd><dt><a id="ERRXQST0066"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0066</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if a Prolog contains more than one default element/type namespace declaration, or more than one default function namespace declaration. </span></p></dd><dt><a id="ERRXQST0067"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0067</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if a Prolog contains more than one </span><a title="construction declaration" class="termref" href="#dt-construction-decl"><span class="deltaxml-new" style="background:#90EE90">construction declaration</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0068"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0068</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if a Prolog contains more than one </span><a title="boundary-space declaration" class="termref" href="#dt-boundary-space-decl"><span class="deltaxml-new" style="background:#90EE90">boundary-space declaration</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0069"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0069</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if a Prolog contains more than one </span><a title="empty order declaration" class="termref" href="#dt-empty-order-decl"><span class="deltaxml-new" style="background:#90EE90">empty order declaration</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0070"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0070</span></dt><dd><div class="xquery"><p class="xquery"><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if one of the predefined prefixes </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> appears in a namespace declaration </span><span><span class="deltaxml-new" style="background:#90EE90">or a default namespace declaration,</span></span><span class="deltaxml-new" style="background:#90EE90"> or if any of the following conditions is statically detected in any expression or declaration: </span></p></div><div class="xpath"><p class="xpath"><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if any of the following conditions is statically detected in any expression: </span></p></div><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to some namespace URI other than </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A prefix other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to any namespace URI. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A prefix other than </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> is bound to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul></dd><dt><a id="ERRXQST0071"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0071</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> is raised if the namespace declaration attributes of a direct element constructor do not have distinct names.</span></p></dd><dt><a id="ERRXQDY0072"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0072</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the result of the content expression of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</span></p></dd><dt><a id="ERRXQDY0074"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0074</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the value of the name expression in a computed element or attribute constructor cannot be converted to an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (for example, because it contains a namespace prefix not found in </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.)</span></p></dd><dt><a id="ERRXQST0075"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0075</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An implementation that does not support the </span><span><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></span><span class="deltaxml-new" style="background:#90EE90"> must raise a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if it encounters a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression.</span></p></dd><dt><a id="ERRXQST0076"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0076</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a </span><code><span class="deltaxml-new" style="background:#90EE90">collation</span></code><span class="deltaxml-new" style="background:#90EE90"> subclause in an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span><span class="deltaxml-new" style="background:#90EE90">or </span><code><span class="deltaxml-new" style="background:#90EE90">group by</span></code></span><span class="deltaxml-new" style="background:#90EE90"> clause of a FLWOR expression does not identify a collation that is present in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically known collations</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0079"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0079</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an extension expression contains neither a </span><a title="pragma" class="termref" href="#dt-pragma"><span class="deltaxml-new" style="background:#90EE90">pragma</span></a><span class="deltaxml-new" style="background:#90EE90"> that is recognized by the implementation nor an expression enclosed in curly braces.</span></p></dd><dt><a id="ERRXPST0080"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0080</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the target type of a </span><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">castable</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><span><code><span class="deltaxml-new" style="background:#90EE90">xs:anySimpleType</span></code><span class="deltaxml-new" style="background:#90EE90">,</span></span><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXPST0081"></a><span class="deltaxml-new" style="background:#90EE90">err:XPST0081</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a QName used in </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90"> contains a namespace prefix that cannot be expanded into a namespace URI by using the </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQDY0084"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0084</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the element validated by a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> statement does not have a top-level element declaration in the </span><a title="in-scope element declarations" class="termref" href="#dt-is-elems"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a><span class="deltaxml-new" style="background:#90EE90">, if validation mode is </span><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0085"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0085</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the namespace URI in a namespace declaration attribute is a zero-length string, and the implementation does not support </span><a href="#XMLNAMES11"><span class="deltaxml-new" style="background:#90EE90">[XML Names 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQTY0086"></a><span class="deltaxml-new" style="background:#90EE90">err:XQTY0086</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the typed value of a copied element or attribute node is </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90"> when </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0087"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0087</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the encoding specified in a Version Declaration does not conform to the definition of </span><code><span class="deltaxml-new" style="background:#90EE90">EncName</span></code><span class="deltaxml-new" style="background:#90EE90"> specified in </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0088"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0088</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the literal that specifies the target namespace in a </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> is of zero length.</span></p></dd><dt><a id="ERRXQST0089"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0089</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a variable bound in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause of a FLWOR expression, and its associated positional variable, do not have distinct names (</span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></dd><dt><a id="ERRXQST0089"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0089</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a variable bound in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression, and its associated positional variable, do not have distinct names (</span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></dd><dt><a id="ERRXQST0090"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0090</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character reference</span></a><span class="deltaxml-new" style="background:#90EE90"> does not identify a valid character in the version of XML that is in use.</span></p></dd><dt><a id="ERRXQDY0091"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0091</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An implementation </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90"> error, as defined in </span><a href="#XMLID"><span class="deltaxml-new" style="background:#90EE90">[XML ID]</span></a><span class="deltaxml-new" style="background:#90EE90">, is encountered during construction of an attribute named </span><code><span class="deltaxml-new" style="background:#90EE90">xml:id</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQDY0092"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0092</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An implementation </span><a title="may" class="termref" href="#may"><span class="deltaxml-new" style="background:#90EE90">MAY</span></a><span class="deltaxml-new" style="background:#90EE90"> raise a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a constructed attribute named </span><code><span class="deltaxml-new" style="background:#90EE90">xml:space</span></code><span class="deltaxml-new" style="background:#90EE90"> has a value other than </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0094"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0094</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The name of each grouping variable must be equal (by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator on </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90">) to the name of a variable in the input tuple stream.</span></p></dd><dt><a id="ERRXQDY0096"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0096</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span><span class="deltaxml-new" style="background:#90EE90">if</span></span><span class="deltaxml-new" style="background:#90EE90"> the node-name of a node constructed by a computed element constructor has any of the following properties: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is not </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Its namespace prefix is other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> and its namespace URI is </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ul></dd><dt><a id="ERRXQST0097"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0097</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a static error for a decimal-format to specify a value that is not valid for a given property, as described in </span><a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">statically known decimal formats</span></a></p></dd><dt><a id="ERRXQST0098"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0098</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a static error if, for any named or unnamed decimal format, the properties representing characters used in a picture string do not each have distinct values. </span><span><span class="deltaxml-new" style="background:#90EE90"> The following properties represent characters used in a picture string: </span><a title="decimal-separator" class="termref" href="#id-static-decimal-format-decimal-separator"><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="exponent-separator" class="termref" href="#id-static-decimal-format-exponent-separator"><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="grouping-separator" class="termref" href="#id-static-decimal-format-grouping-separator"><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="percent" class="termref" href="#id-static-decimal-format-percent"><span class="deltaxml-new" style="background:#90EE90">percent</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="per-mille" class="termref" href="#id-static-decimal-format-per-mille"><span class="deltaxml-new" style="background:#90EE90">per-mille</span></a><span class="deltaxml-new" style="background:#90EE90">, the family of ten decimal digits starting with </span><a title="zero-digit" class="termref" href="#id-static-decimal-format-zero-digit"><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="digit" class="termref" href="#id-static-decimal-format-digit"><span class="deltaxml-new" style="background:#90EE90">digit</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="pattern-separator" class="termref" href="#id-static-decimal-format-pattern-separator"><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></span></p></dd><dt><a id="ERRXQST0099"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0099</span></dt><dd><p><span><span class="deltaxml-new" style="background:#90EE90">No module</span></span><span class="deltaxml-new" style="background:#90EE90"> may contain more than one ContextItemDecl. </span></p></dd><dt><a id="ERRXQDY0101"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0101</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An error is raised if a computed namespace constructor attempts to do any of the following:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Bind the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> to some namespace URI other than </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind a prefix other than </span><code><span class="deltaxml-new" style="background:#90EE90">xml</span></code><span class="deltaxml-new" style="background:#90EE90"> to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/XML/1998/namespace</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind the prefix </span><code><span class="deltaxml-new" style="background:#90EE90">xmlns</span></code><span class="deltaxml-new" style="background:#90EE90"> to any namespace URI. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind a prefix to the namespace URI </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2000/xmlns/</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Bind any prefix (including the empty prefix) to a zero-length namespace URI.</span></p></li></ul></dd><dt><a id="ERRXQDY0102"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0102</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> In an element constructor, if two or more namespace bindings in the in-scope bindings would have the same prefix, then an error is raised if they have different URIs; if they would have the same prefix and URI, duplicate bindings are ignored. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> If the name of an element in an element constructor is in no namespace, creating a default namespace for that element using a computed namespace constructor is an error. </span></p></dd><dt><a id="ERRXQST0103"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0103</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">All variables in a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause must have distinct names.</span></p></dd><dt><a id="ERRXQST0104"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0104</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a href="#doc-xpath40-TypeName"><span class="deltaxml-new" style="background:#90EE90">TypeName</span></a><span class="deltaxml-new" style="background:#90EE90"> that is specified in a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression must be found in the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a></p></dd><dt><a id="ERRXQTY0105"></a><span class="deltaxml-new" style="background:#90EE90">err:XQTY0105</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the content sequence in an element constructor contains a function .</span></p></dd><dt><a id="ERRXQST0106"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0106</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a function declaration contains both a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> and a </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation.</span></p></dd><dt><a id="ERRXQST0108"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0108</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an </span><a title="output declaration" class="termref" href="#dt-output-declaration"><span class="deltaxml-new" style="background:#90EE90">output declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs in a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a id="ERRXQST0109"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0109</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the local name of an output declaration in the </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/xslt-xquery-serialization</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace is not one of the serialization parameter names listed in </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></b></a><span class="deltaxml-new" style="background:#90EE90">, </span><span><span class="deltaxml-new" style="background:#90EE90">or if the name of an output declaration is </span><code><span class="deltaxml-new" style="background:#90EE90">use-character-maps</span></code></span><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a id="ERRXQST0110"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0110</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the same serialization parameter is used more than once in an </span><a title="output declaration" class="termref" href="#dt-output-declaration"><span class="deltaxml-new" style="background:#90EE90">output declaration</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0111"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0111</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> for a query prolog to contain two decimal formats with the same name, or to contain two default decimal formats. </span></p></dd><dt><a id="ERRXQST0113"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0113</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Specifying a </span><a href="#doc-xpath40-VarValue"><span class="deltaxml-new" style="background:#90EE90">VarValue</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#doc-xpath40-VarDefaultValue"><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></a><span class="deltaxml-new" style="background:#90EE90"> for a context item declaration in a library module is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a id="ERRXQST0114"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0114</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> for a decimal format declaration to define the same property more than once. </span></p></dd><dt><a id="ERRXQST0115"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0115</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the document specified by the option </span><code><span class="deltaxml-new" style="background:#90EE90">Q{http://www.w3.org/2010/xslt-xquery-serialization}parameter-document</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a serialization error. </span></p></dd><dt><a id="ERRXQST0116"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0116</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span><span class="deltaxml-new" style="background:#90EE90">if a variable declaration contains both a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> and a </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, or more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation.</span></span></p></dd><dt><a id="ERRXPTY0117"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0117</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">When applying the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a><span class="deltaxml-new" style="background:#90EE90">, if an item is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> and the expected type is </span><a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXPTY0117" title="err:XPTY0117"><span class="deltaxml-new" style="background:#90EE90">err:XPTY0117</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised. </span></p></dd><dt><a id="ERRXQST0118"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0118</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In a direct element constructor, the name used in the end tag must exactly match the name used in the corresponding start tag, including its prefix or absence of a prefix.</span></p></dd><dt><a id="ERRXQST0119"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0119</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a static error if the implementation is not able to process the value of an </span><code><span class="deltaxml-new" style="background:#90EE90">output:parameter-document</span></code><span class="deltaxml-new" style="background:#90EE90"> declaration to produce an XDM instance.</span></p></dd><dt><a id="ERRXQST0125"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0125</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an inline function </span><span><span class="deltaxml-new" style="background:#90EE90">expression</span></span><span class="deltaxml-new" style="background:#90EE90"> is annotated as </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a id="ERRXPDY0130"></a><span class="deltaxml-new" style="background:#90EE90">err:XPDY0130</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An implementation-dependent limit has been exceeded.</span></p></dd><dt><a id="ERRXQST0134"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0134</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The namespace axis is not supported.</span></p></dd><dt><a id="ERRXQDY0137"></a><span class="deltaxml-new" style="background:#90EE90">err:XQDY0137</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">No two keys in a map may have the </span><a title="same key" class="termref" href="#dt-same-key"><span class="deltaxml-new" style="background:#90EE90">same key value</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0140"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0140</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if a named item type declaration is recursive, unless it satisfies the conditions defined in </span><a href="#id-recursive-record-tests"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.4 Recursive Record Tests</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXPTY0141"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0141</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expression</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">clause</span></span></span><span class="deltaxml-new" style="background:#90EE90">, when the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><span class="deltaxml-new" style="background:#90EE90"> is present, the value of the binding collection must be a single array; and when either or both of the keywords </span><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><span class="deltaxml-new" style="background:#90EE90"> are present, the value of the binding collection must be a single map.</span></p></dd><dt><a id="ERRXPTY0144"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0144</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">During the analysis phase, an axis step is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> if the combination of the inferred context item type, the choice of axis, and the supplied node test, is such that the axis step will always return an empty sequence.</span></p></dd><dt><a id="ERRXPTY0145"></a><span class="deltaxml-new" style="background:#90EE90">err:XPTY0145</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">During the analysis phase, a unary or postfix lookup expression is classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90"> if the combination of the inferred type of the left-hand operand (or the context item type in the case of a unary expression) and the choice of key specifier is such that the lookup expression will always return an empty sequence.</span></p></dd><dt><a id="ERRXQST0146"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0146</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if two or more item types declared or imported by a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> have equal </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> (as defined by the </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> operator.)</span></p></dd><dt><a id="ERRXQST0148"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0148</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if an optional parameter in a function declaration is followed by a parameter that does not have a default value.</span></p></dd><dt><a id="ERRXQST0149"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0149</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if the schemas imported by different modules of a query are not compatible as defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#schema-consistency"><span class="deltaxml-new" style="background:#90EE90">Section 2.8.1 Schema Consistency</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRXQST0150"></a><span class="deltaxml-new" style="background:#90EE90">err:XQST0150</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> if any of the parameters in a variadic function declaration is declared as optional: that is, if a function declaration is annotated as </span><code><span class="deltaxml-new" style="background:#90EE90">%variadic</span></code><span class="deltaxml-new" style="background:#90EE90"> then none of its parameters may contain a </span><a href="#doc-xpath40-ParamWithDefault"><span class="deltaxml-new" style="background:#90EE90">ParamWithDefault</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd></dl></div><div class="xquery"><div class="div1 xquery"><h2><a id="id-mime-type"></a><span class="deltaxml-new" style="background:#90EE90">H The </span><code><span class="deltaxml-new" style="background:#90EE90">application/xquery</span></code><span class="deltaxml-new" style="background:#90EE90"> Media Type</span></h2><p><span class="deltaxml-new" style="background:#90EE90">This Appendix specifies the media type for XQuery Version 1.0. XQuery is a language for querying over collections of data from XML data sources, as specified in the main body of this document. This media type is being submitted to the IESG (Internet Engineering Steering Group) for review, approval, and registration with IANA (Internet Assigned Numbers Authority.)</span></p><div class="div2"><h3><a id="id-mime-type-intro"></a><span class="deltaxml-new" style="background:#90EE90">H.1 Introduction</span></h3><p><span class="deltaxml-new" style="background:#90EE90"> This document, found at </span><span class="xquery"><a href="http://www.w3.org/TR/xquery/"><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/TR/xquery/</span></a></span><span class="deltaxml-new" style="background:#90EE90">, together with its normative references, defines the language XQuery Version 1.0. This Appendix provides information about the </span><code><span class="deltaxml-new" style="background:#90EE90">application/xquery</span></code><span class="deltaxml-new" style="background:#90EE90"> media type, which is intended to be used for transmitting queries written in the XQuery language.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This document was prepared by members of the W3C XML Query Working Group. Please send comments to public-qt-comments@w3.org, a public mailing list with archives at </span><a href="http://lists.w3.org/Archives/Public/public-qt-comments"><span class="deltaxml-new" style="background:#90EE90">http://lists.w3.org/Archives/Public/public-qt-comments</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div2"><h3><a id="id-registration-of-mime-type"></a><span class="deltaxml-new" style="background:#90EE90">H.2 Registration of MIME Media Type </span><code><span class="deltaxml-new" style="background:#90EE90">application/xquery</span></code></h3><p><span class="deltaxml-new" style="background:#90EE90">MIME media type name: </span><code><span class="deltaxml-new" style="background:#90EE90">application</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">MIME subtype name: </span><code><span class="deltaxml-new" style="background:#90EE90">xquery</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Required parameters: none</span></p><p><span class="deltaxml-new" style="background:#90EE90">Optional parameters: none</span></p><p><span class="deltaxml-new" style="background:#90EE90">The syntax of XQuery is expressed in Unicode but may be written with any Unicode-compatible character encoding, including UTF-8 or UTF-16, or transported as US-ASCII or ISO-8859-1 with Unicode characters outside the range of the given encoding represented using an XML-style </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#xddd;</span></code><span class="deltaxml-new" style="background:#90EE90"> syntax.</span></p><div class="div3"><h4><a id="id-interoperability-considerations"></a><span class="deltaxml-new" style="background:#90EE90">H.2.1 Interoperability Considerations</span></h4><p><span class="deltaxml-new" style="background:#90EE90">None known.</span></p></div><div class="div3"><h4><a id="id-applications-of-media-type"></a><span class="deltaxml-new" style="background:#90EE90">H.2.2 Applications Using this Media Type</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The public </span><a href="http://www.w3.org/XML/Query/"><span class="deltaxml-new" style="background:#90EE90">XQuery Web page</span></a><span class="deltaxml-new" style="background:#90EE90"> lists more than two dozen implementations of the XQuery language, both proprietary and open source.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This media type is registered to allow for deployment of XQuery on the World Wide Web.</span></p></div><div class="div3"><h4><a id="id-file-extensions"></a><span class="deltaxml-new" style="background:#90EE90">H.2.3 File Extensions</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The most common file extensions in use for XQuery are </span><code><span class="deltaxml-new" style="background:#90EE90">.xq</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">.xquery</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The appropriate Macintosh file type code is </span><code><span class="deltaxml-new" style="background:#90EE90">TEXT</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div3"><h4><a id="id-intended-usage"></a><span class="deltaxml-new" style="background:#90EE90">H.2.4 Intended Usage</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The intended usage of this media type is for interchange of XQuery expressions.</span></p></div><div class="div3"><h4><a id="id-author-change-controller"></a><span class="deltaxml-new" style="background:#90EE90">H.2.5 Author/Change Controller</span></h4><p><span class="deltaxml-new" style="background:#90EE90">XQuery was produced by, and is maintained by, the World Wide Web Consortium’s XML Query Working Group. The W3C has change control over this specification.</span></p></div></div><div class="div2"><h3><a id="xquery-mime-encoding"></a><span class="deltaxml-new" style="background:#90EE90">H.3 Encoding Considerations</span></h3><p><span class="deltaxml-new" style="background:#90EE90">For use with transports that are not 8-bit clean, quoted-printable encoding is recommended since the XQuery syntax itself uses the US-ASCII-compatible subset of Unicode.</span></p><p><span class="deltaxml-new" style="background:#90EE90">An XQuery document may contain an </span><a title="encoding declaration" class="termref" href="#dt-encoding-declaration"><span class="deltaxml-new" style="background:#90EE90">encoding declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> as part of its </span><a title="version declaration" class="termref" href="#dt-version-declaration"><span class="deltaxml-new" style="background:#90EE90">version declaration</span></a><span class="deltaxml-new" style="background:#90EE90">:</span></p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">xquery version "3.1" encoding "utf-8";</span></pre></div></div></div><div class="div2"><h3><a id="xquery-mime-recognizing"></a><span class="deltaxml-new" style="background:#90EE90">H.4 Recognizing XQuery Files</span></h3><p><span class="deltaxml-new" style="background:#90EE90">An XQuery file may have the string </span><code><span class="deltaxml-new" style="background:#90EE90">xquery version "V.V"</span></code><span class="deltaxml-new" style="background:#90EE90"> near the beginning of the document, where </span><code><span class="deltaxml-new" style="background:#90EE90">"V.V"</span></code><span class="deltaxml-new" style="background:#90EE90"> is a version number. Currently the version number, if present, must be </span><code><span class="deltaxml-new" style="background:#90EE90">"1.0"</span></code><span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"3.0"</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">"3.1"</span></code></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></div><div class="div2"><h3><a id="id-charset-default-rules"></a><span class="deltaxml-new" style="background:#90EE90">H.5 Charset Default Rules</span></h3><p><span class="deltaxml-new" style="background:#90EE90">XQuery documents use the Unicode character set and, by default, the UTF-8 encoding.</span></p></div><div class="div2"><h3><a id="id-security-considerations"></a><span class="deltaxml-new" style="background:#90EE90">H.6 Security Considerations</span></h3><p><span class="deltaxml-new" style="background:#90EE90">Queries written in XQuery may cause arbitrary URIs or IRIs to be dereferenced. Therefore, the security issues of </span><a href="#RFC3987"><span class="deltaxml-new" style="background:#90EE90">[RFC3987]</span></a><span class="deltaxml-new" style="background:#90EE90"> Section 8 should be considered. In addition, the contents of resources identified by </span><code><span class="deltaxml-new" style="background:#90EE90">file:</span></code><span class="deltaxml-new" style="background:#90EE90"> URIs can in some cases be accessed, processed and returned as results. XQuery expressions can invoke any of the functions defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc-available()</span></code><span class="deltaxml-new" style="background:#90EE90"> functions allow local filesystem probes as well as access to any URI-defined resource accessible from the system evaluating the XQuery expression. </span><span><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:transform()</span></code><span class="deltaxml-new" style="background:#90EE90"> function allows calls to URI-identified XSLT transformations which may in turn call external extension functions and access or write to the file system. The </span><code><span class="deltaxml-new" style="background:#90EE90">fn:transform()</span></code><span class="deltaxml-new" style="background:#90EE90"> function should be sandboxed or disabled if untrusted queries are run. </span></span></p><p><span class="deltaxml-new" style="background:#90EE90">XQuery is a full declarative programming language, and supports user-defined functions, external function libraries (modules) referenced by URI, and system-specific “native” functions.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Arbitrary recursion is possible, as is arbitrarily large memory usage, and implementations may place limits on CPU and memory usage, as well as restricting access to system-defined functions. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> The optional XQuery Update Facility allows XQuery expressions to create and update persistent data, potentially including writing to arbitrary locations on the local filesystem as well as to remote URIs. Untrusted queries should not be given write access to data. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Furthermore, because the XQuery language permits extensions, it is possible that </span><code><span class="deltaxml-new" style="background:#90EE90">application/xquery</span></code><span class="deltaxml-new" style="background:#90EE90"> may describe content that has security implications beyond those described here.</span></p></div></div></div><div class="div1"><h2><a id="id-glossary"></a><span class="deltaxml-new" style="background:#90EE90">I Glossary (Non-Normative)</span></h2><dl><dt><a href="#dt-anonymous-function"><span class="deltaxml-new" style="background:#90EE90">anonymous function</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An </span><b><span class="deltaxml-new" style="background:#90EE90">anonymous function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> with no name. Anonymous functions may be created, for example, by evaluating an inline function expression or by partial function application.</span></p></dd><dt><a href="#dt-application-function"><span class="deltaxml-new" style="background:#90EE90">application function</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Application functions</span></b><span class="deltaxml-new" style="background:#90EE90"> are function definitions written in a host language such as XQuery or XSLT whose syntax and semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.</span></p></dd><dt><a href="#dt-arg-expr"><span class="deltaxml-new" style="background:#90EE90">argument expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An argument to a function call is either an </span><b><span class="deltaxml-new" style="background:#90EE90">argument expression</span></b><span class="deltaxml-new" style="background:#90EE90"> or an </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a><span class="deltaxml-new" style="background:#90EE90"> (</span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90">); in both cases it may either be supplied positionally, or identified by a name (called a keyword).</span></p></dd><dt><a href="#dt-arity-range"><span class="deltaxml-new" style="background:#90EE90">arity range</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> has an </span><b><span class="deltaxml-new" style="background:#90EE90">arity range</span></b><span class="deltaxml-new" style="background:#90EE90">, which is a range of consecutive non-negative integers. If the function definition has </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> required parameters and </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> optional parameters, then its arity range is from </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> to </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90">+</span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> inclusive.</span></p></dd><dt><a href="#dt-array"><span class="deltaxml-new" style="background:#90EE90">array</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">array</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> that associates a set of positions, represented as positive integer keys, with values.</span></p></dd><dt><a href="#dt-associated-value"><span class="deltaxml-new" style="background:#90EE90">associated value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The value associated with a given key is called the </span><b><span class="deltaxml-new" style="background:#90EE90">associated value</span></b><span class="deltaxml-new" style="background:#90EE90"> of the key.</span></p></dd><dt><a href="#dt-atomic-item"><span class="deltaxml-new" style="background:#90EE90">atomic item</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">atomic item</span></b><span class="deltaxml-new" style="background:#90EE90"> is a value in the value space of an </span><b><span class="deltaxml-new" style="background:#90EE90">atomic type</span></b><span class="deltaxml-new" style="background:#90EE90">, as defined in </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">atomic type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a simple </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><span class="deltaxml-new" style="background:#90EE90"> whose </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">atomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-atomization"><span class="deltaxml-new" style="background:#90EE90">atomization</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Atomization</span></b><span class="deltaxml-new" style="background:#90EE90"> of a sequence is defined as the result of invoking the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:data</span></code><span class="deltaxml-new" style="background:#90EE90"> function, as defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data"><span class="deltaxml-new" style="background:#90EE90">Section 2.1.4 fn:data</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-available-docs"><span class="deltaxml-new" style="background:#90EE90">available documents</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Available documents.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping of strings to document nodes. Each string represents the absolute URI of a resource. The document node is the root of a tree that represents that resource using the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90">. The document node is returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90"> function when applied to that URI.</span></p></dd><dt><a href="#dt-available-collections"><span class="deltaxml-new" style="background:#90EE90">available item collections</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Available collections.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping of strings to sequences of items. Each string represents the absolute URI of a resource. The sequence of items represents the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function when that URI is supplied as the argument. </span></p></dd><dt><a href="#dt-available-text-resources"><span class="deltaxml-new" style="background:#90EE90">available text resources</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Available text resources</span></b><span class="deltaxml-new" style="background:#90EE90">. This is a mapping of strings to text resources. Each string represents the absolute URI of a resource. The resource is returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-text</span></code><span class="deltaxml-new" style="background:#90EE90"> function when applied to that URI.</span></p></dd><dt><a href="#dt-available-uri-collections"><span class="deltaxml-new" style="background:#90EE90">available uri collections</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Available URI collections.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping of strings to sequences of URIs. The string represents the absolute URI of a resource which can be interpreted as an aggregation of a number of individual resources each of which has its own URI. The sequence of URIs represents the result of the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:uri-collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function when that URI is supplied as the argument. </span></p></dd><dt><a href="#dt-axis-step"><span class="deltaxml-new" style="background:#90EE90">axis step</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">axis step</span></b><span class="deltaxml-new" style="background:#90EE90"> returns a sequence of nodes that are reachable from a starting node via a specified axis. Such a step has two parts: an </span><b><span class="deltaxml-new" style="background:#90EE90">axis</span></b><span class="deltaxml-new" style="background:#90EE90">, which defines the "direction of movement" for the step, and a </span><a title="node test" class="termref" href="#dt-node-test"><span class="deltaxml-new" style="background:#90EE90">node test</span></a><span class="deltaxml-new" style="background:#90EE90">, which selects nodes based on their kind, name, and/or </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> .</span></p></dd><dt><a href="#dt-base-uri-decl"><span class="deltaxml-new" style="background:#90EE90">base URI declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">base URI declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> specifies the </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property. The </span><a title="Static Base URI" class="termref" href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a><span class="deltaxml-new" style="background:#90EE90"> property is used when resolving relative URI references.</span></p></dd><dt><a href="#dt-binary"><span class="deltaxml-new" style="background:#90EE90">binary</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In the operator mapping tables, the term </span><b><span class="deltaxml-new" style="background:#90EE90">binary</span></b><span class="deltaxml-new" style="background:#90EE90"> refers to the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-binding-collection"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, when an expression is preceded by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90">, the value of that expression is called a </span><b><span class="deltaxml-new" style="background:#90EE90">binding collection</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-binding-collection-xp"><span class="deltaxml-new" style="background:#90EE90">binding collection</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The result of evaluating the </span><b><span class="deltaxml-new" style="background:#90EE90">binding expression</span></b><span class="deltaxml-new" style="background:#90EE90"> in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is called the </span><b><span class="deltaxml-new" style="background:#90EE90">binding collection</span></b></p></dd><dt><a href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In a </span><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, when an expression is preceded by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><span class="deltaxml-new" style="background:#90EE90">, the value of that expression is called a </span><b><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-boundary-space-decl"><span class="deltaxml-new" style="background:#90EE90">boundary-space declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">boundary-space declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the </span><a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy"><span class="deltaxml-new" style="background:#90EE90">boundary-space policy</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default. Boundary-space policy controls whether </span><a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace"><span class="deltaxml-new" style="background:#90EE90">boundary whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> is preserved by element constructors during processing of the query.</span></p></dd><dt><a href="#dt-boundary-space-policy"><span class="deltaxml-new" style="background:#90EE90">boundary-space policy</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Boundary-space policy.</span></b><span class="deltaxml-new" style="background:#90EE90"> This component controls the processing of </span><a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace"><span class="deltaxml-new" style="background:#90EE90">boundary whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> by </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructors</span></a><span class="deltaxml-new" style="background:#90EE90">, as described in </span><a href="#id-whitespace"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1.4 Boundary Whitespace</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-boundary-whitespace"><span class="deltaxml-new" style="background:#90EE90">boundary whitespace</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Boundary whitespace</span></b><span class="deltaxml-new" style="background:#90EE90"> is a sequence of consecutive whitespace characters within the content of a </span><a title="direct element constructor" class="termref" href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></a><span class="deltaxml-new" style="background:#90EE90">, that is delimited at each end either by the start or end of the content, or by a </span><a href="#doc-xpath40-DirectConstructor"><span class="deltaxml-new" style="background:#90EE90">DirectConstructor</span></a><span class="deltaxml-new" style="background:#90EE90">, or by an </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90">. For this purpose, characters generated by </span><a title="character reference" class="termref" href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character references</span></a><span class="deltaxml-new" style="background:#90EE90"> such as </span><code><span class="deltaxml-new" style="background:#90EE90">&amp;#x20;</span></code><span class="deltaxml-new" style="background:#90EE90"> or by </span><a href="#doc-xpath40-CDataSection"><span class="deltaxml-new" style="background:#90EE90">CDataSections</span></a><span class="deltaxml-new" style="background:#90EE90"> are not considered to be whitespace characters.</span></p></dd><dt><a href="#dt-character-reference"><span class="deltaxml-new" style="background:#90EE90">character reference</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">character reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is an XML-style reference to a </span><a href="#Unicode"><span class="deltaxml-new" style="background:#90EE90">[Unicode]</span></a><span class="deltaxml-new" style="background:#90EE90"> character, identified by its decimal or hexadecimal codepoint.</span></p></dd><dt><a href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">choice item type</span></b><span class="deltaxml-new" style="background:#90EE90"> defines an item type that is the union of a number of alternatives. For example the type </span><code><span class="deltaxml-new" style="background:#90EE90">(xs:hexBinary | xs:base64Binary)</span></code><span class="deltaxml-new" style="background:#90EE90"> defines the union of these two primitive </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic types</span></a><span class="deltaxml-new" style="background:#90EE90">, while the type </span><code><span class="deltaxml-new" style="background:#90EE90">(map(*) | array(*))</span></code><span class="deltaxml-new" style="background:#90EE90"> matches any item that is either a map or an array.</span></p></dd><dt><a href="#dt-coercion-rules"><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">coercion rules</span></b><span class="deltaxml-new" style="background:#90EE90"> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. </span></p></dd><dt><a href="#dt-collation"><span class="deltaxml-new" style="background:#90EE90">collation</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">collation</span></b><span class="deltaxml-new" style="background:#90EE90"> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#string-compare"><span class="deltaxml-new" style="background:#90EE90">Section 5.3 Comparison of strings</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-comma-operator"><span class="deltaxml-new" style="background:#90EE90">comma operator</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">One way to construct a sequence is by using the </span><b><span class="deltaxml-new" style="background:#90EE90">comma operator</span></b><span class="deltaxml-new" style="background:#90EE90">, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.</span></p></dd><dt><a href="#dt-complex-terminal"><span class="deltaxml-new" style="background:#90EE90">complex terminal</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">complex terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="variable terminal" class="termref" href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></a><span class="deltaxml-new" style="background:#90EE90"> whose production rule references, directly or indirectly, an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-computed-elem-const"><span class="deltaxml-new" style="background:#90EE90">computed element constructor</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">computed element constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> creates an element node, allowing both the name and the content of the node to be computed.</span></p></dd><dt><a href="#dt-construction-decl"><span class="deltaxml-new" style="background:#90EE90">construction declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">construction declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the </span><a title="construction mode" class="termref" href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default.</span></p></dd><dt><a href="#dt-construction-mode"><span class="deltaxml-new" style="background:#90EE90">construction mode</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Construction mode.</span></b><span class="deltaxml-new" style="background:#90EE90"> The construction mode governs the behavior of element and document node constructors. If construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, the type of a constructed element node is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyType</span></code><span class="deltaxml-new" style="background:#90EE90">, and all attribute and element nodes copied during node construction retain their original types. If construction mode is </span><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><span class="deltaxml-new" style="background:#90EE90">, the type of a constructed element node is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">; all element nodes copied during node construction receive the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90">, and all attribute nodes copied during node construction receive the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor function</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">constructor function</span></b><span class="deltaxml-new" style="background:#90EE90"> for a given simple type is used to convert instances of other simple types into the given type. The semantics of the constructor function call </span><code><span class="deltaxml-new" style="background:#90EE90">T($arg)</span></code><span class="deltaxml-new" style="background:#90EE90"> are defined to be equivalent to the expression </span><code><span class="deltaxml-new" style="background:#90EE90">(($arg) cast as T?)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In an </span><a title="enclosed expression" class="termref" href="#dt-enclosed-expression"><span class="deltaxml-new" style="background:#90EE90">enclosed expression</span></a><span class="deltaxml-new" style="background:#90EE90">, the optional expression enclosed in curly braces is called the </span><b><span class="deltaxml-new" style="background:#90EE90">content expression</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-context-dependent"><span class="deltaxml-new" style="background:#90EE90">context dependent</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> is said to be </span><b><span class="deltaxml-new" style="background:#90EE90">context dependent</span></b><span class="deltaxml-new" style="background:#90EE90"> if its result depends on the static or dynamic context of its caller. A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name#0</span></code><span class="deltaxml-new" style="background:#90EE90"> is context-dependent while </span><code><span class="deltaxml-new" style="background:#90EE90">fn:name#1</span></code><span class="deltaxml-new" style="background:#90EE90"> is context-independent.</span></p></dd><dt><a href="#dt-context-node"><span class="deltaxml-new" style="background:#90EE90">context node</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">When the context value is a single item, it can also be referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">context item</span></b><span class="deltaxml-new" style="background:#90EE90">; when it is a single node, it can also be referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">context node</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-context-position"><span class="deltaxml-new" style="background:#90EE90">context position</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">context position</span></b><span class="deltaxml-new" style="background:#90EE90"> is the position of the context value within the series of values currently being processed.</span></p></dd><dt><a href="#dt-context-size"><span class="deltaxml-new" style="background:#90EE90">context size</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">context size</span></b><span class="deltaxml-new" style="background:#90EE90"> is the number of values in the series of values currently being processed.</span></p></dd><dt><a href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">context value</span></b><span class="deltaxml-new" style="background:#90EE90"> is the </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-new" style="background:#90EE90">value</span></a><span class="deltaxml-new" style="background:#90EE90"> currently being processed.</span></p></dd><dt><a href="#dt-context-value-static-type"><span class="deltaxml-new" style="background:#90EE90">context value static type</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Context value static type.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">; it defines the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90"> within the scope of a given expression.</span></p></dd><dt><a href="#dt-copy-namespaces-decl"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">copy-namespaces declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the value of </span><a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default. Copy-namespaces mode controls the namespace bindings that are assigned when an existing element node is copied by an element constructor or document constructor.</span></p></dd><dt><a href="#dt-copy-namespaces-mode"><span class="deltaxml-new" style="background:#90EE90">copy-namespaces mode</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Copy-namespaces mode.</span></b><span class="deltaxml-new" style="background:#90EE90"> This component controls the namespace bindings that are assigned when an existing element node is copied by an element constructor, as described in </span><a href="#id-element-constructor"><b><span class="deltaxml-new" style="background:#90EE90">4.12.1 Direct Element Constructors</span></b></a><span class="deltaxml-new" style="background:#90EE90">. Its value consists of two parts: </span><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">inherit</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">no-inherit</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-date-time"><span class="deltaxml-new" style="background:#90EE90">current dateTime</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Current dateTime.</span></b><span class="deltaxml-new" style="background:#90EE90"> This information represents an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> point in time during the processing of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, and includes an explicit timezone. It can be retrieved by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:current-dateTime</span></code><span class="deltaxml-new" style="background:#90EE90"> function. If called multiple times during the execution of </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">a query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">an expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, this function always returns the same result.</span></p></dd><dt><a href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 and XPath 4.0 operates on the abstract, logical structure of an XML document or JSON object rather than its surface syntax. This logical structure, known as the </span><b><span class="deltaxml-new" style="background:#90EE90">data model</span></b><span class="deltaxml-new" style="background:#90EE90">, is defined in </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Data Model (XDM) 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-decimal-format-decl"><span class="deltaxml-new" style="background:#90EE90">decimal-format declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">decimal format declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> adds a decimal format to the </span><a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">statically known decimal formats</span></a><span class="deltaxml-new" style="background:#90EE90">, which define the properties used to format numbers using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-number()</span></code><span class="deltaxml-new" style="background:#90EE90"> function</span></p></dd><dt><a href="#id-static-decimal-format-decimal-separator"><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used to separate the integer part of the number from the fractional part, both in the picture string and in the formatted number; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+002E</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">FULL STOP, PERIOD</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#dt-default-calendar"><span class="deltaxml-new" style="background:#90EE90">default calendar</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default calendar.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the calendar used when formatting dates in human-readable output (for example, by the functions </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">) if no other calendar is requested. The value is a string.</span></p></dd><dt><a href="#dt-def-collation"><span class="deltaxml-new" style="background:#90EE90">default collation</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default collation.</span></b><span class="deltaxml-new" style="background:#90EE90"> This identifies one of the collations in </span><a title="statically known collations" class="termref" href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically known collations</span></a><span class="deltaxml-new" style="background:#90EE90"> as the collation to be used by functions and operators for comparing and ordering values of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code><span class="deltaxml-new" style="background:#90EE90"> (and types derived from them) when no explicit collation is specified.</span></p></dd><dt><a href="#dt-default-collation-decl"><span class="deltaxml-new" style="background:#90EE90">default collation declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">default collation declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the value of the </span><a title="default collation" class="termref" href="#dt-def-collation"><span class="deltaxml-new" style="background:#90EE90">default collation</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, overriding any implementation-defined default.</span></p></dd><dt><a href="#dt-default-collection"><span class="deltaxml-new" style="background:#90EE90">default collection</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default collection.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the sequence of items that would result from calling the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function with no arguments.</span></p></dd><dt><a href="#dt-default-function-namespace"><span class="deltaxml-new" style="background:#90EE90">default function namespace</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default function namespace.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is either a namespace URI, or </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</span></p></dd><dt><a href="#dt-default-language"><span class="deltaxml-new" style="background:#90EE90">default language</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default language.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the natural language used when creating human-readable output (for example, by the functions </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-integer</span></code><span class="deltaxml-new" style="background:#90EE90">) if no other language is requested. The value is a language code as defined by the type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:language</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default namespace for elements and types.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is either a namespace URI, or the special value </span><code><span class="deltaxml-new" style="background:#90EE90">"##any"</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. This indicates how unprefixed QNames are interpreted when they appear in a position where an element name or type name is expected.</span></p></dd><dt><a href="#dt-default-empty-order"><span class="deltaxml-new" style="background:#90EE90">default order for empty sequences</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default order for empty sequences.</span></b><span class="deltaxml-new" style="background:#90EE90"> This component controls the processing of empty sequences and </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> values as ordering keys in an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in a FLWOR expression, as described in </span><a href="#id-order-by-clause"><b><span class="deltaxml-new" style="background:#90EE90">4.13.9 Order By Clause</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-default-place"><span class="deltaxml-new" style="background:#90EE90">default place</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default place.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a geographical location used to identify the place where events happened (or will happen) when formatting dates and times using functions such as </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-date</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-dateTime</span></code><span class="deltaxml-new" style="background:#90EE90">, if no other place is specified. It is used when translating timezone offsets to civil timezone names, and when using calendars where the translation from ISO dates/times to a local representation is dependent on geographical location. Possible representations of this information are an ISO country code or an Olson timezone name, but implementations are free to use other representations from which the above information can be derived.</span></p></dd><dt><a href="#dt-default-uri-collection"><span class="deltaxml-new" style="background:#90EE90">default URI collection</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Default URI collection.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the sequence of URIs that would result from calling the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:uri-collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function with no arguments.</span></p></dd><dt><a href="#delimiting-token"><span class="deltaxml-new" style="background:#90EE90">delimiting terminal symbol</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">delimiting terminal symbols</span></b><span class="deltaxml-new" style="background:#90EE90"> are: </span><code><span class="deltaxml-new" style="background:#90EE90">!</span></code><code><span class="deltaxml-new" style="background:#90EE90">!=</span></code><code><span class="deltaxml-new" style="background:#90EE90">#</span></code><code><span class="deltaxml-new" style="background:#90EE90">$</span></code><code><span class="deltaxml-new" style="background:#90EE90">%</span></code><code><span class="deltaxml-new" style="background:#90EE90">(</span></code><code><span class="deltaxml-new" style="background:#90EE90">)</span></code><code><span class="deltaxml-new" style="background:#90EE90">*</span></code><code><span class="deltaxml-new" style="background:#90EE90">*:</span></code><code><span class="deltaxml-new" style="background:#90EE90">,</span></code><code><span class="deltaxml-new" style="background:#90EE90">-</span></code><code><span class="deltaxml-new" style="background:#90EE90">.</span></code><code><span class="deltaxml-new" style="background:#90EE90">..</span></code><code><span class="deltaxml-new" style="background:#90EE90">:</span></code><code><span class="deltaxml-new" style="background:#90EE90">:*</span></code><code><span class="deltaxml-new" style="background:#90EE90">::</span></code><code><span class="deltaxml-new" style="background:#90EE90">:=</span></code><code><span class="deltaxml-new" style="background:#90EE90">;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;&lt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;=</span></code><code><span class="deltaxml-new" style="background:#90EE90">=</span></code><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">=?&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;=</span></code><code><span class="deltaxml-new" style="background:#90EE90">&gt;&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><code><span class="deltaxml-new" style="background:#90EE90">?[</span></code><code><span class="deltaxml-new" style="background:#90EE90">@</span></code><code><span class="deltaxml-new" style="background:#90EE90">[</span></code><code><span class="deltaxml-new" style="background:#90EE90">]</span></code><code><span class="deltaxml-new" style="background:#90EE90">`</span></code><code><span class="deltaxml-new" style="background:#90EE90">``</span></code><code><span class="deltaxml-new" style="background:#90EE90">{</span></code><code><span class="deltaxml-new" style="background:#90EE90">{{</span></code><code><span class="deltaxml-new" style="background:#90EE90">|</span></code><code><span class="deltaxml-new" style="background:#90EE90">||</span></code><code><span class="deltaxml-new" style="background:#90EE90">}</span></code><code><span class="deltaxml-new" style="background:#90EE90">}}</span></code><code><span class="deltaxml-new" style="background:#90EE90">×</span></code><code><span class="deltaxml-new" style="background:#90EE90">÷</span></code><a href="#prod-xpath40-AposStringLiteral"><span class="deltaxml-new" style="background:#90EE90">AposStringLiteral</span></a><a href="#prod-xpath40-BracedURILiteral"><span class="deltaxml-new" style="background:#90EE90">BracedURILiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">]]&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;![CDATA[</span></code><code><span class="deltaxml-new" style="background:#90EE90">--&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;!--</span></code><code><span class="deltaxml-new" style="background:#90EE90">/&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;/</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><code><span class="deltaxml-new" style="background:#90EE90">#)</span></code><code><span class="deltaxml-new" style="background:#90EE90">(#</span></code><code><span class="deltaxml-new" style="background:#90EE90">?&gt;</span></code><code><span class="deltaxml-new" style="background:#90EE90">&lt;?</span></code><a href="#prod-xpath40-QuotStringLiteral"><span class="deltaxml-new" style="background:#90EE90">QuotStringLiteral</span></a><a href="#prod-xpath40-S"><span class="deltaxml-new" style="background:#90EE90">S</span></a><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><code><span class="deltaxml-new" style="background:#90EE90">]``</span></code><code><span class="deltaxml-new" style="background:#90EE90">``[</span></code><code><span class="deltaxml-new" style="background:#90EE90">}`</span></code><code><span class="deltaxml-new" style="background:#90EE90">`{</span></code><a href="#prod-xpath40-StringLiteral"><span class="deltaxml-new" style="background:#90EE90">StringLiteral</span></a></p></dd><dt><a href="#dt-depends-on"><span class="deltaxml-new" style="background:#90EE90">depends on</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A variable value (or the context value) </span><b><span class="deltaxml-new" style="background:#90EE90">depends on</span></b><span class="deltaxml-new" style="background:#90EE90"> another variable value (or the context value) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.</span></p></dd><dt><a href="#id-static-decimal-format-digit"><span class="deltaxml-new" style="background:#90EE90">digit</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">digit</span></b><span class="deltaxml-new" style="background:#90EE90"> is a character used in the picture string to represent an optional digit; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0023</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">NUMBER SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">#</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#dt-direct-elem-const"><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">direct element constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> is a form of element constructor in which the name of the constructed element is a constant.</span></p></dd><dt><a href="#dt-document-order"><span class="deltaxml-new" style="background:#90EE90">document order</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Informally, </span><b><span class="deltaxml-new" style="background:#90EE90">document order</span></b><span class="deltaxml-new" style="background:#90EE90"> is the order in which nodes appear in the XML serialization of a document.</span></p></dd><dt><a href="#dt-dynamically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">dynamically known function definitions</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Dynamically known function definitions</span></b><span class="deltaxml-new" style="background:#90EE90">. This is a set of </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">. It includes the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> as a subset, but may include other function definitions that are not known statically. </span></p></dd><dt><a href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></b><span class="deltaxml-new" style="background:#90EE90"> of an expression is defined as information that is needed for the dynamic evaluation of an expression.</span></p></dd><dt><a href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></b><span class="deltaxml-new" style="background:#90EE90"> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.</span></p></dd><dt><a href="#dt-dynamic-evaluation"><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></b><span class="deltaxml-new" style="background:#90EE90"> is the phase during which the value of an expression is computed.</span></p></dd><dt><a href="#dt-dynamic-function-invocation"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of a base expression that returns the function and a parenthesized list of zero or more arguments (</span><a title="argument expression" class="termref" href="#dt-arg-expr"><span class="deltaxml-new" style="background:#90EE90">argument expressions</span></a><span class="deltaxml-new" style="background:#90EE90"> or ArgumentPlaceholders).</span></p></dd><dt><a href="#dt-dynamic-function-call"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression that is evaluated by calling a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, which is typically obtained dynamically.</span></p></dd><dt><a href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Every value matches one or more </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90">. A value is said to have a </span><b><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></b><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> if it matches (or </span><b><span class="deltaxml-new" style="background:#90EE90">is an instance of</span></b><span class="deltaxml-new" style="background:#90EE90">) the sequence type </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-ebv"><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">effective boolean value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a value is defined as the result of applying the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> function to the value, as defined in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-boolean"><span class="deltaxml-new" style="background:#90EE90">Section 7.3.1 fn:boolean</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#id-effective-case-switch-expression"><span class="deltaxml-new" style="background:#90EE90">effective case</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The </span><b><span class="deltaxml-new" style="background:#90EE90">effective case</span></b><span class="deltaxml-new" style="background:#90EE90"> of a switch expression is the first case clause that matches, using the rules given above, or the default clause if no such case clause exists.</span></p></dd><dt><a href="#dt-effective-case"><span class="deltaxml-new" style="background:#90EE90">effective case</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">effective case</span></b><span class="deltaxml-new" style="background:#90EE90"> in a </span><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><span class="deltaxml-new" style="background:#90EE90"> expression is the first </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in which the value of the operand expression matches a </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceTypeUnion</span></a><span class="deltaxml-new" style="background:#90EE90"> of the </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, using the rules of </span><a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a href="#dt-empty-order-decl"><span class="deltaxml-new" style="background:#90EE90">empty order declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">empty order declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> sets the </span><a title="default order for empty sequences" class="termref" href="#dt-default-empty-order"><span class="deltaxml-new" style="background:#90EE90">default order for empty sequences</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context,</span></a><span class="deltaxml-new" style="background:#90EE90"> overriding any implementation-defined default. This declaration controls the processing of empty sequences and </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> values as ordering keys in an </span><code><span class="deltaxml-new" style="background:#90EE90">order by</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in a FLWOR expression.</span></p></dd><dt><a href="#dt-empty-sequence"><span class="deltaxml-new" style="background:#90EE90">empty sequence</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A sequence containing zero items is called an </span><b><span class="deltaxml-new" style="background:#90EE90">empty sequence</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-enclosed-expression"><span class="deltaxml-new" style="background:#90EE90">enclosed expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">enclosed expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is an instance of the </span><a href="#doc-xpath40-EnclosedExpr"><span class="deltaxml-new" style="background:#90EE90">EnclosedExpr</span></a><span class="deltaxml-new" style="background:#90EE90"> production, which allows an optional expression within curly braces.</span></p></dd><dt><a href="#dt-encoding-declaration"><span class="deltaxml-new" style="background:#90EE90">encoding declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If present, a version declaration may optionally include an </span><b><span class="deltaxml-new" style="background:#90EE90">encoding declaration</span></b><span class="deltaxml-new" style="background:#90EE90">. The value of the string literal following the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">encoding</span></code><span class="deltaxml-new" style="background:#90EE90"> is an encoding name, and must conform to the definition of </span><code><span class="deltaxml-new" style="background:#90EE90">EncName</span></code><span class="deltaxml-new" style="background:#90EE90"> specified in </span><a href="#XML"><span class="deltaxml-new" style="background:#90EE90">[XML 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0087" title="err:XQST0087"><span class="deltaxml-new" style="background:#90EE90">err:XQST0087</span></a><span class="deltaxml-new" style="background:#90EE90">]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as </span><code><span class="deltaxml-new" style="background:#90EE90">"UTF-8"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"UTF-16"</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">"US-ASCII"</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-entry"><span class="deltaxml-new" style="background:#90EE90">entry</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Each key / value pair in a map is called an </span><b><span class="deltaxml-new" style="background:#90EE90">entry</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">EnumerationType</span></b><span class="deltaxml-new" style="background:#90EE90"> accepts a fixed set of string values.</span></p></dd><dt><a href="#dt-environment-variables"><span class="deltaxml-new" style="background:#90EE90">environment variables</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Environment variables.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from names to values. Both the names and the values are strings. The names are compared using an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> collation, and are unique under this collation. The set of environment variables is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be empty.</span></p></dd><dt><a href="#dt-equivalent-grouping-keys"><span class="deltaxml-new" style="background:#90EE90">equivalent grouping keys</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Two tuples </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> have </span><b><span class="deltaxml-new" style="background:#90EE90">equivalent grouping keys</span></b><span class="deltaxml-new" style="background:#90EE90"> if and only if, for each grouping variable </span><var><span class="deltaxml-new" style="background:#90EE90">GV</span></var><span class="deltaxml-new" style="background:#90EE90">, the atomized value of </span><var><span class="deltaxml-new" style="background:#90EE90">GV</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> is deep-equal to the atomized value of </span><var><span class="deltaxml-new" style="background:#90EE90">GV</span></var><span class="deltaxml-new" style="background:#90EE90"> in </span><var><span class="deltaxml-new" style="background:#90EE90">T</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, as defined by applying the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> using the appropriate collation.</span></p></dd><dt><a href="#dt-error-value"><span class="deltaxml-new" style="background:#90EE90">error value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called </span><b><span class="deltaxml-new" style="background:#90EE90">error values</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-executable-base-uri"><span class="deltaxml-new" style="background:#90EE90">Executable Base URI</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Executable Base URI.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is an absolute URI used to resolve relative URIs during the evaluation of expressions; it is used, for example, to resolve a relative URI supplied to the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:doc</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-text</span></code><span class="deltaxml-new" style="background:#90EE90"> functions. </span></p></dd><dt><a href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></b><span class="deltaxml-new" style="background:#90EE90"> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.</span></p></dd><dt><a href="#id-static-decimal-format-exponent-separator"><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used to separate the mantissa from the exponent in scientific notation both in the picture string and in the formatted number; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0065</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">LATIN SMALL LETTER E</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">e</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#dt-expression-context"><span class="deltaxml-new" style="background:#90EE90">expression context</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">expression context</span></b><span class="deltaxml-new" style="background:#90EE90"> for a given expression consists of all the information that can affect the result of the expression.</span></p></dd><dt><a href="#dt-extension-expression"><span class="deltaxml-new" style="background:#90EE90">extension expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">extension expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression whose semantics are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-external-function"><span class="deltaxml-new" style="background:#90EE90">external function</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">External functions</span></b><span class="deltaxml-new" style="background:#90EE90"> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. In XSLT, external functions are called </span><a href="https://www.w3.org/TR/xslt-30/#extension-functions"><span class="deltaxml-new" style="background:#90EE90">Section 24.1 Extension Functions </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XT30</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a href="#dt-filter-expression"><span class="deltaxml-new" style="background:#90EE90">filter expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> A </span><b><span class="deltaxml-new" style="background:#90EE90">filter expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression in the form </span><code><span class="deltaxml-new" style="background:#90EE90">E1[E2]</span></code><span class="deltaxml-new" style="background:#90EE90">: its effect is to return those items from the value of </span><code><span class="deltaxml-new" style="background:#90EE90">E1</span></code><span class="deltaxml-new" style="background:#90EE90"> that satisfy the predicate in E2.</span></p></dd><dt><a href="#dt-fixed-focus"><span class="deltaxml-new" style="background:#90EE90">fixed focus</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">fixed focus</span></b><span class="deltaxml-new" style="background:#90EE90"> is a focus for an expression that is evaluated once, rather than being applied to a series of values; in a fixed focus, the context value is set to one specific value, the context position is 1, and the context size is 1.</span></p></dd><dt><a href="#dt-focus"><span class="deltaxml-new" style="background:#90EE90">focus</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The first three components of the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90"> (context value, context position, and context size) are called the </span><b><span class="deltaxml-new" style="background:#90EE90">focus</span></b><span class="deltaxml-new" style="background:#90EE90"> of the expression. </span></p></dd><dt><a href="#dt-focus-function"><span class="deltaxml-new" style="background:#90EE90">focus function</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">focus function</span></b><span class="deltaxml-new" style="background:#90EE90"> is an inline function expression in which the function signature is implicit: the function takes a single argument of type </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90"> (that is, any value), and binds this to the context value when evaluating the function body, which returns a result of type </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-function-assertion"><span class="deltaxml-new" style="background:#90EE90">function assertion</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> A </span><b><span class="deltaxml-new" style="background:#90EE90">function assertion</span></b><span class="deltaxml-new" style="background:#90EE90"> is a predicate that restricts the set of functions matched by a FunctionTest. It uses the same syntax as </span><a href="#id-annotations"><b><span class="deltaxml-new" style="background:#90EE90">5.15 Annotations</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-function-coercion"><span class="deltaxml-new" style="background:#90EE90">function coercion</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Function coercion</span></b><span class="deltaxml-new" style="background:#90EE90"> wraps a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90"> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.</span></p></dd><dt><a href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">function definition</span></b><span class="deltaxml-new" style="background:#90EE90"> contains information used to evaluate a static function call, including the name, parameters, and return type of the function.</span></p></dd><dt><a href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">function item</span></b><span class="deltaxml-new" style="background:#90EE90"> is an item that can be called using a </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-call"><span class="deltaxml-new" style="background:#90EE90">dynamic function call</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-generalized-atomic-type"><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">generalized atomic type</span></b><span class="deltaxml-new" style="background:#90EE90"> is an item type whose instances are all atomic items. Generalized atomic types include (a) </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic types</span></a><span class="deltaxml-new" style="background:#90EE90">, either built-in (for example </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">) or imported from a schema, (b) </span><a title="pure union type" class="termref" href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union types</span></a><span class="deltaxml-new" style="background:#90EE90">, either built-in (</span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90">) or imported from a schema, (c) </span><a title="choice item type" class="termref" href="#dt-choice-item-type"><span class="deltaxml-new" style="background:#90EE90">choice item types</span></a><span class="deltaxml-new" style="background:#90EE90"> if their alternatives are all generalized atomic types, and (d) </span><a title="enumeration type" class="termref" href="#dt-enumeration-type"><span class="deltaxml-new" style="background:#90EE90">enumeration types</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a href="#dt-gregorian"><span class="deltaxml-new" style="background:#90EE90">Gregorian</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In the operator mapping tables, the term </span><b><span class="deltaxml-new" style="background:#90EE90">Gregorian</span></b><span class="deltaxml-new" style="background:#90EE90"> refers to the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gYearMonth</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gYear</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gMonthDay</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gDay</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:gMonth</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-grouping-key"><span class="deltaxml-new" style="background:#90EE90">grouping key</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The atomized value of a </span><a title="grouping variable" class="termref" href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90"> is called a </span><b><span class="deltaxml-new" style="background:#90EE90">grouping key</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#id-static-decimal-format-grouping-separator"><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character typically used as a thousands separator, both in the picture string and in the formatted number; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+002C</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">COMMA</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">,</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#dt-grouping-variable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Each grouping specification specifies one </span><a href="#doc-xpath40-GroupingVariable"><span class="deltaxml-new" style="background:#90EE90">grouping variable</span></a><span class="deltaxml-new" style="background:#90EE90">, which refers to variable bindings in the pre-grouping tuples. The values of the grouping variables are used to assign pre-grouping tuples to groups.</span></p></dd><dt><a href="#dt-guarded"><span class="deltaxml-new" style="background:#90EE90">guarded</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An expression </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is said to be </span><b><span class="deltaxml-new" style="background:#90EE90">guarded</span></b><span class="deltaxml-new" style="background:#90EE90"> by some governing condition </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> if evaluation of </span><var><span class="deltaxml-new" style="background:#90EE90">E</span></var><span class="deltaxml-new" style="background:#90EE90"> is not allowed to fail with a </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic error</span></a><span class="deltaxml-new" style="background:#90EE90"> except when </span><var><span class="deltaxml-new" style="background:#90EE90">C</span></var><span class="deltaxml-new" style="background:#90EE90"> applies.</span></p></dd><dt><a href="#dt-host-language"><span class="deltaxml-new" style="background:#90EE90">host language</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> A </span><b><span class="deltaxml-new" style="background:#90EE90">host language</span></b><span class="deltaxml-new" style="background:#90EE90"> for XPath is any environment that provides capabilities for XPath expressions to be defined and evaluated, and that supplies a static and dynamic context for their evaluation. </span></p></dd><dt><a href="#IgnorableWhitespace"><span class="deltaxml-new" style="background:#90EE90">ignorable whitespace</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Ignorable whitespace</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of any </span><a title="whitespace" class="termref" href="#Whitespace"><span class="deltaxml-new" style="background:#90EE90">whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> characters that may occur between </span><a title="terminal" class="termref" href="#terminal"><span class="deltaxml-new" style="background:#90EE90">terminals</span></a><span class="deltaxml-new" style="background:#90EE90">, unless these characters occur in the context of a production marked with a </span><a href="#ExplicitWhitespaceHandling"><span class="deltaxml-new" style="background:#90EE90"> ws:explicit</span></a><span class="deltaxml-new" style="background:#90EE90"> annotation, in which case they can occur only where explicitly specified (see </span><a href="#ExplicitWhitespaceHandling"><b><span class="deltaxml-new" style="background:#90EE90">A.3.5.2 Explicit Whitespace Handling</span></b></a><span class="deltaxml-new" style="background:#90EE90">).</span></p></dd><dt><a href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Certain expressions, while not erroneous, are classified as being </span><b><span class="deltaxml-new" style="background:#90EE90">implausible</span></b><span class="deltaxml-new" style="background:#90EE90">, because they achieve no useful effect.</span></p></dd><dt><a href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation defined</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Implementation-defined</span></b><span class="deltaxml-new" style="background:#90EE90"> indicates an aspect that may differ between implementations, but must be specified by the implementor for each particular implementation.</span></p></dd><dt><a href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation dependent</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Implementation-dependent</span></b><span class="deltaxml-new" style="background:#90EE90"> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementor for any particular implementation.</span></p></dd><dt><a href="#dt-timezone"><span class="deltaxml-new" style="background:#90EE90">implicit timezone</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Implicit timezone.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or arithmetic operation. The implicit timezone is an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90">. See </span><a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones"><span class="deltaxml-new" style="background:#90EE90">Section 3.2.7.3 Timezones </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="https://www.w3.org/TR/xmlschema11-2/#dateTime"><span class="deltaxml-new" style="background:#90EE90">Section 3.3.7 dateTime </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-2</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> for the range of valid values of a timezone.</span></p></dd><dt><a href="#id-static-decimal-format-infinity"><span class="deltaxml-new" style="background:#90EE90">infinity</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">infinity</span></b><span class="deltaxml-new" style="background:#90EE90"> is the string used to represent the double value infinity (</span><code><span class="deltaxml-new" style="background:#90EE90">INF</span></code><span class="deltaxml-new" style="background:#90EE90">); the default value is the string </span><code><span class="deltaxml-new" style="background:#90EE90">"Infinity"</span></code></p></dd><dt><a href="#dt-initial-context-value"><span class="deltaxml-new" style="background:#90EE90">initial context value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> In the dynamic context of every module in a query, the context value component must have the same setting. If this shared setting is not </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent"><span class="deltaxml-new" style="background:#90EE90">absent</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">, it is referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">initial context value</span></b><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a href="#dt-initializing-expression"><span class="deltaxml-new" style="background:#90EE90">initializing expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If a variable declaration includes an expression (</span><code><span class="deltaxml-new" style="background:#90EE90">VarValue</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">VarDefaultValue</span></code><span class="deltaxml-new" style="background:#90EE90">), the expression is called an </span><b><span class="deltaxml-new" style="background:#90EE90">initializing expression.</span></b><span class="deltaxml-new" style="background:#90EE90"> The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog, other than the variable being declared.</span></p></dd><dt><a href="#dt-inline-func"><span class="deltaxml-new" style="background:#90EE90">inline function expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">inline function expression</span></b><span><span class="deltaxml-new" style="background:#90EE90">, when evaluated,</span></span><span class="deltaxml-new" style="background:#90EE90"> creates an </span><a title="anonymous function" class="termref" href="#dt-anonymous-function"><span class="deltaxml-new" style="background:#90EE90">anonymous function</span></a><span class="deltaxml-new" style="background:#90EE90"> defined directly in the inline function expression.</span></p></dd><dt><a href="#dt-is-attrs"><span class="deltaxml-new" style="background:#90EE90">in-scope attribute declarations</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">In-scope attribute declarations.</span></b><span class="deltaxml-new" style="background:#90EE90"> Each attribute declaration is identified either by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (for a top-level attribute declaration) or by an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> attribute identifier (for a local attribute declaration). </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="schema aware feature" class="termref" href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, in-scope attribute declarations include all attribute declarations found in imported schemas.</span></span></span></p></dd><dt><a href="#dt-is-elems"><span class="deltaxml-new" style="background:#90EE90">in-scope element declarations</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">In-scope element declarations.</span></b><span class="deltaxml-new" style="background:#90EE90"> Each element declaration is identified either by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (for a top-level element declaration) or by an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> element identifier (for a local element declaration). </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90"> If the </span><a title="schema aware feature" class="termref" href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, in-scope element declarations include all element declarations found in imported schemas. </span></span></span></p></dd><dt><a href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">In-scope named item types.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> to </span><a title="named item type" class="termref" href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item types</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-in-scope-namespaces"><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">in-scope namespaces</span></b><span class="deltaxml-new" style="background:#90EE90"> property of an element node is a set of namespace bindings, each of which associates a namespace prefix with a URI.</span></p></dd><dt><a href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">In-scope schema definitions</span></b><span class="deltaxml-new" style="background:#90EE90"> is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.</span></p></dd><dt><a href="#dt-is-types"><span class="deltaxml-new" style="background:#90EE90">in-scope schema type</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">In-scope schema types.</span></b><span class="deltaxml-new" style="background:#90EE90"> Each schema type definition is identified either by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> (for a </span><b><span class="deltaxml-new" style="background:#90EE90">named type</span></b><span class="deltaxml-new" style="background:#90EE90">) or by an </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90"> type identifier (for an </span><b><span class="deltaxml-new" style="background:#90EE90">anonymous type</span></b><span class="deltaxml-new" style="background:#90EE90">). The in-scope schema types include the predefined schema types described in </span><a href="#id-predefined-types"><b><span class="deltaxml-new" style="background:#90EE90">3.5 Schema Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">. </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">If the </span><a title="schema aware feature" class="termref" href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></a><span class="deltaxml-new" style="background:#90EE90"> is supported, in-scope schema types also include all type definitions found in imported schemas.</span></span></span></p></dd><dt><a href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">In-scope variables.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> to type. It defines the set of variables that are available for reference within an expression. The </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is the name of the variable, and the type is the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of the variable.</span></p></dd><dt><a href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">item</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An </span><b><span class="deltaxml-new" style="background:#90EE90">item</span></b><span class="deltaxml-new" style="background:#90EE90"> is either an </span><a title="atomic item" class="termref" href="#dt-atomic-item"><span class="deltaxml-new" style="background:#90EE90">atomic item</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><a title="node" class="termref" href="#dt-node"><span class="deltaxml-new" style="background:#90EE90">node</span></a><span class="deltaxml-new" style="background:#90EE90">, or a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a type that can be expressed using the </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax, which forms part of the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax. Item types match individual </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-item-type-designator"><span class="deltaxml-new" style="background:#90EE90">item type designator</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">item type designator</span></b><span class="deltaxml-new" style="background:#90EE90"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xpath40-ItemType"><span class="deltaxml-new" style="background:#90EE90">ItemType</span></a><span class="deltaxml-new" style="background:#90EE90">. An item type designator is said to </span><b><span class="deltaxml-new" style="background:#90EE90">designate</span></b><span class="deltaxml-new" style="background:#90EE90"> an </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-kind-test"><span class="deltaxml-new" style="background:#90EE90">kind test</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An alternative form of a node test called a </span><b><span class="deltaxml-new" style="background:#90EE90">kind test</span></b><span class="deltaxml-new" style="background:#90EE90"> can select nodes based on their kind, name, and </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-qname"><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">lexical QName</span></b><span class="deltaxml-new" style="background:#90EE90"> is a name that conforms to the syntax of the </span><a href="#doc-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><span class="deltaxml-new" style="background:#90EE90"> production</span></p></dd><dt><a href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A module that does not contain a </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a><span class="deltaxml-new" style="background:#90EE90"> is called a </span><b><span class="deltaxml-new" style="background:#90EE90">library module</span></b><span class="deltaxml-new" style="background:#90EE90">. A library module consists of a </span><a title="module declaration" class="termref" href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-literal"><span class="deltaxml-new" style="background:#90EE90">literal</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">literal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a direct syntactic representation of an atomic item.</span></p></dd><dt><a href="#dt-literal-terminal"><span class="deltaxml-new" style="background:#90EE90">literal terminal</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">literal terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a token appearing as a string in quotation marks on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-main-module"><span class="deltaxml-new" style="background:#90EE90">main module</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">main module</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of a </span><a title="Prolog" class="termref" href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a><span class="deltaxml-new" style="background:#90EE90"> followed by a </span><a title="query body" class="termref" href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">Query Body</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-map"><span class="deltaxml-new" style="background:#90EE90">map</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">map</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function that associates a set of keys with values, resulting in a collection of key / value pairs.</span></p></dd><dt><a href="#dt-mapping-arrow-operator"><span class="deltaxml-new" style="background:#90EE90">mapping arrow operator</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The </span><b><span class="deltaxml-new" style="background:#90EE90">mapping arrow operator</span></b><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> applies a function to each item in a sequence.</span></p></dd><dt><a href="#may"><span class="deltaxml-new" style="background:#90EE90">may</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">MAY</span></b><span class="deltaxml-new" style="background:#90EE90"> means that an item is truly optional.</span></p></dd><dt><a href="#dt-member"><span class="deltaxml-new" style="background:#90EE90">member</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The values of an array are called its </span><b><span class="deltaxml-new" style="background:#90EE90">members</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#id-static-decimal-format-minus-sign"><span class="deltaxml-new" style="background:#90EE90">minus-sign</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">minus-sign</span></b><span class="deltaxml-new" style="background:#90EE90"> is the single character used to mark negative numbers; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+002D</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">HYPHEN-MINUS</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">-</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">module</span></b><span class="deltaxml-new" style="background:#90EE90"> is a fragment of XQuery code that conforms to the </span><a href="#doc-xpath40-Module"><span class="deltaxml-new" style="background:#90EE90">Module</span></a><span class="deltaxml-new" style="background:#90EE90"> grammar and can independently undergo the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90"> described in </span><a href="#id-expression-processing"><b><span class="deltaxml-new" style="background:#90EE90">2.3.3 Expression Processing</span></b></a><span class="deltaxml-new" style="background:#90EE90">. Each module is either a </span><a title="main module" class="termref" href="#dt-main-module"><span class="deltaxml-new" style="background:#90EE90">main module</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-module-context"><span class="deltaxml-new" style="background:#90EE90">module context</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">module context</span></b><span class="deltaxml-new" style="background:#90EE90"> for a given module consists of all the information that is accessible to top-level expressions in the module.</span></p></dd><dt><a href="#dt-module-declaration"><span class="deltaxml-new" style="background:#90EE90">module declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">module declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> serves to identify a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> as a </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library module</span></a><span class="deltaxml-new" style="background:#90EE90">. A module declaration begins with the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">module</span></code><span class="deltaxml-new" style="background:#90EE90"> and contains a namespace prefix and a </span><a href="#doc-xpath40-URILiteral"><span class="deltaxml-new" style="background:#90EE90">URILiteral</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-module-feature"><span class="deltaxml-new" style="background:#90EE90">module feature</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">Module Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> allows a query Prolog to contain a </span><b><span class="deltaxml-new" style="background:#90EE90">Module Import</span></b><span class="deltaxml-new" style="background:#90EE90"> and allows </span><b><span class="deltaxml-new" style="background:#90EE90">library modules</span></b><span class="deltaxml-new" style="background:#90EE90"> to be created.</span></p></dd><dt><a href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">module import</span></b><span class="deltaxml-new" style="background:#90EE90"> imports the public variable declarations, public function declarations</span><span><span class="deltaxml-new" style="background:#90EE90">, and public item type declarations</span></span><span class="deltaxml-new" style="background:#90EE90"> from one or more </span><a title="library module" class="termref" href="#dt-library-module"><span class="deltaxml-new" style="background:#90EE90">library modules</span></a><span class="deltaxml-new" style="background:#90EE90"> into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span><span class="deltaxml-new" style="background:#90EE90">, or </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a></span><span class="deltaxml-new" style="background:#90EE90"> of the importing </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#must"><span class="deltaxml-new" style="background:#90EE90">must</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">MUST</span></b><span class="deltaxml-new" style="background:#90EE90"> means that the item is an absolute requirement of the specification.</span></p></dd><dt><a href="#mustnot"><span class="deltaxml-new" style="background:#90EE90">must not</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">MUST NOT</span></b><span class="deltaxml-new" style="background:#90EE90"> means that the item is an absolute prohibition of the specification.</span></p></dd><dt><a href="#dt-named-function-ref"><span class="deltaxml-new" style="background:#90EE90">named function reference</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> A </span><b><span class="deltaxml-new" style="background:#90EE90">named function reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is an expression (written </span><code><span class="deltaxml-new" style="background:#90EE90">name#arity</span></code><span class="deltaxml-new" style="background:#90EE90">) which evaluates to a </span><a title="function item" class="termref" href="#dt-function-item"><span class="deltaxml-new" style="background:#90EE90">function item</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><span><span class="deltaxml-new" style="background:#90EE90">the details of the function item being based on the properties of a </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a></span><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-named-item-type"><span class="deltaxml-new" style="background:#90EE90">named item type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">named item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is an </span><code><span class="deltaxml-new" style="background:#90EE90">ItemType</span></code><span class="deltaxml-new" style="background:#90EE90"> identified by an </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-name-expression"><span class="deltaxml-new" style="background:#90EE90">name expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">When an expression is used to specify the name of a constructed node, that expression is called the </span><b><span class="deltaxml-new" style="background:#90EE90">name expression</span></b><span class="deltaxml-new" style="background:#90EE90"> of the constructor.</span></p></dd><dt><a href="#dt-namespace-declaration"><span class="deltaxml-new" style="background:#90EE90">namespace declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">namespace declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> declares a namespace prefix and associates it with a namespace URI, adding the (prefix, URI) pair to the set of </span><a title="statically known namespaces" class="termref" href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-namespace-decl-attr"><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">namespace declaration attribute</span></b><span class="deltaxml-new" style="background:#90EE90"> is used inside a direct element constructor. Its purpose is to bind a namespace prefix </span><span><span class="deltaxml-new" style="background:#90EE90">(including the zero-length prefix)</span></span><span class="deltaxml-new" style="background:#90EE90"> for the constructed element node, including its attributes.</span></p></dd><dt><a href="#dt-namespace-sensitive"><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">namespace-sensitive</span></b><span class="deltaxml-new" style="background:#90EE90"> types are </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90">, types derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:QName</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NOTATION</span></code><span class="deltaxml-new" style="background:#90EE90">, list types that have a namespace-sensitive item type, and union types with a namespace-sensitive type in their transitive membership.</span></p></dd><dt><a href="#dt-name-test"><span class="deltaxml-new" style="background:#90EE90">name test</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A node test that consists only of an EQName or a Wildcard is called a </span><b><span class="deltaxml-new" style="background:#90EE90">name test</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#id-static-decimal-format-NaN"><span class="deltaxml-new" style="background:#90EE90">NaN</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">NaN</span></b><span class="deltaxml-new" style="background:#90EE90"> is the string used to represent the double value </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> (not a number); the default value is the string </span><code><span class="deltaxml-new" style="background:#90EE90">"NaN"</span></code></p></dd><dt><a href="#dt-node"><span class="deltaxml-new" style="background:#90EE90">node</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">node</span></b><span class="deltaxml-new" style="background:#90EE90"> is an instance of one of the </span><b><span class="deltaxml-new" style="background:#90EE90">node kinds</span></b><span class="deltaxml-new" style="background:#90EE90"> defined in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#Node"><span class="deltaxml-new" style="background:#90EE90">Section 5 Nodes</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-node-test"><span class="deltaxml-new" style="background:#90EE90">node test</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">node test</span></b><span class="deltaxml-new" style="background:#90EE90"> is a condition on the name, kind (element, attribute, text, document, comment, or processing instruction), and/or </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of a node. A node test determines which nodes contained by an axis are selected by a </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-new" style="background:#90EE90">step</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#non-delimiting-token"><span class="deltaxml-new" style="background:#90EE90">non-delimiting terminal symbol</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">non-delimiting terminal symbols</span></b><span class="deltaxml-new" style="background:#90EE90"> are: </span><code><span class="deltaxml-new" style="background:#90EE90">allowing</span></code><code><span class="deltaxml-new" style="background:#90EE90">ancestor</span></code><code><span class="deltaxml-new" style="background:#90EE90">ancestor-or-self</span></code><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><code><span class="deltaxml-new" style="background:#90EE90">attribute</span></code><code><span class="deltaxml-new" style="background:#90EE90">base-uri</span></code><code><span class="deltaxml-new" style="background:#90EE90">boundary-space</span></code><code><span class="deltaxml-new" style="background:#90EE90">by</span></code><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><code><span class="deltaxml-new" style="background:#90EE90">cast</span></code><code><span class="deltaxml-new" style="background:#90EE90">castable</span></code><code><span class="deltaxml-new" style="background:#90EE90">catch</span></code><code><span class="deltaxml-new" style="background:#90EE90">child</span></code><code><span class="deltaxml-new" style="background:#90EE90">collation</span></code><code><span class="deltaxml-new" style="background:#90EE90">comment</span></code><code><span class="deltaxml-new" style="background:#90EE90">construction</span></code><code><span class="deltaxml-new" style="background:#90EE90">context</span></code><code><span class="deltaxml-new" style="background:#90EE90">copy-namespaces</span></code><code><span class="deltaxml-new" style="background:#90EE90">count</span></code><code><span class="deltaxml-new" style="background:#90EE90">decimal-format</span></code><code><span class="deltaxml-new" style="background:#90EE90">decimal-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">declare</span></code><code><span class="deltaxml-new" style="background:#90EE90">default</span></code><code><span class="deltaxml-new" style="background:#90EE90">descendant</span></code><code><span class="deltaxml-new" style="background:#90EE90">descendant-or-self</span></code><code><span class="deltaxml-new" style="background:#90EE90">digit</span></code><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><code><span class="deltaxml-new" style="background:#90EE90">document</span></code><code><span class="deltaxml-new" style="background:#90EE90">document-node</span></code><code><span class="deltaxml-new" style="background:#90EE90">element</span></code><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><code><span class="deltaxml-new" style="background:#90EE90">empty</span></code><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence</span></code><code><span class="deltaxml-new" style="background:#90EE90">encoding</span></code><code><span class="deltaxml-new" style="background:#90EE90">end</span></code><code><span class="deltaxml-new" style="background:#90EE90">enum</span></code><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><code><span class="deltaxml-new" style="background:#90EE90">every</span></code><code><span class="deltaxml-new" style="background:#90EE90">except</span></code><code><span class="deltaxml-new" style="background:#90EE90">exponent-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><code><span class="deltaxml-new" style="background:#90EE90">fixed</span></code><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><code><span class="deltaxml-new" style="background:#90EE90">following</span></code><code><span class="deltaxml-new" style="background:#90EE90">following-sibling</span></code><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><code><span class="deltaxml-new" style="background:#90EE90">group</span></code><code><span class="deltaxml-new" style="background:#90EE90">grouping-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><code><span class="deltaxml-new" style="background:#90EE90">idiv</span></code><code><span class="deltaxml-new" style="background:#90EE90">if</span></code><code><span class="deltaxml-new" style="background:#90EE90">import</span></code><code><span class="deltaxml-new" style="background:#90EE90">in</span></code><code><span class="deltaxml-new" style="background:#90EE90">infinity</span></code><code><span class="deltaxml-new" style="background:#90EE90">inherit</span></code><code><span class="deltaxml-new" style="background:#90EE90">instance</span></code><code><span class="deltaxml-new" style="background:#90EE90">intersect</span></code><code><span class="deltaxml-new" style="background:#90EE90">is</span></code><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><code><span class="deltaxml-new" style="background:#90EE90">item-type</span></code><code><span class="deltaxml-new" style="background:#90EE90">items</span></code><code><span class="deltaxml-new" style="background:#90EE90">key</span></code><code><span class="deltaxml-new" style="background:#90EE90">keys</span></code><code><span class="deltaxml-new" style="background:#90EE90">lax</span></code><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><code><span class="deltaxml-new" style="background:#90EE90">member</span></code><code><span class="deltaxml-new" style="background:#90EE90">minus-sign</span></code><code><span class="deltaxml-new" style="background:#90EE90">mod</span></code><code><span class="deltaxml-new" style="background:#90EE90">module</span></code><code><span class="deltaxml-new" style="background:#90EE90">namespace</span></code><code><span class="deltaxml-new" style="background:#90EE90">namespace-node</span></code><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><code><span class="deltaxml-new" style="background:#90EE90">next</span></code><code><span class="deltaxml-new" style="background:#90EE90">no-inherit</span></code><code><span class="deltaxml-new" style="background:#90EE90">no-preserve</span></code><code><span class="deltaxml-new" style="background:#90EE90">node</span></code><code><span class="deltaxml-new" style="background:#90EE90">of</span></code><code><span class="deltaxml-new" style="background:#90EE90">only</span></code><code><span class="deltaxml-new" style="background:#90EE90">option</span></code><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><code><span class="deltaxml-new" style="background:#90EE90">order</span></code><code><span class="deltaxml-new" style="background:#90EE90">ordered</span></code><code><span class="deltaxml-new" style="background:#90EE90">ordering</span></code><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><code><span class="deltaxml-new" style="background:#90EE90">pairs</span></code><code><span class="deltaxml-new" style="background:#90EE90">parent</span></code><code><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></code><code><span class="deltaxml-new" style="background:#90EE90">per-mille</span></code><code><span class="deltaxml-new" style="background:#90EE90">percent</span></code><code><span class="deltaxml-new" style="background:#90EE90">preceding</span></code><code><span class="deltaxml-new" style="background:#90EE90">preceding-sibling</span></code><code><span class="deltaxml-new" style="background:#90EE90">preserve</span></code><code><span class="deltaxml-new" style="background:#90EE90">previous</span></code><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction</span></code><code><span class="deltaxml-new" style="background:#90EE90">record</span></code><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><code><span class="deltaxml-new" style="background:#90EE90">satisfies</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema-attribute</span></code><code><span class="deltaxml-new" style="background:#90EE90">schema-element</span></code><code><span class="deltaxml-new" style="background:#90EE90">self</span></code><code><span class="deltaxml-new" style="background:#90EE90">sliding</span></code><code><span class="deltaxml-new" style="background:#90EE90">some</span></code><code><span class="deltaxml-new" style="background:#90EE90">stable</span></code><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><code><span class="deltaxml-new" style="background:#90EE90">strict</span></code><code><span class="deltaxml-new" style="background:#90EE90">strip</span></code><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code><code><span class="deltaxml-new" style="background:#90EE90">text</span></code><code><span class="deltaxml-new" style="background:#90EE90">then</span></code><code><span class="deltaxml-new" style="background:#90EE90">to</span></code><code><span class="deltaxml-new" style="background:#90EE90">treat</span></code><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><code><span class="deltaxml-new" style="background:#90EE90">try</span></code><code><span class="deltaxml-new" style="background:#90EE90">tumbling</span></code><code><span class="deltaxml-new" style="background:#90EE90">type</span></code><code><span class="deltaxml-new" style="background:#90EE90">typeswitch</span></code><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><code><span class="deltaxml-new" style="background:#90EE90">unordered</span></code><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><code><span class="deltaxml-new" style="background:#90EE90">value</span></code><code><span class="deltaxml-new" style="background:#90EE90">values</span></code><code><span class="deltaxml-new" style="background:#90EE90">variable</span></code><code><span class="deltaxml-new" style="background:#90EE90">version</span></code><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><code><span class="deltaxml-new" style="background:#90EE90">where</span></code><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><code><span class="deltaxml-new" style="background:#90EE90">window</span></code><code><span class="deltaxml-new" style="background:#90EE90">xquery</span></code><code><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></code><code><span class="deltaxml-new" style="background:#90EE90">ascending</span></code><a href="#prod-xpath40-BinaryIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">BinaryIntegerLiteral</span></a><a href="#prod-xpath40-DecimalLiteral"><span class="deltaxml-new" style="background:#90EE90">DecimalLiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">descending</span></code><a href="#prod-xpath40-DoubleLiteral"><span class="deltaxml-new" style="background:#90EE90">DoubleLiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">external</span></code><code><span class="deltaxml-new" style="background:#90EE90">greatest</span></code><a href="#prod-xpath40-HexIntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">HexIntegerLiteral</span></a><a href="#prod-xpath40-IntegerLiteral"><span class="deltaxml-new" style="background:#90EE90">IntegerLiteral</span></a><code><span class="deltaxml-new" style="background:#90EE90">least</span></code><a href="#prod-xpath40-NCName"><span class="deltaxml-new" style="background:#90EE90">NCName</span></a><a href="#prod-xpath40-QName"><span class="deltaxml-new" style="background:#90EE90">QName</span></a><a href="#prod-xpath40-URIQualifiedName"><span class="deltaxml-new" style="background:#90EE90">URIQualifiedName</span></a></p></dd><dt><a href="#dt-numeric"><span class="deltaxml-new" style="background:#90EE90">numeric</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">When referring to a type, the term </span><b><span class="deltaxml-new" style="background:#90EE90">numeric</span></b><span class="deltaxml-new" style="background:#90EE90"> denotes the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> which are all member types of the built-in union type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-numeric-predicate"><span class="deltaxml-new" style="background:#90EE90">numeric predicate</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A predicate whose predicate expression returns a value of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:numeric+</span></code><span class="deltaxml-new" style="background:#90EE90"> is called a </span><b><span class="deltaxml-new" style="background:#90EE90">numeric predicate</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-operator-function"><span class="deltaxml-new" style="background:#90EE90">operator function</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an expression that invokes an </span><b><span class="deltaxml-new" style="background:#90EE90">operator function</span></b><span class="deltaxml-new" style="background:#90EE90">; the operator function implements the semantics of the operator for the given types.</span></p></dd><dt><a href="#dt-option-declaration"><span class="deltaxml-new" style="background:#90EE90">option declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">option declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> declares an option that affects the behavior of a particular implementation. Each option consists of an identifying EQName and a StringLiteral.</span></p></dd><dt><a href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></b><span class="deltaxml-new" style="background:#90EE90"> is a production rule in </span><a href="#id-grammar"><b><span class="deltaxml-new" style="background:#90EE90">A.1 EBNF</span></b></a><span class="deltaxml-new" style="background:#90EE90"> that is not annotated </span><code><span class="deltaxml-new" style="background:#90EE90">ws:explicit</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-output-declaration"><span class="deltaxml-new" style="background:#90EE90">output declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">output declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> is an option declaration in the namespace </span><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2010/xslt-xquery-serialization</span></code><span class="deltaxml-new" style="background:#90EE90">; it is used to declare serialization parameters.</span></p></dd><dt><a href="#dt-partial-function-application"><span class="deltaxml-new" style="background:#90EE90">partial function application</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> A static or </span><a title="dynamic function call" class="termref" href="#dt-dynamic-function-invocation"><span class="deltaxml-new" style="background:#90EE90">dynamic</span></a><span class="deltaxml-new" style="background:#90EE90"> function call is a </span><b><span class="deltaxml-new" style="background:#90EE90">partial function application</span></b><span class="deltaxml-new" style="background:#90EE90"> if one or more arguments is an </span><a href="#doc-xpath40-ArgumentPlaceholder"><span class="deltaxml-new" style="background:#90EE90">ArgumentPlaceholder</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-partially-applied-function"><span class="deltaxml-new" style="background:#90EE90">partially applied function</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">partially applied function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function created by </span><a title="partial function application" class="termref" href="#dt-partial-function-application"><span class="deltaxml-new" style="background:#90EE90">partial function application</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-path-expression"><span class="deltaxml-new" style="background:#90EE90">path expression</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A path expression consists of a series of one or more </span><a title="step" class="termref" href="#dt-step"><span class="deltaxml-new" style="background:#90EE90">steps</span></a><span class="deltaxml-new" style="background:#90EE90">, separated by </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90">, and optionally beginning with </span><code><span class="deltaxml-new" style="background:#90EE90">/</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">//</span></code><span class="deltaxml-new" style="background:#90EE90">. A </span><b><span class="deltaxml-new" style="background:#90EE90">path expression</span></b><span class="deltaxml-new" style="background:#90EE90"> is typically used to locate nodes within trees. </span></p></dd><dt><a href="#id-static-decimal-format-pattern-separator"><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">pattern-separator</span></b><span class="deltaxml-new" style="background:#90EE90"> is a character used to separate positive and negative sub-pictures in a picture string; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+003B</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">SEMICOLON</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">;</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#id-static-decimal-format-percent"><span class="deltaxml-new" style="background:#90EE90">percent</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">percent</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-hundred fraction; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0025</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">PERCENT SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">%</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#id-static-decimal-format-per-mille"><span class="deltaxml-new" style="background:#90EE90">per-mille</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">per-mille</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+2030</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">PER MILLE SIGN</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">‰</span></code><span class="deltaxml-new" style="background:#90EE90">) .</span></p></dd><dt><a href="#dt-positional-variable"><span class="deltaxml-new" style="background:#90EE90">positional variable</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">positional variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is a variable that is preceded by the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">at</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-pragma"><span class="deltaxml-new" style="background:#90EE90">pragma</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">pragma</span></b><span class="deltaxml-new" style="background:#90EE90"> is denoted by the delimiters </span><code><span class="deltaxml-new" style="background:#90EE90">(#</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">#)</span></code><span class="deltaxml-new" style="background:#90EE90">, and consists of an identifying EQName followed by </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> content.</span></p></dd><dt><a href="#dt-predefined-entity-reference"><span class="deltaxml-new" style="background:#90EE90">predefined entity reference</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">predefined entity reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.</span></p></dd><dt><a href="#dt-predicate-truth-value"><span class="deltaxml-new" style="background:#90EE90">predicate truth value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">predicate truth value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a value </span><code><span class="deltaxml-new" style="background:#90EE90">$V</span></code><span class="deltaxml-new" style="background:#90EE90"> is the result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">if ($V instance of xs:numeric+) then ($V = position()) else fn:boolean($V)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-primary-expression"><span class="deltaxml-new" style="background:#90EE90">primary expression</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Primary expressions</span></b><span class="deltaxml-new" style="background:#90EE90"> are the basic primitives of the language. They include literals, variable references, context value references, </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">constructors, </span></span></span><span class="deltaxml-new" style="background:#90EE90"> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</span></p></dd><dt><a href="#dt-principal-node-kind"><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Every axis has a </span><b><span class="deltaxml-new" style="background:#90EE90">principal node kind</span></b><span class="deltaxml-new" style="background:#90EE90">. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.</span></p></dd><dt><a href="#dt-private-function"><span class="deltaxml-new" style="background:#90EE90">private function</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">private function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function with a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A private function is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can not import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. </span></p></dd><dt><a href="#dt-private-item-type"><span class="deltaxml-new" style="background:#90EE90">private item type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">private item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a named item type with a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A private item type is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can not import it into the </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. </span></p></dd><dt><a href="#dt-private-variable"><span class="deltaxml-new" style="background:#90EE90">private variable</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">private variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is a variable with a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A private variable is hidden from </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can not import it into the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module.</span></p></dd><dt><a href="#dt-prolog"><span class="deltaxml-new" style="background:#90EE90">Prolog</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">Prolog</span></b><span class="deltaxml-new" style="background:#90EE90"> is a series of declarations and imports that define the processing environment for the </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90"> that contains the Prolog.</span></p></dd><dt><a href="#dt-public-function"><span class="deltaxml-new" style="background:#90EE90">public function</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">public function</span></b><span class="deltaxml-new" style="background:#90EE90"> is a function without a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A public function is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can import it into the </span><a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. </span></p></dd><dt><a href="#dt-public-item-type"><span class="deltaxml-new" style="background:#90EE90">public item type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">public item type</span></b><span class="deltaxml-new" style="background:#90EE90"> is an item type declaration without a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A public item type is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can import it into the </span><a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types"><span class="deltaxml-new" style="background:#90EE90">in-scope named item types</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. </span></p></dd><dt><a href="#dt-public-variable"><span class="deltaxml-new" style="background:#90EE90">public variable</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">public variable</span></b><span class="deltaxml-new" style="background:#90EE90"> is a variable without a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation. A public variable is accessible to </span><a title="module import" class="termref" href="#dt-module-import"><span class="deltaxml-new" style="background:#90EE90">module import</span></a><span class="deltaxml-new" style="background:#90EE90">, which can import it into the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> of another module. Using </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a><span class="deltaxml-new" style="background:#90EE90"> [</span><a href="#ERRXQST0116" title="err:XQST0116"><span class="deltaxml-new" style="background:#90EE90">err:XQST0116</span></a><span class="deltaxml-new" style="background:#90EE90">] if a variable declaration contains both a </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> and a </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%private</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation, or more than one </span><code><span class="deltaxml-new" style="background:#90EE90">%public</span></code><span class="deltaxml-new" style="background:#90EE90"> annotation.</span></p></dd><dt><a href="#dt-pure-union-type"><span class="deltaxml-new" style="background:#90EE90">pure union type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">pure union type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><span><b><span class="deltaxml-new" style="background:#90EE90">simple type</span></b></span><span class="deltaxml-new" style="background:#90EE90"> that satisfies the following constraints: (a) </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90">, (b) the </span><code><span class="deltaxml-new" style="background:#90EE90">{facets}</span></code><span class="deltaxml-new" style="background:#90EE90"> property is empty, (c) no type in the transitive membership of the union type has </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><code><span class="deltaxml-new" style="background:#90EE90">list</span></code><span class="deltaxml-new" style="background:#90EE90">, and (d) no type in the transitive membership of the union type is a type with </span><code><span class="deltaxml-new" style="background:#90EE90">{variety}</span></code><code><span class="deltaxml-new" style="background:#90EE90">union</span></code><span class="deltaxml-new" style="background:#90EE90"> having a non-empty </span><code><span class="deltaxml-new" style="background:#90EE90">{facets}</span></code><span class="deltaxml-new" style="background:#90EE90"> property</span></p></dd><dt><a href="#dt-query"><span class="deltaxml-new" style="background:#90EE90">query</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">query</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of one or more </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">modules</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-queryBody"><span class="deltaxml-new" style="background:#90EE90">query body</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">Query Body</span></b><span class="deltaxml-new" style="background:#90EE90">, if present, consists of an expression that defines the result of the query.</span></p></dd><dt><a href="#dt-reserved-namespaces"><span class="deltaxml-new" style="background:#90EE90">reserved namespaces</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">reserved namespace</span></b><span class="deltaxml-new" style="background:#90EE90"> is a namespace that must not be used in the name of a function declaration.</span></p></dd><dt><a href="#dt-resolve-relative-uri"><span class="deltaxml-new" style="background:#90EE90">resolve</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">To </span><b><span class="deltaxml-new" style="background:#90EE90">resolve a relative URI</span></b><code><span class="deltaxml-new" style="background:#90EE90">$rel</span></code><span class="deltaxml-new" style="background:#90EE90"> against a base URI </span><code><span class="deltaxml-new" style="background:#90EE90">$base</span></code><span class="deltaxml-new" style="background:#90EE90"> is to expand it to an absolute URI, as if by calling the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:resolve-uri($rel, $base)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-reverse-document-order"><span class="deltaxml-new" style="background:#90EE90">reverse document order</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The node ordering that is the reverse of document order is called </span><b><span class="deltaxml-new" style="background:#90EE90">reverse document order</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-same-key"><span class="deltaxml-new" style="background:#90EE90">same key</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Two atomic items </span><code><span class="deltaxml-new" style="background:#90EE90">K1</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">K2</span></code><span class="deltaxml-new" style="background:#90EE90"> have the </span><b><span class="deltaxml-new" style="background:#90EE90">same key value</span></b><span class="deltaxml-new" style="background:#90EE90"> if </span><code><span class="deltaxml-new" style="background:#90EE90">fn:atomic-equal(K1, K2)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, as specified in </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-atomic-equal"><span class="deltaxml-new" style="background:#90EE90">Section 13.2.1 fn:atomic-equal</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup></p></dd><dt><a href="#dt-schema-aware-feature"><span class="deltaxml-new" style="background:#90EE90">schema aware feature</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">Schema Aware Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> permits the query Prolog to contain a </span><a title="schema import" class="termref" href="#dt-schema-import"><span class="deltaxml-new" style="background:#90EE90">schema import</span></a><span class="deltaxml-new" style="background:#90EE90">, and permits a query to contain a </span><code><span class="deltaxml-new" style="background:#90EE90">validate</span></code><span class="deltaxml-new" style="background:#90EE90"> expression (see </span><a href="#id-validate"><b><span class="deltaxml-new" style="background:#90EE90">4.24 Validate Expressions</span></b></a><span class="deltaxml-new" style="background:#90EE90">). </span></p></dd><dt><a href="#dt-schema-import"><span class="deltaxml-new" style="background:#90EE90">schema import</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">schema import</span></b><span class="deltaxml-new" style="background:#90EE90"> imports the element declarations, attribute declarations, and type definitions from a schema into the </span><a title="in-scope schema definitions" class="termref" href="#dt-issd"><span class="deltaxml-new" style="background:#90EE90">in-scope schema definitions</span></a><span class="deltaxml-new" style="background:#90EE90">. For each named user-defined simple type in the schema, schema import also adds a corresponding </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor function</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">schema type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a complex type or simple type as defined in the </span><a href="#XMLSchema10"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a href="#XMLSchema11"><span class="deltaxml-new" style="background:#90EE90">[XML Schema 1.1]</span></a><span class="deltaxml-new" style="background:#90EE90"> specifications, including built-in types as well as user-defined types.</span></p></dd><dt><a href="#dt-sequence"><span class="deltaxml-new" style="background:#90EE90">sequence</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">sequence</span></b><span class="deltaxml-new" style="background:#90EE90"> is an ordered collection of zero or more </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-sequence-arrow-operator"><span class="deltaxml-new" style="background:#90EE90">sequence arrow operator</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The </span><b><span class="deltaxml-new" style="background:#90EE90">sequence arrow operator</span></b><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> applies a function to a supplied sequence.</span></p></dd><dt><a href="#dt-sequence-concatenation"><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">sequence concatenation</span></b><span class="deltaxml-new" style="background:#90EE90"> of a number of sequences </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ... </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> is defined to be the sequence formed from the items of </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, followed by the items from </span><var><span class="deltaxml-new" style="background:#90EE90">S</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, and so on, retaining order.</span></p></dd><dt><a href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">sequence type</span></b><span class="deltaxml-new" style="background:#90EE90"> is a type that can be expressed using the </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90"> syntax. Sequence types are used whenever it is necessary to refer to a type in an XQuery 4.0 and XPath 4.0 expression. The term </span><b><span class="deltaxml-new" style="background:#90EE90">sequence type</span></b><span class="deltaxml-new" style="background:#90EE90"> suggests that this syntax is used to describe the type of an XQuery 4.0 and XPath 4.0 value, which is always a sequence.</span></p></dd><dt><a href="#dt-sequence-type-designator"><span class="deltaxml-new" style="background:#90EE90">sequence type designator</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">sequence type designator</span></b><span class="deltaxml-new" style="background:#90EE90"> is a syntactic construct conforming to the grammar rule </span><a href="#doc-xpath40-SequenceType"><span class="deltaxml-new" style="background:#90EE90">SequenceType</span></a><span class="deltaxml-new" style="background:#90EE90">. A sequence type designator is said to </span><b><span class="deltaxml-new" style="background:#90EE90">designate</span></b><span class="deltaxml-new" style="background:#90EE90"> a </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-sequencetype-matching"><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">SequenceType matching</span></b><span class="deltaxml-new" style="background:#90EE90"> compares a value with an expected </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence type</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a href="#dt-serialization"><span class="deltaxml-new" style="background:#90EE90">serialization</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Serialization</span></b><span class="deltaxml-new" style="background:#90EE90"> is the process of converting an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> to a sequence of octets (step DM4 in Figure 1.), as described in </span><a href="#xslt-xquery-serialization-40"><span class="deltaxml-new" style="background:#90EE90">[XSLT and XQuery Serialization 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-serialization-feature"><span class="deltaxml-new" style="background:#90EE90">serialization feature</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">Serialization Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> provides means for serializing the result of a query as specified in </span><a href="#id-serialization"><b><span class="deltaxml-new" style="background:#90EE90">2.3.5 Serialization</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-setter"><span class="deltaxml-new" style="background:#90EE90">setter</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Setters</span></b><span class="deltaxml-new" style="background:#90EE90"> are declarations that set the value of some property that affects query processing, such as construction mode or default collation.</span></p></dd><dt><a href="#should"><span class="deltaxml-new" style="background:#90EE90">should</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">SHOULD</span></b><span class="deltaxml-new" style="background:#90EE90"> means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.</span></p></dd><dt><a href="#dt-singleton"><span class="deltaxml-new" style="background:#90EE90">singleton</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A sequence containing exactly one item is called a </span><b><span class="deltaxml-new" style="background:#90EE90">singleton</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-singleton-focus"><span class="deltaxml-new" style="background:#90EE90">singleton focus</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">singleton focus</span></b><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="fixed focus" class="termref" href="#dt-fixed-focus"><span class="deltaxml-new" style="background:#90EE90">fixed focus</span></a><span class="deltaxml-new" style="background:#90EE90"> in which the </span><a title="context value" class="termref" href="#dt-context-value"><span class="deltaxml-new" style="background:#90EE90">context value</span></a><span class="deltaxml-new" style="background:#90EE90"> is a </span><a title="singleton" class="termref" href="#dt-singleton"><span class="deltaxml-new" style="background:#90EE90">singleton</span></a><span class="deltaxml-new" style="background:#90EE90"> item.</span></p></dd><dt><a href="#stable"><span class="deltaxml-new" style="background:#90EE90">stable</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Document order is </span><b><span class="deltaxml-new" style="background:#90EE90">stable</span></b><span class="deltaxml-new" style="background:#90EE90">, which means that the relative order of two nodes will not change during the processing of a given </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">query</span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">expression</span></span></span><span class="deltaxml-new" style="background:#90EE90">, even if this order is </span><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent"><span class="deltaxml-new" style="background:#90EE90">implementation-dependent</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-static-collations"><span class="deltaxml-new" style="background:#90EE90">statically known collations</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Statically known collations.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is an </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90"> mapping from URI to collation. It defines the names of the collations that are available for use in processing </span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">queries and</span></span></span><span class="deltaxml-new" style="background:#90EE90"> expressions.</span></p></dd><dt><a href="#dt-static-decimal-formats"><span class="deltaxml-new" style="background:#90EE90">statically known decimal formats</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Statically known decimal formats.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from QNames to decimal formats, with one default format that has no visible name, referred to as the unnamed decimal format. Each format is available for use when formatting numbers using the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-number</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p></dd><dt><a href="#dt-statically-known-function-definitions"><span class="deltaxml-new" style="background:#90EE90">statically known function definitions</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Statically known function definitions.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a set of </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definitions</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-static-namespaces"><span class="deltaxml-new" style="background:#90EE90">statically known namespaces</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Statically known namespaces.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is a mapping from prefix to namespace URI that defines all the namespaces that are known during static processing of a given expression.</span></p></dd><dt><a href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></b><span class="deltaxml-new" style="background:#90EE90"> depends on the expression itself and on the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">. The </span><b><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></b><span class="deltaxml-new" style="background:#90EE90"> does not depend on input data (other than schemas).</span></p></dd><dt><a href="#dt-static-base-uri"><span class="deltaxml-new" style="background:#90EE90">Static Base URI</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Static Base URI.</span></b><span class="deltaxml-new" style="background:#90EE90"> This is an absolute URI, used to resolve relative URIs during static analysis. </span></p></dd><dt><a href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">static context</span></b><span class="deltaxml-new" style="background:#90EE90"> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.</span></p></dd><dt><a href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static error</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An error that can be detected during the static analysis phase, and is not a type error, is a </span><b><span class="deltaxml-new" style="background:#90EE90">static error</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-static-function-call"><span class="deltaxml-new" style="background:#90EE90">static function call</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">static function call</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of an EQName followed by a parenthesized list of zero or more arguments.</span></p></dd><dt><a href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">static type</span></b><span class="deltaxml-new" style="background:#90EE90"> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.</span></p></dd><dt><a href="#dt-step"><span class="deltaxml-new" style="background:#90EE90">step</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">step</span></b><span class="deltaxml-new" style="background:#90EE90"> is a part of a </span><a title="path expression" class="termref" href="#dt-path-expression"><span class="deltaxml-new" style="background:#90EE90">path expression</span></a><span class="deltaxml-new" style="background:#90EE90"> that generates a sequence of items and then filters the sequence by zero or more </span><a title="" class="termref" href="#dt-predicate"><span class="deltaxml-new" style="background:#90EE90">predicates</span></a><span class="deltaxml-new" style="background:#90EE90">. The value of the step consists of those items that satisfy the predicates, working from left to right. A step may be either an </span><a title="axis step" class="termref" href="#dt-axis-step"><span class="deltaxml-new" style="background:#90EE90">axis step</span></a><span class="deltaxml-new" style="background:#90EE90"> or a postfix expression.</span></p></dd><dt><a href="#dt-string-constructor"><span class="deltaxml-new" style="background:#90EE90">string constructor</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">String Constructor</span></b><span class="deltaxml-new" style="background:#90EE90"> creates a string from literal text and interpolated expressions. </span></p></dd><dt><a href="#dt-string-value"><span class="deltaxml-new" style="background:#90EE90">string value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">string value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a node is a string and can be extracted by applying the </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-string"><span class="deltaxml-new" style="background:#90EE90">Section 2.1.3 fn:string</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> function to the node.</span></p></dd><dt><a href="#dt-substantively-disjoint"><span class="deltaxml-new" style="background:#90EE90">substantively disjoint</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Two </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90"> are deemed to be </span><b><span class="deltaxml-new" style="background:#90EE90">substantively disjoint</span></b><span class="deltaxml-new" style="background:#90EE90"> if (a) neither is a subtype of the other (see </span><a href="#id-seqtype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3.1 Subtypes of Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">) and (b) the only values that are instances of both types are one or more of the following:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The empty sequence, </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The empty map, </span><code><span class="deltaxml-new" style="background:#90EE90">{}</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The empty array, </span><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul></dd><dt><a href="#dt-substitution-group"><span class="deltaxml-new" style="background:#90EE90">substitution group</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Substitution groups</span></b><span class="deltaxml-new" style="background:#90EE90"> are defined in </span><a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class"><span class="deltaxml-new" style="background:#90EE90">Section 2.2.2.2 Element Substitution Group </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS1-1</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class"><span class="deltaxml-new" style="background:#90EE90">Section 2.2.2.2 Element Substitution Group </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-1</span></small></sup><span class="deltaxml-new" style="background:#90EE90">. Informally, the substitution group headed by a given element (called the </span><b><span class="deltaxml-new" style="background:#90EE90">head element</span></b><span class="deltaxml-new" style="background:#90EE90">) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</span></p></dd><dt><a href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Given two </span><a title="sequence type" class="termref" href="#dt-sequence-type"><span class="deltaxml-new" style="background:#90EE90">sequence types</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a title="item type" class="termref" href="#dt-item-type"><span class="deltaxml-new" style="background:#90EE90">item types</span></a><span class="deltaxml-new" style="background:#90EE90">, the rules in this section determine if one is a </span><b><span class="deltaxml-new" style="background:#90EE90">subtype</span></b><span class="deltaxml-new" style="background:#90EE90"> of the other. If a type </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a subtype of type </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, it follows that every value matched by </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is also matched by </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-subtype-substitution"><span class="deltaxml-new" style="background:#90EE90">subtype substitution</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The use of a value that has a </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> that is a </span><a title="subtype" class="termref" href="#dt-subtype"><span class="deltaxml-new" style="background:#90EE90">subtype</span></a><span class="deltaxml-new" style="background:#90EE90"> of the expected type is known as </span><b><span class="deltaxml-new" style="background:#90EE90">subtype substitution</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#symbol"><span class="deltaxml-new" style="background:#90EE90">symbol</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Each rule in the grammar defines one </span><b><span class="deltaxml-new" style="background:#90EE90">symbol</span></b><span class="deltaxml-new" style="background:#90EE90">, using the following format: </span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">symbol ::= expression</span></pre></div></dd><dt><a href="#symbolseparators"><span class="deltaxml-new" style="background:#90EE90">symbol separators</span></a></dt><dd><p><a title="whitespace" class="termref" href="#Whitespace"><span class="deltaxml-new" style="background:#90EE90">Whitespace</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#doc-xpath40-Comment"><span class="deltaxml-new" style="background:#90EE90">Comments</span></a><span class="deltaxml-new" style="background:#90EE90"> function as </span><b><span class="deltaxml-new" style="background:#90EE90">symbol separators</span></b><span class="deltaxml-new" style="background:#90EE90">. For the most part, they are not mentioned in the grammar, and may occur between any two terminal symbols mentioned in the grammar, except where that is forbidden by the </span><a href="#ws-explicit"><span class="deltaxml-new" style="background:#90EE90">/* ws: explicit */</span></a><span class="deltaxml-new" style="background:#90EE90"> annotation in the EBNF, or by the </span><a href="#parse-note-xml-version"><span class="deltaxml-new" style="background:#90EE90">/* xgc: xml-version */</span></a><span class="deltaxml-new" style="background:#90EE90"> annotation.</span></p></dd><dt><a href="#dt-system-function"><span class="deltaxml-new" style="background:#90EE90">system function</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">System functions</span></b><span class="deltaxml-new" style="background:#90EE90"> include the functions defined in </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">, functions defined by the specifications of a host language, </span><a title="constructor function" class="termref" href="#dt-constructor-function"><span class="deltaxml-new" style="background:#90EE90">constructor functions</span></a><span class="deltaxml-new" style="background:#90EE90"> for atomic types, and any additional functions provided by the implementation. System functions are sometimes called built-in functions.</span></p></dd><dt><a href="#dt-target-namespace"><span class="deltaxml-new" style="background:#90EE90">target namespace</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The </span><b><span class="deltaxml-new" style="background:#90EE90">target namespace</span></b><span class="deltaxml-new" style="background:#90EE90"> of a module is the namespace of the objects (such as elements or functions) that it defines. </span></p></dd><dt><a href="#terminal"><span class="deltaxml-new" style="background:#90EE90">terminal</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is a symbol or string or pattern that can appear in the right-hand side of a rule, but never appears on the left-hand side in the main grammar, although it may appear on the left-hand side of a rule in the grammar for terminals.</span></p></dd><dt><a href="#id-tuple-foobar"><span class="deltaxml-new" style="background:#90EE90">tuple</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">tuple</span></b><span class="deltaxml-new" style="background:#90EE90"> is a set of zero or more named variables, each of which is bound to a value that is an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#id-tuple-stream-foobar"><span class="deltaxml-new" style="background:#90EE90">tuple stream</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">tuple stream</span></b><span class="deltaxml-new" style="background:#90EE90"> is an ordered sequence of zero or more </span><b><span class="deltaxml-new" style="background:#90EE90">tuples</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Each element node and attribute node in an </span><a title="XDM instance" class="termref" href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a><span class="deltaxml-new" style="background:#90EE90"> has a </span><b><span class="deltaxml-new" style="background:#90EE90">type annotation</span></b><span class="deltaxml-new" style="background:#90EE90"> (described in </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#types"><span class="deltaxml-new" style="background:#90EE90">Section 2.8 Schema Information</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM40</span></small></sup><span class="deltaxml-new" style="background:#90EE90">). The type annotation of a node is a reference to a </span><a title="schema type" class="termref" href="#dt-schema-type"><span class="deltaxml-new" style="background:#90EE90">schema type</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt><a href="#dt-typed-data-feature"><span class="deltaxml-new" style="background:#90EE90">typed data feature</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">Typed Data Feature</span></b><span class="deltaxml-new" style="background:#90EE90"> permits an XDM instance to contain element node types other than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> and attributes node types other than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-type-declaration"><span class="deltaxml-new" style="background:#90EE90">type declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A variable binding may be accompanied by a </span><b><span class="deltaxml-new" style="background:#90EE90">type declaration</span></b><span class="deltaxml-new" style="background:#90EE90">, which consists of the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">as</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the static type of the variable, declared using the syntax in </span><a href="#id-sequencetype-syntax"><b><span class="deltaxml-new" style="background:#90EE90">3.1 Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-typed-value"><span class="deltaxml-new" style="background:#90EE90">typed value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">typed value</span></b><span class="deltaxml-new" style="background:#90EE90"> of a node is a sequence of atomic items and can be extracted by applying the </span><a href="https://qt4cg.org/specifications/xpath-functions-40/#func-data"><span class="deltaxml-new" style="background:#90EE90">Section 2.1.4 fn:data</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">FO40</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> function to the node.</span></p></dd><dt><a href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">type error</span></b><span class="deltaxml-new" style="background:#90EE90"> may be raised during the static analysis phase or the dynamic evaluation phase. During the static analysis phase, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs when the </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of an expression does not match the expected type of the context in which the expression occurs. During the dynamic evaluation phase, a </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type error</span></a><span class="deltaxml-new" style="background:#90EE90"> occurs when the </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90"> of a value does not match the expected type of the context in which the value occurs.</span></p></dd><dt><a href="#dt-type-promotion"><span class="deltaxml-new" style="background:#90EE90">type promotion</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Under certain circumstances, an atomic item can be promoted from one type to another.</span></p></dd><dt><a href="#dt-URI"><span class="deltaxml-new" style="background:#90EE90">URI</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Within this specification, the term </span><b><span class="deltaxml-new" style="background:#90EE90">URI</span></b><span class="deltaxml-new" style="background:#90EE90"> refers to a Universal Resource Identifier as defined in </span><a href="#RFC3986"><span class="deltaxml-new" style="background:#90EE90">[RFC3986]</span></a><span class="deltaxml-new" style="background:#90EE90"> and extended in </span><a href="#RFC3987"><span class="deltaxml-new" style="background:#90EE90">[RFC3987]</span></a><span class="deltaxml-new" style="background:#90EE90"> with the new name </span><b><span class="deltaxml-new" style="background:#90EE90">IRI</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-udf"><span class="deltaxml-new" style="background:#90EE90">user-defined function</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">User defined functions</span></b><span class="deltaxml-new" style="background:#90EE90"> are functions that contain a </span><b><span class="deltaxml-new" style="background:#90EE90">function body</span></b><span class="deltaxml-new" style="background:#90EE90">, which provides the implementation of the function as a </span><a title="content expression" class="termref" href="#dt-content-expression"><span class="deltaxml-new" style="background:#90EE90">content expression</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-value"><span class="deltaxml-new" style="background:#90EE90">value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In the </span><a title="data model" class="termref" href="#dt-datamodel"><span class="deltaxml-new" style="background:#90EE90">data model</span></a><span class="deltaxml-new" style="background:#90EE90">, a </span><b><span class="deltaxml-new" style="background:#90EE90">value</span></b><span class="deltaxml-new" style="background:#90EE90"> is always a </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-new" style="background:#90EE90">sequence</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-variable-declartion"><span class="deltaxml-new" style="background:#90EE90">variable declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">variable declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> in the XQuery prolog defines the name and </span><a title="static type" class="termref" href="#dt-static-type"><span class="deltaxml-new" style="background:#90EE90">static type</span></a><span class="deltaxml-new" style="background:#90EE90"> of a variable, and optionally a value for the variable. It adds to the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90">, and may also add to the </span><a title="variable values" class="termref" href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="dynamic context" class="termref" href="#dt-dynamic-context"><span class="deltaxml-new" style="background:#90EE90">dynamic context</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-variable-reference"><span class="deltaxml-new" style="background:#90EE90">variable reference</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">variable reference</span></b><span class="deltaxml-new" style="background:#90EE90"> is an EQName preceded by a $-sign.</span></p></dd><dt><a href="#dt-variable-terminal"><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">variable terminal</span></b><span class="deltaxml-new" style="background:#90EE90"> is an instance of a production rule that is not itself an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90"> but that is named (directly) on the right-hand side of an </span><a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule"><span class="deltaxml-new" style="background:#90EE90">ordinary production rule</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-variable-values"><span class="deltaxml-new" style="background:#90EE90">variable values</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">Variable values</span></b><span class="deltaxml-new" style="background:#90EE90">. This is a mapping from </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> to value. It contains the same </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QNames</span></a><span class="deltaxml-new" style="background:#90EE90"> as the </span><a title="in-scope variables" class="termref" href="#dt-in-scope-variables"><span class="deltaxml-new" style="background:#90EE90">in-scope variables</span></a><span class="deltaxml-new" style="background:#90EE90"> in the </span><a title="static context" class="termref" href="#dt-static-context"><span class="deltaxml-new" style="background:#90EE90">static context</span></a><span class="deltaxml-new" style="background:#90EE90"> for the expression. The </span><a title="expanded QName" class="termref" href="#dt-expanded-qname"><span class="deltaxml-new" style="background:#90EE90">expanded QName</span></a><span class="deltaxml-new" style="background:#90EE90"> is the name of the variable and the value is the dynamic value of the variable, which includes its </span><a title="dynamic type" class="termref" href="#dt-dynamic-type"><span class="deltaxml-new" style="background:#90EE90">dynamic type</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-variadic"><span class="deltaxml-new" style="background:#90EE90">variadic</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><a title="function definition" class="termref" href="#dt-function-definition"><span class="deltaxml-new" style="background:#90EE90">function definition</span></a><span class="deltaxml-new" style="background:#90EE90"> may be declared to be </span><b><span class="deltaxml-new" style="background:#90EE90">variadic</span></b><span class="deltaxml-new" style="background:#90EE90">. In a static call of a variadic function, multiple arguments may be mapped to a single parameter in the function definition. In a variadic function with </span><var><span class="deltaxml-new" style="background:#90EE90">M</span></var><span class="deltaxml-new" style="background:#90EE90"> declared parameters, the arity range is from </span><var><span class="deltaxml-new" style="background:#90EE90">M-1</span></var><span class="deltaxml-new" style="background:#90EE90"> to positive infinity.</span></p></dd><dt><a href="#dt-version-declaration"><span class="deltaxml-new" style="background:#90EE90">version declaration</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> A </span><b><span class="deltaxml-new" style="background:#90EE90">version declaration</span></b><span class="deltaxml-new" style="background:#90EE90"> can identify the applicable XQuery syntax and semantics for a </span><a title="module" class="termref" href="#dt-module"><span class="deltaxml-new" style="background:#90EE90">module</span></a><span class="deltaxml-new" style="background:#90EE90">, as well as its encoding.</span></p></dd><dt><a href="#dt-warning"><span class="deltaxml-new" style="background:#90EE90">warning</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In addition to </span><a title="static error" class="termref" href="#dt-static-error"><span class="deltaxml-new" style="background:#90EE90">static errors</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="dynamic error" class="termref" href="#dt-dynamic-error"><span class="deltaxml-new" style="background:#90EE90">dynamic errors</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="type error" class="termref" href="#dt-type-error"><span class="deltaxml-new" style="background:#90EE90">type errors</span></a><span class="deltaxml-new" style="background:#90EE90">, an XQuery 4.0 and XPath 4.0 implementation may raise </span><b><span class="deltaxml-new" style="background:#90EE90">warnings</span></b><span class="deltaxml-new" style="background:#90EE90">, either during the </span><a title="static analysis phase" class="termref" href="#dt-static-analysis"><span class="deltaxml-new" style="background:#90EE90">static analysis phase</span></a><span class="deltaxml-new" style="background:#90EE90"> or the </span><a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation"><span class="deltaxml-new" style="background:#90EE90">dynamic evaluation phase</span></a><span class="deltaxml-new" style="background:#90EE90">. The circumstances in which warnings are raised, and the ways in which warnings are handled, are </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation-defined</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#Whitespace"><span class="deltaxml-new" style="background:#90EE90">whitespace</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">whitespace</span></b><span class="deltaxml-new" style="background:#90EE90"> character is any of the characters defined by </span><a href="http://www.w3.org/TR/REC-xml/#NT-S"><span class="deltaxml-new" style="background:#90EE90"> [http://www.w3.org/TR/REC-xml/#NT-S]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-wildcard-matches"><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">In these rules, if </span><var><span class="deltaxml-new" style="background:#90EE90">MU</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">NU</span></var><span class="deltaxml-new" style="background:#90EE90"> are </span><a href="#doc-xpath40-NameTestUnion"><span class="deltaxml-new" style="background:#90EE90">NameTestUnions</span></a><span class="deltaxml-new" style="background:#90EE90">, then </span><var><span class="deltaxml-new" style="background:#90EE90">MU</span></var><b><span class="deltaxml-new" style="background:#90EE90">wildcard-matches</span></b><var><span class="deltaxml-new" style="background:#90EE90">NU</span></var><span class="deltaxml-new" style="background:#90EE90"> is true if every name that matches </span><var><span class="deltaxml-new" style="background:#90EE90">MU</span></var><span class="deltaxml-new" style="background:#90EE90"> also matches </span><var><span class="deltaxml-new" style="background:#90EE90">NU</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-window"><span class="deltaxml-new" style="background:#90EE90">window</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">window</span></b><span class="deltaxml-new" style="background:#90EE90"> is a sequence of consecutive items drawn from the </span><a title="binding sequence" class="termref" href="#dt-binding-sequence"><span class="deltaxml-new" style="background:#90EE90">binding sequence</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-data-model-instance"><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The term </span><b><span class="deltaxml-new" style="background:#90EE90">XDM instance</span></b><span class="deltaxml-new" style="background:#90EE90"> is used, synonymously with the term </span><a title="value" class="termref" href="#dt-value"><span class="deltaxml-new" style="background:#90EE90">value</span></a><span class="deltaxml-new" style="background:#90EE90">, to denote an unconstrained </span><a title="sequence" class="termref" href="#dt-sequence"><span class="deltaxml-new" style="background:#90EE90">sequence</span></a><span class="deltaxml-new" style="background:#90EE90"> of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-new" style="background:#90EE90">items</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-xpath-compat-mode"><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">XPath 1.0 compatibility mode.</span></b><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">This component must be set by all host languages that include XPath 3.1 as a subset, indicating whether rules for compatibility with XPath 1.0 are in effect. XQuery sets the value of this component to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></span></span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">This value is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></span></span></p></dd><dt><a href="#dt-xquery-10-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0 Processor</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 1.0 specification. </span></p></dd><dt><a href="#dt-xquery-30-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0 Processor</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 3.0 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 3.0 specification. </span></p></dd><dt><a href="#dt-xquery-31-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1 Processor</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 3.1 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 3.1 specification. </span></p></dd><dt><a href="#dt-xquery-40-processor"><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 Processor</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery 4.0 Processor</span></b><span class="deltaxml-new" style="background:#90EE90"> processes a query according to the XQuery 4.0 specification. </span></p></dd><dt><a href="#dt-version-number"><span class="deltaxml-new" style="background:#90EE90">XQuery version number</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">An </span><b><span class="deltaxml-new" style="background:#90EE90">XQuery version number</span></b><span class="deltaxml-new" style="background:#90EE90"> consists of two integers separated by a dot. The first integer is referred to as the </span><b><span class="deltaxml-new" style="background:#90EE90">major version number</span></b><span class="deltaxml-new" style="background:#90EE90">; the second as the </span><b><span class="deltaxml-new" style="background:#90EE90">minor version number</span></b><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-anyAtomicType"><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></a></dt><dd><p><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> that includes all atomic items (and no values that are not atomic). Its base type is </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anySimpleType</span></code><span class="deltaxml-new" style="background:#90EE90"> from which all simple types, including atomic, list, and union types, are derived. All primitive atomic types, such as </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, have </span><code><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType</span></code><span class="deltaxml-new" style="background:#90EE90"> as their base type.</span></p></dd><dt><a href="#dt-dayTimeDuration"><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></a></dt><dd><p><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></code><span class="deltaxml-new" style="background:#90EE90">. The lexical representation of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:dayTimeDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is restricted to contain only day, hour, minute, and second components.</span></p></dd><dt><a href="#dt-xs-error"><span class="deltaxml-new" style="background:#90EE90">xs:error</span></a></dt><dd><p><code><span class="deltaxml-new" style="background:#90EE90">xs:error</span></code><span class="deltaxml-new" style="background:#90EE90"> is a simple type with no value space. It is defined in </span><a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error"><span class="deltaxml-new" style="background:#90EE90">Section 3.16.7.3 xs:error </span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">XS11-1</span></small></sup><span class="deltaxml-new" style="background:#90EE90"> and can be used in the </span><a href="#id-sequencetype-syntax"><b><span class="deltaxml-new" style="background:#90EE90">3.1 Sequence Types</span></b></a><span class="deltaxml-new" style="background:#90EE90"> to raise errors.</span></p></dd><dt><a href="#dt-untyped"><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></a></dt><dd><p><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> is used as the </span><a title="type annotation" class="termref" href="#dt-type-annotation"><span class="deltaxml-new" style="background:#90EE90">type annotation</span></a><span class="deltaxml-new" style="background:#90EE90"> of an element node that has not been validated, or has been validated in </span><code><span class="deltaxml-new" style="background:#90EE90">skip</span></code><span class="deltaxml-new" style="background:#90EE90"> mode.</span></p></dd><dt><a href="#dt-untypedAtomic"><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></a></dt><dd><p><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> is an </span><a title="atomic type" class="termref" href="#dt-atomic-type"><span class="deltaxml-new" style="background:#90EE90">atomic type</span></a><span class="deltaxml-new" style="background:#90EE90"> that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</span></p></dd><dt><a href="#dt-yearMonthDuration"><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></a></dt><dd><p><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is derived by restriction from </span><code><span class="deltaxml-new" style="background:#90EE90">xs:duration</span></code><span class="deltaxml-new" style="background:#90EE90">. The lexical representation of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:yearMonthDuration</span></code><span class="deltaxml-new" style="background:#90EE90"> is restricted to contain only year and month components.</span></p></dd><dt><a href="#id-static-decimal-format-zero-digit"><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></a></dt><dd><p><b><span class="deltaxml-new" style="background:#90EE90">zero-digit</span></b><span class="deltaxml-new" style="background:#90EE90"> is the character used to represent the digit zero; the default value is </span><span class="unicode-codepoint"><span class="deltaxml-new" style="background:#90EE90">U+0030</span></span><span class="deltaxml-new" style="background:#90EE90"> (</span><span class="unicode-name"><span class="deltaxml-new" style="background:#90EE90">DIGIT ZERO</span></span><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">) . This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.</span></p></dd></dl></div><div class="div1"><h2><a id="id-atomic-comparisons"></a><span class="deltaxml-new" style="background:#90EE90">J Atomic Comparisons: An Overview (Non-Normative)</span></h2><p><span class="deltaxml-new" style="background:#90EE90">This appendix provides a non-normative summary of the various functions and operators used for comparison of atomic items, with some background on the history and rationale.</span></p><div class="div2"><h3><a id="id-equality-comparison"></a><span class="deltaxml-new" style="background:#90EE90">J.1 Equality Comparisons</span></h3><p><span class="deltaxml-new" style="background:#90EE90">In XQuery 4.0 and XPath 4.0 there are essentially four ways of comparing two atomic items for equality:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$A = $B</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This operator was introduced in XPath 1.0. The semantics were changed slightly in XPath 2.0, but the original semantics remain available when XPath 1.0 compatibility mode is enabled.</span></p><p><span class="deltaxml-new" style="background:#90EE90">With a general comparison in XPath 2.0 or later (and in XQuery), the following rules are observed:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Either operand may be a sequence; the result is true if any pair of items from the two sequences compares equal.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In consequence, if either operand is an empty sequence, the result is false.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If nodes are supplied, they are atomized.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Untyped atomic items appearing in one operand are converted to the type of the other operand (if both operands are untyped atomic, they are compared as strings).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">As a result, the operator is not transitive: the untyped atomic items </span><code><span class="deltaxml-new" style="background:#90EE90">"4.0"</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">"4"</span></code><span class="deltaxml-new" style="background:#90EE90"> are not equal to each other, but both compare equal to the integer value </span><code><span class="deltaxml-new" style="background:#90EE90">4</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparison of certain values is context-sensitive. In particular, comparison of strings uses the default collation from the static context, while comparison of date/time values lacking an explicit timezone takes the timezone from the dynamic context.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">NaN is not equal to NaN; negative zero is equal to positive zero.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90"> values are mutually comparable: they are equal if they represent the same sequence of octets.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparing incompatible values (for example </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">) raises an error.</span></p></li></ul></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$A eq $B</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">Value comparisons were introduced in XPath 2.0 and XQuery 1.0. One of the aims was to make the comparison transitive (a precondition for a wide variety of optimizations), however in edge cases involving comparisons across different numeric types this was not entirely achieved.</span></p><p><span class="deltaxml-new" style="background:#90EE90">With a value comparison, the rules are:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Each operand must either be a single atomic item, or an empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If either operand is an empty sequence, the result is an empty sequence; in most contexts this has the same effect as returning false.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If nodes are supplied, they are atomized.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Untyped atomic items are converted to strings (regardless of the type of the other operand).</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Numeric values of types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90"> are converted to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This can lead to problems with implementations of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> that support more precision than can be held in an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">As with general comparisons, the default collation and implicit timezone are taken from the context.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">NaN is not equal to NaN; negative zero is equal to positive zero.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90"> values are mutually comparable: they are equal if they represent the same sequence of octets.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparing incompatible values (for example </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">) raises an error.</span></p></li></ul></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">deep-equal($A, $B)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">As the name implies, the </span><code><span class="deltaxml-new" style="background:#90EE90">deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> function was introduced primarily for comparing nodes, or sequences of nodes; however in its simplest form it can also be used to compare two atomic items. The semantics of the comparison used by </span><code><span class="deltaxml-new" style="background:#90EE90">deep-equal($A, $B)</span></code><span class="deltaxml-new" style="background:#90EE90"> are also invoked by a wide variety of other functions including </span><code><span class="deltaxml-new" style="background:#90EE90">distinct-values</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">all-equal</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">all-different</span></code><span class="deltaxml-new" style="background:#90EE90">; it is also used to underpin grouping constructs in both XQuery 4.0 and XSLT 4.0.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Some of the relevant rules are:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Because </span><code><span class="deltaxml-new" style="background:#90EE90">deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90"> is used to compare sequences, if one of the operands is an empty sequence the result is false; but if both operands are empty sequences, the result is true.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If nodes are supplied, they are not atomized; they are compared as nodes.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Strings can be compared using the default collation or using an explicitly specified collation; there are also options to compare after normalizing whitespace or unicode.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparisons of dates and times lacking a timezone uses the implicit timezone from the dynamic context.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Numeric values are converted to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> prior to comparison, not to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">. This represents a departure in 4.0 from previous versions of the specification. The conversion must use an implementation of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> that does not cause loss of precision. As a result, the comparison is now truly transitive, which makes it suitable to underpin grouping operations.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">To ensure that every value is equal to itself, comparing NaN to NaN returns true.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90"> values are mutually comparable: they are equal if they represent the same sequence of octets.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparing incompatible values (for example </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">) returns false; it does not raise an error.</span></p></li></ul></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">atomic-equal($A, $B)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This comparison operation was introduced in XPath 3.0 (and XQuery 3.0) for comparing keys in maps; the 4.0 specifications expose it directly as a function that can be called from user applications. The dominant requirements for keys in maps were that the comparison should be transitive, error-free, and context-independent. The relevant rules are:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The type signature of the function ensures that it can only be used to compare single items; empty sequences do not arise.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If nodes are supplied, they are atomized.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Strings are compared codepoint-by-codepoint, without reference to any collation or normalization.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Dates and times lacking a timezone are never equal to dates and times that have a timezone. However, when comparing two dates or times that both have a timezone, the timezone is normalized.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">As with </span><code><span class="deltaxml-new" style="background:#90EE90">deep-equal</span></code><span class="deltaxml-new" style="background:#90EE90">, numeric values are converted to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:decimal</span></code><span class="deltaxml-new" style="background:#90EE90"> prior to comparison, not to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparing NaN to NaN returns true.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary</span></code><span class="deltaxml-new" style="background:#90EE90"> values are distinct: both can co-exist as distinct keys in a map even if the underlying sequence of octets is the same.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparing incompatible values (for example </span><code><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:date</span></code><span class="deltaxml-new" style="background:#90EE90">) returns false; it does not raise an error.</span></p></li></ul></li></ul><p><span class="deltaxml-new" style="background:#90EE90">The following table summarizes these differences. For all these examples it is assumed that (a) the default collation is the HTML case-blind collation, (b) the implicit timezone is +01:00, and (c) nodes are untyped.</span></p><div class="small"><table style="border:1px solid" class="small"><thead><tr><th><code><span class="deltaxml-new" style="background:#90EE90">$A</span></code></th><th><code><span class="deltaxml-new" style="background:#90EE90">$B</span></code></th><th><code><span class="deltaxml-new" style="background:#90EE90">$A = $B</span></code></th><th><code><span class="deltaxml-new" style="background:#90EE90">$A eq $B</span></code></th><th><code><span class="deltaxml-new" style="background:#90EE90">deep-equal(​$A, $B)</span></code></th><th><code><span class="deltaxml-new" style="background:#90EE90">atomic-equal(​$A, $B)</span></code></th></tr></thead><tbody><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">error</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">12</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">error</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">(1,2)</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">(2,3)</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">error</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">error</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">12</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">12e0</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">0.2</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">0.2e0</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">+0e0</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">-0e0</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">"A"</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">"a"</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">"A"</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">12</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">error</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">error</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;A&lt;/a&gt;</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">"A"</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">&lt;a&gt;12&lt;/a&gt;</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">12</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">error</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">xs:time(​'12:00:00Z')</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">xs:time(​'13:00:00+01:00')</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">xs:time(​'12:00:00Z')</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">xs:time(​'13:00:00')</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">xs:hexBinary(​"0000")</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">xs:base64Binary(​"AAA=")</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">true</span></code></p></td><td><p><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></p></td></tr></tbody></table></div></div><div class="div2"><h3><a id="id-ordering-comparison"></a><span class="deltaxml-new" style="background:#90EE90">J.2 Ordering Comparisons</span></h3><p><span class="deltaxml-new" style="background:#90EE90">In XQuery 4.0 and XPath 4.0 there are essentially three ways of comparing two atomic items for their relative ordering:</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$A &lt; $B</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$A lt $B</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">Sorting</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">TODO: to be expanded.</span></p></div></div><div class="div1"><h2><a id="id-incompatibilities"></a><span class="deltaxml-new" style="background:#90EE90">K Backwards Compatibility (Non-Normative)</span></h2><div class="div2"><h3><a id="id-incompatibilities-31"></a><span class="deltaxml-new" style="background:#90EE90">K.1 Incompatibilities relative to XQuery and XPath 3.1</span></h3><p><span class="deltaxml-new" style="background:#90EE90">In </span><code><span class="deltaxml-new" style="background:#90EE90">fn:format-integer</span></code><span class="deltaxml-new" style="background:#90EE90">, certain formatting pictures using a circumflex as a grouping separator might be interpreted differently in 4.0: for example </span><code><span class="deltaxml-new" style="background:#90EE90">format-integer(1234, "9^999")</span></code><span class="deltaxml-new" style="background:#90EE90"> would output </span><code><span class="deltaxml-new" style="background:#90EE90">"1^234"</span></code><span class="deltaxml-new" style="background:#90EE90"> in 3.1, but will output </span><code><span class="deltaxml-new" style="background:#90EE90">"1621"</span></code><span class="deltaxml-new" style="background:#90EE90"> (1234 in base 9) with 4.0. As a workaround, this can be rewritten as </span><code><span class="deltaxml-new" style="background:#90EE90">format-integer(1234, "0^000")</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In XQuery 4.0 and XPath 4.0, certain expressions are classified as </span><a title="implausible" class="termref" href="#dt-implausible"><span class="deltaxml-new" style="background:#90EE90">implausible</span></a><span class="deltaxml-new" style="background:#90EE90">: an example is </span><code><span class="deltaxml-new" style="background:#90EE90">@code/text()</span></code><span class="deltaxml-new" style="background:#90EE90">, which will always return an empty sequence. A processor may report a static error when such expressions are encountered; however, processors are </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">required</span></span><span class="deltaxml-new" style="background:#90EE90"> to provide a mode of operation in which such expressions are accepted, thus retaining backwards compatibility.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In expressions that deliver a function item, notably partial function applications, named function references, and the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:function-lookup</span></code><span class="deltaxml-new" style="background:#90EE90"> function, errors may now be detected at the point where the function item is created when they were previously detected at the point where the function item was called. This was underspecified in previous versions. For example, the partial function application </span><code><span class="deltaxml-new" style="background:#90EE90">contains(?, 42)</span></code><span class="deltaxml-new" style="background:#90EE90"> is now required to raise a type error (because the second argument should be a string, not an integer) at the point where the partial function application occurs, not at the point where the resulting function is called.</span></p><p><span class="deltaxml-new" style="background:#90EE90">As explained in </span><a href="#id-function-coercion"><b><span class="deltaxml-new" style="background:#90EE90">3.4.4 Function Coercion</span></b></a><span class="deltaxml-new" style="background:#90EE90">, the fact that coercion rules are now applied to global variables and local variable bindings introduces an incompatibility in the case of variables whose value is a function item. Previously it was possible to supply a function item that accepted a wider range of argument values than those declared in the variable's type declaration; this is no longer the case.</span></p></div><div class="div2"><h3><a id="id-incompatibilities-30"></a><span class="deltaxml-new" style="background:#90EE90">K.2 Incompatibilities relative to XQuery and XPath 3.0</span></h3><p><span class="deltaxml-new" style="background:#90EE90">The following names are now reserved, and cannot appear as function names (see </span><a href="#id-reserved-fn-names"><b><span class="deltaxml-new" style="background:#90EE90">A.4 Reserved Function Names</span></b></a><span class="deltaxml-new" style="background:#90EE90">):</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">map</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">array</span></code></p></li></ul></div><div class="div2"><h3><a id="id-incompatibilities-10"></a><span class="deltaxml-new" style="background:#90EE90">K.3 Incompatibilities relative to XQuery and XPath </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">2.0</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">1.0</span></span></span></h3><p><span class="deltaxml-new" style="background:#90EE90">The following names are now reserved, and cannot appear as function names (see </span><a href="#id-reserved-fn-names"><b><span class="deltaxml-new" style="background:#90EE90">A.4 Reserved Function Names</span></b></a><span class="deltaxml-new" style="background:#90EE90">):</span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">function</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">namespace-node</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">switch</span></code></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">U</span></code><span class="deltaxml-new" style="background:#90EE90"> is a union type with </span><code><span class="deltaxml-new" style="background:#90EE90">T</span></code><span class="deltaxml-new" style="background:#90EE90"> as one of its members, and if </span><code><span class="deltaxml-new" style="background:#90EE90">E</span></code><span class="deltaxml-new" style="background:#90EE90"> is an element with </span><code><span class="deltaxml-new" style="background:#90EE90">T</span></code><span class="deltaxml-new" style="background:#90EE90"> as its type annotation, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">E instance of element(*, U)</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> in both XQuery and XPath 3.0 and 3.1. In </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath 2.0</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0</span></span></span><span class="deltaxml-new" style="background:#90EE90">, it returns </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This is not an incompatibility with XQuery and XPath 3.0. It should be included in XQuery and XPath 3.0 as an incompatibility with </span><span class="xpath"><span class="xpath"><span class="deltaxml-new" style="background:#90EE90">XPath 2.0</span></span></span><span class="xquery"><span class="xquery"><span class="deltaxml-new" style="background:#90EE90">XQuery 1.0</span></span></span><span class="deltaxml-new" style="background:#90EE90">, but it was discovered after publication.</span></p></div></div><div class="xpath"><div class="div2 xpath"><h3><a id="id-backwards-compatibility"></a><span class="deltaxml-new" style="background:#90EE90">K.4 Incompatibilities relative to XPath 1.0</span></h3><p><span class="deltaxml-new" style="background:#90EE90">This appendix provides a summary of the areas of incompatibility between XPath 4.0 and </span><a href="#xpath"><span class="deltaxml-new" style="background:#90EE90">[XML Path Language (XPath) Version 1.0]</span></a><span class="deltaxml-new" style="background:#90EE90">. In each of these cases, an XPath 4.0 processor is compatible with an XPath 2.0, 3.0, or 3.1 processor.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Three separate cases are considered:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Incompatibilities that exist when source documents have no schema, and when running with XPath 1.0 compatibility mode set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">. This specification has been designed to reduce the number of incompatibilities in this situation to an absolute minimum, but some differences remain and are listed individually.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Incompatibilities that arise when XPath 1.0 compatibility mode is set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. In this case, the number of expressions where compatibility is lost is rather greater.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Incompatibilities that arise when the source document is processed using a schema (whether or not XPath 1.0 compatibility mode is set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">). Processing the document with a schema changes the way that the values of nodes are interpreted, and this can cause an XPath expression to return different results.</span></p></li></ol><div class="div3"><h4><a id="id-incompat-in-true-mode"></a><span class="deltaxml-new" style="background:#90EE90">K.4.1 Incompatibilities when Compatibility Mode is true</span></h4><p><span class="deltaxml-new" style="background:#90EE90">The list below contains all known areas, within the scope of this specification, where an XPath 4.0 processor running with compatibility mode set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> will produce different results from an XPath 1.0 processor evaluating the same expression, assuming that the expression was valid in XPath 1.0, and that the nodes in the source document have no type annotations other than </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Incompatibilities in the behavior of individual functions are not listed here, but are included in an appendix of </span><a href="#xpath-functions-40"><span class="deltaxml-new" style="background:#90EE90">[XQuery and XPath Functions and Operators 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Since both XPath 1.0 and </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90"> leave some aspects of the specification implementation-defined, there may be incompatibilities in the behavior of a particular implementation that are outside the scope of this specification. Equally, some aspects of the behavior of XPath are defined by the host language.</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Consecutive comparison operators such as </span><code><span class="deltaxml-new" style="background:#90EE90">A &lt; B &lt; C</span></code><span class="deltaxml-new" style="background:#90EE90"> were supported in XPath 1.0, but are not permitted by the </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90"> grammar. In most cases such comparisons in XPath 1.0 did not have the intuitive meaning, so it is unlikely that they have been widely used in practice. If such a construct is found, an </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90"> processor will report a syntax error, and the construct can be rewritten as </span><code><span class="deltaxml-new" style="background:#90EE90">(A &lt; B) &lt; C</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When converting strings to numbers (either explicitly when using the </span><code><span class="deltaxml-new" style="background:#90EE90">number</span></code><span class="deltaxml-new" style="background:#90EE90"> function, or implicitly say on a function call), certain strings that converted to the special value </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> under XPath 1.0 will convert to values other than </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> under </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90">. These include any number written with a leading </span><code><span class="deltaxml-new" style="background:#90EE90">+</span></code><span class="deltaxml-new" style="background:#90EE90"> sign, any number in exponential floating point notation (for example </span><code><span class="deltaxml-new" style="background:#90EE90">1.0e+9</span></code><span class="deltaxml-new" style="background:#90EE90">), and the strings </span><code><span class="deltaxml-new" style="background:#90EE90">INF</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">-INF</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Furthermore, the strings </span><code><span class="deltaxml-new" style="background:#90EE90">Infinity</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">-Infinity</span></code><span class="deltaxml-new" style="background:#90EE90">, which were accepted by XPath 1.0 as representations of the floating-point values positive and negative infinity, are no longer recognized. They are converted to </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> when running under </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90"> with compatibility mode set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">, and cause a dynamic error when compatibility mode is set to </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90"> does not allow a token starting with a letter to follow immediately after a numeric literal, without intervening whitespace. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">10div 3</span></code><span class="deltaxml-new" style="background:#90EE90"> was permitted in XPath 1.0, but in </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90"> must be written as </span><code><span class="deltaxml-new" style="background:#90EE90">10 div 3</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The namespace axis is deprecated as of XPath 2.0. Implementations may support the namespace axis for backward compatibility with XPath 1.0, but they are not required to do so. (XSLT 2.0 requires that if XPath backwards compatibility mode is supported, then the namespace axis must also be supported; but other host languages may define the conformance rules differently.)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In XPath 1.0, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">-x|y</span></code><span class="deltaxml-new" style="background:#90EE90"> parsed as </span><code><span class="deltaxml-new" style="background:#90EE90">-(x|y)</span></code><span class="deltaxml-new" style="background:#90EE90">, and returned the negation of the numeric value of the first node in the union of </span><code><span class="deltaxml-new" style="background:#90EE90">x</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">y</span></code><span class="deltaxml-new" style="background:#90EE90">. In </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90">, this expression parses as </span><code><span class="deltaxml-new" style="background:#90EE90">(-x)|y</span></code><span class="deltaxml-new" style="background:#90EE90">. When XPath 1.0 Compatibility Mode is true, this will always cause a type error.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The rules for converting numbers to strings have changed. These may affect the way numbers are displayed in the output of a stylesheet. For numbers whose absolute value is in the range </span><code><span class="deltaxml-new" style="background:#90EE90">1E-6</span></code><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">1E+6</span></code><span class="deltaxml-new" style="background:#90EE90">, the result should be the same, but outside this range, scientific format is used for non-integral </span><code><span class="deltaxml-new" style="background:#90EE90">xs:float</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90"> values.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If one operand in a general comparison is a single atomic item of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90">, the other operand is converted to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code><span class="deltaxml-new" style="background:#90EE90"> when XPath 1.0 compatibility mode is set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">. In XPath 1.0, if neither operand of a comparison operation using the &lt;, &lt;=, &gt; or &gt;= operator was a node set, both operands were converted to numbers. The result of the expression </span><code><span class="deltaxml-new" style="background:#90EE90">true() &gt; number('0.5')</span></code><span class="deltaxml-new" style="background:#90EE90"> is therefore </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> in XPath 1.0, but is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> in </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90"> even when compatibility mode is set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In </span><span><span class="deltaxml-new" style="background:#90EE90">XPath 4.0</span></span><span class="deltaxml-new" style="background:#90EE90">, a type error is raised if the PITarget specified in a SequenceType of form </span><code><span class="deltaxml-new" style="background:#90EE90">processing-instruction(PITarget)</span></code><span class="deltaxml-new" style="background:#90EE90"> is not a valid NCName. In XPath 1.0, this condition was not treated as an error.</span></p></li></ol></div><div class="div3"><h4><a id="id-incompat-in-false-mode"></a><span class="deltaxml-new" style="background:#90EE90">K.4.2 Incompatibilities when Compatibility Mode is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code></h4><p><span class="deltaxml-new" style="background:#90EE90">Even when the setting of the XPath 1.0 compatibility mode is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, many XPath expressions will still produce the same results under XPath 4.0 as under XPath 1.0. The exceptions are described in this section.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In all cases it is assumed that the expression in question was valid under XPath 1.0, that XPath 1.0 compatibility mode is </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, and that all elements and attributes are annotated with the types </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untyped</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> respectively.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the description below, the terms </span><em><span class="deltaxml-new" style="background:#90EE90">node-set</span></em><span class="deltaxml-new" style="background:#90EE90"> and </span><em><span class="deltaxml-new" style="background:#90EE90">number</span></em><span class="deltaxml-new" style="background:#90EE90"> are used with their XPath 1.0 meanings, that is, to describe expressions which according to the rules of XPath 1.0 would have generated a node-set or a number respectively.</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">When a node-set containing more than one node is supplied as an argument to a function or operator that expects a single node or value, the XPath 1.0 rule was that all nodes after the first were discarded. Under XPath 4.0, a type error occurs if there is more than one node. The XPath 1.0 behavior can always be restored by using the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[1]</span></code><span class="deltaxml-new" style="background:#90EE90"> to explicitly select the first node in the node-set.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In XPath 1.0, the </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> operators, when applied to two strings, attempted to convert both the strings to numbers and then made a numeric comparison between the results. In XPath 4.0, these operators perform a string comparison using the default collating sequence. (If either value is numeric, however, the results are compatible with XPath 1.0)</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">When an empty node-set is supplied as an argument to a function or operator that expects a number, the value is no longer converted implicitly to </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90">. The XPath 1.0 behavior can always be restored by using the </span><code><span class="deltaxml-new" style="background:#90EE90">number</span></code><span class="deltaxml-new" style="background:#90EE90"> function to perform an explicit conversion.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">More generally, the supplied arguments to a function or operator are no longer implicitly converted to the required type, except in the case where the supplied argument is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> (which will commonly be the case when a node in a schemaless document is supplied as the argument). For example, the function call </span><code><span class="deltaxml-new" style="background:#90EE90">substring-before(10 div 3, ".")</span></code><span class="deltaxml-new" style="background:#90EE90"> raises a type error under XPath 4.0, because the arguments to the </span><code><span class="deltaxml-new" style="background:#90EE90">substring-before</span></code><span class="deltaxml-new" style="background:#90EE90"> function must be strings rather than numbers. The XPath 1.0 behavior can be restored by performing an explicit conversion to the required type using a constructor function or cast.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The rules for comparing a node-set to a boolean have changed. In XPath 1.0, an expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">$node-set = true()</span></code><span class="deltaxml-new" style="background:#90EE90"> was evaluated by converting the node-set to a boolean and then performing a boolean comparison: so this expression would return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if </span><code><span class="deltaxml-new" style="background:#90EE90">$node-set</span></code><span class="deltaxml-new" style="background:#90EE90"> was non-empty. In XPath 4.0, this expression is handled in the same way as other comparisons between a sequence and a singleton: it is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> if </span><code><span class="deltaxml-new" style="background:#90EE90">$node-set</span></code><span class="deltaxml-new" style="background:#90EE90"> contains at least one node whose value, after atomization and conversion to a boolean using the casting rules, is </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">This means that if </span><code><span class="deltaxml-new" style="background:#90EE90">$node-set</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, the result under XPath 4.0 will be </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> regardless of the value of the boolean operand, and regardless of which operator is used. If </span><code><span class="deltaxml-new" style="background:#90EE90">$node-set</span></code><span class="deltaxml-new" style="background:#90EE90"> is non-empty, then in most cases the comparison with a boolean is likely to fail, giving a dynamic error. But if a node has the value </span><code><span class="deltaxml-new" style="background:#90EE90">"0"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"1"</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">"true"</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">"false"</span></code><span class="deltaxml-new" style="background:#90EE90">, evaluation of the expression may succeed.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Comparisons of a number to a boolean, a number to a string, or a string to a boolean are not allowed in XPath 4.0: they result in a type error. In XPath 1.0 such comparisons were allowed, and were handled by converting one of the operands to the type of the other. So for example in XPath 1.0 </span><code><span class="deltaxml-new" style="background:#90EE90">4 = true()</span></code><span class="deltaxml-new" style="background:#90EE90"> returned </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">; </span><code><span class="deltaxml-new" style="background:#90EE90">4 ="+4"</span></code><span class="deltaxml-new" style="background:#90EE90"> returned </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> (because the string </span><code><span class="deltaxml-new" style="background:#90EE90">"+4"</span></code><span class="deltaxml-new" style="background:#90EE90"> converts to </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90">), and </span><code><span class="deltaxml-new" style="background:#90EE90">false = "false"</span></code><span class="deltaxml-new" style="background:#90EE90"> returned </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90"> (because the string </span><code><span class="deltaxml-new" style="background:#90EE90">"false"</span></code><span class="deltaxml-new" style="background:#90EE90"> converts to the boolean </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">). In XPath 3.0 all these comparisons are type errors.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Additional numeric types have been introduced, with the effect that arithmetic may now be done as an integer, decimal, or single- or double-precision floating point calculation where previously it was always performed as double-precision floating point. The result of the </span><code><span class="deltaxml-new" style="background:#90EE90">div</span></code><span class="deltaxml-new" style="background:#90EE90"> operator when dividing two integers is now a value of type decimal rather than double. The expression </span><code><span class="deltaxml-new" style="background:#90EE90">10 div 0</span></code><span class="deltaxml-new" style="background:#90EE90"> raises an error rather than returning positive infinity.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The rules for converting strings to numbers have changed. The implicit conversion that occurs when passing an </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> value as an argument to a function that expects a number no longer converts unrecognized strings to the value </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90">; instead, it reports a dynamic error. This is in addition to the differences that apply when backwards compatibility mode is set to </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Many operations in XPath 4.0 produce an empty sequence as their result when one of the arguments or operands is an empty sequence. Where the operation expects a string, an empty sequence is usually considered equivalent to a zero-length string, which is compatible with the XPath 1.0 behavior. Where the operation expects a number, however, the result is not the same. For example, if </span><code><span class="deltaxml-new" style="background:#90EE90">@width</span></code><span class="deltaxml-new" style="background:#90EE90"> returns an empty sequence, then in XPath 1.0 the result of </span><code><span class="deltaxml-new" style="background:#90EE90">@width+1</span></code><span class="deltaxml-new" style="background:#90EE90"> was </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90">, while with XPath 4.0 it is </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90">. This has the effect that a filter expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">item[@width+1 != 2]</span></code><span class="deltaxml-new" style="background:#90EE90"> will select items having no </span><code><span class="deltaxml-new" style="background:#90EE90">width</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute under XPath 1.0, and will not select them under XPath 4.0.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The typed value of a comment node, processing instruction node, or namespace node under XPath 4.0 is of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">, not </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90">. This means that no implicit conversions are applied if the value is used in a context where a number is expected. If a processing-instruction node is used as an operand of an arithmetic operator, for example, XPath 1.0 would attempt to convert the string value of the node to a number (and deliver </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> if unsuccessful), while XPath 4.0 will report a type error.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In XPath 1.0, it was defined that with an expression of the form </span><code><span class="deltaxml-new" style="background:#90EE90">A and B</span></code><span class="deltaxml-new" style="background:#90EE90">, B would not be evaluated if A was false. Similarly in the case of </span><code><span class="deltaxml-new" style="background:#90EE90">A or B</span></code><span class="deltaxml-new" style="background:#90EE90">, B would not be evaluated if A was true. This is no longer guaranteed with XPath 4.0: the implementation is free to evaluate the two operands in either order or in parallel. This change has been made to give more scope for optimization in situations where XPath expressions are evaluated against large data collections supported by indexes. Implementations may choose to retain backwards compatibility in this area, but they are not obliged to do so.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In XPath 1.0, the expression </span><code><span class="deltaxml-new" style="background:#90EE90">-x|y</span></code><span class="deltaxml-new" style="background:#90EE90"> parsed as </span><code><span class="deltaxml-new" style="background:#90EE90">-(x|y)</span></code><span class="deltaxml-new" style="background:#90EE90">, and returned the negation of the numeric value of the first node in the union of </span><code><span class="deltaxml-new" style="background:#90EE90">x</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">y</span></code><span class="deltaxml-new" style="background:#90EE90">. In XPath 4.0, this expression parses as </span><code><span class="deltaxml-new" style="background:#90EE90">(-x)|y</span></code><span class="deltaxml-new" style="background:#90EE90">. When XPath 1.0 Compatibility Mode is false, this will cause a type error, except in the situation where </span><code><span class="deltaxml-new" style="background:#90EE90">x</span></code><span class="deltaxml-new" style="background:#90EE90"> evaluates to an empty sequence. In that situation, XPath 4.0 will return the value of </span><code><span class="deltaxml-new" style="background:#90EE90">y</span></code><span class="deltaxml-new" style="background:#90EE90">, whereas XPath 1.0 returned the negation of the numeric value of </span><code><span class="deltaxml-new" style="background:#90EE90">y</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol></div><div class="div3"><h4><a id="id-incompat-when-using-schema"></a><span class="deltaxml-new" style="background:#90EE90">K.4.3 Incompatibilities when using a Schema</span></h4><p><span class="deltaxml-new" style="background:#90EE90">An XPath expression applied to a document that has been processed against a schema will not always give the same results as the same expression applied to the same document in the absence of a schema. Since schema processing had no effect on the result of an XPath 1.0 expression, this may give rise to further incompatibilities. This section gives a few examples of the differences that can arise.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Suppose that the context node is an element node derived from the following markup: </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;background color="red green blue"/&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">. In XPath 1.0, the predicate </span><code><span class="deltaxml-new" style="background:#90EE90">[@color="blue"]</span></code><span class="deltaxml-new" style="background:#90EE90"> would return </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">. In XPath 4.0, if the </span><code><span class="deltaxml-new" style="background:#90EE90">color</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is defined in a schema to be of type </span><code><span class="deltaxml-new" style="background:#90EE90">xs:NMTOKENS</span></code><span class="deltaxml-new" style="background:#90EE90">, the same predicate will return </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Similarly, consider the expression </span><code><span class="deltaxml-new" style="background:#90EE90">@birth &lt; @death</span></code><span class="deltaxml-new" style="background:#90EE90"> applied to the element </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;person birth="1901-06-06" death="1991-05-09"/&gt;</span></code><span class="deltaxml-new" style="background:#90EE90">. With XPath 1.0, this expression would return </span><code><span class="deltaxml-new" style="background:#90EE90">false</span></code><span class="deltaxml-new" style="background:#90EE90">, because both attributes are converted to numbers, which returns </span><code><span class="deltaxml-new" style="background:#90EE90">NaN</span></code><span class="deltaxml-new" style="background:#90EE90"> in each case. With XPath 4.0, in the presence of a schema that annotates these attributes as dates, the expression returns </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Once schema validation is applied, elements and attributes cannot be used as operands and arguments of expressions that expect a different data type. For example, it is no longer possible to apply the </span><code><span class="deltaxml-new" style="background:#90EE90">substring</span></code><span class="deltaxml-new" style="background:#90EE90"> function to a date to extract the year component, or to a number to extract the integer part. Similarly, if an attribute is annotated as a boolean then it is not possible to compare it with the strings </span><code><span class="deltaxml-new" style="background:#90EE90">"true"</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">"false"</span></code><span class="deltaxml-new" style="background:#90EE90">. All such operations lead to type errors. The remedy when such errors occur is to introduce an explicit conversion, or to do the computation in a different way. For example, </span><code><span class="deltaxml-new" style="background:#90EE90">substring-after(@temperature, "-")</span></code><span class="deltaxml-new" style="background:#90EE90"> might be rewritten as </span><code><span class="deltaxml-new" style="background:#90EE90">abs(@temperature)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">In the case of an XPath 4.0 implementation that provides the static typing feature, many further type errors will be reported in respect of expressions that worked under XPath 1.0. For example, an expression such as </span><code><span class="deltaxml-new" style="background:#90EE90">round(../@price)</span></code><span class="deltaxml-new" style="background:#90EE90"> might lead to a static type error because the processor cannot infer statically that </span><code><span class="deltaxml-new" style="background:#90EE90">../@price</span></code><span class="deltaxml-new" style="background:#90EE90"> is guaranteed to be numeric.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Schema validation will in many cases perform whitespace normalization on the contents of elements (depending on their type). This will change the result of operations such as the </span><code><span class="deltaxml-new" style="background:#90EE90">string-length</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Schema validation augments the data model by adding default values for omitted attributes and empty elements.</span></p></div></div></div></div><div class="div1"><h2><a id="id-revision-log"></a><span class="deltaxml-new" style="background:#90EE90">L Change Log (Non-Normative)</span></h2><ol><li><p><span class="deltaxml-new" style="background:#90EE90">Use the arrows to browse significant changes since the 3.1 version of this specification.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-introduction"><b><span class="deltaxml-new" style="background:#90EE90">1 Introduction</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Sections with significant changes are marked Δ in the table of contents.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-introduction"><b><span class="deltaxml-new" style="background:#90EE90">1 Introduction</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#eval_context"><b><span class="deltaxml-new" style="background:#90EE90">2.2.2 Dynamic Context</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of </span><code><span class="deltaxml-new" style="background:#90EE90">and</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">or</span></code><span class="deltaxml-new" style="background:#90EE90">, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-guarded-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.5 Guarded Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Enumeration types are added as a new kind of </span><code><span class="deltaxml-new" style="background:#90EE90">ItemType</span></code><span class="deltaxml-new" style="background:#90EE90">, constraining the value space of strings.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-enumeration-types"><b><span class="deltaxml-new" style="background:#90EE90">3.2.6 Enumeration Types</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Element and attribute tests can include alternative names: </span><code><span class="deltaxml-new" style="background:#90EE90">element(chapter|section)</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(role|class)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#node-types"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7 Node Types</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">NodeTest</span></code><span class="deltaxml-new" style="background:#90EE90"> in an </span><code><span class="deltaxml-new" style="background:#90EE90">AxisStep</span></code><span class="deltaxml-new" style="background:#90EE90"> now allows alternatives: </span><code><span class="deltaxml-new" style="background:#90EE90">ancestor::(section|appendix)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#node-types"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7 Node Types</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Element and attribute tests of the form </span><code><span class="deltaxml-new" style="background:#90EE90">element(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> now allow </span><code><span class="deltaxml-new" style="background:#90EE90">N</span></code><span class="deltaxml-new" style="background:#90EE90"> to be any </span><code><span class="deltaxml-new" style="background:#90EE90">NameTest</span></code><span class="deltaxml-new" style="background:#90EE90">, including a wildcard. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-element-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7.2 Element Test</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Setting the default namespace for elements and types to the special value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90"> causes an unprefixed element name to act as a wildcard, matching by local name regardless of namespace. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-element-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7.2 Element Test</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Element and attribute tests of the form </span><code><span class="deltaxml-new" style="background:#90EE90">element(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">attribute(N)</span></code><span class="deltaxml-new" style="background:#90EE90"> now allow </span><code><span class="deltaxml-new" style="background:#90EE90">N</span></code><span class="deltaxml-new" style="background:#90EE90"> to be any </span><code><span class="deltaxml-new" style="background:#90EE90">NameTest</span></code><span class="deltaxml-new" style="background:#90EE90">, including a wildcard. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-attribute-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.7.4 Attribute Test</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The keyword </span><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed as a synonym for </span><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><span class="deltaxml-new" style="background:#90EE90"> in function tests, to align with changes to inline function declarations.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-function-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.1 Function Test</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Record types are added as a new kind of </span><code><span class="deltaxml-new" style="background:#90EE90">ItemType</span></code><span class="deltaxml-new" style="background:#90EE90">, constraining the value space of maps. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-record-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.3 Record Test</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-sequencetype-subtype"><b><span class="deltaxml-new" style="background:#90EE90">3.3 Subtype Relationships</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-coercion-rules"><b><span class="deltaxml-new" style="background:#90EE90">3.4 Coercion Rules</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Function coercion now allows a function with arity </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> to be supplied where a function of arity greater than </span><var><span class="deltaxml-new" style="background:#90EE90">N</span></var><span class="deltaxml-new" style="background:#90EE90"> is expected. For example this allows the function </span><code><span class="deltaxml-new" style="background:#90EE90">true#0</span></code><span class="deltaxml-new" style="background:#90EE90"> to be supplied where a predicate function is required. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-function-coercion"><b><span class="deltaxml-new" style="background:#90EE90">3.4.4 Function Coercion</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> It has been clarified that function coercion applies even when the supplied function item matches the required function type. This is to ensure that arguments supplied when calling the function are checked against the signature of the required function type, which might be stricter than the signature of the supplied function item. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-function-coercion"><b><span class="deltaxml-new" style="background:#90EE90">3.4.4 Function Coercion</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> In inline function expressions, the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">function</span></code><span class="deltaxml-new" style="background:#90EE90"> may be abbreviated as </span><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-inline-func"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.5 Inline Function Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">New abbreviated syntax is introduced (</span><a title="focus function" class="termref" href="#dt-focus-function"><span class="deltaxml-new" style="background:#90EE90">focus function</span></a><span class="deltaxml-new" style="background:#90EE90">) for simple inline functions taking a single argument. An example is </span><code><span class="deltaxml-new" style="background:#90EE90">fn { ../@code }</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-inline-func"><b><span class="deltaxml-new" style="background:#90EE90">4.5.2.5 Inline Function Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The symbols </span><code><span class="deltaxml-new" style="background:#90EE90">×</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">÷</span></code><span class="deltaxml-new" style="background:#90EE90"> can be used for multiplication and division. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-arithmetic"><b><span class="deltaxml-new" style="background:#90EE90">4.8 Arithmetic Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-value-comparisons"><b><span class="deltaxml-new" style="background:#90EE90">4.10.1 Value Comparisons</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Operators such as </span><code><span class="deltaxml-new" style="background:#90EE90">&lt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> can use the full-width forms </span><code><span class="deltaxml-new" style="background:#90EE90">＜</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">＞</span></code><span class="deltaxml-new" style="background:#90EE90"> to avoid the need for XML escaping. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-general-comparisons"><b><span class="deltaxml-new" style="background:#90EE90">4.10.2 General Comparisons</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The lookup operator </span><code><span class="deltaxml-new" style="background:#90EE90">?</span></code><span class="deltaxml-new" style="background:#90EE90"> can now be followed by a string literal, for cases where map keys are strings other than NCNames. It can also be followed by a variable reference. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3 Lookup Expressions for Maps and Arrays</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The arrow operator </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> is now complemented by a “mapping arrow” operator </span><code><span class="deltaxml-new" style="background:#90EE90">=!&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> which applies the supplied function to each item in the input sequence independently. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-mapping-arrow-expression"><b><span class="deltaxml-new" style="background:#90EE90">4.23.2 Mapping Arrow Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">In previous versions the interpretation of location hints in </span><code><span class="deltaxml-new" style="background:#90EE90">import schema</span></code><span class="deltaxml-new" style="background:#90EE90"> declarations was entirely at the discretion of the processor. To improve interoperability, XQuery 4.0 recommends (but does not mandate) a specific strategy for interpreting these hints.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-schema-import"><b><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The rules for the consistency of schemas imported by different query modules, and for consistency between imported schemas and those used for validating input documents, have been defined with greater precision. It is now recognized that these schemas will not always be identical, and that validation with respect to different schemas may produce different outcomes, even if the components of one are a subset of the components of the other.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-schema-import"><b><span class="deltaxml-new" style="background:#90EE90">5.11 Schema Import</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> All implementations must now predeclare the namespace prefixes </span><code><span class="deltaxml-new" style="background:#90EE90">math</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">err</span></code><span class="deltaxml-new" style="background:#90EE90">. In XQuery 3.1 it was permitted but not required to predeclare these namespaces. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-namespace-declaration"><b><span class="deltaxml-new" style="background:#90EE90">5.13 Namespace Declaration</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> can now be declared to be fixed for a query module, meaning it is unaffected by a namespace declaration appearing on a direct element constructor. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-default-namespace"><b><span class="deltaxml-new" style="background:#90EE90">5.14 Default Namespace Declaration</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-context-value-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.17 Context Value Declaration</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Function definitions in the static context may now have optional parameters, provided this does not cause ambiguity across multiple function definitions with the same name. Optional parameters are given a default value, which can be any expression, including one that depends on the context of the caller (so an argument can default to the context value). </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#FunctionDeclns"><b><span class="deltaxml-new" style="background:#90EE90">5.18 Function Declarations</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The operator mapping table has been simplified by removing entries for the operators </span><code><span class="deltaxml-new" style="background:#90EE90">ne</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">le</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">gt</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">ge</span></code><span class="deltaxml-new" style="background:#90EE90">; these are now defined by reference to the rules for the operators </span><code><span class="deltaxml-new" style="background:#90EE90">eq</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">lt</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#mapping"><b><span class="deltaxml-new" style="background:#90EE90">B.2 Operator Mapping</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/tba"><span class="deltaxml-new" style="background:#90EE90">tba&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Predicates in filter expressions for maps and arrays can now be numeric. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-filter-maps-and-arrays"><b><span class="deltaxml-new" style="background:#90EE90">4.14.4 Filter Expressions for Maps and Arrays</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">ordered{E}</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">unordered{E}</span></code><span class="deltaxml-new" style="background:#90EE90"> expressions are retained for backwards compatibility reasons, but in XQuery 4.0 they are deprecated and have no useful effect. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-unordered-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.15 Ordered and Unordered Expressions</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The ordering mode declaration is retained for backwards compatibility reasons, but in XQuery 4.0 it is deprecated and has no useful effect. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-default-ordering-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.7 Ordering Mode Declaration</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90"> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#static_context"><b><span class="deltaxml-new" style="background:#90EE90">2.2.1 Static Context</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The static typing option has been dropped. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-processing-model"><b><span class="deltaxml-new" style="background:#90EE90">2.3 Processing Model</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The static typing feature has been dropped. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-conformance"><b><span class="deltaxml-new" style="background:#90EE90">6 Conformance</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-xq-static-context-components"><b><span class="deltaxml-new" style="background:#90EE90">C.1 Static Context Components</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/28"><span class="deltaxml-new" style="background:#90EE90">28&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Multiple </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clauses can be combined in an expression without an intervening </span><code><span class="deltaxml-new" style="background:#90EE90">return</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-for-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.13.11 For Expressions</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-let-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.13.12 Let Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/159"><span class="deltaxml-new" style="background:#90EE90">159&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Keyword arguments are allowed on static function calls, as well as positional arguments. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-function-calls"><b><span class="deltaxml-new" style="background:#90EE90">4.5.1.1 Static Function Call Syntax</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/254"><span class="deltaxml-new" style="background:#90EE90">254&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-coercion-rules"><b><span class="deltaxml-new" style="background:#90EE90">3.4 Coercion Rules</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The value bound to a variable in a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is now converted to the declared type by applying the coercion rules. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-xquery-let-clause"><b><span class="deltaxml-new" style="background:#90EE90">4.13.3 Let Clause</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The coercion rules are now used when binding values to variables (both global variable declarations and local variable bindings). This aligns XQuery with XSLT, and means that the rules for binding to variables are the same as the rules for binding to function parameters. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-variable-declarations"><b><span class="deltaxml-new" style="background:#90EE90">5.16 Variable Declaration</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/284"><span class="deltaxml-new" style="background:#90EE90">284&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Alternative syntax for conditional expressions is available: </span><code><span class="deltaxml-new" style="background:#90EE90">if (condition) {X} else {Y}</span></code><span class="deltaxml-new" style="background:#90EE90">, with the </span><code><span class="deltaxml-new" style="background:#90EE90">else</span></code><span class="deltaxml-new" style="background:#90EE90"> part being optional. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-conditionals"><b><span class="deltaxml-new" style="background:#90EE90">4.16 Conditional Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/324"><span class="deltaxml-new" style="background:#90EE90">324&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> String templates provide a new way of constructing strings: for example </span><code><span class="deltaxml-new" style="background:#90EE90">`{$greeting}, {$planet}!`</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to </span><code><span class="deltaxml-new" style="background:#90EE90">$greeting || ', ' || $planet || '!'</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-string-templates"><b><span class="deltaxml-new" style="background:#90EE90">4.9.2 String Templates</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/326"><span class="deltaxml-new" style="background:#90EE90">326&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Support for higher-order functions is now a mandatory feature (in 3.1 it was optional). </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-conformance"><b><span class="deltaxml-new" style="background:#90EE90">6 Conformance</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/344"><span class="deltaxml-new" style="background:#90EE90">344&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for member</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is added to FLWOR expressions to allow iteration over an array. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-xquery-for-clause"><b><span class="deltaxml-new" style="background:#90EE90">4.13.2 For Clause</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-for-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.13.11 For Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/364"><span class="deltaxml-new" style="background:#90EE90">364&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Switch expressions now allow a </span><code><span class="deltaxml-new" style="background:#90EE90">case</span></code><span class="deltaxml-new" style="background:#90EE90"> clause to match multiple atomic items. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-switch"><b><span class="deltaxml-new" style="background:#90EE90">4.18 Switch Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/433"><span class="deltaxml-new" style="background:#90EE90">433&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Numeric literals can now be written in hexadecimal or binary notation; and underscores can be included for readability. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-numeric-literals"><b><span class="deltaxml-new" style="background:#90EE90">4.2.1.1 Numeric Literals</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/483"><span class="deltaxml-new" style="background:#90EE90">483&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">start</span></code><span class="deltaxml-new" style="background:#90EE90"> clause in window expressions has become optional, as well as the </span><code><span class="deltaxml-new" style="background:#90EE90">when</span></code><span class="deltaxml-new" style="background:#90EE90"> keyword and its associated expression. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-windows"><b><span class="deltaxml-new" style="background:#90EE90">4.13.4 Window Clause</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/519"><span class="deltaxml-new" style="background:#90EE90">519&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The rules for tokenization have been largely rewritten. In some cases the revised specification may affect edge cases that were handled in different ways by different 3.1 processors, which could lead to incompatible behavior. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#lexical-structure"><b><span class="deltaxml-new" style="background:#90EE90">A.3 Lexical structure</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/587"><span class="deltaxml-new" style="background:#90EE90">587&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Switch and typeswitch expressions can now be written with curly braces, to improve readability. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-switch"><b><span class="deltaxml-new" style="background:#90EE90">4.18 Switch Expressions</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-typeswitch"><b><span class="deltaxml-new" style="background:#90EE90">4.21.2 Typeswitch</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/603"><span class="deltaxml-new" style="background:#90EE90">603&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as </span><code><span class="deltaxml-new" style="background:#90EE90">@price/@value</span></code><span class="deltaxml-new" style="background:#90EE90">, even though dynamic evaluation is defined to return an empty sequence rather than an error. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-implausible-expressions"><b><span class="deltaxml-new" style="background:#90EE90">2.4.6 Implausible Expressions</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#implausible-axis-steps"><b><span class="deltaxml-new" style="background:#90EE90">4.6.4.3 Implausible Axis Steps</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/678"><span class="deltaxml-new" style="background:#90EE90">678&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The comparand expression in a switch expression can be omitted, allowing the switch cases to be provided as arbitrary boolean expressions. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-switch"><b><span class="deltaxml-new" style="background:#90EE90">4.18 Switch Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/682"><span class="deltaxml-new" style="background:#90EE90">682&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The values </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> are allowed in function annotations, and negated numeric literals are also allowed. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-function-annotations"><b><span class="deltaxml-new" style="background:#90EE90">5.18.4 Function Annotations</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/728"><span class="deltaxml-new" style="background:#90EE90">728&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The syntax </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed; it matches any map. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-record-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.3 Record Test</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/820"><span class="deltaxml-new" style="background:#90EE90">820&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The value bound to a variable in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is now converted to the declared type by applying the coercion rules. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-xquery-for-clause"><b><span class="deltaxml-new" style="background:#90EE90">4.13.2 For Clause</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/837"><span class="deltaxml-new" style="background:#90EE90">837&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> A deep lookup operator </span><code><span class="deltaxml-new" style="background:#90EE90">??</span></code><span class="deltaxml-new" style="background:#90EE90"> is provided for searching trees of maps and arrays. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3 Lookup Expressions for Maps and Arrays</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/943"><span class="deltaxml-new" style="background:#90EE90">943&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> A FLWOR expression may now include a </span><code><span class="deltaxml-new" style="background:#90EE90">while</span></code><span class="deltaxml-new" style="background:#90EE90"> clause, which causes early exit from the iteration when a condition is encountered. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-while"><b><span class="deltaxml-new" style="background:#90EE90">4.13.6 While Clause</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/996"><span class="deltaxml-new" style="background:#90EE90">996&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The value of a predicate in a filter expression can now be a sequence of integers. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-filter-expression"><b><span class="deltaxml-new" style="background:#90EE90">4.4 Filter Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1031"><span class="deltaxml-new" style="background:#90EE90">1031&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> An </span><code><span class="deltaxml-new" style="background:#90EE90">otherwise</span></code><span class="deltaxml-new" style="background:#90EE90"> operator is introduced: </span><code><span class="deltaxml-new" style="background:#90EE90">A otherwise B</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the value of </span><code><span class="deltaxml-new" style="background:#90EE90">A</span></code><span class="deltaxml-new" style="background:#90EE90">, unless it is an empty sequence, in which case it returns the value of </span><code><span class="deltaxml-new" style="background:#90EE90">B</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-otherwise"><b><span class="deltaxml-new" style="background:#90EE90">4.17 Otherwise Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1071"><span class="deltaxml-new" style="background:#90EE90">1071&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> In map constructors, the keyword </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> is now optional, so </span><code><span class="deltaxml-new" style="background:#90EE90">map { 0: false(), 1: true() }</span></code><span class="deltaxml-new" style="background:#90EE90"> can now be written </span><code><span class="deltaxml-new" style="background:#90EE90">{ 0: false(), 1: true() }</span></code><span class="deltaxml-new" style="background:#90EE90">, provided it is used in a context where this creates no ambiguity. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-map-constructors"><b><span class="deltaxml-new" style="background:#90EE90">4.14.1.1 Map Constructors</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1125"><span class="deltaxml-new" style="background:#90EE90">1125&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Lookup expressions can now take a modifier (such as </span><code><span class="deltaxml-new" style="background:#90EE90">keys</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">values</span></code><span class="deltaxml-new" style="background:#90EE90">, or </span><code><span class="deltaxml-new" style="background:#90EE90">pairs</span></code><span class="deltaxml-new" style="background:#90EE90">) enabling them to return structured results rather than a flattened sequence. In addition they can be qualified with a type to select only the results that match that type. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-lookup"><b><span class="deltaxml-new" style="background:#90EE90">4.14.3 Lookup Expressions for Maps and Arrays</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1131"><span class="deltaxml-new" style="background:#90EE90">1131&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> A positional variable can be defined in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-for-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.13.11 For Expressions</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The type of a variable used in a </span><code><span class="deltaxml-new" style="background:#90EE90">for</span></code><span class="deltaxml-new" style="background:#90EE90"> expression can be declared. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-for-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.13.11 For Expressions</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The type of a variable used in a </span><code><span class="deltaxml-new" style="background:#90EE90">let</span></code><span class="deltaxml-new" style="background:#90EE90"> expression can be declared. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-let-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.13.12 Let Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1132"><span class="deltaxml-new" style="background:#90EE90">1132&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Choice item types (an item type allowing a set of alternative item types) are introduced. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-choice-item-types"><b><span class="deltaxml-new" style="background:#90EE90">3.2.5 Choice Item Types</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1137"><span class="deltaxml-new" style="background:#90EE90">1137&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Functions may be declared to be variadic. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-static-functions"><b><span class="deltaxml-new" style="background:#90EE90">4.5.1 Static Function Calls</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-variadic-functions-overview"><b><span class="deltaxml-new" style="background:#90EE90">4.5.3 Variadic Functions</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-function-annotations"><b><span class="deltaxml-new" style="background:#90EE90">5.18.4 Function Annotations</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1163"><span class="deltaxml-new" style="background:#90EE90">1163&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Filter expressions for maps and arrays are introduced. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-filter-maps-and-arrays"><b><span class="deltaxml-new" style="background:#90EE90">4.14.4 Filter Expressions for Maps and Arrays</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1181"><span class="deltaxml-new" style="background:#90EE90">1181&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> can be set to the value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#static_context"><b><span class="deltaxml-new" style="background:#90EE90">2.2.1 Static Context</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> If the default namespace for elements and types has the special value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, then an unprefixed name in a </span><code><span class="deltaxml-new" style="background:#90EE90">NameTest</span></code><span class="deltaxml-new" style="background:#90EE90"> acts as a wildcard, matching names in any namespace or none. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#node-tests"><b><span class="deltaxml-new" style="background:#90EE90">4.6.4.2 Node Tests</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The </span><a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types"><span class="deltaxml-new" style="background:#90EE90">default namespace for elements and types</span></a><span class="deltaxml-new" style="background:#90EE90"> can be set to the value </span><code><span class="deltaxml-new" style="background:#90EE90">##any</span></code><span class="deltaxml-new" style="background:#90EE90">, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-default-namespace"><b><span class="deltaxml-new" style="background:#90EE90">5.14 Default Namespace Declaration</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1212"><span class="deltaxml-new" style="background:#90EE90">1212&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> XQuery and XPath 3.0 included </span><code><span class="deltaxml-new" style="background:#90EE90">empty-sequence</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">item</span></code><span class="deltaxml-new" style="background:#90EE90"> as reserved function names, and XQuery and XPath 3.1 added </span><code><span class="deltaxml-new" style="background:#90EE90">map</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">array</span></code><span class="deltaxml-new" style="background:#90EE90">. This was unnecessary since these names never appear followed by a left parenthesis at the start of an expression. They have therefore been removed from the list. New keywords introducing item types, such as </span><code><span class="deltaxml-new" style="background:#90EE90">record</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">enum</span></code><span class="deltaxml-new" style="background:#90EE90">, have not been included in the list. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-reserved-fn-names"><b><span class="deltaxml-new" style="background:#90EE90">A.4 Reserved Function Names</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1249"><span class="deltaxml-new" style="background:#90EE90">1249&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><code><span class="deltaxml-new" style="background:#90EE90">for key/value</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is added to FLWOR expressions to allow iteration over a map. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-xquery-for-clause"><b><span class="deltaxml-new" style="background:#90EE90">4.13.2 For Clause</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> A </span><code><span class="deltaxml-new" style="background:#90EE90">for key/value</span></code><span class="deltaxml-new" style="background:#90EE90"> clause is added to FLWOR expressions to allow iteration over maps.</span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-for-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.13.11 For Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1250"><span class="deltaxml-new" style="background:#90EE90">1250&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> Several decimal format properties, including minus sign, exponent separator, percent, and per-mille, can now be rendered as arbitrary strings rather than being confined to a single character. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-decimal-formats"><b><span class="deltaxml-new" style="background:#90EE90">2.2.1.2 Decimal Formats</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-decimal-format-decl"><b><span class="deltaxml-new" style="background:#90EE90">5.10 Decimal Format Declaration</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1254"><span class="deltaxml-new" style="background:#90EE90">1254&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The rules concerning the interpretation of </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:schemaLocation</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">xsi:noNamespaceSchemaLocation</span></code><span class="deltaxml-new" style="background:#90EE90"> attributes have been tightened up. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-validate"><b><span class="deltaxml-new" style="background:#90EE90">4.24 Validate Expressions</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1265"><span class="deltaxml-new" style="background:#90EE90">1265&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The rules regarding the </span><code><span class="deltaxml-new" style="background:#90EE90">document-uri</span></code><span class="deltaxml-new" style="background:#90EE90"> property of nodes returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">fn:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function have been relaxed. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#eval_context"><b><span class="deltaxml-new" style="background:#90EE90">2.2.2 Dynamic Context</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1361"><span class="deltaxml-new" style="background:#90EE90">1361&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The term </span><b><span class="deltaxml-new" style="background:#90EE90">atomic value</span></b><span class="deltaxml-new" style="background:#90EE90"> has been replaced by </span><b><span class="deltaxml-new" style="background:#90EE90">atomic item</span></b><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-terminology"><b><span class="deltaxml-new" style="background:#90EE90">2.1 Terminology</span></b></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The term </span><b><span class="deltaxml-new" style="background:#90EE90">atomic value</span></b><span class="deltaxml-new" style="background:#90EE90"> has been replaced by </span><a title="atomic item" class="termref" href="#dt-atomic-item"><span class="deltaxml-new" style="background:#90EE90">atomic item</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-values"><b><span class="deltaxml-new" style="background:#90EE90">2.1.1 Values</span></b></a></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1384"><span class="deltaxml-new" style="background:#90EE90">1384&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> If a type declaration is present, the supplied values in the input sequence are now coerced to the required type. Type declarations are now permitted in XPath as well as XQuery. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-quantified-expressions"><b><span class="deltaxml-new" style="background:#90EE90">4.19 Quantified Expressions</span></b></a></p></li></ol></div></div><script src="https://www.w3.org/scripts/TR/2016/fixup.js"></script><script src="/js/scroll.js"></script></body></html>